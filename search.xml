<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务心跳管理机制设计</title>
      <link href="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</a><ul><li><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</a></li><li><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</a></li><li><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</a></li><li><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</a></li></ul></li><li><a href="#ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</a><ul><li><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</a></li><li><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><p>笔记来源：<br><a href="https://time.geekbang.org/column/article/240656">实战：单机如何实现管理百万主机的心跳服务</a></p><h1><span id="ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</span><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu" class="header-anchor">#</a></h1><h2><span id="1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</span><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi" class="header-anchor">#</a></h2><p>全部遍历找超时，O(n)， 百万级别节点消耗非常大，   遍历时可能会因为涉及更新的同步问题， 导致此时无法插入。<br>如果用单线程，这个过程慢的话会造成阻塞。</p><p>实现方式1： LRU+链表+哈希表<br>① 所有心跳放进一个LRU队列中，保证最新的心跳包在队尾，最老的心跳包在队头。<br>② 如果某节点有新的心跳包进来， 利用哈希表找到这个节点的链点位置，删除掉，再将新包插入到队尾。<br>③ 每次心跳检查时， 只要查询队头， 不断将超时的心跳包出队，直到队头的心跳包不超时即可。<br><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/ee76fb4d7bfd65d2190dbadd7760c7f312f74079.png" alt="ee76fb4d7bfd65d2190dbadd7760c7f312f74079"><br>实现方式2： 时间轮，时间轮的做法见最后</p><h2><span id="2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</span><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing" class="header-anchor">#</a></h2><p>上面提到的心跳检查都在内存中，  心跳检查节点如果只有1个的话不可靠，而且量级也会很大。<br>但又不能落盘，这会导致数据库的并发查询压力很大，且数据库自身的可靠性又会成了问题。</p><p>解决方式：<br>分布式处理。<br>心跳入口网关 根据节点的ip或者节点id做哈希， 确保相同节点的心跳包发往同一个节点。<br>如果网关发现某个节点挂了，利用哈希一致算法更新发送的节点即可。</p><h2><span id="3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</span><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng" class="header-anchor">#</a></h2><p>收到心跳后， 涉及心跳的解包，LRU+哈希更新，需要提升处理性能。</p><p>①  多线程处理， 同样利用上面的方法做哈希，分配到特定的心跳处理线程，不同线程之间处理的节点信息不会互相干扰。</p><blockquote><blockquote><p>注意点：  缓存队列放到各自的工作线程中。 即push而非pull的方式，尽可能避免N之间的竞争，即只做1+1的竞争。<br><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8.png" alt="68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8"><br>队列锁采用自旋锁，避免工作线程频繁出现上下文切换（即保证工作线程一直在跑，这个用于高并发场景，高并发场景不能让他停下来的）</p></blockquote></blockquote><p>② 心跳包资源池减少内存释放频率<br>如果只有10w个节点，那么每次收到心跳请求时，不要反复new新的心跳对象，而是从心跳资源池里取出构造好的对象，把最新时间set进去后再扔给分发线程。</p><h2><span id="4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</span><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp" class="header-anchor">#</a></h2><p>满足以下条件的话选择UDP:</p><ol><li>心跳包报文长度内容信息量很少，基本小于MTU， 不需要利用TCP自带的分包机制。</li><li>超时判断时间允许偶然一次的不可靠丢包（即偶尔丢一次并不影响）</li></ol><p>这种情况用UDP在网内发到心跳服务即可。<br>不需要TCP那样的高消耗。</p><h1><span id="ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</span><a href="#ling-yi-ge-fang-shi-shi-jian-lun" class="header-anchor">#</a></h1><p>参考自<a href="https://www.jianshu.com/p/0f0fec47a0ad">TimingWheel 时间轮详解</a></p><p>时间轮本质：</p><ol><li>弄一个数组（看起来是一个环，实际上是数组）</li><li>数组中中每个节点又存了一个双向链表，用于存放实际的任务（用链表是为了方便插入）</li><li>任务具体放数组中的哪个位置？  根据 超期时间取余决定他的实际存放位置。</li><li>如果数组的节点中有任务，会把本身的超期时间带着一起扔进一个 队列中</li><li>队列每次取队头数据， 如果时间没到队头节点指定的延迟时间，就阻塞，直到时间到达，取出里面的任务逐个执行。</li><li>如果任务的定时时间超过整个环的时间？  则新增一个时间轮，时间比这个更长，因此队列里可能会多插入一个节点，节点中会标识我是小时间轮还是大时间轮的。<br><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/2e95b497a970bc8baad42f25d6dee04d0241a079.png" alt="2e95b497a970bc8baad42f25d6dee04d0241a079"></li></ol><hr><p>其他的延时队列怎么做的?<br><a href="https://blog.csdn.net/woniu211111/article/details/109302412">延时队列实现的几种姿势</a></p><hr><h2><span id="q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</span><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma" class="header-anchor">#</a></h2><p>A:</p><ol><li>有一个优先队列， 放入的任务会根据是否快要超期进行排序， 马上就要超期的会放在队头。</li><li>当使用take方法取数据时，看一下队头任务，如果时间到了就返回。</li><li>如果时间还没到</li></ol><ul><li>首先看一下是否已经有线程在等待这个任务了，如果是的话，使用锁的condition机制做await等待。</li><li>如果没有线程正在等待，就计算还差多少时间， 然后用 LockSupport.parkNanos()让这个调用take方法的线程等待特定时间。</li></ul><ol start="4"><li>注意等待期间，会释放锁，因此这期间可以正常offer和take。</li><li>当时间到了后，这个线程肯定能取走数据了。  取完后，顺便看一下队列里还有没有数据，如果有， 调用condition.signal()，通知那堆正在等待的线程， 你们可以试着竞争一下取数据了。</li><li>另外每当有新的任务offer时，如果发现最新入队的数据就是马上要超期的数据， 也会立刻通知等待的各位马上苏醒竞争（因为之前等待的线程认为自己还要睡一会才会有数据）</li></ol><p><a href="https://blog.csdn.net/fuzhongmin05/article/details/105716205">Java阻塞延迟队列DelayQueue原理及使用</a></p><hr><h2><span id="q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</span><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A:<br>java的delayQueue本质上是用堆（优先队列）实现的。<br>接收任务后， 直接把任务放进优先队列中， 按照超期时间确定堆位置。  每次poll时如果发现堆顶没到时间就阻塞，直到时间到了再poll。<br>取出来检查后，再加上时间扔回队列。</p><p>坏处： 插入和删除的复杂度是O(logn)。</p><p>而时间轮并不会把任务扔进 queue中，而是把时间轮的槽扔进queue中。  因此整个延迟队列实际上时针对槽的，不需要堆，按先入先出取数据和插槽即可，O(1)的复杂度。  而后面扔进来的任务，都是往槽里的双向链表塞进去而已。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务缓存设计</title>
      <link href="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ben-di-huan-cun">本地缓存</a><ul><li><a href="#q-shi-me-shi-ben-di-huan-cun">Q: 什么是本地缓存？</a></li><li><a href="#q-you-na-xie-ben-di-huan-cun-chan-pin">Q: 有哪些本地缓存产品？</a></li><li><a href="#q-ben-di-huan-cun-you-shi-me-que-dian">Q: 本地缓存有什么缺点？</a></li><li><a href="#q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi">Q: 本地缓存有哪些更新方式？</a></li><li><a href="#q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang">Q: 被动更新本地缓存有什么要注意的地方？</a></li><li><a href="#q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu">Q: 什么是off-heap技术？有什么好处</a></li><li><a href="#q-zen-me-shi-yong-off-heap">Q: 怎么使用off-heap？</a></li><li><a href="#q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma">Q: directByteBuffer的内存什么时候会被释放？ 需要自己写C++代码释放吗？</a></li></ul></li><li><a href="#fen-bu-shi-huan-cun">分布式缓存</a><ul><li><a href="#q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de">Q: 一致性哈希是做什么的？</a></li><li><a href="#q-fen-cao-suan-fa-shi-shi-me">Q: 分槽算法是什么？</a></li><li><a href="#q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi">Q: 缓存穿透是什么?解决方式是？</a></li><li><a href="#q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng">Q: 要是分布式缓存发生雪崩了怎么办，要怎么防止发生</a></li><li><a href="#q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue">Q: 几十万的用户同时访问某个数据，但这个数据正好缓存里没有，导致十几万的请求打到数据库上，这种情况叫做什么？怎么解决？</a></li><li><a href="#q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai">Q: 缓存过多时，如何进行筛选和淘汰？</a></li></ul></li><li><a href="#huan-cun-re-dian">缓存热点</a><ul><li><a href="#q-shi-me-shi-re-dian-key-wen-ti">Q: 什么是热点Key问题？</a></li><li><a href="#q-ru-he-fa-xian-re-dian">Q: 如何发现热点？</a></li><li><a href="#q-ru-he-jie-jue-re-dian-wen-ti">Q: 如何解决热点问题？</a></li><li><a href="#q-ru-he-shan-chu-re-dian">Q: 如何删除热点？</a></li><li><a href="#q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong">Q: 如何利用redis 实现秒杀系统？</a></li></ul></li><li><a href="#shu-ju-yi-zhi-xing">数据一致性</a><ul><li><a href="#q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti">Q: 当需要删除数据时， 如果我先删缓存，再删数据库，可能会有什么问题？</a></li><li><a href="#q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me">Q: 网络通信正常、命令正常的情况下， 先删库 ，再删缓存， 还是有可能造成脏数据， 知道为什么么？</a></li><li><a href="#q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao">Q: 如果删了库之后， 再删缓存的途中，网络临时不通怎么办？那缓存也有可能一直脏着了。</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="ben-di-huan-cun">本地缓存</span><a href="#ben-di-huan-cun" class="header-anchor">#</a></h1><h2><span id="q-shi-me-shi-ben-di-huan-cun">Q:  什么是本地缓存？</span><a href="#q-shi-me-shi-ben-di-huan-cun" class="header-anchor">#</a></h2><p>A:<br>即在客户端、应用端进行本地缓存， 或在jvm中缓存或在程序的堆外缓存。中间没有跨网络的开销</p><hr><h2><span id="q-you-na-xie-ben-di-huan-cun-chan-pin">Q: 有哪些本地缓存产品？</span><a href="#q-you-na-xie-ben-di-huan-cun-chan-pin" class="header-anchor">#</a></h2><p>A:</p><ul><li>Ehcache(Hibernate的二级缓存就用的这个）</li><li>GuavaCache（轻量，易用，有丰富的被动更新机制）</li><li>MapDb(支持堆外内存）</li></ul><hr><h2><span id="q-ben-di-huan-cun-you-shi-me-que-dian">Q: 本地缓存有什么缺点？</span><a href="#q-ben-di-huan-cun-you-shi-me-que-dian" class="header-anchor">#</a></h2><p>A:</p><ul><li>本地缓存会占用jvm有限的内存资源</li><li>高潮gc次数过快可能会导致贤者时间（stopworld）的延长。</li><li>只在本地缓存， 容易引发数据不同步。</li></ul><hr><h2><span id="q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi">Q: 本地缓存有哪些更新方式？</span><a href="#q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi" class="header-anchor">#</a></h2><p>A:</p><ul><li>被动更新<br>通过自己设置的超时时间， 超期后就自动进行更新，更新就是去重新发请求获取。。</li><li>主动更新<br>数据发生变更，主动通过消息队列的方式同步给订阅的应用（适用于内部服务配置订阅），应用进行更新。</li></ul><hr><h2><span id="q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang">Q: 被动更新本地缓存有什么要注意的地方？</span><a href="#q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang" class="header-anchor">#</a></h2><p>A:<br>如果同时失效的缓存很多，  需要控制更新时的线程必须只有1个， 如果支持同时触发多个线程进行请求更新，可能导致大量请求打到分布式缓存上引发雪崩。<br>两种方式：</p><ol><li>expireAfterWrite，   各超期的缓存起线程准备发请求时，需要先抢到锁，抢到了才能发，否则就阻塞（对性能要求不高可以选这个）</li><li>refreshAfterWrite，  也是抢锁，区别是如果抢不到，就返回旧值，等下次超期再抢。 （ 数据实时性要求不高的情况下可以选择这个）</li></ol><hr><h2><span id="q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu">Q: 什么是off-heap技术？有什么好处</span><a href="#q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu" class="header-anchor">#</a></h2><p>A:<br>堆外内存技术， 将数据存在jvm外的操作系统内存上，避免和原jvm进程互相干扰，因此也不会参与垃圾收集器gc。<br>好处：</p><ul><li>减少gc次数</li><li>扩展和使用更大的内存空间</li><li>省去了物理内存和heap进程内存之间的数据复制步骤，类似于零拷贝了。</li></ul><hr><h2><span id="q-zen-me-shi-yong-off-heap">Q: 怎么使用off-heap？</span><a href="#q-zen-me-shi-yong-off-heap" class="header-anchor">#</a></h2><p>A:</p><ul><li>NIO有个ByteBuffer.allocateDirect(int capacity)方法， 可以生成一个DirectByteBuffer实例</li><li>根据参数capacity的值，它会在物理内存中分配一块固定大小的直接字节缓冲区。</li><li>本质上是调用sum.misc.unsafe里实现的native方法进行内存分配操作。</li><li>可用-XX：MaxDirectMemorySize限制总的最大堆外申请大小，避免申请过多。</li></ul><hr><h2><span id="q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma">Q: directByteBuffer的内存什么时候会被释放？ 需要自己写C++代码释放吗？</span><a href="#q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma" class="header-anchor">#</a></h2><p>A:<br>不需要。   directByteBuffer在jvm中仍然是段引用，只不过buffer数据存到堆外了。 当这个buffer引用被回收了， 那么buffer背后的堆外内存也会被回收。</p><h1><span id="fen-bu-shi-huan-cun">分布式缓存</span><a href="#fen-bu-shi-huan-cun" class="header-anchor">#</a></h1><hr><h2><span id="q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de">Q:  一致性哈希是做什么的？</span><a href="#q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de" class="header-anchor">#</a></h2><p>A:<br><a href="https://blog.csdn.net/qq_42046105/article/details/92802476">https://blog.csdn.net/qq_42046105/article/details/92802476</a><br>普通的哈希表算法一般都是计算出哈希值后，通过取余操作将 key 值映射到不同的服务器上<br>但是当服务器数量发生变化时，取余操作的除数发生变化，所有 key 所映射的服务器几乎都会改变，这对分布式缓存系统来说是不可以接收的。<br>一致性哈希算法能尽可能减少了服务器数量变化所导致的缓存迁移。</p><p>以分布式缓存场景为例，分析一下一致性哈希算法环的原理。<br>首先将缓存服务器（ ip + 端口号）进行哈希，映射成环上的一个节点，计算出缓存数据 key 值的 hash key，同样映射到环上，并顺时针选取最近的一个服务器节点作为该缓存应该存储的服务器。具体实现见后续的章节。</p><p><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/b64d1b6633bdfe624e578751aadc21f0ea591b65.png" alt="b64d1b6633bdfe624e578751aadc21f0ea591b65"><br>服务器 B 宕机下线，服务器 B 中存储的缓存数据要进行迁移，但由于一致性哈希环的存在，只需要迁移key 值为1的数据，其他的数据的存储服务器不会发生变化。这也是一致性哈希算法比取余映射算法出色的地方。<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/9aac123b97d816fed485a1c96c572f008eb025b1.png" alt="9aac123b97d816fed485a1c96c572f008eb025b1"></p><p>现实情况下，服务器在一致性哈希环上的位置不可能分布的这么均匀，导致了每个节点实际占据环上的区间大小不一。</p><p>这种情况下，可以增加虚节点来解决。通过增加虚节点（即A节点实际对应好几个虚节点），使得每个节点在环上所“管辖”的区域更加均匀。</p><p>这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。</p><hr><h2><span id="q-fen-cao-suan-fa-shi-shi-me">Q: 分槽算法是什么？</span><a href="#q-fen-cao-suan-fa-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>在redis官方给出的集群方案中，数据的分配是按照槽位来进行分配的，每一个数据的键被哈希函数映射到一个槽位，redis-3.0.0规定一共有16384个槽位，当然这个可以根据用户的喜好进行配置。当用户put或者是get一个数据的时候，首先会查找这个数据对应的槽位是多少，然后查找对应的节点，然后才把数据放入这个节点。这样就做到了把数据均匀的分配到集群中的每一个节点上，从而做到了每一个节点的负载均衡，充分发挥了集群的威力。</p><p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p><ul><li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</li><li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/5bf0eef7aafe6e5eeb4da6d74b7ba2fa37bbefa2.png" alt="5bf0eef7aafe6e5eeb4da6d74b7ba2fa37bbefa2"><br><a href="https://www.jianshu.com/p/4163916a2a8a">一致性哈希和分槽算法</a></li></ul><hr><h2><span id="q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi">Q: 缓存穿透是什么?解决方式是？</span><a href="#q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi" class="header-anchor">#</a></h2><p>A:<br>大量不存在的请求攻入，反复去查询数据库<br>对于不存在的数据，可以用布隆过滤器（对1个值做多个不同的哈希，放入不同的位图位置里，  后面计算的时候，看下是否有1个位置没满足，没满足就一定不存在）</p><hr><p>Q:  缓存中的布隆过滤器是什么？</p><p>A:</p><p><a href="https://blog.csdn.net/fouy_yun/article/details/81075432">回答1</a><br><a href="https://blog.csdn.net/qq_38080318/article/details/106207978?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control404&amp;depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control40">回答2</a><br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1663600837395.png" alt="1663600837395"></p><hr><hr><h2><span id="q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng">Q: 要是分布式缓存发生雪崩了怎么办，要怎么防止发生</span><a href="#q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng" class="header-anchor">#</a></h2><p>A:<br>缓存雪崩可能是因为数据未加载到缓存中，或者一大堆缓存在同一时间大面积的失效过期，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</p><p>解决方式：</p><ul><li><p>缓存失效可以通过加锁或队列来控制读取数据库的访问的线程数量，比如对某个key值运行一个线程访问数据库，其他线程等待</p></li><li><p>不同的key，设置不同的过期时间，让失效的时间点尽量均匀或者随机，避免一下子大面积失效。</p></li><li><p>做二级缓存，a1失效时候，访问a2，a1失效的时间设置为短期，a2为长期</p></li></ul><hr><h2><span id="q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue">Q: 几十万的用户同时访问某个数据，但这个数据正好缓存里没有，导致十几万的请求打到数据库上，这种情况叫做什么？怎么解决？</span><a href="#q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue" class="header-anchor">#</a></h2><p>A:<br>这种情况叫做  ”缓存击穿“。</p><ol><li>延长热点数据的缓存超期时间。 提前预置热点缓存。</li><li>接口限流、降级、队列。</li></ol><hr><h2><span id="q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai">Q: 缓存过多时，如何进行筛选和淘汰？</span><a href="#q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai" class="header-anchor">#</a></h2><p>A:</p><p>没啥人用的数据占用了很多内存，叫缓存污染</p><p>Redis共支持八种淘汰策略。</p><ul><li>第一类： 不淘汰</li></ul><ol><li>noeviction<br>如果满了，新的写请求就报错</li></ol><ul><li>第二类：淘汰部分过期数据<br>当缓存满却收到新的写请求时，从会过期数据中选一个淘汰。</li></ul><ol start="2"><li>volatile-random 随机删除过期数据中的某一个</li><li>volatile-ttl： 越早过期的数据，越优先被删除</li><li>volatile-lru：局部最近最少使用（即过期数据中一直没被用过的，优先删）。<br>特点是会从集合中随机选N个，从N个里选一个LRU最小的删除。<br>好处：Redis不用维护一个巨大的链表，也不用操作链表，进而提升性能</li><li>volatile-lfu：<br>增加了访问次数<br>先在过期集合中判断访问次数，再判断LRU时间、</li></ol><ul><li>第三类：全部数据可能都被淘汰</li></ul><ol start="6"><li>allkeys-lru</li><li>allkeys-random</li><li>allkeys-lfu<br>和volatile的处理一样，区别是 ”所有缓存“ 而非”部分过期缓存“</li></ol><h1><span id="huan-cun-re-dian">缓存热点</span><a href="#huan-cun-re-dian" class="header-anchor">#</a></h1><h2><span id="q-shi-me-shi-re-dian-key-wen-ti">Q: 什么是热点Key问题？</span><a href="#q-shi-me-shi-re-dian-key-wen-ti" class="header-anchor">#</a></h2><p>A:<br>热点问题产生的原因大致有以下两种：</p><p>用户消费的数据远大于生产的数据（热卖商品、热点新闻、热点评论、明星直播）。<br>在日常工作生活中一些突发的的事件，被大量刊发、浏览的热点新闻、热点评论、明星直播等，这些典型的读多写少的场景会产生热点问题。<br>危害：</p><ul><li>请求分片集中，超过单Server的性能极限。</li><li>在服务端读数据进行访问时，往往会对数据进行分片切分，此过程中会在某一主机Server上对相应的Key进行访问，当访问超过Server极限时，就会导致热点Key问题的产生。</li><li>流量集中，达到物理网卡上限。</li><li>请求过多，缓存分片服务被打垮。</li><li>DB击穿，引起业务雪崩。</li></ul><hr><h2><span id="q-ru-he-fa-xian-re-dian">Q:  如何发现热点？</span><a href="#q-ru-he-fa-xian-re-dian" class="header-anchor">#</a></h2><ol><li>最简单的方式，是提前配置热点key，需要运营人员提供相关数据。</li><li>或者搭建有自身业务特点的热点自动发现平台， 通过分析日志得到热点key，及时更新热点保护。</li><li>client-&gt;Proxy-&gt;redis的proxy层做收集上报，其实类似于上面的自动发现收集。<br><a href="https://blog.csdn.net/liu15835467265liu/article/details/103746821/">发现动态热点数据</a><br><a href="https://blog.csdn.net/cxy_19891109/article/details/87480515">秒杀系统之发现动态热点数据</a></li><li>redis自身有个monitor命令， 可以抓取收到的命令，收集上报热点key。</li></ol><hr><h2><span id="q-ru-he-jie-jue-re-dian-wen-ti">Q: 如何解决热点问题？</span><a href="#q-ru-he-jie-jue-re-dian-wen-ti" class="header-anchor">#</a></h2><p>识别到热点后就是处理策略了。</p><ol><li>升级为本地缓存，也就是redis前置服务增加jvm内部缓存，只针对部分热点key。</li><li>紧急扩容redis缓存（但是扩容需要过程，还涉及预热同步主节点数据问题）</li><li>拆分key分散到更多其它缓存节点避免单节点瓶颈**（redis单节点一般10w qps）**， 即单独对这个热点key添加新的分片算法，分到其他本不属于的redis上。</li></ol><p>换句话说， 根本解决方式就是及时进行缓存的扩容。 有种办法是重写redis的访问机制，将slave节点也用上，实现读写分离。<br>redis有个客户端lettuce，可以开启cluster模式下的读写分离， 水平扩容slave节点来无限延申系统容量。<br><a href="https://www.cnblogs.com/williamjie/p/11250789.html">热点Key问题的发现与解决</a></p><hr><h2><span id="q-ru-he-shan-chu-re-dian">Q: 如何删除热点？</span><a href="#q-ru-he-shan-chu-re-dian" class="header-anchor">#</a></h2><p>A:<br>然后就是删除的问题，，保证最终一致性即可，如果是本地缓存可以用MQ广播消息+超时过期的策略，当然还有些极端情况的不一致可以考虑延迟双删和binlog异步刷新</p><hr><h2><span id="q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong">Q: 如何利用redis 实现秒杀系统？</span><a href="#q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong" class="header-anchor">#</a></h2><p>A:<br><a href="https://www.cnblogs.com/williamjie/p/11250753.html">使用Redis搭建电商秒杀系统</a></p><hr><hr><hr><h1><span id="shu-ju-yi-zhi-xing">数据一致性</span><a href="#shu-ju-yi-zhi-xing" class="header-anchor">#</a></h1><h2><span id="q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti">Q: 当需要删除数据时， 如果我先删缓存，再删数据库，可能会有什么问题？</span><a href="#q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti" class="header-anchor">#</a></h2><p>A:<br>删完缓存，业务代码准备去删数据库时， 另一个请求打到redis这，发现不存在，于是另一个处理线程去数据库中取出了数据，并加载到了缓存中。<br>这导致了缓存删除了个寂寞。</p><p>核心原因是因为业务代码的 删库和读-加载操作是支持并发执行的。</p><ul><li>因此应该先删数据库， 再删缓存，  这样能确保不会把脏数据重新加载到内存中</li></ul><hr><h2><span id="q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me">Q:  网络通信正常、命令正常的情况下， 先删库 ，再删缓存， 还是有可能造成脏数据， 知道为什么么？</span><a href="#q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me" class="header-anchor">#</a></h2><p>A:<br>这种情况一般是”读缓存过期“导致的。</p><p>即正好某个key的读缓存过期，被删除。<br>然后查询请求过来， 决定查库并加载到缓存中。<br>此时又正好发来一个删除请求， 删库+删缓存，  然后又被上面的请求给重新加载了。</p><p>但是一般不考虑， 因为 正好过期+ 正好删除请求 +  ”先删库-&gt;查询缓存-&gt;删缓存-&gt;加载缓存的顺序“    这种概率是非常低的。</p><hr><h2><span id="q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao">Q: 如果删了库之后， 再删缓存的途中，网络临时不通怎么办？那缓存也有可能一直脏着了。</span><a href="#q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao" class="header-anchor">#</a></h2><p>A:<br>失败的话，放入一个消息队列。 搞一个定时线程定期取消息队列中的消息进行处理。<br>为了减少业务代码耦合， 弄一个独立的缓存更新程序， 专门从binlog中拿更新消息进行同步。<br><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/f94f82af9a27192d3240215b4ce5f13b785f87b1.png" alt="f94f82af9a27192d3240215b4ce5f13b785f87b1"></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式存储和事务</title>
      <link href="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-cap-fen-bie-zhi-shi-me">Q: CAP分别指什么？</a></li><li><a href="#q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma">Q: 为什么说CAP无法同时满足？ 能讲清楚3种情况吗？</a></li><li><a href="#q-base-jie-jue-fang-an-shi-shi-me">Q: BASE解决方案是什么？</a></li><li><a href="#q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me">Q: 分布式事务种的2PC是什么？</a></li><li><a href="#q-3pc-you-shi-shi-me">Q: 3PC又是什么？</a></li><li><a href="#q-tcc-you-shi-shi-me">Q: TCC又是什么？</a></li><li><a href="#q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue">Q:数据库主从复制的延时问题如何解决？</a></li><li><a href="#q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian">Q：讲一下分布式锁的实现？</a></li><li><a href="#q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo">Q: 详细讲讲如何用数据库实现锁？</a></li><li><a href="#q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de">Q: redis的红锁是什么？解决什么问题的？</a></li><li><a href="#q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng">Q: 如何实现分布式的负载均衡？</a></li><li><a href="#q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan">Q: 主备数据库如何实现主备切换？</a></li><li><a href="#q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi">Q： 如何防止上面的主备切换过程中的新数据丢失？</a></li><li><a href="#q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao">Q: 如何防止主备切换时的数据不同步？ 和上面的数据丢失不同， 这里指的是master节点已经收到数据， 但是还没有往备节点同步时就挂掉了</a></li><li><a href="#q-ru-he-sheng-cheng-fen-bu-shi-id">Q: 如何生成分布式ID？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="q-cap-fen-bie-zhi-shi-me">Q:  CAP分别指什么？</span><a href="#q-cap-fen-bie-zhi-shi-me" class="header-anchor">#</a></h1><p>A:</p><ul><li><p>C  一致性Consistency ——    多台节点之间数据一致 （响应准确度）</p></li><li><p>A  可用性Availability ——    能快速响应结果，没有延迟或者等待  （响应速度，不需要等待）</p></li><li><p>P   分区容错性PartitionTolerance——  如果有一部分节点挂了， 其他区节点还能提供服务 （ 时刻能响应，不会挂）</p></li></ul><hr><h1><span id="q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma">Q: 为什么说CAP无法同时满足？ 能讲清楚3种情况吗？</span><a href="#q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma" class="header-anchor">#</a></h1><p>A:</p><ul><li><p>CA 无P :<br>不支持分区处理请求，  则仅1个节点， 或者全部是时刻联通， 1个挂了，则认为系统不可用。<br>意味着分布式系统的意义不存在。无法扩展。违背初衷<br>传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p></li><li><p>CP 无A：<br>没有可用性。<br>意味着我会尽可能保证数据同步，  不同步的话我就不返回。<br>如果有节点挂了，就用另外正在同步的节点做。<br>例子： redis、hbase 这类和业务实时性强相关较弱的分布式数据库<br>他们要保证一致性，但不一定要马上能返回结果，</p></li><li><p>AP 无C<br>缺失一致性。<br>就是因为节点同步延迟， 你看到的可能和别人的页面不一样，但是至少会马上给你结果。<br>一般用于不重要的广告、 网页推送、推荐之类的功能。</p></li></ul><p>举个例子：<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/c06e14ad98f2204d0498aa5833018c5d8374a45c.png" alt="c06e14ad98f2204d0498aa5833018c5d8374a45c"><br>以这个图为例<br>如果必须满足P<br>则当DB1和DB0的网络通信断开（需要1分钟才能恢复）<br>N2仍旧要能够返回结果。<br>这时候一致性和可用性无法同时满足<br>如果要求有一致性，则必须等待1分钟才会恢复， 则无法立刻响应结果<br>如果要求可用性， 则必须立刻返回结果，  那么无法保证DB0和DB1是一致的。</p><hr><h1><span id="q-base-jie-jue-fang-an-shi-shi-me">Q: BASE解决方案是什么？</span><a href="#q-base-jie-jue-fang-an-shi-shi-me" class="header-anchor">#</a></h1><p>A:<br>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p><ul><li>基本可用（Basically Available）<br>指系统故障时，能保障核心功能可用，接口性能适当降低</li><li>软状态（Soft state）<br>允许存在中间状态，例如支付中、同步中， 也就是允许数据延时</li><li>最终一致（Eventually Consistent）<br>经过一段时间后，所有节点数据都将会达到一致。如订单的&quot;支付中&quot;状态，最终会变 为“支付成功”或者&quot;支付失败&quot;，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ul><hr><h1><span id="q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me">Q: 分布式事务种的2PC是什么？</span><a href="#q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me" class="header-anchor">#</a></h1><p>A:<br>2PC（ two-phase commit protocol）<br>两阶段提交</p><ul><li>第一阶段：请求/表决阶段（点击放大）<br>问一下这些参与节点&quot;这件事你们能不能处理成功了&quot;，参与者节点打开本地数据库事务，完成后并不会立马提交数据库本地事务，而是先向Coordinator报告说：“我这边可以处理了/我这边不能处理”</li><li>第二阶段：提交/执行阶段（正常流程）<br>所有参与者节点都向协调者报告说“我这边可以处理”，协调者向所有参与者节点发送“全局提交确认通知（global_commit）”，参与者节点就会完成自身本地数据库事务的提交，并最终将提交结果回复“ack”消息给Coordinator，然后Coordinator就会向调用方返回分布式事务处理完成的结果。</li><li>第二阶段：提交/执行阶段（异常流程）<br>参与者节点向协调者节点反馈“Vote_Abort”的消息。此时分布式事务协调者节点就会向所有的参与者节点发起事务回滚的消息（“global_rollback”），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。<br>缺点：性能（阻塞等待）、协调者故障、</li></ul><hr><h1><span id="q-3pc-you-shi-shi-me">Q:  3PC又是什么？</span><a href="#q-3pc-you-shi-shi-me" class="header-anchor">#</a></h1><p>A:<br>在两阶段提交的基础上增加了CanCommit阶段 并引入了超时机制 ，一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。</p><p>第一阶段：CanCommit阶段（确认、检查各节点状态）<br>第二阶段：PreCommit阶段（事务预提交，有执行节点的超时机制）<br>第三阶段：DoCommit阶段（同样引入超时）</p><hr><h1><span id="q-tcc-you-shi-shi-me">Q: TCC又是什么？</span><a href="#q-tcc-you-shi-shi-me" class="header-anchor">#</a></h1><p>A:</p><p>补偿事务TCC协议 （Try-Confirm-Cancel）<br>有3个阶段   Try、confirm、cancel</p><ul><li>Try阶段：主要是对业务系统做检测及资源预留。</li><li>Confirm阶段：确认执行业务操作。</li><li>Cancel阶段：取消执行业务操作。</li></ul><blockquote><blockquote><p>2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p></blockquote></blockquote><p>TCC的不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p><hr><h1><span id="q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue">Q:数据库主从复制的延时问题如何解决？</span><a href="#q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue" class="header-anchor">#</a></h1><p>A:<br>分情况讨论</p><ul><li>如果是写操作太多，导致binlog过多，以至于主库写和从库写都很慢——那么可以通过水平扩容的方式，打散写请求。  或者用高版本mysql支持并行binlog复制</li><li>过大的事务，导致主从延时——拆分大事务语句到若干小事务中，这样能够进行及时提交，减小主从复制延时</li><li>对大表进行alter table操作，导致了表会重新生成并进行迁移。——避免业务高峰执行表修改操作，尽量安排在业务低峰期执行</li><li>从库机器规格、配置和主库不一致。 ——从库有时候规格应该比主库配置要高。</li><li>数据库的表缺少主键或者合适索引，导致更新时的主从复制延时。  —— 去检查表结构，保证每个表都有显式自增主键，并协助用户建立合适索引</li><li>从库的查询请求过多，导致性能下降——增加从库数量，打散从库的查询请求。</li></ul><hr><p><a href="https://zhuanlan.zhihu.com/p/92077345">https://zhuanlan.zhihu.com/p/92077345</a></p><hr><h1><span id="q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian">Q：讲一下分布式锁的实现？</span><a href="#q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian" class="header-anchor">#</a></h1><p>A:<br>分布式锁实现</p><p><a href="https://blog.csdn.net/wuzhiwei549/article/details/80692278">https://blog.csdn.net/wuzhiwei549/article/details/80692278</a></p><ul><li>从理解的难易程度角度（从低到高）</li></ul><p>数据库（最简单） &gt; 缓存 &gt; Zookeeper</p><ul><li>从实现的复杂性角度（从低到高）</li></ul><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><ul><li>从性能角度（从高到低）</li></ul><p>缓存（最快） &gt; Zookeeper &gt;= 数据库</p><ul><li>从可靠性角度（从高到低）</li></ul><p>Zookeeper（最可靠） &gt; 缓存（怕主节点突然挂了，导致锁失效） &gt; 数据库（无失效时间，挂了就gg）</p><hr><h1><span id="q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo">Q: 详细讲讲如何用数据库实现锁？</span><a href="#q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo" class="header-anchor">#</a></h1><p>A:<br>有个locker表<br>分别有4个字典</p><ul><li>锁名</li><li>持有锁的机器id</li><li>version</li><li>超时时间</li></ul><p>先查出这个锁名所在的行数据<br>判断这个锁的id是否为空。<br>如果不为空，且机器id也不是自己，说明被人持有了，返回false。<br>如果为空， 则会尝试去更新， 使用   update 机器id where lockname=‘xxx’ and  <strong>version = 刚才拿到的version+1</strong><br>如果update返回的结果不为0，说明更新成功， 返回true，持有锁成功。<br>如果update结果为0， 说明抢锁失败， 因为version被人改了，导致where条件不成立，没更新任何一条</p><p>抢到锁的人完成自己的事务操作后， 释放锁，即把锁id清理即可。<br>没抢到的人自己选择等一段时间再获取，或者频繁查询。</p><p>利用的行锁和MVCC的特性实现。<br>图片如下：<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/0e3326d72b41e735c84aec1ebb1b23f34149834b.png" alt="locker锁表"></p><hr><h1><span id="q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de">Q: redis的红锁是什么？解决什么问题的？</span><a href="#q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de" class="header-anchor">#</a></h1><p>A:<br>解决的问题：<br>Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点；master故障，发生故障转移，slave节点升级为master节点，导致锁丢失。</p><p>如何解决：</p><ol><li>获取当前时间（单位是毫秒）。</li><li>轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li><li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li><li>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li><li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li></ol><hr><h1><span id="q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng">Q: 如何实现分布式的负载均衡？</span><a href="#q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng" class="header-anchor">#</a></h1><p>A:</p><p>nginx的负载均衡方式<br>反向代理，作为代理服务器进行请求转发。<br>轮询： 指定1个服务器ip列表， 依次按顺序分配<br>weight权重： 根据指定权重， 分配的概率会变高（和服务器不同性能相关）<br>ip哈希算法：  让特定ip都导向同一个服务器（避免不同服务器频繁获取某个用户信息）<br>fair响应时间算法：  根据响应时间，动态调整分配优先级<br>url哈希： 类似ip哈希，根据url哈希，一般是某个服务器会做特定接口缓存的情况。</p><hr><h1><span id="q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan">Q:  主备数据库如何实现主备切换？</span><a href="#q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan" class="header-anchor">#</a></h1><p>A:<br>两种方式</p><ol><li>配置中心实现。 当监控系统发现异常后， 运维人员手动修改配置中心的数据源信息。  shark支持了基于zk的配置中心客户端。</li><li>给主备节点部署keepalive程序。  需要主备机器配置虚拟ip（类似于浮动ip),支持机器进行ip切换。<br>运行过程中，  master和slave机器上的keepalived程序会互相发心跳，确认对方是否存货。 一旦master实例出现异常， 主节点的keeplive会自杀， 同时slave节点开始接管这个虚拟ip。</li></ol><hr><h1><span id="q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi">Q： 如何防止上面的主备切换过程中的新数据丢失？</span><a href="#q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi" class="header-anchor">#</a></h1><p>A:<br>数据优先插入到缓存服务，再通过消息队列插入到数据库， 如果主节点挂了，可以通过failover机制重发，当切换成功后，就能插入到更新后的master节点上了（ 前提是failover的总时间大于主备切换的时间）</p><hr><h1><span id="q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao">Q: 如何防止主备切换时的数据不同步？ 和上面的数据丢失不同， 这里指的是master节点已经收到数据， 但是还没有往备节点同步时就挂掉了</span><a href="#q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao" class="header-anchor">#</a></h1><p>A:</p><ul><li><p>方法1： 如果要求数据强一致， 可以开启半同步复制模式， 即事务提交到master时，master会先发binlog给slave，当slave响应成功后，master才会完成这个事务。 （TPS较高场景不适合该模式）</p></li><li><p>方法2： 就是上面提到的缓存机制，先缓存，再落库。 然后再依靠 GTID（全局事务id）来保证主备数据的最终一致性。</p></li></ul><p>GTID即全局事务ID (global transaction identifier), 其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GTID最初由google实现，官方MySQL在5.6才加入该功能。mysql主从结构在一主一从情况下对于GTID来说就没有优势了，而对于2台主以上的结构优势异常明显，可以在数据不丢失的情况下切换新主<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/5e695f9c56a67777bdb1727f6c2f805f16b0140c.png" alt="5e695f9c56a67777bdb1727f6c2f805f16b0140c"><br>如图, Server1(Master)崩溃，根据从上show slave status获得Master_log_File/Read_Master_Log_Pos的值，Server2(Slave)已经跟上了主，Server3(Slave)没有跟上主。这时要是把Server2提升为主，Server3变成Server2的从。这时在Server3上执行change的时候需要做一些计算。</p><p>这个问题在5.6的GTID出现后，就显得非常的简单。由于同一事务的GTID在所有节点上的值一致，那么<strong>根据Server3当前停止点的GTID就能定位到Server2上的GTID</strong>。甚至由于MASTER_AUTO_POSITION功能的出现，我们都不需要知道GTID的具体值，直接使用CHANGE MASTER TO MASTER_HOST=‘xxx’, MASTER_AUTO_POSITION命令就可以直接完成failover的工作。</p><hr><h1><span id="q-ru-he-sheng-cheng-fen-bu-shi-id">Q: 如何生成分布式ID？</span><a href="#q-ru-he-sheng-cheng-fen-bu-shi-id" class="header-anchor">#</a></h1><p>A:</p><ul><li>UUID<br>UUID.randomUUID()<br>UUID有5个版本，第一个版本比较好理解<br>基于时间戳、随机数、机器MAC地址（java中改成ip地址）生成UUID<br>随机性过强，不连续</li><li>数据库自增ID<br>需要一个单独的MySQL实例用来生成ID，给id字段加上auto_increment关键字，自动id，只不过可能会不连续（可能挂掉）</li><li>数据库多主模式<br>设置两个Mysql实例都能单独的生产自增ID<br>2个实例的自增大小相同，但是起始值不同，就能保证隔开了<br>不方便扩容</li><li>号段模式<br>从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存<br>多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。<br>主流</li><li>Redis<br>利用redis的 incr命令实现ID的原子性自增<br>RDB备份可能导致id重复<br>AOF备份可能导致重启时间过长</li><li>雪花算法Snowflake<br>Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型<br>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p><a href="https://zhuanlan.zhihu.com/p/107939861">9种分布式ID生成方式</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列设计</title>
      <link href="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me">Q: 消息队列的作用是什么？</a></li><li><a href="#q-xiao-xi-dui-lie-du-you-shi-me-que-dian">Q: 消息队列都有什么缺点？</a></li><li><a href="#q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian">Q: Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</a></li><li><a href="#q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling">Q: 如何保证消息队列的高可用？不会因为1台消息队列服务挂掉导致服务失灵？</a></li><li><a href="#q-zen-me-zhi-dao-leader-diao-xian">Q: 怎么知道leader掉线？</a></li><li><a href="#q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei">Q: 如何保证消息不会被重复消费？</a></li><li><a href="#q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de">Q: 是如何保证消息消费时一定是幂等的？</a></li><li><a href="#q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei">Q: 消息队列 mq 怎么保证顺序消费？</a></li><li><a href="#q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi">Q: 如何保证消息的可靠性传输，不会丢失？</a></li><li><a href="#q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya">Q:消息队列满了, 发生阻塞积压怎么办？例如突然流量峰值， 几百万消息持续积压？</a></li><li><a href="#q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu">Q: 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me">Q: 消息队列的作用是什么？</span><a href="#q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h1><p>A:</p><ul><li><p>解耦：<br>通过一个MQ，发布和订阅模型（Pub/Sub模型），系统A就和其它系统彻底解耦。<br>需要考虑一下负责的系统中，是否有类似的场景，就是一个系统或者一个模块，调用了多个系统，互相之间的调用很复杂，维护起来很麻烦。（新增、删除接口都是要两边互相适配）<br>但是其实这个调用是不需要同步调用接口的（不需要等待返回），如果用MQ给他异步化解耦，也是可以的，这个时候可以考虑在自己的项目中，是不是可以运用这个MQ来进行系统的解耦。</p></li><li><p>异步：<br>加快接口的返回。</p></li><li><p>削峰<br>就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。</p></li></ul><hr><h1><span id="q-xiao-xi-dui-lie-du-you-shi-me-que-dian">Q: 消息队列都有什么缺点？</span><a href="#q-xiao-xi-dui-lie-du-you-shi-me-que-dian" class="header-anchor">#</a></h1><p>A:</p><ul><li>系统可用性降低： MQ挂掉的话很危险</li><li>系统复杂性提高：要考虑消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性</li><li>一致性问题：存在关联的消息，被不同消费者消费，如果另一个消费者执行失败，如何感知和回退？</li></ul><hr><h1><span id="q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian">Q: Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</span><a href="#q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian" class="header-anchor">#</a></h1><p>A:<br>列出一个表格<br><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/63e89c47a42f0a17c97a8a2a303e4aeabd0a6de1.png" alt="63e89c47a42f0a17c97a8a2a303e4aeabd0a6de1"></p><p>简单记忆rabitMq和kafka的区别</p><ol><li>kafka高吞吐，适合大数据量的实时计算、日志采集。 但rabitMq的时延更小。</li><li>rabitMq基于主从， kafka则支持分布式（多副本）</li><li>rabitQq基于erlang开发， kafka用scala开发。</li></ol><hr><h1><span id="q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling">Q: 如何保证消息队列的高可用？不会因为1台消息队列服务挂掉导致服务失灵？</span><a href="#q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling" class="header-anchor">#</a></h1><p>A:<br>只讲一下kafka的</p><p>每个partition属于多台机器。<br>有一个是leader节点<br>leader会把数据同步到另外2台机器。<br>如果leader挂了，则消费者选择读取 这个partition的另外2台机器</p><p>假设其中的一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此kafka会自动感知leader已经宕机，同时将其它的follower给选举出来，作为新的leader，并向外提供服务支持。<br><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/45e7b2c323914c2bcc4ed65a2d3d872471f920ed.png" alt="45e7b2c323914c2bcc4ed65a2d3d872471f920ed"></p><hr><h1><span id="q-zen-me-zhi-dao-leader-diao-xian">Q: 怎么知道leader掉线？</span><a href="#q-zen-me-zhi-dao-leader-diao-xian" class="header-anchor">#</a></h1><p>A:<br>对于Kafka而言，定义一个Broker是否“活着”包含两个条件：</p><p>一是它必须维护与ZooKeeper的session（这个通过ZooKeeper的Heartbeat机制来实现）。<br>二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。<br>Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除</p><p>更详细的解释，包括如何感知掉线（ack、zk-session）、如何选举<br><a href="https://www.cnblogs.com/qingyunzong/p/9004703.html">Kafka学习之路 （三）Kafka的高可用</a></p><hr><h1><span id="q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei">Q: 如何保证消息不会被重复消费？</span><a href="#q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei" class="header-anchor">#</a></h1><p>A: 需要消息消费者保证幂等性， 同样的消息，消费2次，结果是一样的。</p><p>幂等性是什么？通俗点说：幂等性就是一个数据，或者一个请求，以相同的内容和方式给你执行多次，得保证对应的数据不会改变，并且不能出错，这就是幂等性。（这样才能做到发送者搞重试或者多发问题）</p><hr><h1><span id="q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de">Q: 是如何保证消息消费时一定是幂等的？</span><a href="#q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de" class="header-anchor">#</a></h1><p>A:<br>需要应用服务器消费消息时是幂等的， 注意<strong>消息队列不保证幂等</strong>。<br>消费中如果是insert相关，且只会insert1次的，通过主键判断，避免重插（消费端）<br>消费端业可以加一个redis， 以缓存消费过的记录， 重复消费可以通过redis识别，并且redis是临时缓存，不会占用太多资源。</p><hr><h1><span id="q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei">Q: 消息队列 mq 怎么保证顺序消费？</span><a href="#q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei" class="header-anchor">#</a></h1><p>A:<br>abbitmq 中， 每个消费者对应一个队列<br>kafka中， 每个消费者对应一个 partition。 partion中是有序的。</p><p>即kafka能保证塞入partion时是有序的<br>因此你要求有序的那堆请求，要有相同的key映射到同一个partion</p><p>同时消费者处理的时候，也要按照核心key在内存中分配给不同的线程（内存线程使用加锁队列去获取消息）， 避免多线程处理的时候出现混乱<br><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/e536b0c4b51e6b9230a6f586b3cb7c65fc9f23d9.png" alt="e536b0c4b51e6b9230a6f586b3cb7c65fc9f23d9"></p><hr><h1><span id="q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi">Q: 如何保证消息的可靠性传输，不会丢失？</span><a href="#q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi" class="header-anchor">#</a></h1><p>A:<br>生产者发送到 MQ的时候丢了： 生产者使用ack机制，如果超时没收到，就回调nack接口做重发</p><p>MQ没发给消费者： 消息持久化，如果MQ挂了，还可以从磁盘中恢复重发。（ack应该在存盘后再发给生产者）</p><p>消费端没收到数据或者消费者挂了：<br>关闭MQ的自动ack， 在消费者的代码逻辑里自己实现ack机制，保证是自己处理完成后才发ack，而不是收到了就发ack。<br>对于kafka来说， 消费者的ack其实就是offset。 offset不能自动发，要自己实现。</p><hr><h1><span id="q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya">Q:消息队列满了, 发生阻塞积压怎么办？例如突然流量峰值， 几百万消息持续积压？</span><a href="#q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya" class="header-anchor">#</a></h1><p>A:<br>运维根据告警信息， 对queue资源和consumer资源都临时进行紧急进行人工扩容。</p><hr><h1><span id="q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu">Q: 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</span><a href="#q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu" class="header-anchor">#</a></h1><p>A:</p><ol><li><p>首先MQ得支持可伸缩性<br>那就需要快速扩容，就可以增加吞吐量和容量，可以设计一个分布式的系统，参考kafka的设计理念，broker - &gt; topic -&gt; partition，每个partition放一台机器，那就存一部分数据，如果现在资源不够了，可以给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多的数据，提高更高的吞吐量</p></li><li><p>其次得考虑一下这个MQ的数据要不要落地磁盘？也就是需不需要保证消息持久化，因为这样可以保证数据的不丢失，那落地盘的时候怎么落？顺序写，这样没有磁盘随机读写的寻址开销，磁盘顺序读的性能是很高的，这就是kafka的思路。</p></li><li><p>其次需要考虑MQ的可用性？这个可以具体到我们上面提到的消息队列保证高可用，提出了多副本 ，leader 和follower模式，当一个leader宕机的时候，马上选取一个follower作为新的leader对外提供服务。</p></li><li><p>需不需要支持数据0丢失？可以参考kafka零丢失方案</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第311场周赛-104名-4题</title>
      <link href="/2022/09/18/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98%20/"/>
      <url>/2022/09/18/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98%20/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98%20/1663509817507.png" alt="1663509817507"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>子数字、子序列的题目， 一定要关注一下有没有”连续“二字！</li><li>排列组合公式可以记忆一下，特别是C二维数组中左边是啥，右边是啥</li></ol><hr><p><a href="https://leetcode.cn/problems/smallest-even-multiple/">6180. 最小偶倍数 - 力扣（LeetCode）</a></p><p>sb题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?n:n*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/">6181. 最长的字母序连续子字符串的长度 - 力扣（LeetCode）</a></p><p>单指针直接遍历计数就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestContinuousSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">lastC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != lastC + <span class="number">1</span>) &#123;</span><br><span class="line">                res = Math.max(len, res);</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;   </span><br><span class="line">            &#125;</span><br><span class="line">            lastC = c;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(len, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/">6182. 反转二叉树的奇数层 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98%20/1663509945954.png" alt="1663509945954"></p><p>先后序dfs记录每个点在哪个层，放进一个list</p><p>然后按层遍历哪些list，把他们的值返回来重新存放即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reverseOddLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;TreeNode&gt;&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="number">0</span>, nodes);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;TreeNode&gt;&gt; entry : nodes.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            List&lt;TreeNode&gt; list = entry.getValue();</span><br><span class="line">            List&lt;Integer&gt; valus = list.stream().map(tn -&gt; tn.val).collect(Collectors.toList());</span><br><span class="line">            Collections.reverse(valus);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size();i++) &#123;</span><br><span class="line">                list.get(i).val = valus.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> level, Map&lt;Integer, List&lt;TreeNode&gt;&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left, level+<span class="number">1</span>, map);</span><br><span class="line">        dfs(node.right, level+<span class="number">1</span>, map);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(level)) &#123;</span><br><span class="line">            map.put(level, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(level).add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/">6183. 字符串的前缀分数和 - 力扣（LeetCode）</a></p><p>字段树，只有1000的范围，不会超，直接构建完树后直接遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Node[] nextNodes = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sumPrefixScores(String[] words) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>].count++;</span><br><span class="line">                node = node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[words.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sum += node.nextNodes[c - <span class="string">&#x27;a&#x27;</span>].count;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[i++] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描线（叠加区间问题）</title>
      <link href="/2022/09/17/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%8F%A0%E5%8A%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2022/09/17/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%8F%A0%E5%8A%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#sao-miao-xian-gai-nian">扫描线概念</a></li><li><a href="#bu-zou">步骤</a></li><li><a href="#xiang-guan-ti-mu">相关题目</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="sao-miao-xian-gai-nian">扫描线概念</span><a href="#sao-miao-xian-gai-nian" class="header-anchor">#</a></h1><p>多个连续区间，计算叠加部分要去掉或者叠加某个价值，这种题常见于那种任务流</p><p>区间的坐标很大（一般是10^9）导致无法遍历坐标值， 但你可以遍历起点和终点坐标。</p><p>则可以将这些起点和终点作为纳入扫描点，逐个按从左到右的顺序扫描,并更新所谓的“高度&quot;&quot;，每次做宽度 乘 高度的计算</p><h1><span id="bu-zou">步骤</span><a href="#bu-zou" class="header-anchor">#</a></h1><ol><li>将终点和起点都放入数组排序， 并注意保留是起点还是终点的信息（有可能起点和终点相同，如果没保留这个标志可能导致出错）</li><li>从左到右扫描各点</li><li>扫描到某点时， 先不着急更新<strong>高度</strong>，  而是先计算&quot;当前高度乘上（当前位置减去上一个位置）&quot;。注意这个过程不需要区分是起点还是终点，都可以直接算。</li><li>计算完成后， 根据是起点还是终点，来更新所谓的高度</li><li>更新上一个位置</li></ol><hr><h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/rectangle-area-ii/">850. 矩形面积 II - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 算法大全 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题常见情况应对思路</title>
      <link href="/2022/09/16/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/09/16/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jie-da-cuo-wu">解答错误</a><ul><li><a href="#pai-cha-yi-shu-zhi-yi-chu">排查一：数值溢出</a></li></ul></li><li><a href="#pai-cha-er-er-fen-fa-xun-zhao-guan-jian-yong-li">排查二： 二分法寻找关键用例</a></li><li><a href="#chao-shi">超时</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="jie-da-cuo-wu">解答错误</span><a href="#jie-da-cuo-wu" class="header-anchor">#</a></h1><h2><span id="pai-cha-yi-shu-zhi-yi-chu">排查一：数值溢出</span><a href="#pai-cha-yi-shu-zhi-yi-chu" class="header-anchor">#</a></h2><p>排查是否存在数值溢出， int要改成用long， 或者根据题意在某个可能溢出的部分没有mod(10^9+7)</p><h1><span id="pai-cha-er-er-fen-fa-xun-zhao-guan-jian-yong-li">排查二： 二分法寻找关键用例</span><a href="#pai-cha-er-er-fen-fa-xun-zhao-guan-jian-yong-li" class="header-anchor">#</a></h1><p>如果给出了用例， 但是用例里的值或者数组特别多，也不存在溢出问题，说明是题意理解有错，且肯定和某个关键值有关（如果不是某个关键值，那么简单用例就该出错了）</p><p>例如：</p><p><img src="/images/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/1663347973949.png" alt="1663347973949"></p><p>则你应对不断二分删除里面的数据， 对比结果，直到缩小用例范围，便可以调试或者打印信息来确认问题原因了。</p><p>上面这边最后可以定位到这样小的范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">166</span>,<span class="number">0</span>,<span class="number">166</span>,<span class="number">808</span>],[<span class="number">441</span>,<span class="number">0</span>,<span class="number">644</span>,<span class="number">435</span>]]</span><br></pre></td></tr></table></figure><p>从而发现是[166,0,166,808]这个数据，明明题目说是矩形，却可以允许x1和x2相等。。</p><h1><span id="chao-shi">超时</span><a href="#chao-shi" class="header-anchor">#</a></h1>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 算法大全 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll原理</title>
      <link href="/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-select-poll-de-que-dian">Q: select/poll的缺点？</a></li><li><a href="#epoll-de-she-ji-yao-dian">epoll的设计要点</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p>来源：<br><a href="https://blog.csdn.net/wxy941011/article/details/80274233">Redis IO多路复用技术以及epoll实现原理</a><br><a href="https://www.sohu.com/a/343216187_120104204">精通Redis！epoll?IO的同/异步、阻塞/非阻塞？都懂了吗?</a></p><hr><h1><span id="q-select-poll-de-que-dian">Q:  select/poll的缺点？</span><a href="#q-select-poll-de-que-dian" class="header-anchor">#</a></h1><p>A:</p><ul><li>select的本质是采用32个整数的32位，即32<em>32= 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE的大小。这个时候就可以标识32</em>max值范围的fd。</li><li>poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</li><li>select/poll的几大缺点：</li></ul><ol><li>每次调用select/poll，都需要把<strong>fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></li><li>同时每次调用select/poll都需要在<strong>内核遍历</strong>传递进来的所有fd，这个开销在fd很多时也很大</li><li>针对select支持的文件描述符数量<strong>太小了</strong>，默认是1024</li><li>select返回的是含有整个句柄的数组，<strong>应用程序需要遍历</strong>整个数组才能发现哪些句柄发生了事件；</li><li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li><li>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制 ，但其他三个缺点依然存在。</li></ol><p>而用了epoll，上面select的缺点都不复存在了。<br>他们三者的对比如下：<br><img src="/images/epoll%E5%8E%9F%E7%90%86/af606199b857d67784fc708b01ad193a0ae5b2ab.png" alt="af606199b857d67784fc708b01ad193a0ae5b2ab"></p><hr><h1><span id="epoll-de-she-ji-yao-dian">epoll的设计要点</span><a href="#epoll-de-she-ji-yao-dian" class="header-anchor">#</a></h1><p>A:</p><ol><li><p>首选Epoll在Linux内核中构建了一个文件系统，该文件系统<strong>采用红黑树</strong>来构建，红黑树在查询、新增、删除的效率极高，保障了在存在大量活跃连接的情况下的性能。 即新连接通过红黑树方式插入和更新</p></li><li><p>其次Epoll红黑树上采用事件异步唤醒，内核监听I/O，<strong>事件发生后内核搜索红黑树并将对应节点数据放入异步唤醒的事件队列中</strong>。这就避免了无差别的轮询，不会因为连接数增加而导致性能的快速下降。</p></li><li><p>最后Epoll的数据从用户空间到内核空间采用mmap存储I/O映射来加速。该方法是目前Linux进程间通信中传递最快,消耗最小,传递数据过程不涉及系统调用的方法。这点大大提升了存在大量FD时数据拷贝的消耗</p></li></ol><blockquote><blockquote><p>详细解释：epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象</p></blockquote></blockquote><p><img src="/images/epoll%E5%8E%9F%E7%90%86/398cc1e5fdaa0abf90cd8e577fd826ade07c3ecf.png" alt="398cc1e5fdaa0abf90cd8e577fd826ade07c3ecf"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> linux-unix原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,linux-unix原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux零拷贝</title>
      <link href="/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#dma">DMA</a><ul><li><a href="#q-dma-de-zuo-yong-shi-shi-me">Q:DMA的作用是什么？</a></li></ul></li><li><a href="#chuan-tong-shu-ju-chuan-song">传统数据传送</a></li><li><a href="#ling-kao-bei-yuan-li">零拷贝原理</a><ul><li><a href="#shi-me-shi-ling-kao-bei">什么是零拷贝?</a></li><li><a href="#yi-mmap-nei-cun-ying-she">一、mmap内存映射</a></li><li><a href="#er-sendfile">二、sendfile</a></li><li><a href="#san-sendfile-with-dma-scatter-gather-copy">三、、Sendfile With DMA Scatter/Gather Copy</a></li><li><a href="#si-splice">四、splice</a></li></ul></li><li><a href="#linux-ling-kao-bei-ji-zhi-dui-bi">linux 零拷贝机制对比</a></li><li><a href="#ling-kao-bei-de-ying-yong">零拷贝的应用</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p><a href="https://www.jianshu.com/p/2fd2f03b4cc3">来源参考</a></p><blockquote></blockquote><h1><span id="dma">DMA</span><a href="#dma" class="header-anchor">#</a></h1><h2><span id="q-dma-de-zuo-yong-shi-shi-me">Q:DMA的作用是什么？</span><a href="#q-dma-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>IO中断，需要CPU响应，需要CPU参与，因此效率比较低<br>用户进程需要读取磁盘数据，需要CPU中断，发起IO请求，每次的IO中断，都带来CPU的上下文切换。<br>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。</p><hr><p>实际因此IO读取，涉及两个过程：</p><ol><li>DMA等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</li><li>用户进程，将内核缓冲区的数据copy到用户空间。<br>这两个过程，都是阻塞的,占用时间。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/9bc71cd4950d1563b41e145c834a7a02714125b7.png" alt="9bc71cd4950d1563b41e145c834a7a02714125b7"></li></ol><h1><span id="chuan-tong-shu-ju-chuan-song">传统数据传送</span><a href="#chuan-tong-shu-ju-chuan-song" class="header-anchor">#</a></h1><p>Q: 传统数据传送的缺点是什么？</p><p>A: 如果是把文件二进制数据直接通过网络传输， 会涉及4次传输。</p><ol><li>第一次：将磁盘文件，读取到操作系统内核缓冲区；</li><li>第二次：将内核缓冲区的数据，copy到application应用程序的buffer；</li><li>第三步：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；</li><li>第四次：将socket buffer的数据，copy到网卡，由网卡进行网络传输。</li></ol><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/b81d9302d0571857e766209319deeb824473bd49.png" alt="b81d9302d0571857e766209319deeb824473bd49"></p><p>如果不对数据做特殊处理的话， 那么2和3是没有必要的。</p><h1><span id="ling-kao-bei-yuan-li">零拷贝原理</span><a href="#ling-kao-bei-yuan-li" class="header-anchor">#</a></h1><h2><span id="shi-me-shi-ling-kao-bei">什么是零拷贝?</span><a href="#shi-me-shi-ling-kao-bei" class="header-anchor">#</a></h2><p>零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p><ul><li>零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</li><li>零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销</li></ul><blockquote><p>可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</p></blockquote><p>目的：减少IO流程中不必要的拷贝<br>零拷贝需要OS支持，也就是需要kernel暴露api。虚拟机不能操作内核，</p><h2><span id="yi-mmap-nei-cun-ying-she">一、mmap内存映射</span><a href="#yi-mmap-nei-cun-ying-she" class="header-anchor">#</a></h2><p>DMA加载磁盘数据到kernel buffer后，应用程序缓冲区(application buffers)和内核缓冲区(kernel buffer)进行映射，数据再应用缓冲区和内核缓存区的改变就能省略。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/3fb0ac7085f297bc9ebc376ca0b813313c0b703b.png" alt="3fb0ac7085f297bc9ebc376ca0b813313c0b703b"></p><p>mmap内存映射将会经历：3次拷贝: 1次cpu copy，2次DMA copy；</p><p>epoll中事件的传递用的是mmap</p><h2><span id="er-sendfile">二、sendfile</span><a href="#er-sendfile" class="header-anchor">#</a></h2><p>当调用sendfile()时，DMA将磁盘数据复制到kernel buffer，然后将内核中的kernel buffer直接拷贝到socket buffer；<br>一旦数据全都拷贝到socket buffer，sendfile()系统调用将会return、代表数据转化的完成。<br>socket buffer里的数据就能在网络传输了。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/6bc1d3912c82b88534cca1582fb77446d1a45916.png" alt="6bc1d3912c82b88534cca1582fb77446d1a45916"><br>sendfile会经历：3次拷贝，1次CPU copy 2次DMA copy；<br>以及2次上下文切换</p><h2><span id="san-sendfile-with-dma-scatter-gather-copy">三、、Sendfile With DMA Scatter/Gather Copy</span><a href="#san-sendfile-with-dma-scatter-gather-copy" class="header-anchor">#</a></h2><p>Scatter/Gather可以看作是sendfile的增强版，批量sendfile。</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/dae3d6b62f5de10f215226d8a8790ecc7ee6db5b.png" alt="dae3d6b62f5de10f215226d8a8790ecc7ee6db5b"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/49ca15a47fae3cad2a776b8fdd5c4b5099f1cf5e.png" alt="49ca15a47fae3cad2a776b8fdd5c4b5099f1cf5e"><br><a href="https://blog.csdn.net/weixin_38006908/article/details/87375404">浅谈scatter-gather DMA</a><br>Scatter/Gather会经历2次拷贝: 0次cpu copy，2次DMA copy</p><p>为什么都是sendfile，  scatter/gather不需要cpu拷贝呢？<br>我理解是copy过程借助的是DMA的gathercopy， 不再需要cpu的参与， 他可以一次性全部拷贝完，不用分多次。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/7941f2f9868b88a70c970e955c7ceff5495734cd.png" alt="7941f2f9868b88a70c970e955c7ceff5495734cd"></p><h2><span id="si-splice">四、splice</span><a href="#si-splice" class="header-anchor">#</a></h2><p>数据从磁盘读取到OS内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据buffer，而不需要拷贝到用户空间。<br>如下图所示，从磁盘读取到内核buffer后，在内核空间直接与socket buffer建立pipe管道。<br>和sendfile()不同的是，splice()不需要硬件支持。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/d24a7b4f5d20e931f5a4b6bd681f556b98a012c5.png" alt="d24a7b4f5d20e931f5a4b6bd681f556b98a012c5"><br>splice会经历 2次拷贝: 0次cpu copy 2次DMA copy；</p><blockquote><blockquote><p>注意splice和sendfile的不同，sendfile是将磁盘数据加载到kernel buffer后，需要一次CPU copy,拷贝到socket buffer。<br>而splice是更进一步，连这个CPU copy也不需要了，直接将两个内核空间的buffer进行set up pipe。</p></blockquote></blockquote><h1><span id="linux-ling-kao-bei-ji-zhi-dui-bi">linux 零拷贝机制对比</span><a href="#linux-ling-kao-bei-ji-zhi-dui-bi" class="header-anchor">#</a></h1><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/e44c722b8b1949c80cd6267f9abc23e5e78bd4f0.png" alt="e44c722b8b1949c80cd6267f9abc23e5e78bd4f0"></p><h1><span id="ling-kao-bei-de-ying-yong">零拷贝的应用</span><a href="#ling-kao-bei-de-ying-yong" class="header-anchor">#</a></h1><p>Q: 知道零拷贝用在哪些地方吗？<br>A:</p><ul><li>NIO提供的内存映射 MappedByteBuffer   ——Linux mmap()</li><li>NIO  FileChannel.transferTo()  —— Linux sendfile()</li><li>Kafka Producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入；</li><li>Kafka Customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。</li></ul><hr><ul><li>mmap 适合小数据量读写，sendFile 适合大文件传输。</li><li>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</li><li>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</li><li>在这个选择上：rocketMQ 在消费消息时，使用了 mmap。kafka 使用了 sendFile。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> linux-unix原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,linux-unix原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统启动过程</title>
      <link href="/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zheng-ti-liu-cheng">整体流程</a></li><li><a href="#qi-dong-di-yi-bu-jia-zai-bios">启动第一步－－加载BIOS</a></li><li><a href="#qi-dong-di-er-bu-du-qu-mbr">启动第二步－－读取MBR</a></li><li><a href="#qi-dong-di-san-bu-boot-loader">启动第三步－－Boot Loader</a></li><li><a href="#qi-dong-di-si-bu-jia-zai-nei-he"><strong>启动<strong><strong>第四步</strong></strong>－－加载内核</strong></a></li><li><a href="#qi-dong-di-wu-bu-yong-hu-ceng-init-yi-ju-inittab-wen-jian-lai-she-ding-yun-xing-deng-ji"><strong>启动<strong><strong>第五步</strong></strong>－－用户层init依据inittab文件来设定运行等级</strong></a></li><li><a href="#qi-dong-di-liu-bu-init-jin-cheng-zhi-xing-rc-sysinit"><strong>启动<strong><strong>第六步</strong></strong>－－init进程执行rc.sysinit</strong></a></li><li><a href="#qi-dong-di-qi-bu-qi-dong-nei-he-mo-kuai"><strong>启动<strong><strong>第七步</strong></strong>－－启动内核模块</strong></a></li><li><a href="#qi-dong-di-ba-bu-zhi-xing-bu-tong-yun-xing-ji-bie-de-jiao-ben-cheng-xu"><strong>启动<strong><strong>第八步</strong></strong>－－执行不同运行级别的脚本程序</strong></a></li><li><a href="#qi-dong-di-jiu-bu-zhi-xing-etc-rc-d-rc-local"><strong>启动<strong><strong>第九步</strong></strong>－－执行/etc/rc.d/rc.local</strong></a></li><li><a href="#qi-dong-di-shi-bu-zhi-xing-bin-login-cheng-xu-jin-ru-deng-lu-zhuang-tai"><strong>启动<strong><strong>第十步</strong></strong>－－执行/bin/login程序，进入登录状态</strong></a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="zheng-ti-liu-cheng">整体流程</span><a href="#zheng-ti-liu-cheng" class="header-anchor">#</a></h1><ol><li><p>加载BIOS(CPU相关信息)</p></li><li><p>读取磁道第一个扇区MBR（预启动信息）</p></li><li><p>boot loader(操作系统运行之前运行的小程序)</p></li><li><p>加载内核</p></li><li><p>设定运行等级</p></li><li><p>启动内核</p></li><li><p>启动脚本登录界面</p></li></ol><h1><span id="qi-dong-di-yi-bu-jia-zai-bios">启动第一步－－加载BIOS</span><a href="#qi-dong-di-yi-bu-jia-zai-bios" class="header-anchor">#</a></h1><p>当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。</p><h1><span id="qi-dong-di-er-bu-du-qu-mbr">启动第二步－－读取MBR</span><a href="#qi-dong-di-er-bu-du-qu-mbr" class="header-anchor">#</a></h1><p>众所周知，硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。</p><p>系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。</p><h1><span id="qi-dong-di-san-bu-boot-loader">启动第三步－－Boot Loader</span><a href="#qi-dong-di-san-bu-boot-loader" class="header-anchor">#</a></h1><p>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。</p><p>Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。</p><p>我们以Grub为例来讲解吧，毕竟用lilo和spfdisk的人并不多。</p><p>系统读取内存中的grub配置信息（一般为menu.lst或grub.lst），并依照此配置信息来启动不同的操作系统。</p><h1><span id="qi-dong-di-si-bu-jia-zai-nei-he"><strong>启动<strong><strong>第四步</strong></strong>－－加载内核</strong></span><a href="#qi-dong-di-si-bu-jia-zai-nei-he" class="header-anchor">#</a></h1><p>根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。</p><p>系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。</p><h1><span id="qi-dong-di-wu-bu-yong-hu-ceng-init-yi-ju-inittab-wen-jian-lai-she-ding-yun-xing-deng-ji"><strong>启动<strong><strong>第五步</strong></strong>－－用户层init依据inittab文件来设定运行等级</strong></span><a href="#qi-dong-di-wu-bu-yong-hu-ceng-init-yi-ju-inittab-wen-jian-lai-she-ding-yun-xing-deng-ji" class="header-anchor">#</a></h1><p>内核被加载后，<strong>第一个</strong>运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。</p><p>其实/etc/inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。Linux的运行等级设定如下：</p><p>0：关机</p><p>1：单用户模式</p><p>2：无网络支持的多用户模式</p><p>3：有网络支持的多用户模式</p><p>4：保留，未使用</p><p>5：有网络支持有X-Window支持的多用户模式</p><p>6：重新引导系统，即重启</p><p>关于/etc/inittab文件的学问，其实还有很多</p><h1><span id="qi-dong-di-liu-bu-init-jin-cheng-zhi-xing-rc-sysinit"><strong>启动<strong><strong>第六步</strong></strong>－－init进程执行rc.sysinit</strong></span><a href="#qi-dong-di-liu-bu-init-jin-cheng-zhi-xing-rc-sysinit" class="header-anchor">#</a></h1><p>在设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（/etc/sysconfig/network）、启动swap分区、设定/proc等等。如果你有兴趣，可以到/etc/rc.d中查看一下rc.sysinit文件，里面的脚本够你看几天的</p><h1><span id="qi-dong-di-qi-bu-qi-dong-nei-he-mo-kuai"><strong>启动<strong><strong>第七步</strong></strong>－－启动内核模块</strong></span><a href="#qi-dong-di-qi-bu-qi-dong-nei-he-mo-kuai" class="header-anchor">#</a></h1><p>具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块。</p><h1><span id="qi-dong-di-ba-bu-zhi-xing-bu-tong-yun-xing-ji-bie-de-jiao-ben-cheng-xu"><strong>启动<strong><strong>第八步</strong></strong>－－执行不同运行级别的脚本程序</strong></span><a href="#qi-dong-di-ba-bu-zhi-xing-bu-tong-yun-xing-ji-bie-de-jiao-ben-cheng-xu" class="header-anchor">#</a></h1><p>根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。</p><h1><span id="qi-dong-di-jiu-bu-zhi-xing-etc-rc-d-rc-local"><strong>启动<strong><strong>第九步</strong></strong>－－执行/etc/rc.d/rc.local</strong></span><a href="#qi-dong-di-jiu-bu-zhi-xing-etc-rc-d-rc-local" class="header-anchor">#</a></h1><p>你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：</p><p># This script will be executed <em>after</em> all the other init scripts.</p><p># You can put your own initialization stuff in here if you don’t</p><p># want to do the full Sys V style init stuff.</p><p>rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。</p><h1><span id="qi-dong-di-shi-bu-zhi-xing-bin-login-cheng-xu-jin-ru-deng-lu-zhuang-tai"><strong>启动<strong><strong>第十步</strong></strong>－－执行/bin/login程序，进入登录状态</strong></span><a href="#qi-dong-di-shi-bu-zhi-xing-bin-login-cheng-xu-jin-ru-deng-lu-zhuang-tai" class="header-anchor">#</a></h1><p>此时，系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。😃</p><p>===</p><p>漫长的启动过程结束了，一切都清静了…</p><p>其实在这背后，还有着更加复杂的底层函数调用，等待着你去研究…本文就算抛砖引玉了:)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> linux-unix原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,linux-unix原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unix高级编程思维导图笔记</title>
      <link href="/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#biao-zhun-io-ku">标准IO库</a></li><li><a href="#wen-jian-io">文件IO</a></li><li><a href="#wen-jian-he-mu-lu">文件和目录</a></li><li><a href="#xi-tong-shu-ju-wen-jian-he-xin-xi">系统数据文件和信息</a></li><li><a href="#xin-hao">信号</a></li><li><a href="#jin-cheng-huan-jing">进程环境</a></li><li><a href="#jin-cheng-guan-xi">进程关系</a></li><li><a href="#jin-cheng-kong-zhi">进程控制</a></li><li><a href="#xian-cheng">线程</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="biao-zhun-io-ku">标准IO库</span><a href="#biao-zhun-io-ku" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217174719501" alt="img"></p><h1><span id="wen-jian-io">文件IO</span><a href="#wen-jian-io" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217174838423" alt="img"></p><h1><span id="wen-jian-he-mu-lu">文件和目录</span><a href="#wen-jian-he-mu-lu" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/2018021717500292" alt="img"></p><h1><span id="xi-tong-shu-ju-wen-jian-he-xin-xi">系统数据文件和信息</span><a href="#xi-tong-shu-ju-wen-jian-he-xin-xi" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217175013204" alt="img"></p><h1><span id="xin-hao">信号</span><a href="#xin-hao" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217175207636" alt="img"></p><h1><span id="jin-cheng-huan-jing">进程环境</span><a href="#jin-cheng-huan-jing" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/2018021717522228" alt="img"></p><h1><span id="jin-cheng-guan-xi">进程关系</span><a href="#jin-cheng-guan-xi" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217175231672" alt="img"></p><h1><span id="jin-cheng-kong-zhi">进程控制</span><a href="#jin-cheng-kong-zhi" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217175244585" alt="img"></p><h1><span id="xian-cheng">线程</span><a href="#xian-cheng" class="header-anchor">#</a></h1><p><img src="/images/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/20180217175257321" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> linux-unix原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,linux-unix原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/15/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p>[toc]</p><p>man 命令输出该命令的使用手册<br>./ 当前目录…/ 父目录<br>ls常用参数-a 显示所有文件（包括隐藏的，all）-i  列出索引节点（inode）-l  输出长列表（即包含文件的各种信息，long）-s  输出每个文件的块大小（size）-F 区分各个文件，目录后加/，可执行文件后加*（区分file）<br>ls 参数 匹配串则可以只显示匹配字符串的文件，可以用*和？</p><hr><p>touch 文件名创建一个空文件<br>touch -t 200101011200 文件名 这样可以修改文件的时间</p><hr><p>cp 源文件 目标文件cp test1 test2  在当前目录中，将test1复制为新的test2cp test1 dir   将test1复制到目录dir中cp dir/test1  .   将dir/test1复制到当前目录中<br>cp -R dir1 dir2  将dir1中的所有内容进行复制，复制成dir2cp -f 强制覆盖，即如果有重复直接覆盖，不提示用户<br>cp -l test1 testlink  创建一个硬链接testlink，索引节点号与test1相同，类似“复制”。不可跨文件系统或挂载点cp -s test1 soft_test    创建一个软连接soft_test，节点号不同，可以跨文件系统或挂载点</p><hr><p>mv test1 test_new_name  将test1重命名为test_new_name当重命名时，test1的软连接会变成无效链接，硬链接则仍然有效<br>rm 删除文件删除test1后，硬连接仍然显示内容，软连接则已经无效。<br>mkdirmkdir -m=MODE 设定模式，rwx-umaskmkdir -p parents 若路径上的目录不存在，自己建1个父目录mkdir -v  建目录时要显示信息<br>rmdir dir1  默认情况下，rmdir只能删除空目录rm -f dir1 ，可删除dir1中的所有文件加目录，但是会有提示rm -rf dir1， 删除所有且无提示<br>stat test1  可查看test1的状态信息，但没有文件类型file test1  可查看文件的类型（文本文件，可执行文件，数据文件）</p><hr><p>当前目录中有a和bls&gt;c则先生成c，再执行ls，再执行传输进C<br>tar：压缩命令z 创建tar.gz格式文件x 解压  c压缩vf一般都跟在最后，f指把压缩文件输出到某个目录下tar 命令符  所得到的压缩文件名字  要被压缩的目录<br>cat 直接跳最后一页less 可以上下查看more 只能向下查看</p><hr><p>cat -n test1 给所有行加上“行号”cat -b test1 给“非空行”加上“行号”cat -s test1 压缩连续空白行为一行cat -T<br>tail 查看文件末尾10行，可用-n指定行数head 查看文件头，也可用-n指定行数</p><hr><p>ps 查看当前进程<br>ps-e 查看系统所有进程<br>参数含义UID:启动用户PID:进程的进程号PPID：父进程号C： CPU利用率STIME：进程启动的系统时间TTY：进程启动时的终端设备TIME：运行进程需要的CPU时间CMD:程序名称<br>top：实时显示进程<br>w命令显示当前登录的用户和其进行的操作<br>uptime查看当前系统的启动时间</p><hr><p>kill 进程号  相当于kill-TERM 尽可能地杀死进程，如果进程跑飞则可能无法杀死<br>kill -s HUP 进程号  先停止进程再结束进程<br>killall 进程名（可使用通配符）<br>mount 输出挂载设备</p><hr><p>df 查看磁盘空间情况<br>du 了解哪个磁盘没有空间了cat /proc/cpuinfo：查看一台linux机器的CPU信息<br>du：查看该目录占用文件系统数据块的情况 cat /proc/swaps：查看SWAP分区信息df -lh：查看硬盘信息<br>sort file 对文本中的字符串进行排序<br>sort -n file 对文本中的数字进行排序<br>grep 字符串  文件   查找字符串在文件中的位置<br>tar 压缩文件</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> linux-unix原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,linux-unix原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11种行为型模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11%E7%A7%8D%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11%E7%A7%8D%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jie-shi-qi-mo-shi">解释器模式</a></li><li><a href="#mo-ban-fang-fa-mo-shi">模板方法模式</a></li><li><a href="#ze-ren-lian-mo-shi">责任链模式</a></li><li><a href="#ming-ling-mo-shi">命令模式</a></li><li><a href="#die-dai-qi-mo-shi">迭代器模式</a></li><li><a href="#bei-wang-lu-mo-shi">备忘录模式</a></li><li><a href="#guan-cha-zhe-mo-shi">观察者模式</a></li><li><a href="#zhong-cai-zhe">仲裁者</a></li><li><a href="#zhuang-tai-mo-shi">状态模式</a></li><li><a href="#ce-lue-mo-shi">策略模式</a></li><li><a href="#fang-wen-zhe-mo-shi">访问者模式</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="jie-shi-qi-mo-shi">解释器模式</span><a href="#jie-shi-qi-mo-shi" class="header-anchor">#</a></h1><p><a href="https://www.runoob.com/design-pattern/interpreter-pattern.html">https://www.runoob.com/design-pattern/interpreter-pattern.html</a></p><p>这种模式实现了一个表达式接口，该接口解释一个特定的上下文。</p><p>项目中的expresion里的evalute本质上就是解释器模式。</p><h1><span id="mo-ban-fang-fa-mo-shi">模板方法模式</span><a href="#mo-ban-fang-fa-mo-shi" class="header-anchor">#</a></h1><p>抽象类定义n个抽象方法，提供一个对外接口确定抽象方法的调用顺序， 子类负责实现这几个内部的抽象方法。</p><h1><span id="ze-ren-lian-mo-shi">责任链模式</span><a href="#ze-ren-lian-mo-shi" class="header-anchor">#</a></h1><p>if/else太多了判断起来很烦， 用setNext设置一个责任链，谁完不成就交给下一个，这样后续直接添加setNext就好，不用再加else。</p><p>适用于需要“动态”添加判断条件情况。</p><h1><span id="ming-ling-mo-shi">命令模式</span><a href="#ming-ling-mo-shi" class="header-anchor">#</a></h1><p>把命令作为一个commond类看待，这样可以把命令放到队列或者栈里去处理。</p><h1><span id="die-dai-qi-mo-shi">迭代器模式</span><a href="#die-dai-qi-mo-shi" class="header-anchor">#</a></h1><p>提供给外界一个iterator()专门用于next遍历， 这样外界不用关心内部的存储逻辑。</p><h1><span id="bei-wang-lu-mo-shi">备忘录模式</span><a href="#bei-wang-lu-mo-shi" class="header-anchor">#</a></h1><p><a href="https://www.runoob.com/design-pattern/memento-pattern.html">https://www.runoob.com/design-pattern/memento-pattern.html</a></p><p>备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</p><h1><span id="guan-cha-zhe-mo-shi">观察者模式</span><a href="#guan-cha-zhe-mo-shi" class="header-anchor">#</a></h1><p>A做了一件事之后，把自己的状态通知 B\C\D这3个观察者（需要绑定观察者）</p><p>注意和访问者不是同一个模式。</p><h1><span id="zhong-cai-zhe">仲裁者</span><a href="#zhong-cai-zhe" class="header-anchor">#</a></h1><p>A\B\C\D 这几个类对象每当做完一件事，就调用 E.update(xxx)， E会负责更新整体状态，或者作为中间人去调度其他几个类。</p><h1><span id="zhuang-tai-mo-shi">状态模式</span><a href="#zhuang-tai-mo-shi" class="header-anchor">#</a></h1><p>状态不同， doAction时发生的事情也不同，类似于项目中做互信时，不同状态有不同的doAction处理逻辑</p><p><img src="/images/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%20-%20%E5%89%AF%E6%9C%AC/d146ad3e20bcc846133a5bb32f2bef82890f29d6-1663082735876.png" alt="d146ad3e20bcc846133a5bb32f2bef82890f29d6"></p><blockquote><p>和策略模式的区别： 状态模式在于状态之间是由关联的，是可以切换状态的，且状态A到状态B可能有限制。<br>但是策略模式的话，不同的策略之间可能是独立的，仅仅是有同一个基类，但不存在可以切换的状态图。</p></blockquote><h1><span id="ce-lue-mo-shi">策略模式</span><a href="#ce-lue-mo-shi" class="header-anchor">#</a></h1><p>装备了不同的武器或者策略，就会有不同的战斗结果。 我只要不断切换自己装备的武器子类即可。</p><h1><span id="fang-wen-zhe-mo-shi">访问者模式</span><a href="#fang-wen-zhe-mo-shi" class="header-anchor">#</a></h1><p>同一份数据或者树型结构， 可以用不同的vistor去访问，得到不同的结果或者展示。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 行为型(和做具体事情有关) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#xiang-yuan-mo-shi">享元模式</a></li><li><a href="#he-qi-ta-de-qu-bie">和其他的区别：</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="xiang-yuan-mo-shi">享元模式</span><a href="#xiang-yuan-mo-shi" class="header-anchor">#</a></h1><p>当有几种对象， 可能会被经常创建，且属性变化不大，也许就几种（例如常量1-100经常用）</p><p>一种方式是调用者经常自己手动创建这些对象</p><p>还有一种是封装到一个factory中，  调用者取factory中拿。</p><p>factory中会维护一个map， 缓存这些对象，这样就不用经常创建了。所以叫享元。<br><img src="/images/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/fbcb7c5c2bb6242e758efb7b42bfcf7bb57b731e.png" alt="fbcb7c5c2bb6242e758efb7b42bfcf7bb57b731e"></p><hr><h1><span id="he-qi-ta-de-qu-bie">和其他的区别：</span><a href="#he-qi-ta-de-qu-bie" class="header-anchor">#</a></h1><ul><li>和原型模式的区别： 原型模式的重点在于提供clone方法去创建对象。  而享元模式不存在创建，更多是一个缓存结构（所以是结构型设计模式）</li><li>和工厂模式的区别： 享元模式其实类似于单例+工厂的结合。  工厂模式不一定是享元模式，因为工厂模式可能真的是创建新的。  而享元模式基本会提供类似工厂方法的get方法，给调用者使用，本质上不生成新的对象了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 结构型（和类的继承、接口实现、封装有关） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式和代理模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wai-guan-mo-shi">外观模式</a></li><li><a href="#dai-li-mo-shi">代理模式</a></li><li><a href="#dai-li-mo-shi-he-qi-ta-mo-shi-de-qu-bie">代理模式和其他模式的区别</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="wai-guan-mo-shi">外观模式</span><a href="#wai-guan-mo-shi" class="header-anchor">#</a></h1><p>也叫门面模式。</p><ul><li>当我们有很多的类，各种类之间的方法互相关联，存在复杂的调用先后顺序时</li></ul><ol><li>一种方法是告诉别人 这些类的用法， 让他们自己注意使用顺序。（比如你要先调A再调B才有用）</li><li>另一种是提供一个统一对外的接口，  在接口里去组装这些顺序。</li></ol><p>这就是facade模式，看起来像一个窗口或者客户端，   外界不知道这些类的关系，但是只需要调门面的几个方法即可。<br><img src="/images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/a4624283bf8c71587ad996a7279f4891ab4f1cf3.png" alt="a4624283bf8c71587ad996a7279f4891ab4f1cf3"><br>也不一定是为了复杂的调用顺序，可能就是为了让调用者不用关心用哪个类，只关心调哪个方法，如下：<br><img src="/images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/2a2f769be48fb696ae6d25a31f79e378ae6d6cdd.png" alt="2a2f769be48fb696ae6d25a31f79e378ae6d6cdd"></p><ul><li>因为是将很多类作为成员封装进一个门面类里， 所以是结构型的设计模式。</li></ul><p>举例：  做饭（买菜、洗碗、烧菜，希望封装到一个仆人类里来做）</p><hr><h1><span id="dai-li-mo-shi">代理模式</span><a href="#dai-li-mo-shi" class="header-anchor">#</a></h1><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><p>代理模式中，  提供的行为和被代理对象是基本一致的，只是会额外做一些处理（例如打日志、监控），再调用被代理对象的方法。</p><hr><h1><span id="dai-li-mo-shi-he-qi-ta-mo-shi-de-qu-bie">代理模式和其他模式的区别</span><a href="#dai-li-mo-shi-he-qi-ta-mo-shi-de-qu-bie" class="header-anchor">#</a></h1><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li><li>和外观模式的区别： 外观模式是可以封装好几个类，提供特定的单方法或者组合方法。  而代理模式大多是针对一个类做代理，且对外方法与被代理对象 基本一致。</li><li>和仲裁者模式的区别： 仲裁者更多是三方 ABC交互，由B承担沟通工作，A不需要直接调用C。   代理模式则只涉及代理和被代理者。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 结构型（和类的继承、接口实现、封装有关） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式和装饰者模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zu-he-mo-shi-he-zhuang-shi-zhe-mo-shi">组合模式和装饰者模式</a><ul><li><a href="#yi-zu-he-mo-shi">一、组合模式</a></li><li><a href="#you-dian">优点</a></li><li><a href="#que-dian">缺点</a></li></ul></li><li><a href="#er-zhuang-shi-zhe-mo-shi">二、装饰者模式</a><ul><li><a href="#q-zhuang-shi-mo-shi-he-zu-he-mo-shi-du-shi-cheng-yuan-li-hui-bao-han-zi-ji-zhe-ge-lei-huo-zhe-zi-lei-qu-bie-shi">Q: 装饰模式和组合模式都是成员里会包含自己这个类或者子类，区别是？</a></li><li><a href="#q-zhuang-shi-zhao-mo-shi-he-proxy-dai-li-mo-shi-you-you-shi-me-qu-bie-dai-li-mo-shi-ye-shi-yong-cheng-yuan-de-fang-fa-diao-yong-zhi-hou-zai-zuo-yi-xie-e-wai-chu-li">Q: 装饰着模式和proxy代理模式又有什么区别？ 代理模式也是用成员的方法调用之后，再做一些额外处理</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="zu-he-mo-shi-he-zhuang-shi-zhe-mo-shi">组合模式和装饰者模式</span><a href="#zu-he-mo-shi-he-zhuang-shi-zhe-mo-shi" class="header-anchor">#</a></h1><h2><span id="yi-zu-he-mo-shi">一、组合模式</span><a href="#yi-zu-he-mo-shi" class="header-anchor">#</a></h2><p>该模式的意义：<br>用于树类，  或者支持将多个A对象合成1个A对象的 情形下<br><img src="/images/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/8953af0abe9db9e2badbc02eacbeb5a0325e0ab6.png" alt="8953af0abe9db9e2badbc02eacbeb5a0325e0ab6"><br>该模式的意义：<br>用于树类，  或者支持将多个A对象合成1个A对象的 情形下</p><p>主要方法：</p><ul><li>基类（ 包含add或insert方法 ）</li><li>子类 包括  叶子类   和  非叶类</li><li>非叶类 即可以add  叶子， 叶可以 add非叶。</li><li>其实就是 子类里可以包含父类容器，不断添加、延伸。</li></ul><p>计算引擎中的GNODE、logicalNode就是这种。</p><p><img src="/images/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/32a2333013afb0eb27642c817eb4e8de9d0f1cc7.png" alt="32a2333013afb0eb27642c817eb4e8de9d0f1cc7"></p><h2><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor">#</a></h2><ol><li><p>客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。</p></li><li><p>可以形成复杂的树形结构。</p></li><li><p>更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</p></li></ol><h2><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor">#</a></h2><p>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性<br>而且不是所有的方法都与叶子对象子类都有关联<br>要注意使用场景</p><h1><span id="er-zhuang-shi-zhe-mo-shi">二、装饰者模式</span><a href="#er-zhuang-shi-zhe-mo-shi" class="header-anchor">#</a></h1><p>如果我们 对某个 类， 以后可能会有很多小的修改加上去， 而且都是“装饰”性质的， 即加“功能”，而且这些功能可以一层层叠加<br>如果加功能频率很多，我们可以用装饰者模式。 经典应用就是java中的stream流<br>new XXXStream(new BufferStream(new FileOutputStream()))<br><img src="/images/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/d96605fa973db16ce93300c7e89582aa219dec2f.png" alt="d96605fa973db16ce93300c7e89582aa219dec2f"></p><h2><span id="q-zhuang-shi-mo-shi-he-zu-he-mo-shi-du-shi-cheng-yuan-li-hui-bao-han-zi-ji-zhe-ge-lei-huo-zhe-zi-lei-qu-bie-shi">Q: 装饰模式和组合模式都是成员里会包含自己这个类或者子类，区别是？</span><a href="#q-zhuang-shi-mo-shi-he-zu-he-mo-shi-du-shi-cheng-yuan-li-hui-bao-han-zi-ji-zhe-ge-lei-huo-zhe-zi-lei-qu-bie-shi" class="header-anchor">#</a></h2><p>A:<br>组合模式， 重点体现在用成员类组成一个树形或者图型结构（重点不在于做事情）， 使用者会关心成员类的内容且可能会遍历。<br>装饰者模式，重点体现在用成员类的方法做相同的事情，自己再做一些补充， 且可以不断叠加。 叠加后只提供一个最终叠加后的对象给别人使用， 别人不用关心里面叠加的那些中间对象。</p><hr><h2><span id="q-zhuang-shi-zhao-mo-shi-he-proxy-dai-li-mo-shi-you-you-shi-me-qu-bie-dai-li-mo-shi-ye-shi-yong-cheng-yuan-de-fang-fa-diao-yong-zhi-hou-zai-zuo-yi-xie-e-wai-chu-li">Q: 装饰着模式和proxy代理模式又有什么区别？ 代理模式也是用成员的方法调用之后，再做一些额外处理</span><a href="#q-zhuang-shi-zhao-mo-shi-he-proxy-dai-li-mo-shi-you-you-shi-me-qu-bie-dai-li-mo-shi-ye-shi-yong-cheng-yuan-de-fang-fa-diao-yong-zhi-hou-zai-zuo-yi-xie-e-wai-chu-li" class="header-anchor">#</a></h2><p>A:</p><ul><li>使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了。 注意AOP里的所有代理对象其实都是编译时定好了用哪个代理</li><li>而 装饰者能够在运行时递归地被构造，即运行期可以设置不同的装饰对象做装饰， 但是代理的话，代理是固定的，只不过可能会选用不同的代理罢了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 结构型（和类的继承、接口实现、封装有关） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接者模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wei-shi-me-yao-yong-qiao-jie">为什么要用桥接</a></li><li><a href="#qiao-jie-fang-shi">桥接方式</a></li><li><a href="#qiao-jie-mo-shi-you-dian">桥接模式优点：</a></li><li><a href="#qiao-jie-mo-shi-de-que-dian">桥接模式的缺点</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="wei-shi-me-yao-yong-qiao-jie">为什么要用桥接</span><a href="#wei-shi-me-yao-yong-qiao-jie" class="header-anchor">#</a></h1><p>假设希望设计一个补数据接口类Downloader，用于向其他服务器同步数据。　对外提供一个接口<br>download()<br>最开始以为只需要同步不同类型的数据即可， 那么只要实现<br>DataADownloader、 DataBDownloader这几种即可。</p><p>但是到后来， 发现不仅要在下载数据中选择，  还可能要选择补数据的方式。<br>比如有的服务希望是异步download<br>有的服务是希望加密download</p><p>如果只是简单增加类型，则可能出现<br>AsyncDataADownloader<br>AsyncDataBDownloader<br>EncryptDataADownloader<br>EncryptDataBDownloader</p><p>当你发现你不断实现的子类 <strong>出现了功能在不同层次叠加</strong>的情况，就要注意用桥接模式，做不同层次接口的桥接，而不是只用一个接口导致子类爆炸增长。</p><h1><span id="qiao-jie-fang-shi">桥接方式</span><a href="#qiao-jie-fang-shi" class="header-anchor">#</a></h1><p>用 <strong>成员</strong>的方式进行桥接。<br>把功能A类型接口作为成员，桥接进另一个功能B类型的抽象类中， 另一个功能的抽象方法只要考虑如何调用这个成员即可。</p><p>补数据的场景如下所示：</p><hr><p><img src="/images/%E6%A1%A5%E6%8E%A5%E8%80%85%E6%A8%A1%E5%BC%8F/87c460721063abb1d3856e4a124534cd49b21ce3.png" alt="87c460721063abb1d3856e4a124534cd49b21ce3"></p><h1><span id="qiao-jie-mo-shi-you-dian">桥接模式优点：</span><a href="#qiao-jie-mo-shi-you-dian" class="header-anchor">#</a></h1><ul><li>解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。<br>抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象</li><li>桥接模式可以取代多层继承方案（例如刚才的另一种解决方案可能是多重继承2个接口），多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数</li><li>提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”</li></ul><h1><span id="qiao-jie-mo-shi-de-que-dian">桥接模式的缺点</span><a href="#qiao-jie-mo-shi-de-que-dian" class="header-anchor">#</a></h1><ul><li>增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程</li><li>要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。<br>因此缺点主要在设计难度上。</li></ul><hr><p>其他案例： <a href="https://zhuanlan.zhihu.com/p/58903776">知乎：用点咖啡来讲解桥接模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 结构型（和类的继承、接口实现、封装有关） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#gua-pei-qi-mo-shi">适配器模式</a></li><li><a href="#q-lei-gua-pei-qi-mo-shi-he-dui-xiang-gua-pei-qi-mo-shi-de-qu-bie">Q: 类适配器模式和对象适配器模式的区别？</a></li><li><a href="#q-gua-pei-qi-mo-shi-de-you-dian">Q: 适配器模式的优点？</a></li><li><a href="#q-lei-gua-pei-qi-mo-shi-he-dui-xiang-gua-pei-qi-na-ge-hao-wei-shi-me">Q: 类适配器模式和对象适配器哪个好？为什么</a></li><li><a href="#q-jiang-yi-xia-gua-pei-qi-mo-shi-de-ying-yong">Q: 讲一下适配器模式的应用</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="gua-pei-qi-mo-shi">适配器模式</span><a href="#gua-pei-qi-mo-shi" class="header-anchor">#</a></h1><p>当你试图引入一个外部jar包的api时， 担心这个jar包以后会换成别的， 或者因为包版本经常更新，api可能会变。<br>这时候可以用一个adpter来适配一下，  把这个api封装到自己的adpter里，然后再通过adapter提供给自己的代码使用。</p><p><img src="/images/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/0b43d0acc4ebf7c24233c420b0f3afa64f6c6783.png" alt="0b43d0acc4ebf7c24233c420b0f3afa64f6c6783"></p><p>注意第三方调用的方法名不是request，这就是经常会变动的地方，所以我们封住到adpter里使用。</p><hr><h1><span id="q-lei-gua-pei-qi-mo-shi-he-dui-xiang-gua-pei-qi-mo-shi-de-qu-bie">Q: 类适配器模式和对象适配器模式的区别？</span><a href="#q-lei-gua-pei-qi-mo-shi-he-dui-xiang-gua-pei-qi-mo-shi-de-qu-bie" class="header-anchor">#</a></h1><p>A:<br>类适配器： 本身继承自需要适配的那个对象<br><img src="/images/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/118ad90eb040674630cb4a19e34490cd8ed5d0b3.png" alt="118ad90eb040674630cb4a19e34490cd8ed5d0b3"><br>对象适配器： 把需要适配的对象作为成员<br><img src="/images/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/57964df74fd72f44157e6d51628fee576d84361e.png" alt="57964df74fd72f44157e6d51628fee576d84361e"></p><hr><h1><span id="q-gua-pei-qi-mo-shi-de-you-dian">Q: 适配器模式的优点？</span><a href="#q-gua-pei-qi-mo-shi-de-you-dian" class="header-anchor">#</a></h1><p>A:</p><ol><li>增加了调用类的透明性和复用性。 调用者无需关心内部实现，且容易复用给其他模块</li><li>灵活性和扩展性非常好， 内部api升级修改时，无需引发扩散修改。<br>通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ol><hr><h1><span id="q-lei-gua-pei-qi-mo-shi-he-dui-xiang-gua-pei-qi-na-ge-hao-wei-shi-me">Q: 类适配器模式和对象适配器哪个好？为什么</span><a href="#q-lei-gua-pei-qi-mo-shi-he-dui-xiang-gua-pei-qi-na-ge-hao-wei-shi-me" class="header-anchor">#</a></h1><p>A:<br>建议用对象适配器，类适配器的限制较多。<br>类适配器的缺点：</p><ol><li>对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li><li>适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</li><li>在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ol><hr><h1><span id="q-jiang-yi-xia-gua-pei-qi-mo-shi-de-ying-yong">Q: 讲一下适配器模式的应用</span><a href="#q-jiang-yi-xia-gua-pei-qi-mo-shi-de-ying-yong" class="header-anchor">#</a></h1><p>A:</p><hr><p>参考： <a href="https://blog.csdn.net/wwwdc1012/article/details/82780560">设计模式 | 适配器模式及典型应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 结构型（和类的继承、接口实现、封装有关） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jian-dan-ban-ben">简单版本</a></li><li><a href="#chou-xiang-ban-ben">抽象版本</a><ul><li><a href="#q-jian-zao-zhe-mo-shi-de-you-dian-shi-shi-me">Q: 建造者模式的优点是什么？</a></li><li><a href="#q-jian-zao-zhe-mo-shi-de-que-dian-shi-shi-me">Q: 建造者模式的缺点是什么？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><p>参考: <a href="https://zhuanlan.zhihu.com/p/58093669">秒懂设计模式之建造者模式（Builder pattern</a></p><h1><span id="jian-dan-ban-ben">简单版本</span><a href="#jian-dan-ban-ben" class="header-anchor">#</a></h1><p>java的builder构造方式就是经典建造者的应用（但不是模式，因为不涉及父类啥的）<br>XXX xxx = XXX.builder().set().set().set().build();</p><h1><span id="chou-xiang-ban-ben">抽象版本</span><a href="#chou-xiang-ban-ben" class="header-anchor">#</a></h1><p>抽象的模式版本中，  builder是一个接口，可以被继承的， 因此可以有多个builder。<br>而会有一个指挥者Direct，负责去调用builder的set操作，塞入不同的值</p><ul><li>Product: 最终要生成的对象，例如 Computer实例。</li><li>Builder： 构建者的抽象基类（有时会使用接口代替）。其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法Product getProduct()。</li><li>ConcreteBuilder: Builder的实现类。</li><li>Director: 决定如何构建最终产品的算法. 其会包含一个负责组装的方法void Construct(Builder builder)， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品。</li></ul><p><img src="/images/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/5344c172e18ca7fb47e7ccb4d96e90bdefcc372c.png" alt="5344c172e18ca7fb47e7ccb4d96e90bdefcc372c"></p><hr><h2><span id="q-jian-zao-zhe-mo-shi-de-you-dian-shi-shi-me">Q: 建造者模式的优点是什么？</span><a href="#q-jian-zao-zhe-mo-shi-de-you-dian-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>封装性好，客户端不必知道内部产品的实现细节。<br>建造者独立，容易扩展， 不用维护复杂的入参列表。<br>便于控制细节风险。</p><hr><h2><span id="q-jian-zao-zhe-mo-shi-de-que-dian-shi-shi-me">Q: 建造者模式的缺点是什么？</span><a href="#q-jian-zao-zhe-mo-shi-de-que-dian-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；<br>如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。（即builder提供的接口有很大的差异，或者很多用不上的话，就不好用了，还不如不抽象，自己写一个）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 创建型(都是创建相关的) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂相关设计模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jian-dan-gong-han">简单工厂</a><ul><li><a href="#q-jiang-yi-xia-jian-dan-gong-han-mo-shi">Q: 讲一下简单工厂模式</a></li><li><a href="#q-jian-dan-gong-han-mo-shi-de-que-dian-shi-shi-me">Q: 简单工厂模式的缺点是什么？</a></li></ul></li><li><a href="#gong-han-fang-fa-mo-shi">工厂方法模式</a><ul><li><a href="#q-jiang-yi-xia-gong-han-fang-fa-mo-shi-shi-shi-me">Q: 讲一下工厂方法模式是什么?</a></li><li><a href="#q-he-jian-dan-gong-han-xiang-bi-you-dian-shi-shi-me">Q: 和简单工厂相比，优点是什么？</a></li><li><a href="#q-gong-han-fang-fa-de-que-dian-shi-shi-me">Q: 工厂方法的缺点是什么？</a></li></ul></li><li><a href="#chou-xiang-gong-han-mo-shi">抽象工厂模式</a><ul><li><a href="#q-chou-xiang-gong-han-shi-shi-me">Q: 抽象工厂是什么？</a></li><li><a href="#q-chou-xiang-gong-han-xiang-bi-gong-han-fang-fa-mo-shi-de-gai-jin">Q: 抽象工厂相比工厂方法模式的改进？</a></li><li><a href="#q-chou-xiang-gong-han-de-que-dian">Q: 抽象工厂的缺点？</a></li><li><a href="#q-jiang-yi-xia-gong-han-fang-fa-mo-shi-he-chou-xiang-gong-han-mo-shi-de-ying-yong">Q: 讲一下工厂方法模式和抽象工厂模式的应用？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="jian-dan-gong-han">简单工厂</span><a href="#jian-dan-gong-han" class="header-anchor">#</a></h1><h2><span id="q-jiang-yi-xia-jian-dan-gong-han-mo-shi">Q: 讲一下简单工厂模式</span><a href="#q-jiang-yi-xia-jian-dan-gong-han-mo-shi" class="header-anchor">#</a></h2><p>A:<br>简单工厂模式不是23种设计模式里的一种，简而言之，就是有一个专门生产某个产品的类。<br>比如下图中的鼠标工厂，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。<br>注意这个参数，  我必须根据入参去确定返回<br><strong>factory.create(int type)</strong></p><p><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/10a62974ba163f38f838686b36b3a7bc028589bb.png" alt="10a62974ba163f38f838686b36b3a7bc028589bb"></p><h2><span id="q-jian-dan-gong-han-mo-shi-de-que-dian-shi-shi-me">Q: 简单工厂模式的缺点是什么？</span><a href="#q-jian-dan-gong-han-mo-shi-de-que-dian-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>当我试图新增一种类型， 我就得在create里新增case-when， 外面也要做类型的适配</p><blockquote><blockquote><p>但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</p></blockquote></blockquote><hr><h1><span id="gong-han-fang-fa-mo-shi">工厂方法模式</span><a href="#gong-han-fang-fa-mo-shi" class="header-anchor">#</a></h1><h2><span id="q-jiang-yi-xia-gong-han-fang-fa-mo-shi-shi-shi-me">Q:  讲一下工厂方法模式是什么?</span><a href="#q-jiang-yi-xia-gong-han-fang-fa-mo-shi-shi-shi-me" class="header-anchor">#</a></h2><p>A: 把创建对象的操作集中到工厂方法中，工厂支持继承。<br>外界不关注内部怎么生成或者生成什么， 只要给了对应的工厂，返回给我正确的产品基类即可。<br>举例：<br>有1个父类模式<br>工厂接口A ，   和 产品接口B<br>从接口上可以看出，   接口A.create()函数生产出产品B，</p><p>然后后面类似工厂-&gt;生产-&gt;产品的情况， 都继承过来</p><p>工厂类C继承接口A，  产品类D继承接口B。<br>于是工厂就有好多个了</p><p><strong>当我试图切换产品，只需要切换工厂即可，不再需要给出方法入参了！</strong><br><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1b2cf617402f7f5975285f9056cfbbb11b580879.png" alt="1b2cf617402f7f5975285f9056cfbbb11b580879"><br>**</p><h2><span id="q-he-jian-dan-gong-han-xiang-bi-you-dian-shi-shi-me">Q: 和简单工厂相比，优点是什么？</span><a href="#q-he-jian-dan-gong-han-xiang-bi-you-dian-shi-shi-me" class="header-anchor">#</a></h2><p>A:</p><ul><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。（调用者不用想着我传啥参数了，是1还是2还是什么枚举，直接拿到这个工厂create就完事）</li></ul><hr><h2><span id="q-gong-han-fang-fa-de-que-dian-shi-shi-me">Q: 工厂方法的缺点是什么？</span><a href="#q-gong-han-fang-fa-de-que-dian-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><blockquote><blockquote><p>注意: 这里的工厂方法，一般只有一个create()方法，没有其他的了， 所以模式名特地指出了”方法“二字</p></blockquote></blockquote><hr><h1><span id="chou-xiang-gong-han-mo-shi">抽象工厂模式</span><a href="#chou-xiang-gong-han-mo-shi" class="header-anchor">#</a></h1><h2><span id="q-chou-xiang-gong-han-shi-shi-me">Q: 抽象工厂是什么？</span><a href="#q-chou-xiang-gong-han-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于 <strong>抽象工厂方法里的create有好几个，是一个产品族</strong><br><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/6149353b20a1615a3a79e672af25da6cbc5f3bbe.png" alt="6149353b20a1615a3a79e672af25da6cbc5f3bbe"></p><hr><h2><span id="q-chou-xiang-gong-han-xiang-bi-gong-han-fang-fa-mo-shi-de-gai-jin">Q: 抽象工厂相比工厂方法模式的改进？</span><a href="#q-chou-xiang-gong-han-xiang-bi-gong-han-fang-fa-mo-shi-de-gai-jin" class="header-anchor">#</a></h2><p>A:<br>工厂方法模式只有1种create，  当你要新增一类产品的时候，  得重新设计工厂接口类。<br>而抽象工厂中，  直接工厂接口类上新增方法，  后面的子类同一实现即可。<br><strong>新增接口方法， 不需要再新增接口类</strong></p><ul><li>因此这个工厂更像一个有很多能力的大工厂了， 不再是一个简单的create()了</li></ul><blockquote><blockquote><p>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。<br>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。<br>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p></blockquote></blockquote><hr><h2><span id="q-chou-xiang-gong-han-de-que-dian">Q: 抽象工厂的缺点？</span><a href="#q-chou-xiang-gong-han-de-que-dian" class="header-anchor">#</a></h2><p>A:<br>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p><hr><h2><span id="q-jiang-yi-xia-gong-han-fang-fa-mo-shi-he-chou-xiang-gong-han-mo-shi-de-ying-yong">Q: 讲一下工厂方法模式和抽象工厂模式的应用？</span><a href="#q-jiang-yi-xia-gong-han-fang-fa-mo-shi-he-chou-xiang-gong-han-mo-shi-de-ying-yong" class="header-anchor">#</a></h2><p>A:</p><ul><li>我们最常用的 Spring  就是一个最大的 Bean 工厂，IOC 通过FactoryBean对Bean 进行管理。</li><li>我们使用的日志门面框架slf4j，点进去就可以看到熟悉的味道 private final static Logger logger = LoggerFactory.getLogger(HelloWord.class);<br>而这里的工厂实现，通过类加载去获取，应用开发者根本不需要关心背后实现是什么。 项目维护人员维护好日志jar包和配置即可。</li><li>JDK 的 Calendar 使用了简单工厂模式Calendar calendar = Calendar.getInstance();</li><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。</li><li>比如 Hibernate 换数据库只需换方言和驱动就可以</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 创建型(都是创建相关的) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计思想</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ooa">OOA</a></li><li><a href="#ood">OOD</a><ul><li><a href="#q-oo-mian-xiang-dui-xiang-object-oriented-he-po-mian-xiang-guo-cheng-process-oriented-de-qu-bie">Q: OO面向对象(Object-Oriented)和PO面向过程(process oriented)的区别？</a></li></ul></li><li><a href="#oop">OOP</a></li><li><a href="#ddd">DDD</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="ooa">OOA</span><a href="#ooa" class="header-anchor">#</a></h1><p>Object-Oriented Analysis:面向对象分析法<br>指的是在一个系统的开发过程中进行了系统业务调查以后，按照面向对象的思想来分析问题。</p><ul><li>OOA方法的具体步骤<br>在用OOA具体分析一个事物时。大致上遵循如下5个基本步骤；</li></ul><ol><li>确定对象和类。这里所说的对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界总某些事物的信息能力。。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。</li><li>确定结构（structure）。结构是指问题域的复杂性和连接关系。类成员结构反映了泛华—特化关系，整体-部分结构反映整体和局部之间的关系</li><li>确定主题（subject）。主题是指事物的总体概貌和总体分析模型</li><li>确定属性（attribute）。属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。</li><li>确定方法（method）。方法是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择一个方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。</li></ol><hr><h1><span id="ood">OOD</span><a href="#ood" class="header-anchor">#</a></h1><p>面向对象设计（Object-oriented Design,OOD）方法是oo方法中一个中间过渡环节。其主要作用是对OOA分析的结构作进一步的规范化整理，以便能够被oop直接接受。</p><p>OOD就是“根据需求决定所需的类、类的操作以及类之间关联的过程”。</p><p>使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为</p><hr><h2><span id="q-oo-mian-xiang-dui-xiang-object-oriented-he-po-mian-xiang-guo-cheng-process-oriented-de-qu-bie">Q:  OO面向对象(Object-Oriented)和PO面向过程(process oriented)的区别？</span><a href="#q-oo-mian-xiang-dui-xiang-object-oriented-he-po-mian-xiang-guo-cheng-process-oriented-de-qu-bie" class="header-anchor">#</a></h2><p>A:</p><ul><li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li><li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li></ul><h1><span id="oop">OOP</span><a href="#oop" class="header-anchor">#</a></h1><p>所谓的OOP就是指的面向对象编程<br>OOP的一条基本准则是计算机程序是由单个能够引起子程序作用的单元或对象组合而成.OOP达到了软件工程的三个主要目标:重用性,灵活性和扩展性.为了实现整体运算,每个对象都能够接收消息,处理数据和向其它对象发送消息.OOP主要有以下的概念和组件.</p><h1><span id="ddd">DDD</span><a href="#ddd" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/h295928126/article/details/122951726">https://blog.csdn.net/h295928126/article/details/122951726</a></p><p>DDD(domain driver designer，也就是领域驱动设计)，它有三个关键词：领域，驱动，设计。领域，是要探索业务的边界；驱动,表示前者是后者的决定性因素；设计，包括产品设计，UIUE设计，软件设计。它不仅仅是开发架构的方案，而是完整的解决方案实施思路。正是因为它是完整的方案，才能让领域专家，产品和研发真正在同一个角度去思考和沟通，避免推诿扯皮，含糊不清。<br>从上文就可以知道DDD是一种拆解业务、划分业务、确定业务边界的方法， 是一种高度复杂的领域设计思想，将我们的问题拆分成一个个的域， 试图分离技术实现的复杂性，主要解决的是软件难以理解难以演进的问题，DDD不是一种架构， 而是一种架构方法论， 目的就是将复杂问题领域简单化， 帮助我们设计出清晰的领域和边界， 可以很好的实现技术架构的演进。下面为常用的的设计架构图</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/1bce8e4c93a14d4ba31c9ce4ecaa1a17.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 设计理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-jiang-yi-xia-dan-li-mo-shi-de-you-dian">Q: 讲一下单例模式的优点？</a></li><li><a href="#q-jiang-yi-xia-dan-li-mo-shi-de-que-dian">Q: 讲一下单例模式的缺点？</a></li><li><a href="#dan-li-de-ji-chong-java-shi-xian">单例的几种java实现</a><ul><li><a href="#q-xia-mian-de-e-han-dan-li-shi-xian-you-shi-me-wen-ti">Q: 下面的饿汉单例实现有什么问题？</a></li><li><a href="#q-xia-mian-de-lan-han-shi-dan-li-sui-ran-neng-bi-mian-qi-dong-su-du-guo-man-dan-zhe-ge-dai-ma-you-shi-me-wen-ti">Q: 下面的懒汉式单例虽然能避免启动速度过慢，但这个代码有什么问题？</a></li><li><a href="#q-jiang-yi-xia-lan-han-jia-zai-ru-he-bi-mian-shang-shu-de-wen-ti">Q: 讲一下懒汉加载如何避免上述的问题？</a></li><li><a href="#q-ke-yi-bu-yong-suo-shi-xian-java-de-dan-li-yan-chi-jia-zai-ma">Q: 可以不用锁实现java的单例延迟加载吗？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><p>单例模式，顾名思义， 就是一个系统内只提供一个单例，只有一个静态getInstance()方法。</p><ul><li>单例模式的类，其构造函数是private的，禁止外部去new</li></ul><p><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/deb5ab479e94e371f07f770c11c80a0b202a07c4.png" alt="deb5ab479e94e371f07f770c11c80a0b202a07c4"></p><hr><h1><span id="q-jiang-yi-xia-dan-li-mo-shi-de-you-dian">Q: 讲一下单例模式的优点？</span><a href="#q-jiang-yi-xia-dan-li-mo-shi-de-you-dian" class="header-anchor">#</a></h1><p>A:</p><ul><li><p>在内存中只有一个对象，节省内存空间；</p></li><li><p>避免频繁的创建销毁对象，可以提高性能；</p></li><li><p>避免对共享资源的多重占用，简化访问；</p></li><li><p>为整个系统提供一个全局访问点。</p></li></ul><hr><h1><span id="q-jiang-yi-xia-dan-li-mo-shi-de-que-dian">Q: 讲一下单例模式的缺点？</span><a href="#q-jiang-yi-xia-dan-li-mo-shi-de-que-dian" class="header-anchor">#</a></h1><p>A:</p><ul><li>不适用于变化频繁的对象；</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li></ul><h1><span id="dan-li-de-ji-chong-java-shi-xian">单例的几种java实现</span><a href="#dan-li-de-ji-chong-java-shi-xian" class="header-anchor">#</a></h1><h2><span id="q-xia-mian-de-e-han-dan-li-shi-xian-you-shi-me-wen-ti">Q: 下面的饿汉单例实现有什么问题？</span><a href="#q-xia-mian-de-e-han-dan-li-shi-xian-you-shi-me-wen-ti" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">singleton1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getSingleton1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>会造成启动速度变慢。 如果这个单例对象比较大或者多的话。  例如springbean的单例，如果都设置成饿汉式，则启动会很慢。</p><hr><h2><span id="q-xia-mian-de-lan-han-shi-dan-li-sui-ran-neng-bi-mian-qi-dong-su-du-guo-man-dan-zhe-ge-dai-ma-you-shi-me-wen-ti">Q: 下面的懒汉式单例虽然能避免启动速度过慢，但这个代码有什么问题？</span><a href="#q-xia-mian-de-lan-han-shi-dan-li-sui-ran-neng-bi-mian-qi-dong-su-du-guo-man-dan-zhe-ge-dai-ma-you-shi-me-wen-ti" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton2;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getSingleton2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 被动创建，在真正需要使用时才去创建</span></span><br><span class="line">        <span class="keyword">if</span> (singleton2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton2 = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</p><hr><h2><span id="q-jiang-yi-xia-lan-han-jia-zai-ru-he-bi-mian-shang-shu-de-wen-ti">Q: 讲一下懒汉加载如何避免上述的问题？</span><a href="#q-jiang-yi-xia-lan-han-jia-zai-ru-he-bi-mian-shang-shu-de-wen-ti" class="header-anchor">#</a></h2><p>A:<br>使用双重加锁，  先判空， 判空后再加锁判断，  拿到锁之后再进行new<br><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/0b16110f2c2e97166c7998baf7ebdb228d00c4cb.png" alt="0b16110f2c2e97166c7998baf7ebdb228d00c4cb"></p><hr><h2><span id="q-ke-yi-bu-yong-suo-shi-xian-java-de-dan-li-yan-chi-jia-zai-ma">Q: 可以不用锁实现java的单例延迟加载吗？</span><a href="#q-ke-yi-bu-yong-suo-shi-xian-java-de-dan-li-yan-chi-jia-zai-ma" class="header-anchor">#</a></h2><p>A:<br>可以， 使用内部类的静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//实例的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是因为内部类的加载和初始化本身是有用到类锁的，而内部类只会用到的时候加载， 不会提前被扫描进来。因此不会出现重复new两次， 但能够保证用到的时候才生成。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 创建型(都是创建相关的) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ying-yong-chang-jing">应用场景</a></li><li><a href="#you-dian">优点</a></li><li><a href="#que-dian">缺点</a></li><li><a href="#java-zhong-de-yuan-xing-lei-ying-yong">java中的原型类应用：</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p><a href="https://blog.csdn.net/zhengzhb/article/details/7393528">23种设计模式（5）：原型模式 CSDN</a></p><p>含义：   就一个clone的抽象接口， 告诉实现的子类们 你们必须实现这个方法， 因为外面（client）很可能经常要用到你的拷贝类</p><p><img src="../../../../images/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/48fdece0e11b0bb3039a1e8d5ff1467bad7e9e24.png" alt="48fdece0e11b0bb3039a1e8d5ff1467bad7e9e24"></p><h1><span id="ying-yong-chang-jing">应用场景</span><a href="#ying-yong-chang-jing" class="header-anchor">#</a></h1><p>而且用到clone，一般做的是复制对象或者直接取出一个不可变的引用， <strong>不需要重新new一个新对象</strong><br>clone可以带参数，例如clone(int type)<br>实现类里有一个内存map&lt;type, 原型对象&gt;   ， 从map里取出已经构造好的返回去。</p><h1><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor">#</a></h1><ul><li><p>提升创建对象的性能<br>因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p></li><li><p>简化对象的创建<br>使得创建对象就像我们在编辑文档时的复制粘贴一样简。</p></li></ul><h1><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor">#</a></h1><p>如果返回的原型对象会被外部调用进行”修改“，而非检查读操作，  那么容易引发原型对象的变更，导致下一次clone时内容发生变化。<br>因此一般要注意返回的是不可变类。</p><h1><span id="java-zhong-de-yuan-xing-lei-ying-yong">java中的原型类应用：</span><a href="#java-zhong-de-yuan-xing-lei-ying-yong" class="header-anchor">#</a></h1><ul><li>实现Cloneable接口。<br>在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</li><li>重写Object类中的clone方法。<br>Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 创建型(都是创建相关的) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式七大原则</title>
      <link href="/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2022/09/13/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#dan-yi-zhi-ze-yuan-ze-single-responsibility-principle">单一职责原则 (Single Responsibility Principle)</a></li><li><a href="#kai-fang-guan-bi-yuan-ze-open-closed-principle">开放-关闭原则 (Open-Closed Principle)</a></li><li><a href="#li-shi-ti-huan-yuan-ze-liskov-substitution-principle">里氏替换原则 (Liskov Substitution Principle)</a></li><li><a href="#yi-lai-dao-zhuan-yuan-ze-dependence-inversion-principle">依赖倒转原则 (Dependence Inversion Principle)</a></li><li><a href="#jie-kou-ge-chi-yuan-ze-interface-segregation-principle">接口隔离原则 (Interface Segregation Principle)</a></li><li><a href="#di-mi-te-fa-ze-law-of-demeter">迪米特法则（Law Of Demeter）</a></li><li><a href="#zu-he-ju-he-fu-yong-yuan-ze-composite-aggregate-reuse-principle">组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="dan-yi-zhi-ze-yuan-ze-single-responsibility-principle">单一职责原则 (Single Responsibility Principle)</span><a href="#dan-yi-zhi-ze-yuan-ze-single-responsibility-principle" class="header-anchor">#</a></h1><p>就一个类而言，应该仅有一个让它变化的原因；通俗地说，即一个类只负责一项职责</p><hr><h1><span id="kai-fang-guan-bi-yuan-ze-open-closed-principle">开放-关闭原则 (Open-Closed Principle)</span><a href="#kai-fang-guan-bi-yuan-ze-open-closed-principle" class="header-anchor">#</a></h1><p>软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改<br>即尽可能避免修改内部逻辑，而是扩展实现</p><hr><h1><span id="li-shi-ti-huan-yuan-ze-liskov-substitution-principle">里氏替换原则 (Liskov Substitution Principle)</span><a href="#li-shi-ti-huan-yuan-ze-liskov-substitution-principle" class="header-anchor">#</a></h1><p>当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为<br>即你新增的P2，不能影响父类方法其他的功能逻辑， 必须其他方法中用到了override的P2，结果导致出错了。</p><hr><h1><span id="yi-lai-dao-zhuan-yuan-ze-dependence-inversion-principle">依赖倒转原则 (Dependence Inversion Principle)</span><a href="#yi-lai-dao-zhuan-yuan-ze-dependence-inversion-principle" class="header-anchor">#</a></h1><p>高层模块不应该依赖低层模块，二者都应该于抽象。进一步说，抽象不应该依赖于细节，细节应该依赖于抽象<br>处理业务逻辑的程序员提供一个封装好数据库操作的抽象接口，交给低层模块的程序员去编写，这样双方可以单独编写而互不影响</p><hr><h1><span id="jie-kou-ge-chi-yuan-ze-interface-segregation-principle">接口隔离原则 (Interface Segregation Principle)</span><a href="#jie-kou-ge-chi-yuan-ze-interface-segregation-principle" class="header-anchor">#</a></h1><p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</p><hr><h1><span id="di-mi-te-fa-ze-law-of-demeter">迪米特法则（Law Of Demeter）</span><a href="#di-mi-te-fa-ze-law-of-demeter" class="header-anchor">#</a></h1><p>它表示一个对象应该对其它对象保持最少的了解。通俗来说就是，只与直接的朋友通信<br>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息。</p><hr><h1><span id="zu-he-ju-he-fu-yong-yuan-ze-composite-aggregate-reuse-principle">组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</span><a href="#zu-he-ju-he-fu-yong-yuan-ze-composite-aggregate-reuse-principle" class="header-anchor">#</a></h1><p>对于被依赖的类来说，无论逻辑多么复杂，都尽量的将逻辑封装在类的内部，对外提供 public 方法，不对泄漏任何信息。</p><p><a href="https://zhuanlan.zhihu.com/p/24614363">设计模式原则例子详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 设计模式 </category>
          
          <category> 设计理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机总线原理</title>
      <link href="/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zong-xian">总线</a><ul><li><a href="#1-gai-nian">1概念</a><ul><li><a href="#1-1-she-bei-gai-nian">1.1设备概念：</a></li><li><a href="#1-2-te-dian">1.2特点：</a></li></ul></li><li><a href="#2-zong-xian-fen-lei">2 总线分类</a><ul><li><a href="#2-1-an-jie-gou-fen-lei">2.1 按结构分类</a><ul><li><a href="#2-1-1-dan-zong-xian">2.1.1 单总线</a></li><li><a href="#2-1-2-mian-xiang-cpu-shuang-zong-xian">2.1.2 面向CPU双总线</a></li><li><a href="#2-1-3-san-zong-xian">2.1.3 三总线</a></li></ul></li><li><a href="#2-2-an-lian-jie-bu-jian-fen-lei">2.2 按连接部件分类</a><ul><li><a href="#2-2-1-pian-nei-zong-xian">2.2.1 片内总线</a></li><li><a href="#2-2-2-xi-tong-zong-xian">2.2.2 系统总线</a></li><li><a href="#2-2-3-tong-xin-zong-xian-wai-zong-xian">2.2.3 通信总线（外总线）</a></li></ul></li></ul></li><li><a href="#3-xing-neng-zhi-biao">3. 性能指标</a></li><li><a href="#4-zong-xian-biao-zhun">4. 总线标准</a></li><li><a href="#5-zong-xian-zhong-cai">5. 总线仲裁</a><ul><li><a href="#5-1-pan-you-kong-zhi">5.1 判优控制</a></li><li><a href="#5-2-lian-shi-cha-xun">5.2 链式查询</a></li><li><a href="#5-3-ji-shu-qi-ding-shi-cha-xun-n-gen">5.3 计数器定时查询（n根）</a></li><li><a href="#reng-shi-gong-you-yi-gen-zong-xian-qing-qiu-xian">仍是共有一根总线请求线。</a></li><li><a href="#5-4-du-li-qing-qiu">5.4 独立请求</a></li><li><a href="#5-5-fen-bu-shi-zhong-cai">5.5 分布式仲裁</a></li></ul></li><li><a href="#tong-xin-fang-shi">通信方式</a><ul><li><a href="#tong-bu-tong-xin">同步通信</a></li><li><a href="#yi-bu-tong-xin">异步通信</a></li></ul><ul><li><a href="#ban-tong-bu-tong-xin">半同步通信</a></li><li><a href="#fen-chi-shi-tong-xin">分离式通信</a></li></ul></li></ul></li><li><a href="#q-shi-me-shi-zong-xian-suo-you-shi-me-que-dian-ti-dai-fang-an-shi-shi-me">Q: 什么是总线锁？有什么缺点？替代方案是什么？</a></li><li><a href="#q-shi-me-qing-kuang-xia-huan-cun-yi-zhi-xing-hui-shi-xiao">Q: 什么情况下缓存一致性会失效？</a></li><li><a href="#q-huan-cun-yi-zhi-xing-ke-neng-hui-yin-fa-shi-me-wen-ti">Q: 缓存一致性可能会引发什么问题？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="zong-xian">总线</span><a href="#zong-xian" class="header-anchor">#</a></h1><h2><span id="1-gai-nian">1概念</span><a href="#1-gai-nian" class="header-anchor">#</a></h2><p>总线是连接多个部件的信息传输线<br>各部件共享的传输介质（多个组件共用1条总线）</p><h3><span id="1-1-she-bei-gai-nian">1.1设备概念：</span><a href="#1-1-she-bei-gai-nian" class="header-anchor">#</a></h3><p>主设备——当前获得总线控制权的设备<br>从设备——被主设备访问的设备，只能响应</p><h3><span id="1-2-te-dian">1.2特点：</span><a href="#1-2-te-dian" class="header-anchor">#</a></h3><p>分时： 同一时刻只允许一个组件发送消息<br>共享： 可多个线同时接收信息</p><h2><span id="2-zong-xian-fen-lei">2 总线分类</span><a href="#2-zong-xian-fen-lei" class="header-anchor">#</a></h2><h3><span id="2-1-an-jie-gou-fen-lei">2.1 按结构分类</span><a href="#2-1-an-jie-gou-fen-lei" class="header-anchor">#</a></h3><h4><span id="2-1-1-dan-zong-xian">2.1.1 单总线</span><a href="#2-1-1-dan-zong-xian" class="header-anchor">#</a></h4><p>内存、CPU、I/O都连接同一根线<br>发生抢占时，需要让总线判断优先级<br>且不适用单周期指令，1个时钟周期内没法传输地址+数据</p><h4><span id="2-1-2-mian-xiang-cpu-shuang-zong-xian">2.1.2 面向CPU双总线</span><a href="#2-1-2-mian-xiang-cpu-shuang-zong-xian" class="header-anchor">#</a></h4><p>总共两根线，分别是</p><ul><li>M内存总线（CPU与内存之间的总线）</li><li>I/O总线（I/O和CPU的总线）<br>缺点：<br>当希望从IO直接传给内存时，需要先经过CPU</li></ul><h4><span id="2-1-3-san-zong-xian">2.1.3 三总线</span><a href="#2-1-3-san-zong-xian" class="header-anchor">#</a></h4><p>以内存为中心<br>CPU&lt;–&gt; Memory &lt;–&gt; I/O<br>CPU和Memory之间可能存在DMA进行高速交互。</p><h3><span id="2-2-an-lian-jie-bu-jian-fen-lei">2.2 按连接部件分类</span><a href="#2-2-an-lian-jie-bu-jian-fen-lei" class="header-anchor">#</a></h3><h4><span id="2-2-1-pian-nei-zong-xian">2.2.1 片内总线</span><a href="#2-2-1-pian-nei-zong-xian" class="header-anchor">#</a></h4><p>指在芯片内部的总线<br>比如CPU内部、寄存器之间、ALU与寄存器</p><h4><span id="2-2-2-xi-tong-zong-xian">2.2.2 系统总线</span><a href="#2-2-2-xi-tong-zong-xian" class="header-anchor">#</a></h4><p>连接CPU\主存、IO的总线<br>数据线： 传送指令、数据、中断信号<br>地址线： 访问主存或者IO，由CPU单向通往内存。 位数决定地址空间<br>控制线： 监控和维护各部件状态， 传送应答信号</p><h4><span id="2-2-3-tong-xin-zong-xian-wai-zong-xian">2.2.3 通信总线（外总线）</span><a href="#2-2-3-tong-xin-zong-xian-wai-zong-xian" class="header-anchor">#</a></h4><p>计算机和其他系统之间的总线（计算机外部的）。</p><blockquote><blockquote><p>猝发传输： 一次性传输存储地址下的多个字</p></blockquote></blockquote><h2><span id="3-xing-neng-zhi-biao">3. 性能指标</span><a href="#3-xing-neng-zhi-biao" class="header-anchor">#</a></h2><ul><li>传输周期/总线周期 —— 一次总线操作所需的时间</li><li>总线宽度——<strong>数据总线</strong>的根数（并非地址总线）</li><li>时钟同/异步——和CPU时钟是否同步工作</li><li>总线复用—— 能否在1根总线中复用地址和数据的功能</li><li>信号线数——地址、数据、控制 三线总和</li><li>控制方式——  突发控制/计数控制/配置控制</li><li>其他指标—— 负载能力/电源电压/宽度扩展性</li></ul><h2><span id="4-zong-xian-biao-zhun">4. 总线标准</span><a href="#4-zong-xian-biao-zhun" class="header-anchor">#</a></h2><p>总线标准， 指 系统和模块间的互连标准， 只要求自身与接口一致即可， 不一定要求所有线都一样。</p><ul><li>ISA—— 独立于CPU的总线时间</li><li>EISA—— 和ISA兼容，  主线控制权不由CPU决定</li><li>VESA—— 局部总线， 使用高速信息传输通道</li><li>PCI——局部总线， 猝发传输</li><li>AGP——显卡专用总线， 双激励，时钟上下沿都可以传输</li><li>RS-232C——用于DTE终端设备和DCE数据通信设备。  解/调码器之间的那根线</li><li>USB——设备总线， 连接设备与设备控制器</li><li>PCI\AGP\PCI-E 负责连接 主存、网卡、视频卡之类内部局部总线</li></ul><h2><span id="5-zong-xian-zhong-cai">5. 总线仲裁</span><a href="#5-zong-xian-zhong-cai" class="header-anchor">#</a></h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/f1b6d0148c0426779d3adb1f906a9e81cf2e4f1c.png" alt="f1b6d0148c0426779d3adb1f906a9e81cf2e4f1c"></p><h4><span id="5-1-pan-you-kong-zhi">5.1 判优控制</span><a href="#5-1-pan-you-kong-zhi" class="header-anchor">#</a></h4><p>主设备才有优先级之分<br>主线才能传输数据。</p><ul><li>集中式总线： 控制逻辑集中于CPU，利用一个特定的裁决算法进行裁决</li><li>分布式总线： 优先逻辑分散到各部件</li></ul><p>集中式仲裁方式如下：</p><h4><span id="5-2-lian-shi-cha-xun">5.2 链式查询</span><a href="#5-2-lian-shi-cha-xun" class="header-anchor">#</a></h4><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/0873d9af0c25df689e116c960251d1dfd8204452.png" alt="0873d9af0c25df689e116c960251d1dfd8204452"></p><ul><li>总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器，总线控制器便查询总线是否忙碌，如不忙碌便立即发总线响应信号到 BG 线串行地从一个部件传送到下一个部件，依次查询，直到某个部件有总线请求便不再传下去。</li><li>此方式下，部件离总线控制器越近优先级越高，离总线控制器越远则优先级越低。</li><li>优点：优先级固定，只需较少的控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</li><li>缺点：对硬件电路的故障敏感，且优先级不能改变，这要极易导致当优先级高的部件频繁请求总线时，优先级低的部件长期不能使用总线。</li></ul><h4><span id="5-3-ji-shu-qi-ding-shi-cha-xun-n-gen">5.3 计数器定时查询（n根）</span><a href="#5-3-ji-shu-qi-ding-shi-cha-xun-n-gen" class="header-anchor">#</a></h4><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/5a8557fe7db45a7b9a15729a6a18cb8d67c545b5.png" alt="5a8557fe7db45a7b9a15729a6a18cb8d67c545b5"></p><h4><span id="reng-shi-gong-you-yi-gen-zong-xian-qing-qiu-xian">仍是共有一根总线请求线。</span><a href="#reng-shi-gong-you-yi-gen-zong-xian-qing-qiu-xian" class="header-anchor">#</a></h4><ul><li>工作原理如下，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件，当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</li><li>优点：计数器计数可从“0”开始，当设备优先次序固定，则设备优先级就按0，1……的顺序排列，固定不变；计数可以从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等；计数器的初值还可由程序设置，因此优先次序可以改变，且这种方式对电路的故障不那么敏感。</li><li>缺点：增加了控制线，若设备有 n 个，则大致需要 ?log_2?n ?+2条控制线，控制也比链式查询复杂。</li></ul><h4><span id="5-4-du-li-qing-qiu">5.4 独立请求</span><a href="#5-4-du-li-qing-qiu" class="header-anchor">#</a></h4><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/d87d9c7042b349025ebc77b41891c34fba9fd50b.png" alt="d87d9c7042b349025ebc77b41891c34fba9fd50b"></p><ul><li>每个设备都有一对总线请求线和总线允许线，当部件需要使用总线时，经各自的总线请求线向总线控制器发送总线请求信号，在控制器中排队，总线控制器按一定的优先次序决定批准某个部件的请求，并经该部件的总线允许线向该部件发送总线响应信号，将总线控制器交给该部件。</li><li>优点：响应速度快，对优先次序的控制相当灵活。</li><li>缺点：控制线数量多，若有设备 n 个，则需要 2n+1 条控制线，其中的 1 是指反馈线，用于让设备向总线控制器反馈已经使用完总线；总线控制逻辑复杂。</li></ul><h4><span id="5-5-fen-bu-shi-zhong-cai">5.5 分布式仲裁</span><a href="#5-5-fen-bu-shi-zhong-cai" class="header-anchor">#</a></h4><p>分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。<br>当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器从仲裁总线上得到的仲裁号与自己的仲裁号比较。<br>若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。</p><h2><span id="tong-xin-fang-shi">通信方式</span><a href="#tong-xin-fang-shi" class="header-anchor">#</a></h2><p>总线周期的4个阶段<br>申请分配——寻址——传数据——结束</p><h4><span id="tong-bu-tong-xin">同步通信</span><a href="#tong-bu-tong-xin" class="header-anchor">#</a></h4><p>按照4个周期上升沿才执行，主从设备完全按照周期执行<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/1314b925470f419d06eb92e8fd83c23ca79e7bce.png" alt="1314b925470f419d06eb92e8fd83c23ca79e7bce"></p><p>读： 发地址-&gt;发送读命令-&gt;读取数据-&gt;撤销占用<br>写：发地址-&gt;提取数据-&gt;发送写命令-&gt;撤销<br>用于存取时间比较一致且短的场合</p><h4><span id="yi-bu-tong-xin">异步通信</span><a href="#yi-bu-tong-xin" class="header-anchor">#</a></h4><p>不会一定要主从设备按照一样的周期执行<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/dad51425b7a657c21e60027d737acbbf975a85df.png" alt="dad51425b7a657c21e60027d737acbbf975a85df"></p><ul><li>不互锁：  不用接收应答，按时间撤销</li><li>半互锁： 主模块接收应答才撤销——共享存储器</li><li>全互锁： 主从都要应答，类似TCP的应答方式</li></ul><h3><span id="ban-tong-bu-tong-xin">半同步通信</span><a href="#ban-tong-bu-tong-xin" class="header-anchor">#</a></h3><p>和同步类似， 但是在命令和数据周期内增加了Tw等待周期。<br>发送方用系统时钟前沿法信号<br>接收方用后沿判断和等待<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/f9664e2e26ce03170b7537e95fb020cf5816c758.png" alt="f9664e2e26ce03170b7537e95fb020cf5816c758"></p><p>以上三种通信的共同点：<br>（1）主模块发地址、命令 占用总线<br>（2）从模块准备数据 不占用总线 总线空闲（3）从模块向主模块发数据 占用总线</p><h3><span id="fen-chi-shi-tong-xin">分离式通信</span><a href="#fen-chi-shi-tong-xin" class="header-anchor">#</a></h3><p>充分挖掘系统总线每个瞬间的潜力<br>一个总线传输周期<br>子周期1 ：主模块申请占用总线，使用完后即放弃总线的使用权。<br>子周期2：从模块申请占用总线，将各种信息送至总线上。</p><p>分离式通信特点：<br>1、各模块有权申请占用总线<br>2、采用同步方式通信，不等对方回答<br>3、各模块准备数据时，不占用总线<br>4、总线被占用时，无空闲</p><hr><h1><span id="q-shi-me-shi-zong-xian-suo-you-shi-me-que-dian-ti-dai-fang-an-shi-shi-me">Q: 什么是总线锁？有什么缺点？替代方案是什么？</span><a href="#q-shi-me-shi-zong-xian-suo-you-shi-me-que-dian-ti-dai-fang-an-shi-shi-me" class="header-anchor">#</a></h1><p>A:</p><ul><li>在早期处理器提供一个 LOCK# 信号，CPU1在操作共享变量的时候会预先对总线加锁，此时CPU2就不能通过总线来读取内存中的数据了</li><li>缺点：但这无疑会大大降低CPU的执行效率。其他CPU都无法正常操作了。</li><li>替代方案：缓存一致性协议<br>由于总线锁的效率太低所以就出现了缓存一致性协议，Intel 的MESI协议就是其中一个佼佼者。MESI协议保证了每个缓存变量中使用的共享变量的副本都是一致的<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%BB%E7%BA%BF/2a4506c7e57b0e03c7d9a44613a843dce3ee207e.png" alt="2a4506c7e57b0e03c7d9a44613a843dce3ee207e"></li><li>CPU1使用共享数据时会先数据拷贝到CPU1缓存中,然后置为独占状态(E)，这时CPU2也使用了共享数据，也会拷贝也到CPU2缓存中。</li><li>通过总线嗅探机制，当该CPU1监听总线中其他CPU对内存进行操作，此时共享变量在CPU1和CPU2两个缓存中的状态会被标记为共享状态(S)；</li><li>若CPU1将变量通过缓存回写到主存中，需要先锁住缓存行，此时状态切换为（M），向总线发消息告诉其他在嗅探的CPU该变量已经被CPU1改变并回写到主存中。</li><li>接收到消息的其他CPU会将共享变量状态从（S）改成无效状态（I），缓存行失效。若其他CPU需要再次操作共享变量则需要重新从内存读取。</li></ul><hr><h1><span id="q-shi-me-qing-kuang-xia-huan-cun-yi-zhi-xing-hui-shi-xiao">Q: 什么情况下缓存一致性会失效？</span><a href="#q-shi-me-qing-kuang-xia-huan-cun-yi-zhi-xing-hui-shi-xiao" class="header-anchor">#</a></h1><p>A:</p><ul><li>共享变量大于缓存行大小，MESI无法进行缓存行加锁；</li><li>CPU并不支持缓存一致性协议</li></ul><hr><h1><span id="q-huan-cun-yi-zhi-xing-ke-neng-hui-yin-fa-shi-me-wen-ti">Q:  缓存一致性可能会引发什么问题？</span><a href="#q-huan-cun-yi-zhi-xing-ke-neng-hui-yin-fa-shi-me-wen-ti" class="header-anchor">#</a></h1><p>A: 可能会引发总线风暴。原因如下：</p><ul><li>嗅探机制：每个处理器会通过嗅探器来监控总线上的数据来检查自己缓存内的数据是否过期，如果发现自己缓存行对应的地址被修改了，就会将此缓存行置为无效。当处理器对此数据进行操作时，就会重新从主内存中读取数据到缓存行。</li><li>MESI会触发嗅探器进行数据传播。当有大量的volatile 和cas 进行数据修改的时候就会产大量嗅探消息。</li><li>结合上面2点， 总线是固定的，所有相应可以接受的通信能力也就是固定的了</li><li>如果缓存一致性流量突然激增，必然会使总线的处理能力受到影响。而恰好CAS和volatile 会导致缓存一致性流量增大。如果很多线程都共享一个变量，当共享变量进行CAS等数据变更时，就有可能产生总线风暴。<br>因此volatile和CAS不能用太多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU执行原理</title>
      <link href="/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-kong-zhi-qi">1. 控制器</a></li><li><a href="#2-yun-suan-qi">2.运算器</a></li><li><a href="#zhi-ling-zhou-qi">指令周期</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p>cpu包含两类东西：</p><ol><li>控制器。</li><li>运算器ALU</li></ol><p>详解：</p><h1><span id="1-kong-zhi-qi">1. 控制器</span><a href="#1-kong-zhi-qi" class="header-anchor">#</a></h1><p>控制器主要负责</p><ul><li>取指令</li><li>分析指令（译码）</li><li>执行指令</li></ul><p>包含的东西有</p><ul><li>程序计数器PC</li><li>指令寄存器IR</li><li>指令译码器</li><li>地址寄存器MAR</li><li>数据寄存器MDR</li><li>时序系统，分频，时序信号</li><li>微操作信号发生器CU</li><li>中断标记寄存器</li></ul><h1><span id="2-yun-suan-qi">2.运算器</span><a href="#2-yun-suan-qi" class="header-anchor">#</a></h1><p>包含</p><ul><li>ALU算术逻辑单元（底层是数电的那种门电路实现）</li><li>暂存寄存器——只负责暂存读出来的数据，不存中间结果</li><li>累加寄存器——暂存ALU的“运算”结果</li><li>通用寄存器组—— 存放操作数和地址信息等。</li><li>程序状态字寄存器PSW——存放当前指令执行结果的各种状态信息，如有无进位（CY位），有无溢出（OV位），结果正负（SF位），结果是否为零（ZF位），奇偶标志位（P位）</li><li>移位器</li><li>计数器——控制乘除时的操作步数</li></ul><h1><span id="zhi-ling-zhou-qi">指令周期</span><a href="#zhi-ling-zhou-qi" class="header-anchor">#</a></h1><p>CPU指令周期分为 取指、间指、执行、中断四个周期。</p><ul><li>取指：<br>PC-&gt;MAR-&gt;主存-&gt;MDR-&gt;IR-&gt;CU控制PC+1</li></ul><p>简单来说<br>PC把指令地址存入MAR地址寄存器<br>主存取出指令数据，放到MDR<br>MDR把指令转到IR里存着<br>CU控制PC+1</p><ul><li>间指<br>IR-&gt;MDR-&gt;MAR-&gt;存储器-&gt;MDR</li></ul><p>要寻找指令执行数据的地址<br>IR解析地址数据，放到MDR中<br>MDR把地址放到MAR中，让他进行读操作<br>主存中读出的数据放入MDR中</p><ul><li>中断<br>PC-&gt;MDR-&gt;主存 原地址存入主存<br>CU-&gt;PC更新中断地址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU缓存原理</title>
      <link href="/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-wei-shi-me-bian-li-er-wei-shu-zu-shi-zui-hao-shi-xian-xing-hou-lie">Q: 为什么遍历二维数组时，最好是先行后列？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><p><a href="https://blog.csdn.net/juS3Ve/article/details/100135619">多图详解CPU Cache Memory</a></p><hr><h1><span id="q-wei-shi-me-bian-li-er-wei-shu-zu-shi-zui-hao-shi-xian-xing-hou-lie">Q: 为什么遍历二维数组时，最好是先行后列？</span><a href="#q-wei-shi-me-bian-li-er-wei-shu-zu-shi-zui-hao-shi-xian-xing-hou-lie" class="header-anchor">#</a></h1><p>A:<br>先行后列是最常见的二维数组的遍历方式，而且效率非常高<br>因为二维数组的每一行都是一段连续的空间<br>根据局部性原理，操作系统再访问每个元素时，会将该元素附近多个元素一次性加载到缓存中来提高程序效率。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO中断原理</title>
      <link href="/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/IO%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/IO%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shi-me-shi-zhong-duan">什么是中断</a></li><li><a href="#zhong-duan-lei-xing">中断类型</a><ul><li><a href="#ying-jian-zhong-duan">硬件中断</a></li><li><a href="#ruan-jian-zhong-duan">软件中断</a></li><li><a href="#i-o-zhong-duan-liu-cheng">I/O中断流程</a></li><li><a href="#wu-zhong-duan">无中断</a></li><li><a href="#you-zhong-duan">有中断</a></li></ul></li><li><a href="#zhong-duan-chu-li-wan-zheng-liu-cheng">中断处理完整流程</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p>原文链接：<a href="https://www.cnblogs.com/Jack-Blog/p/12038716.html">I/O中断原理</a></p><h1><span id="shi-me-shi-zhong-duan">什么是中断</span><a href="#shi-me-shi-zhong-duan" class="header-anchor">#</a></h1><p>中断指当出现需要时，<strong>CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。</strong><br>即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。</p><p>我们知道CPU是按指令顺序进行执行的，操作系统每过大约15ms会发生一次线程调度(Windows下)，根据线程优先级先调度优先级高的线程。但是实际情况并没有那么简单，若我们接收到一个网络请求，如果要等当前线程执行完或15ms线程调度之后才去处理网络请求，网卡缓冲区很有可能会被占满，此时就发生了丢包。</p><h1><span id="zhong-duan-lei-xing">中断类型</span><a href="#zhong-duan-lei-xing" class="header-anchor">#</a></h1><p>中断分为硬件中断和软件中断。</p><h2><span id="ying-jian-zhong-duan">硬件中断</span><a href="#ying-jian-zhong-duan" class="header-anchor">#</a></h2><p>硬件中断即为硬件发出的中断信号，如I/O中断和硬件失效中断。</p><ul><li>I/O中断：由I/O控制器产生，用于发送信号通知操作完成等信号。</li><li>硬件失效中断：如掉电或存储器奇偶错之类的故障。</li></ul><h2><span id="ruan-jian-zhong-duan">软件中断</span><a href="#ruan-jian-zhong-duan" class="header-anchor">#</a></h2><p>软件中断即为非硬件发出的中断信号，如程序中断和时钟中断。</p><ul><li>程序中断：一些指令产生的异常(如算数移除、除数为0等)。</li><li>时钟中断：由处理器内部的计时器产生，允许操作系统以一定规程执行函数。</li></ul><blockquote><blockquote><p>我们提到了操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的。</p></blockquote></blockquote><h2><span id="i-o-zhong-duan-liu-cheng">I/O中断流程</span><a href="#i-o-zhong-duan-liu-cheng" class="header-anchor">#</a></h2><p>I/O中断通过中断处理器执行中断操作。<br>当外部设备的I/O模块准备好时，它会发送给CPU一个中断信号，CPU则会“立即”做出响应，暂停当前程序的处理去服务该I/O设备的程序。</p><p>为了更好的说明中断带来的性能提升，我们先描述一下没有中断时程序如何处理I/O操作。</p><h2><span id="wu-zhong-duan">无中断</span><a href="#wu-zhong-duan" class="header-anchor">#</a></h2><p><img src="/images/IO%E6%80%BB%E7%BA%BF/dec2cbc5c149303dc347d1ae30cfcd3a0413c63e.png" alt="dec2cbc5c149303dc347d1ae30cfcd3a0413c63e"></p><ol><li>当我们程序需要从硬盘读取一个文件时，会先检查内核缓存中是否有数据，若没有数据，则执行实际I/O操作。</li><li>在I/O操作执行时，我们的用户线程将阻塞等待数据从硬盘写到内存中。对于用户来说线程是被阻塞的。</li><li>在实际的I/O操作过程中，若没有中断操作，CPU会不断轮询检查I/O操作是否完成</li><li>若I/O操作没有完成则继续调度其他线程，过一会儿再来检查。若操作完成，CPU将线程加入到线程就绪队列中并恢复线程上下文信息。</li><li>线程处于就绪队列，可以被操作系统调度从而继续执行读操作，此时会将数据从操作系统内核缓存读取到用户缓存中。</li></ol><h2><span id="you-zhong-duan">有中断</span><a href="#you-zhong-duan" class="header-anchor">#</a></h2><p><img src="/images/IO%E6%80%BB%E7%BA%BF/22fb8d915066c9a461c4fbe3a75f3a58d536469f.png" alt="22fb8d915066c9a461c4fbe3a75f3a58d536469f"></p><ol><li>当我们程序需要从硬盘读取一个文件时，会先检查内核缓存中是否有数据，若没有数据，则执行实际I/O操作。在I/O操作执行时，我们的用户线程将阻塞等待数据从硬盘写到内存中。对于用户来说线程是被阻塞的。</li><li>在实际的I/O操作过程中，CPU向I/O模块(DMA控制器)发送读指令，然后就去调度其他线程。</li><li>当I/O模块(DMA控制器)I/O执行完成后，会产生中断信号在通知CPU，CPU将线程加入到线程就绪队列中并恢复线程上下文信息。</li><li>线程处于就绪队列，可以被操作系统调度从而继续执行读操作，此时会将数据从操作系统内核缓存读取到用户缓存中。</li></ol><ul><li>由上面可知，有中断还是没有中断对于用户来说线程都是阻塞的，对于操作系统内核来说通过中断方式主动通知CPU的方式减少了线程轮询判断，提高了线程执行效率。</li></ul><h1><span id="zhong-duan-chu-li-wan-zheng-liu-cheng">中断处理完整流程</span><a href="#zhong-duan-chu-li-wan-zheng-liu-cheng" class="header-anchor">#</a></h1><p>当I/O设备完成一次I/O操作时，发生以下事件：</p><ol><li>开始I/O操作前，处理器将当前处理的相关信息如指令地址、必要的状态信息等保存到栈中，使得中断后可以恢复执行。</li><li>I/O操作完成后，设备给处理器发送一个中断信号。</li><li>处理器响应中断信号。</li><li>处理器对中断信号进行判断，若存在未响应的中断，则给产生中断信号的设备发送确认信号，确认信号使得设备取消它的中断信号。</li><li>处理器将控制前转移给中断程序中，中断程序从栈中获取之前保存的信息，使得能继续执行I/O完成时的后续操作。</li><li>处理器将中断程序入口地址载入到程序计数器中，使得处理器能继续执行下一个指令周期。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理全流程</title>
      <link href="/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/09/12/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p>[toc]</p><p>全景流程图：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%A8%E6%B5%81%E7%A8%8B/61d991c7e401fd06a8be13df.png" alt="计算机组成原理全景流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统原理</title>
      <link href="/2022/09/09/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/09/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#7-1-ji-ben-gai-nian">7.1 基本概念</a><ul><li><a href="#7-1-1-wen-jian-ding-yi">7.1.1 文件定义</a></li><li><a href="#7-1-2-wen-jian-jie-gou">7.1.2 文件结构</a></li><li><a href="#7-1-3-wen-jian-shu-xing">7.1.3 文件属性</a></li><li><a href="#7-1-4-wen-jian-chang-jian-cao-zuo">7.1.4 文件常见操作</a></li><li><a href="#7-1-5-open-da-kai-wen-jian-de-guo-cheng">7.1.5 open打开文件的过程</a></li></ul></li><li><a href="#7-2-mu-lu">7.2 目录</a><ul><li><a href="#7-2-1-wen-jian-de-zu-zhi-jie-gou">7.2.1 文件的组织结构</a><ul><li><a href="#7-2-1-1-wen-jian-kong-zhi-kuai-fcb-wen-jian-mu-lu-xiang">7.2.1.1 文件控制块FCB（文件目录项）</a></li><li><a href="#7-2-1-2-suo-yin-jie-dian">7.2.1.2 索引节点</a></li><li><a href="#7-2-1-3-wen-jian-kong-zhi-kuai-he-suo-yin-jie-dian-de-qu-bie">7.2.1.3 文件控制块和索引节点的区别</a></li></ul></li><li><a href="#7-2-2-mu-lu-de-jie-gou">7.2.2 目录的结构</a></li><li><a href="#7-2-3-wen-jian-ceng-ci-jie-gou">7.2.3 文件层次结构</a></li><li><a href="#7-2-4-mu-lu-de-shi-xian-yuan-li">7.2.4 目录的实现原理</a></li></ul></li><li><a href="#7-3-wen-jian-gong-xiang">7.3 文件共享</a><ul><li><a href="#7-3-1-ruan-lian-jie">7.3.1 软连接</a></li><li><a href="#7-3-2-ying-lian-jie">7.3.2 硬连接</a></li></ul></li><li><a href="#7-4-wen-jian-de-shi-xian-yuan-li">7.4 文件的实现原理</a><ul><li><a href="#7-4-1-wen-jian-fen-pei">7.4.1 文件分配</a></li><li><a href="#7-4-1-1-lian-xu-fen-pei">7.4.1.1 连续分配：</a><ul><li><a href="#7-4-1-2-lian-jie-fen-pei">7.4.1.2 链接分配：</a></li><li><a href="#7-4-1-3-suo-yin-fen-pei">7.4.1.3 索引分配</a></li></ul></li><li><a href="#7-4-2-cun-chu-kong-jian-guan-li">7.4.2 存储空间管理</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="7-1-ji-ben-gai-nian">7.1 基本概念</span><a href="#7-1-ji-ben-gai-nian" class="header-anchor">#</a></h1><h2><span id="7-1-1-wen-jian-ding-yi">7.1.1 文件定义</span><a href="#7-1-1-wen-jian-ding-yi" class="header-anchor">#</a></h2><p>文件是以计算机硬盘为载体的信息集合<br>需要提供文件系统进行管理</p><h2><span id="7-1-2-wen-jian-jie-gou">7.1.2 文件结构</span><a href="#7-1-2-wen-jian-jie-gou" class="header-anchor">#</a></h2><ul><li>数据项：<br>类似于int、string这种，或者 学号、姓名等值（类似sql表中的某个值内容）</li><li>记录：<br>一组数据项集合<br>比如学号和姓名，组成了学生记录（例如sql表中的某一行）</li><li>文件</li></ul><p>按逻辑结构可以分为2类：<br>? 无结构文件： 一般都是二进制文件流文件，直接按顺序封装。这里面不包含记录的概念<br>? 有结构文件： 包含记录的概念<br>顺序文件：按记录中的某个关键字排序过，可二分查找记录行<br>索引文件： 需要1个索引表，记录每个记录的位置<br>索引顺序文件：先按关键字索引，在部分擦护照<br>直接、散列文件：用哈希键值确定记录位置</p><h2><span id="7-1-3-wen-jian-shu-xing">7.1.3 文件属性</span><a href="#7-1-3-wen-jian-shu-xing" class="header-anchor">#</a></h2><p>名称<br>标识符——确认文件唯一性<br>类型<br>位置——设备文件指针<br>大小——文件大小或者文件最大值<br>保护——访问控制权限<br>时间、日期<br>用户标志——哪个用户可用</p><h2><span id="7-1-4-wen-jian-chang-jian-cao-zuo">7.1.4 文件常见操作</span><a href="#7-1-4-wen-jian-chang-jian-cao-zuo" class="header-anchor">#</a></h2><ul><li>创建文件</li><li>写文件——要指定一个写指针确认从哪开始写</li><li>读文件——读写共用一个指针，避免文件不同步</li><li>重定位——修改文件位置</li><li>删除文件——先删除文件目录项，再去清理空间，避免还没清理完有人却正要用</li><li>截断文件——把文件长度截断</li></ul><h2><span id="7-1-5-open-da-kai-wen-jian-de-guo-cheng">7.1.5 open打开文件的过程</span><a href="#7-1-5-open-da-kai-wen-jian-de-guo-cheng" class="header-anchor">#</a></h2><ol><li>从外存把文件属性拷贝进内存，建立文件目录表</li><li>返回一个文件编号给用户</li><li>用文件打开计数器，记录有多少个进程正在打开该进程。当没有进程在使用时，回收内存。</li><li>进程获取文件的以下信息：</li></ol><ul><li>文件指针</li><li>文件打开计数</li><li>文件磁盘位置</li><li>访问权限</li></ul><h1><span id="7-2-mu-lu">7.2 目录</span><a href="#7-2-mu-lu" class="header-anchor">#</a></h1><p>目录就是文件的外部组织结构</p><h2><span id="7-2-1-wen-jian-de-zu-zhi-jie-gou">7.2.1 文件的组织结构</span><a href="#7-2-1-wen-jian-de-zu-zhi-jie-gou" class="header-anchor">#</a></h2><h3><span id="7-2-1-1-wen-jian-kong-zhi-kuai-fcb-wen-jian-mu-lu-xiang">7.2.1.1 文件控制块FCB（文件目录项）</span><a href="#7-2-1-1-wen-jian-kong-zhi-kuai-fcb-wen-jian-mu-lu-xiang" class="header-anchor">#</a></h3><ul><li>存放了操作文件所需要的信息</li><li>文件目录中存放了许多FCB，可以通过FCB按名查取。</li><li>包含的信息有：<br>基本信息： 文件名/物理位置/逻辑结构/物理结构<br>存取控制信息： 访问权限<br>使用信息：建立时间、修改时间</li></ul><h3><span id="7-2-1-2-suo-yin-jie-dian">7.2.1.2 索引节点</span><a href="#7-2-1-2-suo-yin-jie-dian" class="header-anchor">#</a></h3><ul><li><p>存放文件描述信息， 但是不包含文件名</p></li><li><p>文件目录中只存放文件名和i节点指针</p></li><li><p>可减少外村磁盘的查找速度</p></li><li><p>节点内容包括：<br>标识符、类型、权限、存取时间<br>地址长度、链接计数<br>节点编号、状态（是否上锁）<br>访问计数、设备号</p></li><li><p>文件打开时，会把索引节点从磁盘复制进内存，称为内存索引节点</p></li></ul><h3><span id="7-2-1-3-wen-jian-kong-zhi-kuai-he-suo-yin-jie-dian-de-qu-bie">7.2.1.3 文件控制块和索引节点的区别</span><a href="#7-2-1-3-wen-jian-kong-zhi-kuai-he-suo-yin-jie-dian-de-qu-bie" class="header-anchor">#</a></h3><p>只需要文件位置信息等时，只需要拿文件控制块来唯一确认一个文件即可。<br>但是需要真正使用文件时，则需要索引节点里的信息<br>但如果把索引节点提前加载进内存的话，容易导致开销浪费。所以只有需要的时候，才回去用到索引节点，减少要拷贝的信息。<br><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/2021031423522644.png" alt="在这里插入图片描述"></p><h2><span id="7-2-2-mu-lu-de-jie-gou">7.2.2 目录的结构</span><a href="#7-2-2-mu-lu-de-jie-gou" class="header-anchor">#</a></h2><p>单级目录<br>两级目录<br>多级目录：树形结构，有相对路径和绝对路径</p><h2><span id="7-2-3-wen-jian-ceng-ci-jie-gou">7.2.3 文件层次结构</span><a href="#7-2-3-wen-jian-ceng-ci-jie-gou" class="header-anchor">#</a></h2><p>从用户层从上往下排列</p><ol><li>用户接口：<br>若干程序模块组织曾，每一个模块对应一个系统调用</li><li>文件目录系统： 查找目录项，找到索引节点<br>存取控制：用户要访问的权限和FCB中的权限做比对<br>逻辑文件系统： 把要读取的记录转为罗季葵爱好<br>物理文件系统——把逻辑块号转为实际物理地址<br>设备管理模块——分配磁盘设备做输入输出</li></ol><h2><span id="7-2-4-mu-lu-de-shi-xian-yuan-li">7.2.4 目录的实现原理</span><a href="#7-2-4-mu-lu-de-shi-xian-yuan-li" class="header-anchor">#</a></h2><p>线性列表——宠用目录项， 顺序检索。<br>哈希表——根据文件名得到key值</p><p>linux的目录实现原理：</p><h1><span id="7-3-wen-jian-gong-xiang">7.3 文件共享</span><a href="#7-3-wen-jian-gong-xiang" class="header-anchor">#</a></h1><h2><span id="7-3-1-ruan-lian-jie">7.3.1 软连接</span><a href="#7-3-1-ruan-lian-jie" class="header-anchor">#</a></h2><p>符号链接<br>建立一个文件， 文件中存放共享文件的路径<br>只有文件拥有者才能有指向文件的i节点指针<br>不会出现指针悬空， 不存在时，软链接会被删除。<br><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/20210314235239640.png" alt="在这里插入图片描述"></p><h2><span id="7-3-2-ying-lian-jie">7.3.2 硬连接</span><a href="#7-3-2-ying-lian-jie" class="header-anchor">#</a></h2><p>即一个文件名的指针<br>各用户文件目录表用i节点指针指向同一个索引节点<br>当文件被删除，另一个用户就不能访问了。<br>容易出错。<br><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/20210314235249696.png" alt="在这里插入图片描述"></p><h1><span id="7-4-wen-jian-de-shi-xian-yuan-li">7.4 文件的实现原理</span><a href="#7-4-wen-jian-de-shi-xian-yuan-li" class="header-anchor">#</a></h1><h2><span id="7-4-1-wen-jian-fen-pei">7.4.1 文件分配</span><a href="#7-4-1-wen-jian-fen-pei" class="header-anchor">#</a></h2><p>指怎么给文件分配磁盘块</p><h2><span id="7-4-1-1-lian-xu-fen-pei">7.4.1.1 连续分配：</span><a href="#7-4-1-1-lian-xu-fen-pei" class="header-anchor">#</a></h2><p>每个文件在磁盘上占一组连续的块<br>目录项记录文件的起始位置和长度<br>这样能让作业的磁盘寻道数最少<br>适用于长度固定的文件</p><h3><span id="7-4-1-2-lian-jie-fen-pei">7.4.1.2 链接分配：</span><a href="#7-4-1-2-lian-jie-fen-pei" class="header-anchor">#</a></h3><ul><li><p>隐式链接：<br>每个文件有一个链表， 每个节点是一个磁盘块，next指针指向下一个磁盘块</p></li><li><p>显式链接：<br>用一个二维数组表替代next指针， [0]是盘块，[1]是下一个盘块<br>这个表就是文件分配表FAT<br>文件的第一个盘号也就是链表头 会放入FCB的物理地址中</p></li></ul><h3><span id="7-4-1-3-suo-yin-fen-pei">7.4.1.3 索引分配</span><a href="#7-4-1-3-suo-yin-fen-pei" class="header-anchor">#</a></h3><p>为了防止这个表占据太大空间或者不够用<br>给每个文件有一个索引表，按顺序给出盘块<br>同时可以多级索引， 即可以给出磁盘中下一级索引表的盘块号。然后再去把盘中的二级索引表导入到内存中使用</p><h2><span id="7-4-2-cun-chu-kong-jian-guan-li">7.4.2 存储空间管理</span><a href="#7-4-2-cun-chu-kong-jian-guan-li" class="header-anchor">#</a></h2><p>即把哪些磁盘块分给文件呢？</p><ul><li>文件卷、逻辑卷</li></ul><p>以下是空闲块分配方法：</p><ul><li>空闲表法—— 从空闲盘块表中选取， 释放的时候要做前后空闲区合并</li><li>空闲链块法：把空闲块组成链表</li><li>位视图法：  用010101确定是否空闲，可减少空闲块信息的大小</li><li>成组链接法：<br>把n个空闲区分组，存入不同的空闲盘块栈中。并且有各种指针指向其他组的空闲盘块<br>当某组内的空闲块变化时， 可以修改上一个块号栈的指针指向位置。<br><img src="/images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/20210314235307680.png" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统磁盘和IO原理</title>
      <link href="/2022/09/08/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E5%92%8CIO%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/08/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E5%92%8CIO%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#7-5-1-chang-jian-ci-pan-gai-nian">7.5.1 常见磁盘概念</a><ul><li><a href="#7-5-1-1-jie-gou">7.5.1.1 结构</a></li><li><a href="#7-5-1-2-fen-lei">7.5.1.2 分类</a></li><li><a href="#7-5-1-3-cun-qu-shi-jian">7.5.1.3 存取时间</a></li></ul></li><li><a href="#7-5-2-diao-du-suan-fa">7.5.2 调度算法</a></li><li><a href="#7-5-3-shan-mian-hua-fen">7.5.3 扇面划分</a></li><li><a href="#7-5-4-ci-pan-guan-li">7.5.4 磁盘管理</a><ul><li><a href="#7-5-4-1-chu-shi-hua">7.5.4.1 初始化</a></li><li><a href="#7-5-4-2-yin-dao-kuai">7.5.4.2 引导块</a></li><li><a href="#7-5-4-3-pi-kuai">7.5.4.3 坏块</a></li></ul></li><li><a href="#7-6-io-guan-li">7.6 IO管理</a><ul><li><a href="#7-6-1-io-kong-zhi-fang-shi">7.6.1 IO控制方式</a></li><li><a href="#7-6-2-io-ceng-ci-xing-jie-gou">7.6.2 IO层次性结构</a></li><li><a href="#7-6-3-she-bei-kong-zhi-qi-gua-pei-qi">7.6.3 设备控制器（适配器）</a></li><li><a href="#7-6-4-io-he-xin-zi-xi-tong">7.6.4 IO核心子系统</a><ul><li><a href="#7-6-4-1-huan-chong-qu">7.6.4.1 缓冲区</a></li><li><a href="#7-6-4-2-she-bei-fen-pei-he-hui-shou-ji-zhi">7.6.4.2 设备分配和挥手机制</a></li><li><a href="#7-6-4-3-spooling-ji-zhu-xu-ni-hua-she-bei">7.6.4.3 spooling技术（虚拟化设备）</a></li></ul></li><li><a href="#q-jiang-yi-xia-zu-sai-he-fei-zu-sai-de-qu-bie-zhu-yi-mei-you-xi-dai-io-dui-ying-de-shi-guang-yi-de-fang-fa-diao-yong-shi-de-zu-sai-he-fei-zu-sai">Q: 讲一下阻塞和非阻塞的区别？（注意没有携带IO，对应的是广义的方法调用时的阻塞和非阻塞）</a></li><li><a href="#q-tong-bu-he-yi-bu-de-qu-bie-zhu-yi-mei-you-xi-dai-io-dui-ying-de-shi-guang-yi-de-fang-fa-diao-yong-shi-de-tong-bu-he-yi-bu">Q: 同步和异步的区别？（注意没有携带IO，对应的是广义的方法调用时的同步和异步）</a></li><li><a href="#q-jiang-yi-xia-wu-chong-io-mo-xing">Q: 讲一下五种IO模型</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="7-5-1-chang-jian-ci-pan-gai-nian">7.5.1 常见磁盘概念</span><a href="#7-5-1-chang-jian-ci-pan-gai-nian" class="header-anchor">#</a></h1><h2><span id="7-5-1-1-jie-gou">7.5.1.1 结构</span><a href="#7-5-1-1-jie-gou" class="header-anchor">#</a></h2><ul><li>磁道：可以立即为磁盘上的圈圈</li><li>扇区<br>1个磁道会划分为多个扇区<br>扇区即块（盘块，即上面文件里提到的盘块）<br>存储能力受限于内道的最大记录密度</li><li>磁盘地址<br>地址=(柱面，盘面，扇区号）<br>以簇为单位作为各文件的磁盘分配</li></ul><h2><span id="7-5-1-2-fen-lei">7.5.1.2 分类</span><a href="#7-5-1-2-fen-lei" class="header-anchor">#</a></h2><p>根据磁头动作，可以分为   固定头磁盘 /  活动头磁盘<br>根据磁盘是否固定，可分为 固定盘磁盘 / 可换盘磁盘</p><h2><span id="7-5-1-3-cun-qu-shi-jian">7.5.1.3 存取时间</span><a href="#7-5-1-3-cun-qu-shi-jian" class="header-anchor">#</a></h2><p>这个时间是衡量磁盘设计好坏的重要因素</p><ul><li><p>寻找时间Ts （先找磁道，即找在圈里的第几层）<br>指找到磁道的时间<br>Ts = 0.2ms * 跨越磁道数 + st(磁臂启动时间，即扫描的那个东西开始动的时间)</p></li><li><p>延迟时间（磁道找完，定位扇区，即在圈上的哪个方位）<br>定位置某一扇区的时间<br>转一圈的时间/2作为延迟时间， 即对转一圈的时间求个平均（毕竟实际速度和扫描算法有关）<br>Tr = 1/2r</p></li><li><p>传输时间（找到位置了，接着开始读数据）<br>就是读写数据时间<br>扇区占一圈的几分之几 * 转一圈的描述</p></li></ul><p>其实就是磁臂按正常速度扫完这个内容要花的时间。</p><h1><span id="7-5-2-diao-du-suan-fa">7.5.2 调度算法</span><a href="#7-5-2-diao-du-suan-fa" class="header-anchor">#</a></h1><p>其实就是收到多个盘块的请求，选择扫描磁道的方法</p><ul><li>FCFS 先来先服务<br>按盘块请求里的顺序来扫描<br>适合那种聚在一起的盘块</li><li>SSTF 最短时间优先<br>一直找最近的磁道<br>如果频繁收到比较近的磁道，可能造成其他磁道饥饿，无法被访问</li><li>SCAN 扫描、电梯算法<br>从上倒下，再从下到上，再从上到下，扫到请求里的盘块就算检测到。<br>对两端的节点不公平，扫描频率会比中间的低</li><li>C-SCAN 循环扫描算法<br>方向固定，每次都是从下往上， 当到达顶部时， 直接快速转回到底部，然后再继续从下往上（快速转回的过程不会响应任何盘块请求）</li></ul><h1><span id="7-5-3-shan-mian-hua-fen">7.5.3 扇面划分</span><a href="#7-5-3-shan-mian-hua-fen" class="header-anchor">#</a></h1><ul><li>交替编号<br>1 3 2 4这样编号<br>因为读出数据需要时间，这时候如果让磁道继续转动，可能已经移动到后面第2个扇区了。<br>但数据又是希望能连续读的，所以交替放，保证读完后，不用再移动，直接用这个区的</li><li>错位命名<br>第一层磁道的扇区是1 3 2 4<br>第二层磁道的扇区是4 1 3 2<br>第三层的磁道是 2 4 1 3<br>可以看到每一层磁道的扇区，整体都右移了一位<br>这是为了减少切换磁道时，重新扫圈的时间</li></ul><h1><span id="7-5-4-ci-pan-guan-li">7.5.4 磁盘管理</span><a href="#7-5-4-ci-pan-guan-li" class="header-anchor">#</a></h1><h2><span id="7-5-4-1-chu-shi-hua">7.5.4.1 初始化</span><a href="#7-5-4-1-chu-shi-hua" class="header-anchor">#</a></h2><ul><li>低级格式化<br>初始化扇区号和纠错代码（ECC），ECC用于检验磁盘正确性<br>物理分区</li><li>逻辑格式化<br>初始化磁盘数据结构<br>分为C\D\E盘， 对linux就是那些opt分区之类的</li></ul><h2><span id="7-5-4-2-yin-dao-kuai">7.5.4.2 引导块</span><a href="#7-5-4-2-yin-dao-kuai" class="header-anchor">#</a></h2><p>磁盘的启动程序会放在磁盘的引导块上</p><h2><span id="7-5-4-3-pi-kuai">7.5.4.3 坏块</span><a href="#7-5-4-3-pi-kuai" class="header-anchor">#</a></h2><p>对于损坏的磁盘块， 他会检测并避免再使用这些坏块。</p><p><a href="http://c.biancheng.net/view/1291.html">更多</a></p><h1><span id="7-6-io-guan-li">7.6 IO管理</span><a href="#7-6-io-guan-li" class="header-anchor">#</a></h1><h2><span id="7-6-1-io-kong-zhi-fang-shi">7.6.1 IO控制方式</span><a href="#7-6-1-io-kong-zhi-fang-shi" class="header-anchor">#</a></h2><ul><li>程序直接控制</li><li>中断驱动方式</li><li>DMA方式<br>特点：<br>以块位单位<br>数据直接进入内存<br>开始和结束需要CPU干预，无法通过外设自己完成</li></ul><p>DMA会设置4个寄存器：<br>命令/状态寄存器CR——用于接收CPU发来的控制命令，存储当前状态<br>内存地址MAR——存放内存地址<br>数据寄存器DR——暂存数据<br>数据计数器DC——用于传输计数</p><p>工作过程：</p><ol><li>CPU收到程序发来的DMA请求——发出控制命令</li><li>启动DMA-&gt;DMA存取-&gt;结束</li><li>发送中断信号——CPU中断，通知调用程序DMA结束</li></ol><p>DMA和中断的区别</p><blockquote><ul><li>DMA：是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制，使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率.</li><li>中断：是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。</li></ul><blockquote><p>所以中断和DMA的区别就是DMA不需CPU参与，而中断是需要CPU参与的。</p></blockquote></blockquote><ul><li>通道控制方式<br>是DMA的升级版<br>指令单一，和CPU共享内存<br>是一种硬件、特殊的处理器，无内存，指令存在主机内存中。<br>传输数据的带线啊哦、内存存放位置，通道可以自主决定！<br>即比DMA更高级了</li></ul><h2><span id="7-6-2-io-ceng-ci-xing-jie-gou">7.6.2 IO层次性结构</span><a href="#7-6-2-io-ceng-ci-xing-jie-gou" class="header-anchor">#</a></h2><p>从上往下介绍</p><ol><li>用户层IO软件</li></ol><ul><li>由用户提供的库函数</li><li>需要一系列系统调用</li></ul><ol start="2"><li>设备独立性软件<br>曹旭哦提供相关调用</li></ol><ul><li>功能： 指向设备的共有操作，向用户层提供统一的IO接口（例如unix底层和IO相关的c函数）</li><li>支持设备独立，程序和设备可独立切换，不强依赖。</li></ul><ol start="3"><li>设备驱动程序<br>商家提供</li></ol><ul><li>实行系统对设备的具体操作</li><li>具体的硬件设备会配置1个驱动</li></ul><ol start="4"><li>中断处理程序</li><li>硬件设备</li></ol><h2><span id="7-6-3-she-bei-kong-zhi-qi-gua-pei-qi">7.6.3 设备控制器（适配器）</span><a href="#7-6-3-she-bei-kong-zhi-qi-gua-pei-qi" class="header-anchor">#</a></h2><ul><li>通过寄存器与CPU进行通信<br>具有内存映像，占有CPU内存<br>寄存器独立编址，采用IO专用地址</li><li>功能<br>接收、识别CPU的命令<br>实现数据交换<br>提供设备状态、提供地址识别</li><li>组成部分<br>与CPU的接口——数据、地址、命令线<br>与设备的接口——1个接口一个设备<br>IO控制器（地址、命令译码）</li></ul><p><a href="https://blog.csdn.net/weixin_46250447/article/details/113828056">更多</a></p><h2><span id="7-6-4-io-he-xin-zi-xi-tong">7.6.4 IO核心子系统</span><a href="#7-6-4-io-he-xin-zi-xi-tong" class="header-anchor">#</a></h2><ul><li>是一个进行设备控制的子系统</li><li>内核无需做太多的IO设备管理</li><li>子系统实现IO调度队列，改善IO的响应时间，比如磁盘调度</li></ul><h3><span id="7-6-4-1-huan-chong-qu">7.6.4.1 缓冲区</span><a href="#7-6-4-1-huan-chong-qu" class="header-anchor">#</a></h3><p>磁盘高速缓存： 在内存中开辟单独空间，利用未利用的页做缓冲池</p><p>缓冲区的目的：<br>减少CPU\IO速度的不匹配<br>减少CPU中断<br>提高IO和CPU的并行性</p><p>缓冲分类</p><ul><li>单缓冲：<br>IO和CPU之间只有1个缓冲区。 处理数据的时候，可以提前读进来1份。</li><li>双缓冲<br>2个缓冲区。<br>缓冲1满了之后，装2. CPU可以接连取<br>缓冲区1满了之后，</li><li>循环缓冲<br>有一个缓冲循环队列， 有2个指针<br>in指针指向空的缓冲，用于进行外部数据的IO输入。<br>out指针指向满的缓冲，用于把数据读进系统中</li><li>缓冲池<br>要用到的时候，就从池中取一个缓冲区。 用完就归还</li></ul><h3><span id="7-6-4-2-she-bei-fen-pei-he-hui-shou-ji-zhi">7.6.4.2 设备分配和挥手机制</span><a href="#7-6-4-2-she-bei-fen-pei-he-hui-shou-ji-zhi" class="header-anchor">#</a></h3><p>设备分配分类</p><ul><li>独占设备——只允许单进程</li><li>分时设备——分时交替IO</li><li>spooling设备——虚拟设备</li></ul><p>设备分配表<br>DCT设备控制表—— 1个控制表代表一个设备。<br>COCT控制器控制表——与内存交换数据。请求通道服务——指向CHCT<br>CHCT通道控制表<br>SDT系统设备表——记录系统中已连接的设备情况<br><img src="https://img-blog.csdnimg.cn/20210314235456551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3OTk1ODEyMjk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3><span id="7-6-4-3-spooling-ji-zhu-xu-ni-hua-she-bei">7.6.4.3 spooling技术（虚拟化设备）</span><a href="#7-6-4-3-spooling-ji-zhu-xu-ni-hua-she-bei" class="header-anchor">#</a></h3><ul><li>SPOOLing 技术是用于将 I\O 设备进行虚拟化的技术，</li><li>它是专门用于欺骗进程的。</li><li>就拿打印机举栗吧，我就买了一台打印机，但此时我打开了 word 和 pdf，想要打印 word 和 pdf 中的内容；此时计算机中有2个进程，word 进程和 pdf 进程，这两个进程都认为自己拥有一个打印机，那么是否此时我作为计算机的主人就拥有2台打印机了呢？当然不是啊，我又不是睁眼瞎，我就看到了一台打印机啊</li><li>这就是通过虚拟化技术欺骗了2个无知的进程。具体的实现道理我都懂，那么怎么实现欺骗进程的目的呢（也就是怎么实现SPOOLing技术呢）？</li><li></li><li>SPOOLing 技术首先需要提供统一的调用接口，每一个进程都可以调用该接口，这样在进程看了自己是拥有该设备的。需要将磁盘设备和内存作为缓冲区，磁盘设备上的缓冲区称作井，而内存上的缓存区被称作缓冲区。需要一个专门的输入输出进程来实现对 I/O 设备的读写数据。</li></ul><p>以向 I/O 设备写数据为例子，做出概念图，如下所示：<br><img src="https://img-blog.csdnimg.cn/20210314235519751.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210314235539460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3OTk1ODEyMjk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>首先某一个进程（例如 word）调用了统一的接口，然后进入内核。内核例程负责将 word 想要打印的内容做成一个打印申请表，将这个申请表放入打印输出队列中（这个队列在输出井中）。然后由输出进程从打印队列中取打印申请表，根据表格内容将用户数据从磁盘中取出放入内存输出缓冲区，然后再输出到 I/O 设备中。输出进程会不断的查看打印输出队列，直到队列为空，则输出进程被阻塞。</p><p>即对于进程来说，看起来都已经输出或者输入了，实际上看还没有响应，有延迟，物理上共用1个设备。逻辑上是2个设备</p><hr><h2><span id="q-jiang-yi-xia-zu-sai-he-fei-zu-sai-de-qu-bie-zhu-yi-mei-you-xi-dai-io-dui-ying-de-shi-guang-yi-de-fang-fa-diao-yong-shi-de-zu-sai-he-fei-zu-sai">Q: 讲一下阻塞和非阻塞的区别？（注意没有携带IO，对应的是广义的方法调用时的阻塞和非阻塞）</span><a href="#q-jiang-yi-xia-zu-sai-he-fei-zu-sai-de-qu-bie-zhu-yi-mei-you-xi-dai-io-dui-ying-de-shi-guang-yi-de-fang-fa-diao-yong-shi-de-zu-sai-he-fei-zu-sai" class="header-anchor">#</a></h2><p>A:<br>阻塞，对应的是执行线程会被挂起，线程时间片暂停执行，有结果了才返回。<br>非阻塞，线程不会挂起，而是直接返回结果或者异常，让线程调用者自己确认是否完成了读取，因此线程不会挂起。</p><p>阻塞和非阻塞的区别就在于：是否需要线程自己轮询检查</p><hr><h2><span id="q-tong-bu-he-yi-bu-de-qu-bie-zhu-yi-mei-you-xi-dai-io-dui-ying-de-shi-guang-yi-de-fang-fa-diao-yong-shi-de-tong-bu-he-yi-bu">Q: 同步和异步的区别？（注意没有携带IO，对应的是广义的方法调用时的同步和异步）</span><a href="#q-tong-bu-he-yi-bu-de-qu-bie-zhu-yi-mei-you-xi-dai-io-dui-ying-de-shi-guang-yi-de-fang-fa-diao-yong-shi-de-tong-bu-he-yi-bu" class="header-anchor">#</a></h2><p>A:<br>同步， 调用Io方法时， 必须等结果返回，这个方法才会结束。<br>异步， 调用io方法时， 不需要等结果。 由接收方进行异步的通知或者发请求，因此线程可以作别的事情了。（与非阻塞IO不同）</p><p>同步和异步的区别就在于：是否通过回调函数进行通知确认结果。<br>综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。</p><hr><h2><span id="q-jiang-yi-xia-wu-chong-io-mo-xing">Q: 讲一下五种IO模型</span><a href="#q-jiang-yi-xia-wu-chong-io-mo-xing" class="header-anchor">#</a></h2><p>A:</p><ol><li>阻塞I/O（blocking I/O）<br>调用recv()系统函数，阻塞挂起线程</li><li>非阻塞I/O （nonblocking I/O）<br>socket才支持，设置非阻塞时， recv是返回错误， 线程不断轮询</li><li>I/O复用(select 和poll) （I/O multiplexing）<br>本质上是阻塞IO，关键在于可以监听多个端口上的读或写事件，直到有数据可读或可写时，才真正调用I/O操作函数</li><li>信号驱动I/O （signal driven I/O (SIGIO)）<br>需要绑定一个信号驱动。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据</li><li>异步I/O （asynchronous I/O (the POSIX aio_functions)）<br>当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。<br>需要服务调用方实现通知或者回调机制。<br><img src="5051b94487d8d983aa28ebebf6d526af951739fb.png" alt="5051b94487d8d983aa28ebebf6d526af951739fb"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统内存原理</title>
      <link href="/2022/09/08/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/08/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#6-1-nei-cun-guan-li-de-gai-nian">6.1 内存管理的概念</a></li><li><a href="#6-2-nei-cun-fang-yi-chu-ji-zhi">6.2 内存防溢出机制</a></li><li><a href="#6-3-nei-cun-fen-pei-ji-zhi">6.3 内存分配机制</a><ul><li><a href="#6-3-1-lian-xu-fen-pei-nei-cun">6.3.1 连续分配内存</a></li><li><a href="#6-3-1-1-dan-yi-lian-xu">6.3.1.1 单一连续：</a></li><li><a href="#6-3-1-2-gu-ding-fen-qu-fen-pei">6.3.1.2 固定分区分配</a></li><li><a href="#6-3-1-3-dong-tai-fen-qu-fen-pei">6.3.1.3 动态分区分配</a></li><li><a href="#6-3-2-fei-lian-xu-nei-cun-fen-pei">6.3.2 非连续内存分配</a><ul><li><a href="#6-3-2-1-fen-ye">6.3.2.1 分页</a></li><li><a href="#6-3-2-2-fen-duan">6.3.2.2 分段</a></li><li><a href="#6-3-2-3-duan-ye-jie-he">6.3.2.3 段页结合</a></li></ul></li></ul></li><li><a href="#6-4-xu-ni-nei-cun">6.4 虚拟内存</a><ul><li><a href="#6-4-1-gai-nian">6.4.1 概念</a></li><li><a href="#6-4-2-qing-qiu-fen-ye-ji-zhi">6.4.2 请求分页机制</a></li><li><a href="#6-4-3-gong-zuo-ji-gai-nian">6.4.3 工作集概念</a></li><li><a href="#6-4-4-ye-mian-zhi-huan-suan-fa">6.4.4 页面置换算法</a></li><li><a href="#6-4-5-ye-mian-fen-pei-liang-ce-lue">6.4.5 页面分配量策略</a></li></ul></li><li><a href="#6-5-linux-zhong-de-nei-cun-ji-zhi">6.5 linux中的内存机制</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="6-1-nei-cun-guan-li-de-gai-nian">6.1 内存管理的概念</span><a href="#6-1-nei-cun-guan-li-de-gai-nian" class="header-anchor">#</a></h1><ul><li><p>内存管理指操作系统对内存的划分和动态分配</p></li><li><p>地址空间：<br>逻辑地址空间： 相对地址， 从0开始编址<br>物理地址空间：  地址转换的最终地址</p></li></ul><p>程序运行时和<br>编译： 吧源代码编译成目标模块<br>链接： 吧目标模块、库函数链接成1个装入模块<br>链接属于形成进程逻辑地址的过程</p><p>装入：<br>绝对装入： 编译时就确定了装入地址<br>可重定位装入：  根据内存情况， 把程序装到适当位置<br>运行时动态装入：运行前才真正把程序装起来（前面2个都是先分配，再装，再运行）</p><h1><span id="6-2-nei-cun-fang-yi-chu-ji-zhi">6.2 内存防溢出机制</span><a href="#6-2-nei-cun-fang-yi-chu-ji-zhi" class="header-anchor">#</a></h1><p>即怎么防止内存越界</p><ul><li>设置上下限寄存器：<br>存放内存中该进程的 上下限地址<br>每次访问时，判断是否越界</li></ul><p>重定位+界地址：<br>重定位寄存器——存放物理地址的最小地址<br>界地址寄存器——存放逻辑地址的最大值</p><p>先把访问地址（相对地址） 与界地址比较是否越界<br>再加到重定位寄存器上，作为物理地址</p><p>min + x，  且x &lt;max， 这样保证地址在min到min+max之内</p><h1><span id="6-3-nei-cun-fen-pei-ji-zhi">6.3 内存分配机制</span><a href="#6-3-nei-cun-fen-pei-ji-zhi" class="header-anchor">#</a></h1><h2><span id="6-3-1-lian-xu-fen-pei-nei-cun">6.3.1 连续分配内存</span><a href="#6-3-1-lian-xu-fen-pei-nei-cun" class="header-anchor">#</a></h2><p>连续分配指 为用户程序分配的内存空间一定是连续的</p><h2><span id="6-3-1-1-dan-yi-lian-xu">6.3.1.1 单一连续：</span><a href="#6-3-1-1-dan-yi-lian-xu" class="header-anchor">#</a></h2><p>内存分为系统区和用户区2个区<br>每次用户区只能放1个程序， 这样可确保不会越界</p><h2><span id="6-3-1-2-gu-ding-fen-qu-fen-pei">6.3.1.2 固定分区分配</span><a href="#6-3-1-2-gu-ding-fen-qu-fen-pei" class="header-anchor">#</a></h2><p>用户区分成若干个大小的分区， 每个分区只能装一个作业。<br>程序如果大了会装不下<br>程序小了则有内存碎片</p><h2><span id="6-3-1-3-dong-tai-fen-qu-fen-pei">6.3.1.3 动态分区分配</span><a href="#6-3-1-3-dong-tai-fen-qu-fen-pei" class="header-anchor">#</a></h2><p>程序装入内存时，按照所需大小动态生成1个分区。 有多少碎片空间就给多少</p><p>可能会存在碎片， 比如中间的进程结束了， 于是中间就空出来一个内存碎片，而可能因为太小，其他进程帆布进来。</p><p>动态分配策略：</p><ul><li>首次适应： 从上往下找第一个满足的分区——最简单也最好</li><li>最佳适应： 找一个大小差距最小的分区——最烂，碎片最多</li><li>最坏适应： 直接找最大的分区转入</li><li>邻近适应： 从上次查找位置开始找，而不是从第一个碎片位置开始找。——末尾碎片会很多</li></ul><h2><span id="6-3-2-fei-lian-xu-nei-cun-fen-pei">6.3.2 非连续内存分配</span><a href="#6-3-2-fei-lian-xu-nei-cun-fen-pei" class="header-anchor">#</a></h2><p>非连续指进程内存可以 分成不同地址存放，不一定全部集中在一起。</p><h3><span id="6-3-2-1-fen-ye">6.3.2.1 分页</span><a href="#6-3-2-1-fen-ye" class="header-anchor">#</a></h3><p>把内存划分成固定大小的块， 进程以块为单位申请多个不同位置的块作为空间。</p><ul><li>页表：<br>每个进程PCB中会有一个页面寄存器PRT， 告知页表的起始位置和起始长度<br>找到页表后， 页面中会告知你所持有的页号和偏移。<br>通过   页号 * 块大小 + 偏移， 可知道这段内存的起始位置。</li></ul><p>进程每次想通过虚拟地址去定位物理地址时，都需要先去页表中找到虚拟地址对应的页，然后再得到物理地址。</p><ul><li><p>快表TBL（Translation Lookaside Buffer )）：<br>为了避免每次斗取页表换算地址， 快表会缓存  虚拟地址-&gt;物理地址的直接映射，加快速度<br><img src="/images/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/20210314234723510.png" alt="在这里插入图片描述"></p></li><li><p>多级页表<br>地址空间超级大， 1页装不下怎么办？<br>用多级<br>一级页表指明二级页表的地址<br>二级页表再去实际地址<br>这样就可以有多页了。<br><img src="/images/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/20210314234804903.png" alt="在这里插入图片描述"></p></li></ul><p><img src="/images/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/20210314234756201.png" alt="在这里插入图片描述"></p><h3><span id="6-3-2-2-fen-duan">6.3.2.2 分段</span><a href="#6-3-2-2-fen-duan" class="header-anchor">#</a></h3><p>分页的话， 页的长度时固定的，  所以偏移量的最大值是固定的</p><p>分段的话不限制偏移量最大值，即可以很长一段。</p><p>分段属于二维地址空间， 因为他除了给出逻辑地址，还得给出段长</p><p>有利于做动态链接： 程序动态修改<br><img src="/images/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/2021031423500574.png" alt="在这里插入图片描述"></p><h3><span id="6-3-2-3-duan-ye-jie-he">6.3.2.3 段页结合</span><a href="#6-3-2-3-duan-ye-jie-he" class="header-anchor">#</a></h3><p>作业先分成若干段， 再把段分页， 每个段可以找到一个也变</p><p>段号S 页号P  页内偏移<br><img src="/images/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/20210314235043680.png" alt="在这里插入图片描述"></p><hr><p>Q: 遍历二维数组的时候, 行遍历优先和列遍历优先的效率差别, 为什么会这样</p><p>A: 按行遍历比按列遍历的效率高体现在这些方面：</p><ol><li>CPU高速缓存</li><li>CPU缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。随着数组元素越来越多，按列读取速度也会越来越慢。</li></ol><h1><span id="6-4-xu-ni-nei-cun">6.4 虚拟内存</span><a href="#6-4-xu-ni-nei-cun" class="header-anchor">#</a></h1><h2><span id="6-4-1-gai-nian">6.4.1 概念</span><a href="#6-4-1-gai-nian" class="header-anchor">#</a></h2><p>虚拟地址可以让进程获得比实际内存要大的内存<br>特征：</p><ul><li>多次性——作业可分多次装入内存</li><li>对换性——可在运行时对内存做兑换处理</li><li>虚拟性——逻辑上可充分扩充容量</li></ul><p>要求：<br>必须使用非连续分配方式——分页、分段、段页<br>硬件需要支持  页表、中断、地址变换机构</p><p>理论依据：<br>时间局部性—— 指令和数据总是会在一段时间内被连续访问<br>空间局部性——某单元被访问，那么他附件的单元也很大概率会被访问</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/20210314235146459.png" alt="在这里插入图片描述"></p><h2><span id="6-4-2-qing-qiu-fen-ye-ji-zhi">6.4.2 请求分页机制</span><a href="#6-4-2-qing-qiu-fen-ye-ji-zhi" class="header-anchor">#</a></h2><p>再分页的基础上， 增加了2个功能：<br>请求调页——当页面不在内存中时，从外村申请调入<br>页面置换——把暂时不用的内存换出去，给其他需要进来的页腾出空间</p><p>页表项：<br>页号、物理块号<br>状态位P：是否已经调入内存<br>访问字段A： 记录访问次数或者访问标记，用于置换策略判断<br>修改维 M： 记录是否被修改过<br>外村地址——当页被换出去时，指明这个页在外存的何处</p><p>缺页中断机构： 当页面不存在时， 负责产生缺页中断，进行页面置换操作。</p><p>缺页只能高端和系统中断不同， 属于指令中的操作，在执行期产生多次</p><p>地址变换机构：<br>1.先检索快表，如果能找到，则直接修改页表项的访问位。<br>2.快表中没有，则去 再检索内存中的页表，通过状态为P确认是否在内存中<br>如果不在，则产生缺页中断。</p><h2><span id="6-4-3-gong-zuo-ji-gai-nian">6.4.3 工作集概念</span><a href="#6-4-3-gong-zuo-ji-gai-nian" class="header-anchor">#</a></h2><p>驻留集：指系统给每个进程分配的内存中实际页面集合<br>但是可能分配了10个， 却只有5个经常在用</p><p>工作集： 某时间段内，这个进程访问和使用的页面集合</p><p>通过工作集， 系统可以评估这个驻留集是否需要做删减，以及哪些页应该持续保留。<br>这样可以减少抖动，即减少内外村之间频繁的交换页</p><h2><span id="6-4-4-ye-mian-zhi-huan-suan-fa">6.4.4 页面置换算法</span><a href="#6-4-4-ye-mian-zhi-huan-suan-fa" class="header-anchor">#</a></h2><ul><li>最佳置换算法：<br>选未来最长时间不会被用到的页<br>这个要基于预测，比较难</li><li>先进先出FIFO<br>可能引发bleady异常：</li></ul><blockquote><blockquote><p>较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p></blockquote></blockquote><ul><li>最近最久未使用（LRU）<br>选之前最长时间没访问的，  引入优先队列（最大堆）<br>需要设置访问时间字段</li><li>简单时钟clock（最近未使用NRU）<br>每个页有个标记。<br>刚换入内存或者被访问时，都会置1</li></ul><p>如果需要换页时，步骤如下：</p><ol><li>扫描围成换的页链表</li><li>如果标记为1，则改成0，继续往下扫</li><li>如果位0， 则替换，并让指针指向下一页。</li></ol><ul><li>改进的clock<br>把标记为改成   访问位u和修改维m</li><li>1类(A =0, M = 0)：表示该页面最近既未被访问，又未被修改，是最佳淘汰页。</li><li>2类(A =0, M = 1)：表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。</li><li>3类(A =1, M = 0)：表示该页面最近已被访问，但未被修改，该页有可能再被访问。</li><li>4类(A =1, M = 1)：表示该页最近已被访问且被修改，该页可能再被访问。</li></ul><ol><li>先优先找u=0和m=0的页，有就直接替换</li><li>没有，则找 u = 0 且m=1的页（ 没访问的最优先替换）， 做替换</li><li>如果中间遇到U=1的， 则都会置0，  如果m=1的也会置0</li><li>如果一圈都没有，则下一圈肯定有01或者00的。</li></ol><h2><span id="6-4-5-ye-mian-fen-pei-liang-ce-lue">6.4.5 页面分配量策略</span><a href="#6-4-5-ye-mian-fen-pei-liang-ce-lue" class="header-anchor">#</a></h2><ul><li>固定分配，局部替换<br>每个进程分配固定的物理块，  且只能自己的块之间做替换</li><li>可变分配，全局替换<br>缺页时，可以从全局队列的页替换</li><li>可变分配，局部置换<br>自己替换自己，但是不够的时候可以加块</li></ul><p>分配来源：<br>对换区：频繁切换的区<br>文件区：补怎么会变动和修改的</p><h1><span id="6-5-linux-zhong-de-nei-cun-ji-zhi">6.5 linux中的内存机制</span><a href="#6-5-linux-zhong-de-nei-cun-ji-zhi" class="header-anchor">#</a></h1>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度</title>
      <link href="/2022/09/08/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2022/09/08/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#4-1-diao-du-de-gai-nian">4.1 调度的概念</a><ul><li><a href="#4-1-1-san-ji-diao-du">4.1.1 三级调度</a></li><li><a href="#4-1-2-chang-jian-diao-du-fang-shi">4.1.2 常见调度方式</a></li><li><a href="#4-1-3-diao-du-xi-tong-she-ji-de-ping-jie-zhun-ze">4.1.3 调度系统设计的评价准则</a></li></ul></li><li><a href="#4-2-jin-cheng-diao-du-suan-fa">4.2 进程调度算法</a><ul><li><a href="#4-2-1-fcfs-xian-lai-xian-fu-wu">4.2.1 FCFS先来先服务</a></li><li><a href="#4-2-2-duan-zuo-ye-you-xian">4.2.2 短作业优先</a></li><li><a href="#4-2-3-you-xian-ji-diao-du-suan-fa">4.2.3 优先级调度算法</a></li><li><a href="#4-2-4-gao-xiang-ying-bi-you-xian">4.2.4 高相应比优先</a></li><li><a href="#4-2-5-shi-jian-pian-lun-zhuan">4.2.5 时间片轮转</a></li><li><a href="#4-2-6-duo-ji-fan-kui-dui-lie-diao-du-suan-fa">4.2.6 多级反馈队列调度算法</a></li><li><a href="#4-2-7-linux-he-windows-zhong-de-diao-du-suan-fa">4.2.7 linux和windows中的调度算法</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="4-1-diao-du-de-gai-nian">4.1 调度的概念</span><a href="#4-1-diao-du-de-gai-nian" class="header-anchor">#</a></h1><p>从就绪队列中选一个进程分配给处理机<br>处理机调度是操作系统进行多道程序运行的核心</p><h2><span id="4-1-1-san-ji-diao-du">4.1.1  三级调度</span><a href="#4-1-1-san-ji-diao-du" class="header-anchor">#</a></h2><p>操作系统中有三种调度：</p><ul><li>作业调度（外存到内存）<br>属于一种高级调度<br>从外存队列中选一批作业进入内存进行执行。<br>可以理解为有人一次性执行了10000个脚本，这时候的脚本作业是有调度机制的，没法一次性全部加载到内存中执行。</li><li>内存调度（外存-&gt;内存）<br>就是决定将哪个挂起状态的进程从外存重新调回内存。 但是此时还没开始跑任务，只是从外存切换到内存就绪队列</li><li>进程调度（内存-&gt;CPU)<br>从内存就绪队列中选择进程， 进行执行。</li></ul><p>分别是从高级到低级， 频率从低到高</p><h2><span id="4-1-2-chang-jian-diao-du-fang-shi">4.1.2 常见调度方式</span><a href="#4-1-2-chang-jian-diao-du-fang-shi" class="header-anchor">#</a></h2><p>剥夺式调度： 按优先级、短时间、时间片进行抢占式调度，会强制暂停某些进程<br>非剥夺调度： 当某个进程完成，或者出现阻塞，才会重新分配CPU。 不可用于分时和实时系统。</p><p>linux属于剥夺还是费伯多？</p><h2><span id="4-1-3-diao-du-xi-tong-she-ji-de-ping-jie-zhun-ze">4.1.3 调度系统设计的评价准则</span><a href="#4-1-3-diao-du-xi-tong-she-ji-de-ping-jie-zhun-ze" class="header-anchor">#</a></h2><p>CPU利用率： CPU运行时间/ 空闲时间加运行时间<br>系统吞吐量： 单位时间内完成的作业数量<br>周转时间： 从提交到作业完成的时间， 包括了等待\IO等<br>等待时间： 在就绪队列中等待的时间之和<br>响应时间： 从提交请求到系统首次擦还是你哼响应的时间。</p><h1><span id="4-2-jin-cheng-diao-du-suan-fa">4.2 进程调度算法</span><a href="#4-2-jin-cheng-diao-du-suan-fa" class="header-anchor">#</a></h1><h2><span id="4-2-1-fcfs-xian-lai-xian-fu-wu">4.2.1 FCFS先来先服务</span><a href="#4-2-1-fcfs-xian-lai-xian-fu-wu" class="header-anchor">#</a></h2><ul><li>不可抢占式</li><li>用于作业调度和进程调度</li><li>有利于CPU繁忙作业，即基本都在高强度计算，不会有IO操作等。这时候一般不允许抢占。</li></ul><h2><span id="4-2-2-duan-zuo-ye-you-xian">4.2.2 短作业优先</span><a href="#4-2-2-duan-zuo-ye-you-xian" class="header-anchor">#</a></h2><ul><li>从优先就绪队列中选择 预估运行时间最短的作业</li><li>可能导致长作业的饥饿</li><li>但是能让  平均等待时间最短， 但一般不考虑这个</li></ul><h2><span id="4-2-3-you-xian-ji-diao-du-suan-fa">4.2.3 优先级调度算法</span><a href="#4-2-3-you-xian-ji-diao-du-suan-fa" class="header-anchor">#</a></h2><ul><li>选择优先级最高的作业运行</li><li>有2种优先级判断方式：<ol><li>静态优先：进程创建时已经决定了优先级</li><li>动态优先: 根据CPU占有时间、等待时间，判断他是否属于IO繁忙，并调整优先级</li></ol></li></ul><h2><span id="4-2-4-gao-xiang-ying-bi-you-xian">4.2.4 高相应比优先</span><a href="#4-2-4-gao-xiang-ying-bi-you-xian" class="header-anchor">#</a></h2><ul><li>相应比=  （等待时间+ 估计运行时间） / 估计运行时间<br>这样等待的越久，就越有可能出队，避免4.2.2中的长作业饥饿</li></ul><h2><span id="4-2-5-shi-jian-pian-lun-zhuan">4.2.5 时间片轮转</span><a href="#4-2-5-shi-jian-pian-lun-zhuan" class="header-anchor">#</a></h2><ul><li>时间片用完，立刻切换到下一个进程</li><li>时间片的长短，取决于系统的处理能力、队列中的进程数量、系统响应时间</li></ul><h2><span id="4-2-6-duo-ji-fan-kui-dui-lie-diao-du-suan-fa">4.2.6 多级反馈队列调度算法</span><a href="#4-2-6-duo-ji-fan-kui-dui-lie-diao-du-suan-fa" class="header-anchor">#</a></h2><ul><li>设置多个不同优先级的队列。</li><li>队列优先级越高， 运行的时间片就越小</li><li>每当有一个作业跑完1次时间片，就放到下一级队列（相当于降低优先级）</li><li>当新进程进入，默认放入高优先级队列。对于短作业而言可以立刻响应，而他如果是长作业，则会逐步降低优先级。</li><li>相当于结合了短作业优先、 优先级调度、 时间片3个算法的优势</li></ul><h2><span id="4-2-7-linux-he-windows-zhong-de-diao-du-suan-fa">4.2.7 linux和windows中的调度算法</span><a href="#4-2-7-linux-he-windows-zhong-de-diao-du-suan-fa" class="header-anchor">#</a></h2><p><a href="http://c.biancheng.net/view/1255.html">linux的调度算法</a></p><p>Linux 标准内核实现两个调度类：采用 CFS 调度算法的默认调度类和实时调度类.</p><p>CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据友好值来计算的。友好值的范围从 -20 到 +19，数值较低的友好值表示较高的相对优先级。具有较低友好值的任务，与具有较高友好值的任务相比，会得到更高比例的处理器处理时间。默认友好值为 0。<br><img src="/images/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/57c9082810a435e9ddcdc689b8698b6b0bb3b3a3.png" alt="57c9082810a435e9ddcdc689b8698b6b0bb3b3a3"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程同步</title>
      <link href="/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#5-1-tong-bu-de-gai-nian">5.1 同步的概念</a></li><li><a href="#5-2-lin-jie-qu-de-hu-chi-shi-xian-yuan-li">5.2 临界区的互斥实现原理</a><ul><li><a href="#5-2-1-ruan-jian-shi-xian-fang-shi">5.2.1 软件实现方式</a></li><li><a href="#5-2-2-ying-jian-fang-shi">5.2.2 硬件方式</a></li></ul></li><li><a href="#5-3-chang-jian-tong-bu-fang-shi">5.3 常见同步方式</a><ul><li><a href="#5-3-1-xin-hao-liang">5.3.1 信号量</a></li><li><a href="#5-3-2-guan-cheng">5.3.2 管程</a></li></ul></li><li><a href="#5-4-tong-bu-jing-dian-li-zi">5.4 同步经典例子</a><ul><li><a href="#5-4-1-sheng-chan-zhe-xiao-fei-zhe-mo-xing">5.4.1 生产者消费者模型</a></li><li><a href="#5-4-2-du-xie-zhe-wen-ti">5.4.2 读写者问题</a></li><li><a href="#5-4-3-zhe-xue-jia-chi-fan-wen-ti">5.4.3 哲学家吃饭问题</a></li><li><a href="#5-4-4-xi-yan-zhe-wen-ti">5.4.4 吸烟者问题</a></li></ul></li><li><a href="#5-5-si-suo">5.5 死锁</a><ul><li><a href="#5-5-1-yuan-yin">5.5.1 原因</a></li><li><a href="#5-5-2-si-suo-de-4-ge-tiao-jian-he-yu-fang">5.5.2 死锁的4个条件和预防</a></li><li><a href="#5-5-3-si-suo-jian-ce-he-jie-chu">5.5.3 死锁检测和解除</a></li><li><a href="#5-5-4-si-suo-bi-mian-suan-fa">5.5.4 死锁避免算法</a><ul><li><a href="#5-5-4-1-xi-tong-an-quan-zhuang-tai-shi-me-shi-hou-xi-tong-shi-an-quan-de">5.5.4.1 系统安全状态（什么时候系统是安全的）：</a></li><li><a href="#5-5-4-2-yin-xing-jia-suan-fa">5.5.4.2 银行家算法</a></li></ul></li></ul></li><li><a href="#5-5-jin-cheng-xian-cheng-tong-bu-de-qu-bie">5.5 进程、线程同步的区别</a></li><li><a href="#5-6-linux-yan-shen">5.6 linux延申</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="5-1-tong-bu-de-gai-nian">5.1 同步的概念</span><a href="#5-1-tong-bu-de-gai-nian" class="header-anchor">#</a></h1><p>不同进程之间需要相互制约，或者存在先后顺序，就会用到同步。</p><ul><li>临界资源： 1次只允许1个进程使用<br>临界资源访问过程分为四步：</li></ul><ol><li>进入区： 检查和设置临界区标识</li><li>临界区： 访问和使用资源</li><li>退出区： 清楚临界区标志</li><li>剩余区：？</li></ol><ul><li><p>同步： 也称作直接制约关系<br>为完成某个任务，多个进程需要协调工作次序并等待，即这个制约关系应该是意料之中出现的。</p></li><li><p>互斥： 间接制约关系<br>因临界资源冲突而引发访问和等待，即不是他想要的制约关系。</p></li><li><p>同步机制准则：<br>空闲让进：  资源空闲的时候允许进入<br>忙则等待： 临界区被占用，其他等待<br>有限等待： 不能一直等待，出现出现饥饿<br>让权等待： 无法进入临界区时，要放弃CPU挂起一段时间，避免一直占用CPU</p></li></ul><h1><span id="5-2-lin-jie-qu-de-hu-chi-shi-xian-yuan-li">5.2 临界区的互斥实现原理</span><a href="#5-2-lin-jie-qu-de-hu-chi-shi-xian-yuan-li" class="header-anchor">#</a></h1><h2><span id="5-2-1-ruan-jian-shi-xian-fang-shi">5.2.1 软件实现方式</span><a href="#5-2-1-ruan-jian-shi-xian-fang-shi" class="header-anchor">#</a></h2><ul><li>单标志法：就是在临界区前后判断turn标志确认临界区谁可进， 当从临界区粗来，再修改临界区标志为另一个进程可进。</li><li>双标志法先检查： flag[i]标识低i个进程是否在临界区。 每次检查flag确认是否能进<br>可能检查时两个人都通过了，就出错。<br>属于先查，后改</li><li>双标志法后检查：<br>即先改后查，可能2个人同时改，引发饥饿</li><li>peterson法：<br>turn和flag[]一起用。<br>用turn判断谁可以先进。这样避免2个人同时改。</li></ul><h2><span id="5-2-2-ying-jian-fang-shi">5.2.2 硬件方式</span><a href="#5-2-2-ying-jian-fang-shi" class="header-anchor">#</a></h2><ul><li>中断屏蔽——禁止一切中断发生？？？ 这啥意思</li><li>硬件指令<br>TestAndSet  原子操作，  读取lock并修改lock为true<br>swap： 原子交换命令， 交换2个字节内容。</li></ul><h1><span id="5-3-chang-jian-tong-bu-fang-shi">5.3 常见同步方式</span><a href="#5-3-chang-jian-tong-bu-fang-shi" class="header-anchor">#</a></h1><h2><span id="5-3-1-xin-hao-liang">5.3.1 信号量</span><a href="#5-3-1-xin-hao-liang" class="header-anchor">#</a></h2><p>共享资源数目有限时一般使用信号量。</p><ul><li><p>P操作——wait  申请和获取资源<br>先减去信号量，再判断， 如果信号量&lt;0，则进程加入阻塞队列</p></li><li><p>V操作——signal   释放资源<br>每次操作时，直接增加信号量<br>此时说明已经有人空闲了一个资源了。<br>当发现信号量此时&lt;=0， 则从阻塞队列里选一个出队</p></li></ul><h2><span id="5-3-2-guan-cheng">5.3.2 管程</span><a href="#5-3-2-guan-cheng" class="header-anchor">#</a></h2><p>在内存中而非外村中<br>是一个共享数据结构</p><p>1次只允许1个进管道<br>可以理解为信号量变成了  只有1的管道<br>为满时，不可写<br>为空时，不可读</p><p>管程和信号量的区别：<br>1、信号量可以并发，并发量是取决于s的初始值，而管程则是在任意时刻都是只能有一个。</p><p>2、信号量的P操作在操作之前不知道是否会被阻塞，而管程的wait操作则是一定会被阻塞。</p><p>3、管程的进程如果执行csignal后，但是没有在这个条件变量上等待的任务的话，则丢弃这个信号。进程在发出信号后会将自己置于紧急队列之中，因为他已经执行了部分代码，所以应该优先于入口队列中的新进入的进程执行。</p><p>4、当前进程对一个信号量加1后，会唤醒另一个进程，被唤醒进程程与当前进程并发执行</p><h1><span id="5-4-tong-bu-jing-dian-li-zi">5.4 同步经典例子</span><a href="#5-4-tong-bu-jing-dian-li-zi" class="header-anchor">#</a></h1><h2><span id="5-4-1-sheng-chan-zhe-xiao-fei-zhe-mo-xing">5.4.1 生产者消费者模型</span><a href="#5-4-1-sheng-chan-zhe-xiao-fei-zhe-mo-xing" class="header-anchor">#</a></h2><p>简单的信号量模型</p><h2><span id="5-4-2-du-xie-zhe-wen-ti">5.4.2 读写者问题</span><a href="#5-4-2-du-xie-zhe-wen-ti" class="header-anchor">#</a></h2><p>读可以并发读<br>写的话，必须等读的人都结束了才能写。</p><h2><span id="5-4-3-zhe-xue-jia-chi-fan-wen-ti">5.4.3 哲学家吃饭问题</span><a href="#5-4-3-zhe-xue-jia-chi-fan-wen-ti" class="header-anchor">#</a></h2><p>每个人都先拿自己最左边的筷子，就会吃不上饭</p><p>1次拿2双即可，而不是先拿左手，再拿右手。</p><h2><span id="5-4-4-xi-yan-zhe-wen-ti">5.4.4 吸烟者问题</span><a href="#5-4-4-xi-yan-zhe-wen-ti" class="header-anchor">#</a></h2><p>3种原材料的供应问题<br>每个人只有1种材料。<br>但是吸烟要3种材料。<br>供应者用完了再上新的<br>于是吸烟者每次要直接拿2个，而不能1次只拿1个。</p><h1><span id="5-5-si-suo">5.5 死锁</span><a href="#5-5-si-suo" class="header-anchor">#</a></h1><h2><span id="5-5-1-yuan-yin">5.5.1 原因</span><a href="#5-5-1-yuan-yin" class="header-anchor">#</a></h2><ul><li>进程请求资源的顺序不对， 出现交叉申请的情况</li><li>共同竞争不可剥夺资源</li></ul><h2><span id="5-5-2-si-suo-de-4-ge-tiao-jian-he-yu-fang">5.5.2 死锁的4个条件和预防</span><a href="#5-5-2-si-suo-de-4-ge-tiao-jian-he-yu-fang" class="header-anchor">#</a></h2><ol><li>互斥——1个资源只能1个进程使用</li><li>不可剥夺——不允许主动抢占，必须等对方释放了才能用。</li><li>请求和保持——<br>请求：自己占用资源的情况下，还可以继续请求其他资源。<br>保持： 被阻塞的情况下， 自己持有的资源仍然不会释放</li><li>循环等待： 出现循环等待链</li></ol><p>根据上面4个条件，可以给出4个预防措施</p><ol><li>破坏互斥——让资源可共享使用——无法实现</li><li>破坏不可剥夺—— 当请求不成功时，会释放自己的资源给别人使用（这样确认不会有人卡着，要么是有人正在全力计算，要么就是阻塞后直接释放，下次再请求）—— 可能引发反复申请，开销大</li><li>破坏请求和保持—— 一次性申请全部资源，不会申请到一半的情况（资源浪费，比如有时候确实得先用一半，接着再用另一半）</li><li>破坏循环等待—— 请求资源时，按照顺序请求资源，给资源编号按优先级申请。——太麻烦</li></ol><h2><span id="5-5-3-si-suo-jian-ce-he-jie-chu">5.5.3 死锁检测和解除</span><a href="#5-5-3-si-suo-jian-ce-he-jie-chu" class="header-anchor">#</a></h2><p>该方法不会影响资源分配。 只会定时地去检测，然后看是否解除某些死锁</p><p>以进程和资源构建一张DAG图<br><img src="https://img-blog.csdnimg.cn/2021031423422596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3OTk1ODEyMjk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>死锁检测定理：</li></ul><ol><li>找到申请资源充足的进程，消去该进程的所有边</li><li>继续消除，如果边被全部消完，说明无死锁。如果无法消除完，则存在死锁</li></ol><ul><li>死锁接触：<br>资源剥夺——把死锁进程暂时挂起， 以释放资源，等ok后再放回来。<br>撤销进程法——按优先级，强制kill一些进程<br>进程回退法—— 把请求资源的操作回退，直到回退到不会发生死锁的DAG</li></ul><h2><span id="5-5-4-si-suo-bi-mian-suan-fa">5.5.4 死锁避免算法</span><a href="#5-5-4-si-suo-bi-mian-suan-fa" class="header-anchor">#</a></h2><p>这个算法会影响分配过程，即在资源分配前判断以下。</p><h3><span id="5-5-4-1-xi-tong-an-quan-zhuang-tai-shi-me-shi-hou-xi-tong-shi-an-quan-de">5.5.4.1 系统安全状态（什么时候系统是安全的）：</span><a href="#5-5-4-1-xi-tong-an-quan-zhuang-tai-shi-me-shi-hou-xi-tong-shi-an-quan-de" class="header-anchor">#</a></h3><ol><li>存在一个安全序列P1\P2\P3， 理解为3个进程，并给出3个进程此时所需的资源</li><li>先把剩余资源都给P1，然后P1用完后再给P2， P2用完再给P3</li><li>按这个顺序下来都没发生资源不够的情况的花，则认为至少是安全的（即至少可通过顺序给资源保证顺利完成剩余任务）</li></ol><h3><span id="5-5-4-2-yin-xing-jia-suan-fa">5.5.4.2 银行家算法</span><a href="#5-5-4-2-yin-xing-jia-suan-fa" class="header-anchor">#</a></h3><p>假设进程数量有n个<br>假设资源有r种</p><p>定义以下数组<br>各资源当前可用数量 Avaialbe[r]<br>各进程最大需求 max[n][r]<br>各进程当前已占资源 allocation[n][r]<br>各进程还需要的资源量  need[n][r]<br>此时的某进程i对各资源的请求量 request[r]</p><p>银行家算法描述：</p><ol><li>request必须小于等于need，否则request有错误（即你肯定不能要得过多，都超出需求了）</li><li>检查request是否比avali大，如果过大，则资源不足</li><li>如果1和2都检验通过， 则分配资源，修改avalible、allocation、need</li><li>执行安全性算法，  判断按照最优情况给资源时，是否会出现资源不足<br>5.若分配不会导致系统进入不安全状态，则分配，否则等待一段时间，再判断</li></ol><p>安全性算法描述：<br>按顺序，每次把进程剩余need的资源都占去，并剪掉avalid， 看下遍历完是否会出现不够用的情况</p><h1><span id="5-5-jin-cheng-xian-cheng-tong-bu-de-qu-bie">5.5 进程、线程同步的区别</span><a href="#5-5-jin-cheng-xian-cheng-tong-bu-de-qu-bie" class="header-anchor">#</a></h1><p>这个 同步 的概念都是一致的. 不论是进程还是线程.<br>不同在于所采用的同步方式, 进程的同步方式是线程的同步方式的子集. 换句话说, 进程之间的同步方式会比线程之间同步方式选择小. 就这样而已.</p><p>线程通信一般是指同一进程内的线程进行通讯，由于在同一进程内，共享地址空间，因此交互比较容易，全局变量之类的都能起到作用。</p><p>进程通信一般是指不同进程间的线程进行通讯，由于地址空间不同，因此需要使用操作系统相关机制进行“中转”，比如共享文件、管道、SOCKET。</p><h1><span id="5-6-linux-yan-shen">5.6 linux延申</span><a href="#5-6-linux-yan-shen" class="header-anchor">#</a></h1><p><a href="https://www.cnblogs.com/arnoldlu/p/8580387.html">linux的死锁检测、避免机制Lockdep</a><br><a href="http://kernel.meizu.com/linux-dead-lock-detect-lockdep.html">http://kernel.meizu.com/linux-dead-lock-detect-lockdep.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程基础概念</title>
      <link href="/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#3-1-gai-nian">3.1 概念</a><ul><li><a href="#3-1-1-mu-de">3.1.1 目的</a></li><li><a href="#3-1-2-zu-cheng">3.1.2 组成</a><ul><li><a href="#3-1-3-shi-xian-fang-shi">3.1.3 实现方式</a></li></ul></li></ul></li><li><a href="#3-2-jin-cheng-he-xian-cheng-de-qu-bie">3.2 进程和线程的区别</a><ul><li><a href="#q-bing-fa-he-bing-xing-you-shi-me-qu-bie-ni">Q: 并发和并行有什么区别呢？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="3-1-gai-nian">3.1 概念</span><a href="#3-1-gai-nian" class="header-anchor">#</a></h1><ul><li>是基本的CPU执行单元</li><li>是程序执行流的最小胆小</li><li>被系统调度和分配的基本单位</li></ul><h2><span id="3-1-1-mu-de">3.1.1 目的</span><a href="#3-1-1-mu-de" class="header-anchor">#</a></h2><ul><li>提高系统性能</li><li>减小程序并发执行时的时空开销</li></ul><h2><span id="3-1-2-zu-cheng">3.1.2 组成</span><a href="#3-1-2-zu-cheng" class="header-anchor">#</a></h2><ul><li>线程id</li><li>程序计数器PC</li><li>寄存器集合</li><li>堆栈</li></ul><h3><span id="3-1-3-shi-xian-fang-shi">3.1.3 实现方式</span><a href="#3-1-3-shi-xian-fang-shi" class="header-anchor">#</a></h3><p>一般会有2种线程：</p><ul><li>用户级线程ULT：  创建发生在用户空间</li><li>系统级线程KLT： 完成系统内所有线程的管理，提供给用户一定的线程管理接口。</li></ul><p>ULT和KLT的映射关系分类（即用户线程能给哪些系统线程管理）：</p><ul><li>多用户线程对应1个系统线程。 即所有线程公用一个线程管理接口<br>这样如果一旦阻塞就全部阻塞</li><li>一对一： 每个用户线程单独使用1个系统线程做管理<br>这样会导致系统线程过多，开销大</li><li>多对多： n个用户线程对应m个内核线程（n&gt;=m)<br>这个比较好</li></ul><p>linux用的是哪种呢？</p><h1><span id="3-2-jin-cheng-he-xian-cheng-de-qu-bie">3.2 进程和线程的区别</span><a href="#3-2-jin-cheng-he-xian-cheng-de-qu-bie" class="header-anchor">#</a></h1><ul><li>从调度上看<br>线程是CPU调度的最小单位<br>进程是拥有资源的基本单位</li><li>切换<br>同一进程内的线程之间切换，不用引起进程切换<br>从a进程的线程跳到b进程的线程，需要引起进程切换</li><li>资源<br>线程只独立拥有一点点小资源（线程栈、共享虚拟地址空间）<br>进程则拥有很多</li><li>通信： 线程可通过读写进程的全局变量来通信，但是进程之间通信则无法依赖变量。</li><li>开销<br>线程的系统/时空开销少</li><li>并发<br>进程和线程都支持并发。<br>是否支持并行要看CPU情况。</li></ul><hr><h2><span id="q-bing-fa-he-bing-xing-you-shi-me-qu-bie-ni">Q: 并发和并行有什么区别呢？</span><a href="#q-bing-fa-he-bing-xing-you-shi-me-qu-bie-ni" class="header-anchor">#</a></h2><p>A:</p><ul><li>并发指 在某一个时间段内跑多个任务， 这些任务可能抢占同一个CPU资源， ”存在交替执行“</li><li>并行指 同一时刻，有多个任务同时在跑，  即分别占用不同的CPU跑任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础概念</title>
      <link href="/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#2-1-gai-nian-he-te-zheng">2.1 概念和特征</a></li><li><a href="#2-2-jin-cheng-zhuang-tai-ji-tu">2.2 进程状态机图</a></li><li><a href="#2-3-jin-cheng-zhuang-tai-bian-hua-shi-de-ju-ti-guo-cheng">2.3 进程状态变化时的具体过程</a><ul><li><a href="#2-3-1-jin-cheng-chuang-jian">2.3.1 进程创建</a></li><li><a href="#2-3-2-jin-cheng-de-zhong-zhi">2.3.2 进程的终止</a></li><li><a href="#2-3-3-jin-cheng-de-zu-sai">2.3.3 进程的阻塞</a></li><li><a href="#2-3-4-jin-cheng-huan-xing">2.3.4 进程唤醒</a></li><li><a href="#2-3-5-jin-cheng-qie-huan">2.3.5 进程切换</a></li></ul></li><li><a href="#2-4-jin-cheng-de-zu-cheng">2.4 进程的组成</a><ul><li><a href="#2-4-1-pcb-jin-cheng-kong-zhi-kuai">2.4.1 PCB进程控制块</a></li></ul></li><li><a href="#2-5-jin-cheng-zhi-jian-de-tong-xin">2.5 进程之间的通信</a></li><li><a href="#2-6-linux-yan-shen">2.6 linux延申</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="2-1-gai-nian-he-te-zheng">2.1 概念和特征</span><a href="#2-1-gai-nian-he-te-zheng" class="header-anchor">#</a></h1><ul><li><p>是资源分配、调度的独立单位</p></li><li><p>进程包含以下内容：</p><ol><li>程序段（代码段）</li><li>数据段（存数据）</li><li>PCB进程控制块（ 进程存在的唯一标志）</li></ol></li><li><p>进程具有动态性，是一个动态的概念。</p></li><li><p>每个进程具有独立的PCB结构， 资源也独立。</p></li></ul><h1><span id="2-2-jin-cheng-zhuang-tai-ji-tu">2.2 进程状态机图</span><a href="#2-2-jin-cheng-zhuang-tai-ji-tu" class="header-anchor">#</a></h1><p><img src="/images/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/20210314234102979.png" alt="在这里插入图片描述"></p><h1><span id="2-3-jin-cheng-zhuang-tai-bian-hua-shi-de-ju-ti-guo-cheng">2.3 进程状态变化时的具体过程</span><a href="#2-3-jin-cheng-zhuang-tai-bian-hua-shi-de-ju-ti-guo-cheng" class="header-anchor">#</a></h1><h2><span id="2-3-1-jin-cheng-chuang-jian">2.3.1 进程创建</span><a href="#2-3-1-jin-cheng-chuang-jian" class="header-anchor">#</a></h2><ul><li>创建过程：</li></ul><ol><li>分配进程；申请PCB</li><li>分配资源</li><li>初始化PCB</li><li>插入到系统的就绪队列</li></ol><ul><li>父进程创建子进程：<br>子进程可以继承父进程的所有资源。<br>父进程退出时，需要杀光子进程。</li></ul><h2><span id="2-3-2-jin-cheng-de-zhong-zhi">2.3.2 进程的终止</span><a href="#2-3-2-jin-cheng-de-zhong-zhi" class="header-anchor">#</a></h2><p>终止有3种触发情况</p><ul><li>正常结束——运行完毕</li><li>异常结束——越界、非法</li><li>外界干预——直接kill进程</li></ul><p>终止的触发过程：</p><ol><li>根据进程标识符，找到PCB控制块，读取进程状态</li><li>如果正常执行，则终止进程。 如果有子进程，则杀死子进程</li><li>归还资源给父进程或者操作系统</li><li>将PCB从系统PCB队列删除</li></ol><h2><span id="2-3-3-jin-cheng-de-zu-sai">2.3.3 进程的阻塞</span><a href="#2-3-3-jin-cheng-de-zu-sai" class="header-anchor">#</a></h2><p>阻塞的过程：</p><ol><li>根据标识符找到PCB</li><li>切换PCB状态为阻塞状态</li><li>把PCB插入到等待队列中</li></ol><h2><span id="2-3-4-jin-cheng-huan-xing">2.3.4 进程唤醒</span><a href="#2-3-4-jin-cheng-huan-xing" class="header-anchor">#</a></h2><p>唤醒的过程：</p><ol><li>根据标识符从等待队列中找到PCB</li><li>移出等待队列，修改运行状态为就绪</li><li>插入到就绪队列</li></ol><h2><span id="2-3-5-jin-cheng-qie-huan">2.3.5 进程切换</span><a href="#2-3-5-jin-cheng-qie-huan" class="header-anchor">#</a></h2><ol><li>保存当前处理器上下文信息，更新PCB并移入队列</li><li>选择另一个进程，更新PCB状态</li><li>更新内存管理</li><li>恢复处理器上下文</li></ol><p>上面可以看到基本是围绕 PCB、等待队列、就绪队列、进程状态更新这4个概念展开的。</p><p>注意调度是一个决策行为， 而切换是一个执行行为， 因此都是先调度，再切换。</p><h1><span id="2-4-jin-cheng-de-zu-cheng">2.4 进程的组成</span><a href="#2-4-jin-cheng-de-zu-cheng" class="header-anchor">#</a></h1><h2><span id="2-4-1-pcb-jin-cheng-kong-zhi-kuai">2.4.1 PCB进程控制块</span><a href="#2-4-1-pcb-jin-cheng-kong-zhi-kuai" class="header-anchor">#</a></h2><p>pcb控制块在进程创建后， 就常驻内存中<br>是进程的唯一标志</p><p>PCB控制块包含以下内容：</p><ul><li>进程描述<br>包括进程标识符 和 用户标识符</li><li>进程控制和管理<br>包括  当前运行状态、 优先级、  入口地址、 外村地址、 进入内存时间、 CPU占用时间、信号量</li><li>资源分配清单<br>包括  3个段指针（代码段、数据段、堆栈段），  文件描述符，   键盘/鼠标资源</li><li>处理器相关信息<br>寄存器值<br>程序状态字</li></ul><p>PCB控制块的组织方式：</p><ul><li>链接方式： 各运行状态都有1个队列， 相关状态PCB都会放在链表队列中（因此可以非顺序取出）。</li><li>索引方式： 建立一个索引表，指向对应pcb， 即用数组去组织</li></ul><h1><span id="2-5-jin-cheng-zhi-jian-de-tong-xin">2.5 进程之间的通信</span><a href="#2-5-jin-cheng-zhi-jian-de-tong-xin" class="header-anchor">#</a></h1><p>进程的通信有3种方式</p><ul><li><p>共享存储方式<br>由操作系统系统存储空间调用方式。<br>注意用户进程的空间是互相独立的，不会互相访问。</p></li><li><p>消息传递<br>直接通信： 发送到对方的消息队列，从消息队列去<br>间接通信： 发信到中间邮箱（非双方进程）， 接收方自己去取。</p></li><li><p>管道通信：<br>管道： 链接读写进程之间的共享文件<br>功能为互斥、同步<br>属于一次性操作， 一旦被读取，数据就被从管道中抛弃<br>半双工， 只有1方能操作，要么存入要么写。<br>如果要实现双方互动，则需要2个管道。</p></li></ul><h1><span id="2-6-linux-yan-shen">2.6 linux延申</span><a href="#2-6-linux-yan-shen" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/cosmoslhf/article/details/41486965">linux进程状态解读</a><br><img src="/images/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/20210314234119864.png" alt="在这里插入图片描述"></p><p><a href="https://www.cnblogs.com/yungyu16/p/13024626.html">linux下的PCB控制块</a><br><img src="/images/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/20210314234141176.png" alt="在这里插入图片描述"></p><p><a href="https://www.baidu.com/link?url=dS4YKcBwUx_-P05HmWh94_240ltWinPQbqk8zOa98itcDcM3G5JQOxDjrsnulDhVxdES9epB3hcNxjKYy7T_va&amp;wd=&amp;eqid=cfc3a9450028d72300000004603bc886">linux中的进程通信方式</a></p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/20210314234155422.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础概念</title>
      <link href="/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/09/07/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-1-yun-xing-zhuang-tai">1.1运行状态</a><ul><li><a href="#1-1-1-yong-hu-tai">1.1.1 用户态</a></li><li><a href="#1-1-2-he-xin-tai">1.1.2 核心态</a></li><li><a href="#q-wei-shi-me-yao-qu-fen-xi-tong-tai-he-yong-hu-tai">Q: 为什么要区分系统态和用户态？</a></li></ul></li><li><a href="#1-2-xi-tong-diao-yong">1.2 系统调用</a></li><li><a href="#1-3-zhong-duan-he-yi-chang">1.3 中断和异常</a></li><li><a href="#1-4-linux-yan-shen">1.4 linux延申</a></li><li><a href="#q-cha-shang-dian-yuan-zhi-hou-ji-suan-ji-xi-tong-zuo-liao-shi-me">Q: 插上电源之后，计算机系统做了什么？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="1-1-yun-xing-zhuang-tai">1.1运行状态</span><a href="#1-1-yun-xing-zhuang-tai" class="header-anchor">#</a></h1><ul><li>行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制</li><li>而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制</li></ul><h2><span id="1-1-1-yong-hu-tai">1.1.1 用户态</span><a href="#1-1-1-yong-hu-tai" class="header-anchor">#</a></h2><p>程在执行用户自己的代码时，则称其处于用户运行态（用户态）,相当于运行用户自己的代码函数都是用户态，linux系统的底层调用接口不属于用户态。</p><ul><li>访管指令是用户态调用的</li></ul><h2><span id="1-1-2-he-xin-tai">1.1.2 核心态</span><a href="#1-1-2-he-xin-tai" class="header-anchor">#</a></h2><ul><li>内核态，在操作系统内核运行的状态。</li><li>核心态运行时的特</li><li>负责管理进程、存储<br>用户态什么时候会进入核心态？就是下面提到的系统调用、中断和异常。</li></ul><hr><h2><span id="q-wei-shi-me-yao-qu-fen-xi-tong-tai-he-yong-hu-tai">Q: 为什么要区分系统态和用户态？</span><a href="#q-wei-shi-me-yao-qu-fen-xi-tong-tai-he-yong-hu-tai" class="header-anchor">#</a></h2><p>A:</p><ul><li>CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。</li><li>最主要原因是要把用户程序和系统程序区分开，以利于程序的共享和保护。显然，这也是以增加系统复杂度和系统开销为代价的。</li></ul><h1><span id="1-2-xi-tong-diao-yong">1.2 系统调用</span><a href="#1-2-xi-tong-diao-yong" class="header-anchor">#</a></h1><ul><li>系统调用概念：从用户进程自身堆栈 切换为系统堆栈</li><li>执行系统调用后，就会进入核心态</li><li>时钟管理属于核心态的概念（用于进程切换计时和系统时间）</li><li>和系统资源有关的都要用到系统调用，如下：<ol><li>存储</li><li>IO传输</li><li>文件管理</li></ol></li><li>系统调用需要在用户态触发trap命令</li></ul><blockquote><blockquote><p>陷入指令是指用户程序所依靠的指令，用于发起系统调用，请求操作系统提供服务。陷入指令有其中一点特殊在于，<strong>其只能在用户态下执行，而不可以在核心态下执行</strong>。</p></blockquote></blockquote><p>trap命令具体流程：</p><ol><li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务</li><li>用户态程序执行陷阱指令</li><li>CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分,</li><li>后面的这些指令会读取程序放入内存的数据参数, 并执行程序请求的服务</li><li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果</li></ol><h1><span id="1-3-zhong-duan-he-yi-chang">1.3 中断和异常</span><a href="#1-3-zhong-duan-he-yi-chang" class="header-anchor">#</a></h1><ul><li>外中断 = 中断： 即外设请求或者人为程序干预</li><li>内中断= 异常： 指令中断（溢出）、 软件故障、硬件故障。</li></ul><p>即中断就是正常行为， 异常则可能是故障引发。</p><h1><span id="1-4-linux-yan-shen">1.4 linux延申</span><a href="#1-4-linux-yan-shen" class="header-anchor">#</a></h1><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/20210314234044212.png" alt="在这里插入图片描述"><br><a href="https://www.cnblogs.com/bakari/p/5520860.html">https://www.cnblogs.com/bakari/p/5520860.html</a></p><hr><h1><span id="q-cha-shang-dian-yuan-zhi-hou-ji-suan-ji-xi-tong-zuo-liao-shi-me">Q: 插上电源之后，计算机系统做了什么？</span><a href="#q-cha-shang-dian-yuan-zhi-hou-ji-suan-ji-xi-tong-zuo-liao-shi-me" class="header-anchor">#</a></h1><p>A:</p><ol><li>加电––––打开电源开关，给主板和内部风扇供电。</li><li>启动引导程序––––CPU开始执行存储在ROM BIOS中的指令。</li><li>开机自检––––计算机对系统的主要部件进行诊断测试。</li><li>加载操作系统––––计算机将操作系统文件从磁盘读到内存中。</li><li>检查配置文件，定制操作系统的运行环境––––读取配置文件，根据用户的设置对操作系统进行定制。<br>在Windows中对运行环境进行配置的方法很多，比如修改注册表，编辑System.ini、Win.ini等系统配置文件，或将希望启动完Windows后立即执行的内容放入Windows的启动（Startup）组中。</li><li>准备读取命令和数据––––计算机等待用户输入命令和数据。<br><a href="https://blog.csdn.net/ai_yue/article/details/82958153">接通电源后，计算机做了那些基本操作</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第86 场双周赛-930名-3题</title>
      <link href="/2022/09/04/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/"/>
      <url>/2022/09/04/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/1662394885933.png" alt="1662394885933"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>滑动窗口最大值，一定要用过期有限队列</li></ol><p><a href="https://leetcode.cn/problems/find-subarrays-with-equal-sum/">2395. 和相等的子数组 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/1662394935649.png" alt="1662394935649"></p><p>直接哈希表，但是要处理long的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; nums.length) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(map.contains((<span class="type">long</span>)nums[i] + nums[j])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.add((<span class="type">long</span>) (nums[i] + nums[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/strictly-palindromic-number/">2396. 严格回文的数字 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/1662395006184.png" alt="1662395006184"></p><p>还好，不需要考虑回文比较的性能，直接统计每个数字即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStrictlyPalindromic</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n-<span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> n;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(num % i);</span><br><span class="line">                num /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.reverse().toString();</span><br><span class="line">            <span class="keyword">if</span> (!s1.equals(s2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397. 被列覆盖的最多行数 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/1662395135512.png" alt="1662395135512"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRows</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        dfs(mat, cols, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">boolean</span>[mat[<span class="number">0</span>].length]);</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> colRealCount, <span class="type">int</span> colIndex, <span class="type">boolean</span>[] select)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colRealCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;y&lt;mat.length;y++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; mat[<span class="number">0</span>].length;x++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mat[y][x] == <span class="number">1</span> &amp;&amp; !select[x]) &#123;</span><br><span class="line">                        flag  =<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxCount = Math.max(maxCount, count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> colIndex;col &lt; mat[<span class="number">0</span>].length;col++) &#123;</span><br><span class="line">            select[col] = <span class="literal">true</span>;</span><br><span class="line">            dfs(mat, colRealCount-<span class="number">1</span>, col+<span class="number">1</span>, select);</span><br><span class="line">            select[col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接dfs即可</p><hr><p><a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/">2398. 预算内的最多机器人数目 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-930%E5%90%8D-3%E9%A2%98/1662395196873.png" alt="1662395196873"></p><p>没有做完就总结， 已经忘记当时为什么11点30就提交了第一次，然后改了半个小时也没搞定。。</p><p>好像是因为  我要求的应该是滑动窗口的最大值以及滑动窗口的总和， 然而最大值那个好像搞错了，应该要引入过期队列的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRobots</span><span class="params">(<span class="type">int</span>[] chargeTimes, <span class="type">int</span>[] runningCosts, <span class="type">long</span> budget)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[chargeTimes.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chargeTimes.length;i++) &#123;</span><br><span class="line">            array[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;chargeTimes[i], runningCosts[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = runningCosts.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueCount</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(b[<span class="number">1</span>]-a[<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length;i++) &#123;</span><br><span class="line">                sum += array[i][<span class="number">1</span>];</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, array[i][<span class="number">0</span>]&#125;);</span><br><span class="line">                <span class="keyword">if</span> ( i &lt; mid - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peek()[<span class="number">0</span>] &lt; i - queueCount) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> queue.peek()[<span class="number">1</span>];</span><br><span class="line">                <span class="type">long</span> <span class="variable">ksum</span> <span class="operator">=</span> sum ;</span><br><span class="line">                <span class="type">long</span> <span class="variable">buck</span> <span class="operator">=</span> max + k * ksum;</span><br><span class="line">                <span class="keyword">if</span> (buck &lt;= budget) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= array[i - queueCount][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, left-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排个序就好了，没啥难的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum + nums[j] &gt; queries[i]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/removing-stars-from-a-string/">6161. 从字符串中移除星号 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701444253.png" alt="1661701444253"></p><p>既然每次要移除最左边， 我就从右往左边遍历， 碰到星号，说明下次碰到字母时要变星号，记录一个数字即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeStars</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] bs = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">needDeduceCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                needDeduceCount++;</span><br><span class="line">                bs[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needDeduceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                needDeduceCount--;</span><br><span class="line">                bs[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bs[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/">6162. 收集垃圾的最少总时间 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701543477.png" alt="1661701543477"></p><p>这种题目啥情况，啥算法也不用，直接3次遍历即可，主要是得计算到最后一个有这个垃圾的房子时就要截至了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">garbageCollection</span><span class="params">(String[] garbage, <span class="type">int</span>[] travel)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">realSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; garbage.length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">garba</span> <span class="operator">=</span> garbage[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> g : garba.toCharArray()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == c) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sum += count;</span><br><span class="line">                    realSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != garbage.length-<span class="number">1</span>) &#123;</span><br><span class="line">                    sum += travel[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += realSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/build-a-matrix-with-conditions/">6163. 给定条件下构造矩阵 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701601482.png" alt="1661701601482"></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701607970.png" alt="1661701607970"></p><p>想了半太天才意识到是拓扑排序，  越是叶子的，越可以放前面， 越是根的，越可以放后面</p><p>早点想到的话应该20分钟就做出来了，拓扑还是很简单的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] buildMatrix(<span class="type">int</span> k, <span class="type">int</span>[][] rowConditions, <span class="type">int</span>[][] colConditions) &#123;</span><br><span class="line">        <span class="type">int</span>[] rows = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] cols = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!sort(k, rowConditions, rows) </span><br><span class="line">                ||  !sort(k, colConditions, cols)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[k][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=k;i++) &#123;</span><br><span class="line">            res[rows[i]][cols[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[][] rowConditions, <span class="type">int</span>[] rows)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] inCount = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        List&lt;Integer&gt;[] outLists = <span class="keyword">new</span> <span class="title class_">List</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=k;i++) &#123;</span><br><span class="line">            outLists[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : rowConditions) &#123;</span><br><span class="line">            inCount[row[<span class="number">1</span>]]++;</span><br><span class="line">            outLists[row[<span class="number">0</span>]].add(row[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inCount[i]  &gt; <span class="number">0</span> || vis[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> out : outLists[i]) &#123;</span><br><span class="line">                    inCount[out]--;</span><br><span class="line">                &#125;</span><br><span class="line">                rows[i] = y;</span><br><span class="line">                y++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == k+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inCount[i] &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第309场周赛-1345名-3题</title>
      <link href="/2022/09/04/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B-1345%E5%90%8D-3%E9%A2%98/"/>
      <url>/2022/09/04/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B-1345%E5%90%8D-3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B-1345%E5%90%8D-3%E9%A2%98/1662393708201.png" alt="1662393708201"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>子数字、子序列的题目， 一定要关注一下有没有”连续“二字！</li><li>排列组合公式可以记忆一下，特别是C二维数组中左边是啥，右边是啥</li></ol><hr><p><a href="https://leetcode.cn/problems/check-distances-between-same-letters/">2399. 检查相同字母间的距离 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B-1345%E5%90%8D-3%E9%A2%98/1662393833962.png" alt="1662393833962"></p><p>直接2个遍历找距离即可,因为每个字母恰好是2次！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkDistances</span><span class="params">(String s, <span class="type">int</span>[] distance)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;s.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> j - i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (distance[c-<span class="string">&#x27;a&#x27;</span>] != len) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/">2400. 恰好移动 k 步到达某一位置的方法数目 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B-1345%E5%90%8D-3%E9%A2%98/1662393987326.png" alt="1662393987326"></p><p>这个题目为啥想了20分钟。。</p><p>很明显左移和右移的个数是确定的！</p><p>那基本就是排列组合了，结果那个排列组合的方法又整了半天，组合数的计算方式总是记不住！</p><p>个数少的时候，直接杨辉三角解法即可， 注意我这个是c[n][m]，  n是大的那个！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfWays</span><span class="params">(<span class="type">int</span> startPos, <span class="type">int</span> endPos, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> Math.abs(startPos - endPos);</span><br><span class="line">        <span class="type">int</span> <span class="variable">chak</span> <span class="operator">=</span> k - cha;</span><br><span class="line">        <span class="keyword">if</span> (chak %<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chak &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k1</span> <span class="operator">=</span> cha + chak/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k2</span> <span class="operator">=</span> chak/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span>[][] c = <span class="keyword">new</span> <span class="title class_">long</span>[k+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">                c[i][j]=(c[i-<span class="number">1</span>][j]+c[i-<span class="number">1</span>][j-<span class="number">1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)c[k][k1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/longest-nice-subarray/">2401. 最长优雅子数组 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC309%E5%9C%BA%E5%91%A8%E8%B5%9B-1345%E5%90%8D-3%E9%A2%98/1662394562551.png" alt="1662394562551"></p><p>我TM又没看到“连续”二字！！！题目里也没有体现！</p><p>以后看到子数组和子序列都注意啊！注意是不是连续，我十多分钟都花在怎么处理非连续了！</p><p>知道连续以后就很容易了，记录最左边那个会造成同位1，然后时刻更新最左边的有效点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestNiceSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] indexNears = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">33</span>];</span><br><span class="line">        Arrays.fill(indexNears, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">novalidLeft</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    novalidLeft = Math.max(novalidLeft, indexNears[k]);</span><br><span class="line">                    indexNears[k] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                num/=<span class="number">2</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">canValidLeft</span> <span class="operator">=</span> novalidLeft + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (canValidLeft &gt; lastLeft) &#123;</span><br><span class="line">                lastLeft = canValidLeft;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, i - lastLeft + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/meeting-rooms-iii/">2402. 会议室 III - 力扣（LeetCode）</a></p><p>等待后面纳入日常中重新写</p><p>题目我会做，就是几个细节没处理好导致gg，主要就是优先队列的比较函数</p><ol><li>当同时有几个会议室需要释放时， 需要选最小的会议室先出队，这导致我的优先队列比较函数非常关键</li><li>会议延期要放入一个常规队列，且需要更新时间，还要对原先优先队列里的结束时间做过期处理</li><li>注意int范围越界，特别是比较函数不可以直接a[0] - b[0],都可能越界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mostBooked</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] newMeetins = <span class="keyword">new</span> <span class="title class_">long</span>[meetings.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; meetings.length;i++) &#123;</span><br><span class="line">            newMeetins[i] = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;meetings[i][<span class="number">0</span>], meetings[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 会议占用了哪个会议室</span></span><br><span class="line">        <span class="type">int</span>[] places = <span class="keyword">new</span> <span class="title class_">int</span>[newMeetins.length];</span><br><span class="line">        <span class="comment">//Arrays.fill(places, n+1);</span></span><br><span class="line">        Queue&lt;<span class="type">long</span>[]&gt; meets = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(!(a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; b[<span class="number">0</span>] == <span class="number">1</span>) ? ( a[<span class="number">1</span>] &gt;= b[<span class="number">1</span>] ? <span class="number">1</span> : -<span class="number">1</span>) :(places[(<span class="type">int</span>)a[<span class="number">2</span>]] - places[(<span class="type">int</span>)b[<span class="number">2</span>]])));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] meet : newMeetins) &#123;</span><br><span class="line">            meets.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, meet[<span class="number">0</span>], j&#125;);</span><br><span class="line">            meets.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">1</span>, meet[<span class="number">1</span>], j&#125;);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        priorityQueue.addAll(IntStream.range(<span class="number">0</span>, n).boxed().collect(Collectors.toSet()));</span><br><span class="line">        Queue&lt;Integer&gt; waitList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; waitSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] meetHappendCounts = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (!meets.isEmpty()) &#123;</span><br><span class="line">            <span class="type">long</span>[] meet = meets.poll();</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> meet[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">meetIndex</span> <span class="operator">=</span> (<span class="type">int</span>)meet[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (meet[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">                    meetHappendCounts[place]++;</span><br><span class="line">                    places[meetIndex] = place;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    waitList.offer(meetIndex);</span><br><span class="line">                    waitSet.add(meetIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (newMeetins[meetIndex][<span class="number">1</span>] != time) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (waitSet.contains(meetIndex)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 要识别这个end是不是延迟的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> places[meetIndex];</span><br><span class="line">                <span class="keyword">if</span> (!waitList.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">waitmeet</span> <span class="operator">=</span> waitList.poll();</span><br><span class="line">                    waitSet.remove(waitmeet);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> newMeetins[waitmeet][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> newMeetins[waitmeet][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">long</span> <span class="variable">use</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">newEndTime</span> <span class="operator">=</span> time + use;</span><br><span class="line">                    newMeetins[waitmeet][<span class="number">1</span>] = (<span class="type">long</span>)newEndTime;</span><br><span class="line">                    meets.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">1</span>, newEndTime, waitmeet&#125;);</span><br><span class="line">                    places[waitmeet] = place;</span><br><span class="line">                    meetHappendCounts[place]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    priorityQueue.offer(place);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meetHappendCounts[i] &gt; max) &#123;</span><br><span class="line">                max = meetHappendCounts[i];</span><br><span class="line">                select = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> select;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我要坚持练习算法</title>
      <link href="/2022/09/01/%E7%BC%96%E7%A8%8B/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E5%9D%9A%E6%8C%81%E7%BB%83%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/01/%E7%BC%96%E7%A8%8B/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E5%9D%9A%E6%8C%81%E7%BB%83%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yi-ti-sheng-kai-fa-zhe-zi-ce-neng-li">一、提升开发者自测能力</a></li><li><a href="#er-jia-shen-dui-bian-cheng-yu-yan-de-shi-yong">二、加深对编程语言的使用</a><ul><li><a href="#1-api-ying-yong">1.api应用</a></li><li><a href="#2-yu-fa-wen-ti-cha-que-bu-lou">2. 语法问题查缺补漏</a></li></ul></li><li><a href="#san-shou-huo-si-xiang-zuo-wei-cheng-xu-you-hua-de-si-xiang-chu-bei">三、收获“思想”，作为程序优化的思想储备</a></li><li><a href="#si-bao-chi-dai-ma-si-wei-he-shou-gan">四、保持代码思维和手感</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="yi-ti-sheng-kai-fa-zhe-zi-ce-neng-li">一、提升开发者自测能力</span><a href="#yi-ti-sheng-kai-fa-zhe-zi-ce-neng-li" class="header-anchor">#</a></h1><p>面试时的上机编程有一个特点，就是不会给出“错误用例”。<br>有时也会听到“为什么不能提示错误用例”之类的吐槽。<br>这种思维类似于&quot;测试为什么没测出来这个bug&quot; 、“缺少堆栈和日志，不能设断点，我没法排查这个问题”</p><p>然而被提单次数，会影响自己的代码质量评估。 生产环境往往也因为安全限制，无法直接远程调试。 因此这种思维是很危险和不可取的。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E5%9D%9A%E6%8C%81%E7%BB%83%E4%B9%A0%E7%AE%97%E6%B3%95/image(348).png" alt="image.png"></p><p>算法题熟练的同学，有个特点，就是能在接口中提前加上各种判断，或者写上todo注释作为开发遗留。<br>原因就是在大量的算法题练习过程中，掌握了边界的处理，或者通过阅读代码逻辑，找出其中漏洞。<br>学习开发者的白盒测试理论是很有利于解决这种情况的。<br>里面的几种边界，对于开发者自身应该要能熟练掌握。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E5%9D%9A%E6%8C%81%E7%BB%83%E4%B9%A0%E7%AE%97%E6%B3%95/image(350).png" alt="image.png"></p><p>因此大家平时如果在leetcode或者其他平台练习题目时，最好以零出错为目目标一次性搞定。 出错的第一时间， 先不要拿着用例去调试， 而是想一想自己为什么会漏了这种情况。 否则很容易形成对错误用例和调试的依赖。</p><h1><span id="er-jia-shen-dui-bian-cheng-yu-yan-de-shi-yong">二、加深对编程语言的使用</span><a href="#er-jia-shen-dui-bian-cheng-yu-yan-de-shi-yong" class="header-anchor">#</a></h1><h2><span id="1-api-ying-yong">1.api应用</span><a href="#1-api-ying-yong" class="header-anchor">#</a></h2><p>以java为例， 当你频繁用for循环写各种初始化或者赋值代码时，可能会觉得心很累。<br>例如需要将&quot;0,1,2,3&quot;这个字符串转成一个整数数组，新手写法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int[] buildIntArray(String str) &#123;</span><br><span class="line">    String[] numStrs = str.split(&quot;,&quot;);</span><br><span class="line">    int[] result = new int[numStrs.length];</span><br><span class="line">    for (int i = 0;i&lt;result.length;i++) &#123;</span><br><span class="line">        result[i] = Integer.valueOf(numStrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用javaStream的话，一行代码就搞定了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int[] buildIntArray(String str) &#123;</span><br><span class="line">    return Arrays.stream(str.split(&quot;,&quot;)).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此练习中即使解决了题目，也不妨看看其他人的代码， 进而将好的用法引申到工作中。（当然写太复杂的java stream代码会影响可读性，视情况而用）。</p><h2><span id="2-yu-fa-wen-ti-cha-que-bu-lou">2. 语法问题查缺补漏</span><a href="#2-yu-fa-wen-ti-cha-que-bu-lou" class="header-anchor">#</a></h2><p>另外练习过程中，也能遇到很多编程知识的应用。 假设我们需要自定义一个优先队列，有人写了下面这个代码，却有部分用例无法通过，为什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            <span class="comment">// 当a=b的另一种判断条件.....</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际上是因为 Integer包装类型不能用==和!=直接去比较，  因为Integer范围不在-128到127时，比较的就是引用地址而非实际大小了。因此应该用equals方法。从这里可以看出一些编程知识在开发工作中的重要性。</p><h1><span id="san-shou-huo-si-xiang-zuo-wei-cheng-xu-you-hua-de-si-xiang-chu-bei">三、收获“思想”，作为程序优化的思想储备</span><a href="#san-shou-huo-si-xiang-zuo-wei-cheng-xu-you-hua-de-si-xiang-chu-bei" class="header-anchor">#</a></h1><p>相信很多人从做题攻略和自主练习过程中，  学到了 动态规划、 链表、KMP、二分查找、 并查集等 诸多“套路”。 这些算法却在平时的业务开发中却很少用到， 不免会让人吐槽都是&quot;花拳绣腿&quot;，折腾人，对绩效和KPI也没有帮助。</p><p>那么可以换个角度理解，学习数学有什么用？ 如果仅仅是用于工程应用，不做研究，大部分也只是做api的调用者，不会追究到数学证明、公式推导等层面。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E5%9D%9A%E6%8C%81%E7%BB%83%E4%B9%A0%E7%AE%97%E6%B3%95/image(351).png" alt="image.png"></p><p>但数学作为从小到大一直在重点考察的学科一直陪伴着我们。为什么？<br>个人理解，是因为数学可以锻炼我们的逻辑思维能力，培养一种理性思维和解决问题的方式。</p><p>算法和数学都是一种思想。 包括你去学习设计模式、学习jvm原理、学习操作系统等，都是在学习一种思想。 而对思想的理解和加深，则需要大量的练习。因此上机编程成了重要的考察方式。</p><p>以二分查找为例，有的人只关注循环不变式模板、&quot;逃课&quot;api(指不用手写二分，可以直接用的接口，例如treeMap的floor()）<br>有的人则会在大量的练习中，悟到什么时候、哪种情况下可以剔除不必要的搜索遍历过程，并使用二分解决性能问题。</p><p>因此建议大家在备考刷题的过程中， 除了关注&quot;套路&quot;、&quot;题目面板&quot;外，多关注一下这个解法的背后思想是什么， 当你能理解到这一个层次时，  往往对你的编程工作会有持续的潜移默化影响，尽管可能不是那么显而易见罢了。</p><h1><span id="si-bao-chi-dai-ma-si-wei-he-shou-gan">四、保持代码思维和手感</span><a href="#si-bao-chi-dai-ma-si-wei-he-shou-gan" class="header-anchor">#</a></h1><p>大家应该都有这种时期， 就是某段时间都是各种杂事，可能1个月就写了几百行代码，事后再捡起来就不会写了。<br>因此这种时期练练题目，对自己也维持手感也会有帮助。有句话叫做“ 流水不腐户枢不蠹”。<br>另外看到一段关于跑步的话，这里分享一下：</p><blockquote><blockquote><p>如果你经常跑步，你也许会知道其实 4 个多小时一点都不快，完全就是业余跑者的水平；也许你也知道，其实即便是大众跑者，5 年完成百公里也是相当难的，甚至身体的原因，不是所有人都能跑下来越野。<br>所以当我开始追求速度时，慢慢发现，当我在为 5 公里没有跑进 20 分而焦虑和努力时，学校里的那些体育生都在追求如何跑进 17 分了。后来我释然了：之前我对于跑步的疯狂，是因为没有搞懂跑步的意义：<br>因为跑步不会让我毕业。<br>因为跑步不会让我找到工作。<br>因为跑步不会让我找到女朋友。<br>跑步对于我的意义，就是能让我保持身体健康，仅此而已。</p></blockquote></blockquote><hr><p>以上就是我的一些想法，个人技术水平和经验有限，没有资格让大家全部认同。<br>另外考查程序员素养的指标绝对不仅仅只是代码。上机题的考察方式本身也可能存在缺陷。如果你是对此有更深理解的朋友，也可以讲一下你对这方面的看法和收获，大家一起学习和参考。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 为什么我要坚持练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年9月</title>
      <link href="/2022/09/01/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B49%E6%9C%88/"/>
      <url>/2022/09/01/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B49%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#2022-09-16">2022-09-16</a><ul><li><a href="#di-yi-ti-duo-ge-lian-xu-qu-jian-chang-du-mian-ji-wen-ti-sao-miao-xian">第一题： 多个连续区间长度、面积问题——扫描线</a></li></ul></li><li><a href="#2022-09-15">2022-09-15</a></li><li><a href="#2022-09-14">2022-09-14</a><ul><li><a href="#di-yi-ti-qian-zhui-he-ha-xi-huo-zhe-qian-zhui-he-dan-diao-zhan">第一题：前缀和+哈希或者前缀和+单调栈</a></li><li><a href="#di-er-ti-zhu-yi-java-zhong-ye-shi-te-shu-zheng-ze-fu-hao-xu-yao-zhuan-yi">第二题： 注意java中|也是特殊正则符号，需要转移</a></li><li><a href="#di-san-ti">第三题</a></li></ul></li><li><a href="#2022-09-11">2022-09-11</a></li><li><a href="#2022-09-08">2022-09-08</a></li><li><a href="#2022-09-07">2022-09-07</a><ul><li><a href="#di-yi-ti-ru-guo-ji-suan-3-ge-dian-shi-fou-yi-ge-zhi-xian">第一题： 如果计算3个点是否一个直线</a></li><li><a href="#di-er-ti-xiu-gai-gen-jie-dian">第二题：修改跟节点</a></li></ul></li><li><a href="#2022-09-06">2022-09-06</a></li><li><a href="#2022-09-05">2022-09-05</a></li><li><a href="#2022-09-04-zhou-sai">2022-09-04 周赛</a></li><li><a href="#2022-09-03-shuang-zhou-sai">2022-09-03：双周赛</a></li><li><a href="#2022-09-02">2022-09-02</a><ul><li><a href="#di-yi-ti-di-gui-jian-dan-ti">第一题： 递归简单题</a></li><li><a href="#di-er-ti-dui-jiao-xian-pan-duan">第二题：对角线判断</a></li><li><a href="#di-san-ti-jia-fa-shu-zhi-yao-yuan-su-du-yi-zhi-na-jiu-shi-xiang-deng">第三题：加法树只要元素都一致那就是相等</a></li></ul></li><li><a href="#2022-09-01">2022-09-01</a><ul><li><a href="#di-yi-ti-jian-dan-er-cha-shu-di-gui">第一题：简单二叉树递归</a></li><li><a href="#di-er-ti-jian-dan-hui-wen-pan-duan">第二题：简单回文判断</a></li><li><a href="#di-san-ti-tan-xin-jian-ge-bai-fang-zi-fu-yao-qiu-zui-chang">第三题：贪心间隔摆放字符要求最长</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="2022-09-16">2022-09-16</span><a href="#2022-09-16" class="header-anchor">#</a></h1><h2><span id="di-yi-ti-duo-ge-lian-xu-qu-jian-chang-du-mian-ji-wen-ti-sao-miao-xian">第一题： 多个连续区间长度、面积问题——扫描线</span><a href="#di-yi-ti-duo-ge-lian-xu-qu-jian-chang-du-mian-ji-wen-ti-sao-miao-xian" class="header-anchor">#</a></h2><p>多个连续区间，叠加部分要去掉或者叠加某个价值，这种题常见于那种任务流</p><p>区间的坐标很大导致无法遍历坐标值， 但可以遍历起点和终点坐标。</p><p>如果是求多个连续区间叠加后的横向长度（去除覆盖部分） ，就是最基础的扫描线应用</p><p>每次碰到关键点， 就将当前宽度（只能是0或者1）乘上（当前位置减去上一个位置）</p><p>然后直接更新上一个位置</p><p>并修改宽度（你只要考虑当前线段数量是否为0还是1）</p><p>求叠加线段长度的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getYLen</span><span class="params">(List&lt;<span class="type">int</span>[]&gt; yList)</span> &#123;</span><br><span class="line">    Collections.sort(yList, (a,b)-&gt;(a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] yp : yList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> yp[<span class="number">0</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isStart</span> <span class="operator">=</span> yp[<span class="number">2</span>] == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前线段数量大于等于1，宽度就为1</span></span><br><span class="line">        sum += (count&gt;=<span class="number">1</span>?<span class="number">1</span>:<span class="number">0</span>) * (y - last);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据是起点还是终点更新线段数量</span></span><br><span class="line">        <span class="keyword">if</span> (isStart) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        last = y;</span><br><span class="line">    &#125;</span><br><span class="line">    sum %= MOD;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这题求的是面积</p><p>因此是二维的扫描线应用，即用到了两个方向上的扫描线</p><p>先是按x作为扫描点，从左往右遍历</p><p>每次遇到起点或者终点时， 先尝试计算 当前宽度 * （当前点-上一个点）</p><p>当前宽度则根据上面的y轴叠加线段的计算方式计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectangleArea</span><span class="params">(<span class="type">int</span>[][] rectangles)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; xlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rectangles.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] rect = rectangles[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">xLeft</span> <span class="operator">=</span> rect[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRight</span> <span class="operator">=</span> rect[<span class="number">2</span>];</span><br><span class="line">        xlist.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;xLeft, i, <span class="number">0</span>&#125;);</span><br><span class="line">        xlist.add(<span class="keyword">new</span>  <span class="title class_">int</span>[]&#123;xRight, i, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(xlist, (a,b)-&gt;(a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ylist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] xp : xlist) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> xp[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> xp[<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeft</span> <span class="operator">=</span> xp[<span class="number">2</span>] == <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] rect = rectangles[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">yDown</span> <span class="operator">=</span> rect[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">yUp</span> <span class="operator">=</span> rect[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">            <span class="comment">// 把之前那段面积先加起来</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">ylen</span> <span class="operator">=</span> getYLen(ylist);</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> ylen * (x - lastX);</span><br><span class="line">            sum %= MOD;</span><br><span class="line">            res += sum;</span><br><span class="line">            res %= MOD;</span><br><span class="line">            <span class="comment">// 接着加入这段新的y区间</span></span><br><span class="line">            ylist.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;yUp, i, <span class="number">1</span>&#125;);</span><br><span class="line">            ylist.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;yDown, i, <span class="number">0</span>&#125;);</span><br><span class="line">            lastX = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右点</span></span><br><span class="line">            <span class="comment">// 先计算之前的面积</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">ylen</span> <span class="operator">=</span> getYLen(ylist);</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> ylen * (x - lastX);</span><br><span class="line">            sum %= MOD;</span><br><span class="line">            res += sum;</span><br><span class="line">            res %= MOD;</span><br><span class="line">            <span class="comment">// 删除这段y区间</span></span><br><span class="line">            <span class="comment">// 删除的时候要注意用迭代器</span></span><br><span class="line">            Iterator&lt;<span class="type">int</span>[]&gt; it = ylist.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.next()[<span class="number">1</span>] == i) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lastX = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-09-15">2022-09-15</span><a href="#2022-09-15" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/bulb-switcher-ii/">672. 灯泡开关 Ⅱ - 力扣（LeetCode）</a></p><p>这题最佳题解是找规律，逐步定位到只需要判断前面4个灯泡即可。</p><p>但是这个找规律其实并不好找，不符合计算机思维。实际上可以不用得到只判断4个灯泡这个条件。而是知道以下几点即可：</p><ol><li>每个开关只有开奇数次才算生效。 因此要么0要么1，4个开关可以理解成4位二进制</li><li>当二进制中1的个数小于等于按压次数时，只要取余相同，则一定可以得到这种情况</li></ol><p>那么基于这个，就可以直接模拟计算出16种按压情况下，n位灯泡的总数（用hashset）不用找那个规律。</p><p>注意编号是从1到n的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">flipLights</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> presses)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>;i++) &#123;</span><br><span class="line">           <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">               bits[j] = (i&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">                sum += bits[j];</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span> (sum &lt;= presses &amp;&amp; sum %<span class="number">2</span> == presses %<span class="number">2</span>) &#123;              </span><br><span class="line">                StringBuilder sb= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length;j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bits[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                        arr[j] = arr[j] ^ <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (bits[<span class="number">1</span>] ==<span class="number">1</span> &amp;&amp; j %<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        arr[j] = arr[j] ^ <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (bits[<span class="number">2</span>] ==<span class="number">1</span> &amp;&amp; j %<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        arr[j] = arr[j] ^ <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (bits[<span class="number">3</span>] ==<span class="number">1</span> &amp;&amp; j %<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        arr[j] = arr[j] ^ <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(arr[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                sets.add(sb.toString());</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sets);</span><br><span class="line">        <span class="keyword">return</span> sets.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-09-14">2022-09-14</span><a href="#2022-09-14" class="header-anchor">#</a></h1><h2><span id="di-yi-ti-qian-zhui-he-ha-xi-huo-zhe-qian-zhui-he-dan-diao-zhan">第一题：前缀和+哈希或者前缀和+单调栈</span><a href="#di-yi-ti-qian-zhui-he-ha-xi-huo-zhe-qian-zhui-he-dan-diao-zhan" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/longest-well-performing-interval/">1124. 表现良好的最长时间段 - 力扣（LeetCode）</a></p><p>又是涉及sum[i]、sun[j]然后求j-i最大的题目</p><p>然后果不其然想歪了怎么也写错了</p><p>最后要么用哈希记录最左端位置，因为是逐个按1或者-1增加前缀和的，那么当你是-5的时候，前面如果有-6，则一定是最前面的-6， 如果没有-6说明不行。 如果你是5的前缀和，那默认当前位置最长了。</p><p>要么是单调栈，但是是特殊的单调栈，不会出栈，只是构造递减的栈，然后反向遍历，这个根本想不到。</p><p>这题实际上偏难了不算中等题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[hours.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hours.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hours[i] &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                sum++; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            pre[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sumToIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hours.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res = Math.max(res, i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">needPre</span> <span class="operator">=</span> pre[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sumToIndexMap.containsKey(needPre)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> sumToIndexMap.get(needPre);</span><br><span class="line">                    res = Math.max(res, i - lastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!sumToIndexMap.containsKey(pre[i])) &#123;</span><br><span class="line">                    sumToIndexMap.put(pre[i], i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="di-er-ti-zhu-yi-java-zhong-ye-shi-te-shu-zheng-ze-fu-hao-xu-yao-zhuan-yi">第二题： 注意java中|也是特殊正则符号，需要转移</span><a href="#di-er-ti-zhu-yi-java-zhong-ye-shi-te-shu-zheng-ze-fu-hao-xu-yao-zhuan-yi" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/count-asterisks/">2315. 统计星号 - 力扣（LeetCode）</a></p><p>关键地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = s.split(<span class="string">&quot;\\|&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意|的写法</p><h2><span id="di-san-ti">第三题</span><a href="#di-san-ti" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/">1619. 删除某些元素后的数组均值 - 力扣（LeetCode）</a></p><h1><span id="2022-09-11">2022-09-11</span><a href="#2022-09-11" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/submissions/">857. 雇佣 K 名工人的最低成本 - 力扣（LeetCode）</a></p><p>这题想不到的是要按工资比例做排序</p><p>最低工资/价值  来从小到大排序</p><p>从左到右遍历，选中一个那个就是作为最低工资标准，则前面任意都直接拿价值乘这个工资标准比率即可</p><p>而又可以根据k个的quality和可以直接乘……&amp;这个还是蛮难想到的， 但是想懂后其实就是k个最大堆的应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">mincostToHireWorkers</span><span class="params">(<span class="type">int</span>[] quality, <span class="type">int</span>[] wage, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Integer[] indexs = <span class="keyword">new</span> <span class="title class_">Integer</span>[quality.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> quality.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; quality.length;i++) &#123;</span><br><span class="line">            indexs[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(indexs, (a,b)-&gt;(((<span class="type">double</span>)wage[a]/quality[a] - (<span class="type">double</span>)wage[b]/quality[b] &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>)));</span><br><span class="line">        Queue&lt;Integer&gt; minKQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(b-a));</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">qua</span> <span class="operator">=</span> quality[index];</span><br><span class="line">            <span class="type">int</span> <span class="variable">wag</span> <span class="operator">=</span> wage[index];</span><br><span class="line">            <span class="type">double</span> <span class="variable">rate</span> <span class="operator">=</span> (<span class="type">double</span>)wag/qua;</span><br><span class="line">            <span class="keyword">if</span> (minKQueue.size() &lt; k) &#123;</span><br><span class="line">                minKQueue.offer(qua);</span><br><span class="line">                sum += qua;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minKQueue.size() == k &amp;&amp; qua &lt; minKQueue.peek()) &#123;</span><br><span class="line">                sum -= minKQueue.poll();</span><br><span class="line">                minKQueue.offer(qua);</span><br><span class="line">                sum += qua;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minKQueue.size() == k) &#123;</span><br><span class="line">                res = Math.min(res, sum * rate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-09-08">2022-09-08</span><a href="#2022-09-08" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/beautiful-arrangement-ii/submissions/">667. 优美的排列 II - 力扣（LeetCode）</a></p><p>规律题，还好没纠结</p><p><img src="/images/22%E5%B9%B49%E6%9C%88/1662652885074.png" alt="1662652885074"></p><p>对于1~n的数字， 想要满足有n-1个前后差值不同，必须满足</p><p>[1,  n,   2 ,   n-1,  3,  n-2]  这样最小和最大值交叉出现</p><p>而如果是相同，则就是按顺序出现</p><p>那么想要任意k个差值不同，那就前面先都按顺序， 后面再交叉出现即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] constructArray(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;n-k;i++) &#123;</span><br><span class="line">            res[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> n-k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; n) &#123;</span><br><span class="line">                res[index++] = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; n) &#123;</span><br><span class="line">                res[index++] = right;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-09-07">2022-09-07</span><a href="#2022-09-07" class="header-anchor">#</a></h1><h2><span id="di-yi-ti-ru-guo-ji-suan-3-ge-dian-shi-fou-yi-ge-zhi-xian">第一题： 如果计算3个点是否一个直线</span><a href="#di-yi-ti-ru-guo-ji-suan-3-ge-dian-shi-fou-yi-ge-zhi-xian" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/valid-boomerang/">1037. 有效的回旋镖 - 力扣（LeetCode）</a></p><p>y1 - y2 / (x1-x2) = (y1-y3) / (x1-x3)</p><p>即以(x1,y1)为出发点，确定和另外两个点是否都是同一个斜率</p><p>为了防止x1-x2为0的情况，转化为相乘的形式即可</p><h2><span id="di-er-ti-xiu-gai-gen-jie-dian">第二题：修改跟节点</span><a href="#di-er-ti-xiu-gai-gen-jie-dian" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/change-the-root-of-a-binary-tree/">1666. 改变二叉树的根节点 - 力扣（LeetCode）</a></p><p><img src="/images/22%E5%B9%B49%E6%9C%88/1662563625565.png" alt="1662563625565"></p><p>其实就是按照她这个规则修改，而且就是从叶子到root修改</p><p>那就是每次要把儿子节点带上来，而且要注意修改父节点的指向，很麻烦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node parent;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">flipBinaryTree</span><span class="params">(Node root, Node node)</span> &#123;</span><br><span class="line">        dfs(root, node, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> node;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root, Node node, Node son)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == son) &#123;</span><br><span class="line">            node.left = <span class="literal">null</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == root) &#123;</span><br><span class="line">            node.parent = son;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> node.parent;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = parent;</span><br><span class="line">        dfs(root, parent, node);</span><br><span class="line">         node.parent = son;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-09-06">2022-09-06</span><a href="#2022-09-06" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/">1404. 将二进制表示减到 1 的步骤数 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/JFETK5/">剑指 Offer II 002. 二进制加法 - 力扣（LeetCode）</a></p><p>都是模拟二进制加法，都是注意反过来计算，然后最后末尾补1好一点</p><p><a href="https://leetcode.cn/problems/Q91FMA/">剑指 Offer II 093. 最长斐波那契数列 - 力扣（LeetCode）</a></p><p>这个问题因为涉及a+b=c，前面有a和b两个数字才能决定c， 因此状态应该是a和b共同决定，因此dp要有2位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lenLongestFibSubseq</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++) &#123;</span><br><span class="line">        map.put(arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length+<span class="number">1</span>][arr.length+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> arr[j];</span><br><span class="line">            <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> num - num2;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(num3) || num3 &gt;=num2) &#123;</span><br><span class="line">                dp[j][i] =  <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index3</span> <span class="operator">=</span> map.get(num3);</span><br><span class="line">                dp[j][i] = dp[index3][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">2</span> ? res : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-09-05">2022-09-05</span><a href="#2022-09-05" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/">1974. 使用特殊打字机键入单词的最少时间 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/fix-names-in-a-table/">1667. 修复表中的名字 - 力扣（LeetCode）</a></p><p>SQL中存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(<span class="built_in">UPPER</span>(<span class="keyword">left</span>(name, <span class="number">1</span>)), <span class="built_in">LOWER</span>(<span class="keyword">RIGHT</span>(name, length(name) <span class="operator">-</span> <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>这些函数， 可以把第一个大写，其他都小写</p><p><a href="https://leetcode.cn/problems/find-total-time-spent-by-each-employee/">1741. 查找每个员工花费的总时间 - 力扣（LeetCode）</a></p><p>group by是可以针对2组key进行的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> event_day <span class="keyword">as</span> <span class="keyword">day</span>, emp_id, <span class="built_in">sum</span>(out_time<span class="operator">-</span>in_time) <span class="keyword">as</span> total_time <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> event_day,emp_id;</span><br></pre></td></tr></table></figure><p>统计每个员工每天的工作总时间</p><h1><span id="2022-09-04-zhou-sai">2022-09-04 周赛</span><a href="#2022-09-04-zhou-sai" class="header-anchor">#</a></h1><h1><span id="2022-09-03-shuang-zhou-sai">2022-09-03：双周赛</span><a href="#2022-09-03-shuang-zhou-sai" class="header-anchor">#</a></h1><h1><span id="2022-09-02">2022-09-02</span><a href="#2022-09-02" class="header-anchor">#</a></h1><h2><span id="di-yi-ti-di-gui-jian-dan-ti">第一题： 递归简单题</span><a href="#di-yi-ti-di-gui-jian-dan-ti" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/nested-list-weight-sum-ii/">364. 加权嵌套序列和 II - 力扣（LeetCode）</a></p><p>题目比较难理解，类似于给了一个树， 注意maxDepth也就是树的最大深度的意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">                Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger nest : nestedList) &#123;</span><br><span class="line">            dfs(nest, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger nest : nestedList) &#123;</span><br><span class="line">            sum += dfs2(nest, <span class="number">1</span>, maxDep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(NestedInteger nest, <span class="type">int</span> dep)</span> &#123;</span><br><span class="line">            maxDep = Math.max(maxDep, dep);</span><br><span class="line">        <span class="keyword">if</span>(nest.isInteger()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nexts = nest.getList();</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxDep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (NestedInteger next : nexts) &#123;</span><br><span class="line">                dfs(next, dep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs2</span><span class="params">(NestedInteger nest, <span class="type">int</span> dep, <span class="type">int</span> maxDep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nest.isInteger()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nest.getInteger();</span><br><span class="line">            <span class="keyword">return</span> num * (maxDep - dep + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nexts = nest.getList();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (NestedInteger next : nexts) &#123;</span><br><span class="line">                sum += dfs2(next, dep + <span class="number">1</span>, maxDep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="di-er-ti-dui-jiao-xian-pan-duan">第二题：对角线判断</span><a href="#di-er-ti-dui-jiao-xian-pan-duan" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/">2319. 判断矩阵是否是一个 X 矩阵 - 力扣（LeetCode）</a></p><p><img src="/images/22%E5%B9%B49%E6%9C%88/1662168968681.png" alt="1662168968681"></p><p>主要考察对 正方形对角线的处理, 确定y的情况下，这一行上符合对角线的点是(y, y)和(y, xlen - 1 - y)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkXMatrix</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ylen</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xlen</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> xlen - <span class="number">1</span> - y;</span><br><span class="line">        <span class="keyword">if</span> (grid[y][x1] == <span class="number">0</span> || grid[y][x2] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == x1 || x == x2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[y][x] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="di-san-ti-jia-fa-shu-zhi-yao-yuan-su-du-yi-zhi-na-jiu-shi-xiang-deng">第三题：加法树只要元素都一致那就是相等</span><a href="#di-san-ti-jia-fa-shu-zhi-yao-yuan-su-du-yi-zhi-na-jiu-shi-xiang-deng" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/">1612. 检查两棵二叉表达式树是否等价 - 力扣（LeetCode）</a></p><p><img src="/images/22%E5%B9%B49%E6%9C%88/1662169121771.png" alt="1662169121771"></p><p>其实无论什么顺序， 因为只有加法，都是一样的，只要元素（叶子节点）完全一致即可,也可以用map判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkEquivalence</span><span class="params">(Node root1, Node root2)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    get(root1, list1);</span><br><span class="line">    get(root2, list2);</span><br><span class="line">    Collections.sort(list1);</span><br><span class="line">    Collections.sort(list2);</span><br><span class="line">    <span class="keyword">return</span> list1.equals(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Node node, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val != <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        list.add((<span class="type">int</span>)node.val);</span><br><span class="line">    &#125;</span><br><span class="line">     get(node.left, list);</span><br><span class="line">     get(node.right, list) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="2022-09-01">2022-09-01</span><a href="#2022-09-01" class="header-anchor">#</a></h1><h2><span id="di-yi-ti-jian-dan-er-cha-shu-di-gui">第一题：简单二叉树递归</span><a href="#di-yi-ti-jian-dan-er-cha-shu-di-gui" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree/">2331. 计算布尔二叉树的值 - 力扣（LeetCode）</a></p><p>没啥好说的直接遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">evaluateTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> evaluateTree(root.left) || evaluateTree(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">           <span class="keyword">return</span> evaluateTree(root.left) &amp;&amp; evaluateTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="di-er-ti-jian-dan-hui-wen-pan-duan">第二题：简单回文判断</span><a href="#di-er-ti-jian-dan-hui-wen-pan-duan" class="header-anchor">#</a></h2><p><a href="https://leetcode.cn/problems/valid-palindrome-iv/">2330. 有效的回文 IV - 力扣（LeetCode）</a></p><p>没看懂这题的意义是啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makePalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="di-san-ti-tan-xin-jian-ge-bai-fang-zi-fu-yao-qiu-zui-chang">第三题：贪心间隔摆放字符要求最长</span><a href="#di-san-ti-tan-xin-jian-ge-bai-fang-zi-fu-yao-qiu-zui-chang" class="header-anchor">#</a></h2><p><img src="/images/22%E5%B9%B49%E6%9C%88/1662049690107.png" alt="1662049690107"></p><p>这种给几种字母让你排列， 一般都是要间隔放，而且每次都是优先放大的那2个。</p><p>这题我就是每次选2个当前最大的，然后放进去。 当都放完，看下有剩余的（且肯定是单个），再找到那个字母数量都+1， 再有剩余就不处理了。和答案思路基本一致</p><p><img src="/images/22%E5%B9%B49%E6%9C%88/1662049857921.png" alt="1662049857921"></p><p>这题里面我用了int[]来表示， 答案定义了Pair类，以后可以参考下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">longestDiverseString</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="string">&#x27;a&#x27;</span>, a&#125;,&#123;<span class="string">&#x27;b&#x27;</span>, b&#125;,&#123;<span class="string">&#x27;c&#x27;</span>,c&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(arr[<span class="number">0</span>][<span class="number">1</span>] &gt; <span class="number">0</span> || arr[<span class="number">1</span>][<span class="number">1</span>] &gt; <span class="number">0</span> || arr[<span class="number">2</span>][<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如何得到3个的排序？</span></span><br><span class="line">            <span class="comment">// 每次选前2个放进来</span></span><br><span class="line">            Arrays.sort(arr, (x,y)-&gt;(y[<span class="number">1</span>] - x[<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>][<span class="number">0</span>], <span class="number">1</span>&#125;);</span><br><span class="line">                arr[<span class="number">0</span>][<span class="number">1</span>]--;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">1</span>][<span class="number">0</span>], <span class="number">1</span>&#125;);</span><br><span class="line">                arr[<span class="number">1</span>][<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[<span class="number">0</span>][<span class="number">0</span>], <span class="number">1</span>&#125;);</span><br><span class="line">                arr[<span class="number">0</span>][<span class="number">1</span>]--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() &amp;&amp; arr[<span class="number">0</span>][<span class="number">1</span>] &gt; <span class="number">0</span>;i++) &#123;</span><br><span class="line">                    <span class="type">int</span>[] ar = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (ar[<span class="number">0</span>] == arr[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                        ar[<span class="number">1</span>]++;</span><br><span class="line">                        arr[<span class="number">0</span>][<span class="number">1</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ar : list) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>)ar[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (ar[<span class="number">1</span>] ==<span class="number">2</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>)ar[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年9月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP注解应用</title>
      <link href="/2022/09/01/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/"/>
      <url>/2022/09/01/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p>[toc]</p><ul><li><p>增加了@AspectJ注解形式的AOP使用方式</p><p>注意只是使用方式变了，底层的实现逻辑和基本概念还是相同的。</p><p>注解形式的pointcut：<br>可通过注解直接定义pointcut内容，就不需要实现里面的方法了<br>这里的方法名仅仅是作为1个代号，代号可以提供给其它的pointcut去合并使用</p><p>下面这个图，二者标识的pointcut其实是一样的<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/82adc5bbf93caa060e7649ff9c73c9c3370480e7.png" alt="82adc5bbf93caa060e7649ff9c73c9c3370480e7"></p><p>引用时也能包含包名</p><p>pointcut表达式符号：<br>execution(指定方法签名，支持通配)： 标识仅支持方法执行类型的joinPoint<br>并支持方法参数识别<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/93ad48e07377ac8591a10b2564b89e7845238640.png" alt="93ad48e07377ac8591a10b2564b89e7845238640"></p><p>within 匹配<br>只能和包路径相关<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/0c416b8d211008bddc39219e2ba16087ffefb398.png" alt="0c416b8d211008bddc39219e2ba16087ffefb398"></p><p>@within（注解类名）<br>比上面多了个@，相当于只切入标注了某个注解的方法，且只用于对象是否标注了这个注解类名的注解</p><p>this(objectType)<br>当目标对象的代理对象是objectType，则切入</p><p>target(objectType)<br>当目标对象是objectType,则切入<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/eb927a4ab949516c2436f86038ed53c1cc00d4e3.png" alt="eb927a4ab949516c2436f86038ed53c1cc00d4e3"><br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/9921eefea0e72b57b2ae905ef1d340d8ccbd9173.png" alt="9921eefea0e72b57b2ae905ef1d340d8ccbd9173"><br>@target（注解类型）<br>如果对象的目标对象 拥有target括号里的注解类型，则切入</p><p>args<br>指定方法输入参数<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/6150e3e656d5bf81f4cfe3d77d02dd5d223dd52b.png" alt="6150e3e656d5bf81f4cfe3d77d02dd5d223dd52b"></p><p>@annotation<br>系统内所有标注了annotation的方法，都会切入。 和@within的区别在于前者是方法，后者是对象<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/372535ab8ea8a2c77bf69b070a2c05bcde4cb335.png" alt="372535ab8ea8a2c77bf69b070a2c05bcde4cb335"></p><p>注解形式的Advice<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/56a84406b604aecce420c12d942ba93526f26998.png" alt="56a84406b604aecce420c12d942ba93526f26998"><br>可以和pointcut 合并？</p><p><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/cad1ea69bdfce12bff029f46bbe9848b12322677.png" alt="cad1ea69bdfce12bff029f46bbe9848b12322677"></p><p><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/ae8ce5ca694623441181af71dca6155d822e9e68.png" alt="ae8ce5ca694623441181af71dca6155d822e9e68"></p><p><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/0e176c14cd01488fe4e90e65cabf0f582d80c46e.png" alt="0e176c14cd01488fe4e90e65cabf0f582d80c46e"><br>@AspectJ的注意事项：</p><p>如果类中定义了多个相同位置的@advice， 则执行顺序取决于声明顺序</p><p><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/070bcb0b29a519f5d2d842885461f5681c4e5bb2.png" alt="070bcb0b29a519f5d2d842885461f5681c4e5bb2"><br>如果有多个AspectJ类， 然后不同aspectJ的advice冲突了，怎么办？<br>需要实现Order接口，否则是不确定顺序<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/96574a574ffed6e4dee6477a922da1a12a5d2051.png" alt="96574a574ffed6e4dee6477a922da1a12a5d2051"></p><p>也可以指定实例化的方式，默认是单例实例化。</p><p><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/4b69c4b45e1e1a67ba51196cf7654e1a2982daef.png" alt="4b69c4b45e1e1a67ba51196cf7654e1a2982daef"></p><p>嵌套执行代理的问题：<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/f6a306ee8b151bbc9b210a7083de0a3bb16e3bd6.png" alt="f6a306ee8b151bbc9b210a7083de0a3bb16e3bd6"><br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/79b459a1b92d33b253f8db3ae3250cb4ce30882c.png" alt="79b459a1b92d33b253f8db3ae3250cb4ce30882c"></p><p>如果执行method1，  只会进行method1的代理，  method2并不会动， 这是因为底层原理，导致 我们生成1个method1的代理后，  执行时里面的method2并不会动， 即method1的代理里没有method2的代理，。<br>之所叫横切，就是因为他会切入到同一个逻辑层上，<br>如果需要层层横切，需要在method1里调用method2的代理<br><img src="/images/AOP%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/052b9e9888e60902ec8e7596f59f7300bbe3bb63.png" alt="052b9e9888e60902ec8e7596f59f7300bbe3bb63"><br>而这个代理可以用注入的方式，不要在这里写死。<a href="https://www.cnblogs.com/cloudwill/p/13648539.html">https://www.cnblogs.com/cloudwill/p/13648539.html</a>)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> spring原理 </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,spring原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP实现原理</title>
      <link href="/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#springaop-de-dong-tai-dai-li">SpringAOP的动态代理</a><ul><li><a href="#jdk-dai-li">JDK代理</a><ul><li><a href="#cglib-dong-tai-zi-jie-ma-sheng-cheng">CGLIB动态字节码生成：</a></li></ul></li></ul></li></ul><!-- tocstop --></div> <p>[toc]<br>SpringAOP采用动态代理机制和字节码生成技术实现。<br>在运行期间，为目标对象生成1个代理对象，并把横切逻辑织入到代理对象中。系统运行时用的是代理对象，而非目标对象。</p><p>复习静态代理模式：</p><p><img src="/images/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/fb5135fa4b3e6ebfb33692fe85e6fb56d07ca1d2.png" alt="fb5135fa4b3e6ebfb33692fe85e6fb56d07ca1d2"><br><strong>缺点</strong>：  一旦横切逻辑变多，我们要手动添加的类也越多。如果要创建N多个代理对象，会很麻烦。另外如果加了1个方法，每个代理中也都要加，数量是很恐怖的。</p><hr><p><strong>java动态代理缺点</strong>： 如果类没有实现任何的接口，就无法使用动态代理生成动态代理对象。（即需要1个类似于request方法的对外接口，让外界即可用代理类访问，也可用原生类访问）</p><hr><h1><span id="springaop-de-dong-tai-dai-li">SpringAOP的动态代理</span><a href="#springaop-de-dong-tai-dai-li" class="header-anchor">#</a></h1><ul><li>如果发现对象实现了interface，就会用动态代理为其生成代理实例。</li><li>如果没有实现interface，则会尝试使用CGLIB的开源动态字节码生成类库，来为目标对象生成动态的代理实力。</li></ul><h3><span id="jdk-dai-li">JDK代理</span><a href="#jdk-dai-li" class="header-anchor">#</a></h3><p>Q: 为什么jdk代理的方式必须要接口？<br>A:<br>因为java动态代理的代理生成方法Proxy.newProxyInstance中，第二个参数就是被代理对象的inteface，通过这个他才能识别对哪些方法做代理（即根据接口找到方法做代理）</p><p>而且返回值就是这个接口类型。</p><p>Info proxyInfo = （Info）Proxy.newProxyInstance（代理类对象.getClass().getClassLoader()，实际对象.handler.getInterfaces(), 代理类对象.</p><h4><span id="cglib-dong-tai-zi-jie-ma-sheng-cheng">CGLIB动态字节码生成：</span><a href="#cglib-dong-tai-zi-jie-ma-sheng-cheng" class="header-anchor">#</a></h4><p>对目标对象进行继承，生成子类，然后子类中通过覆写方法来扩展父类的方法，把横切逻辑加入， 然后让系统调用扩展后的这个子类即可。<br>例子：<br>原类：<br><img src="/images/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/10b062705bc164ed9b0c075253f19d700b9bbc14.png" alt="10b062705bc164ed9b0c075253f19d700b9bbc14"><br>先实现1个MethodInterceptor（继承自Callback)接口，作为扩展类，里面就包含了横切逻辑 <img src="/images/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/e25c6ab0a93a9c3853c1572ea84ae06c2333095e.png" alt="e25c6ab0a93a9c3853c1572ea84ae06c2333095e">  <img src="/images/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/541de8756dc5fb393e27d95706eeb4d32f839c62.png" alt="541de8756dc5fb393e27d95706eeb4d32f839c62"></p><p>然后通过CGLIB的Enhancer对来生成扩展子类<br><img src="/images/AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/92faab1eefa2f8665648526eb8bf4ec8053c354e.png" alt="92faab1eefa2f8665648526eb8bf4ec8053c354e"></p><p>缺陷：  无法对final方法做覆写</p><hr><p>Q: 如果我做了AOP， AOP的那个类里有一个private方法，这个方法是在AOP的范围内的，有什么问题?<br>A: 如果那个方法里用到一个autowire注入的对象，就会报空指针。<br>原因：</p><ul><li>AOP本质是继承原类，生成一个CGLIB新类， 重写里面的public或者protect方法，替换成自己切入的那个方法。</li><li>从public方法切入后，实际上会走进原生bean对象，因此用的autowire对象是原生bean里的东西，是注入过的。</li><li>而private不会重写，因此代码没变，”不会跳转到原生bean里去调用“， 而CGLIB代理对象是不会做bean注入的（因为顺序问题，先bean初始化再AOP）， 所以我们调用privatge时，用的是CGLIB对象里的autowire成员，他从未被注入过。<br>详细源码：<a href="https://www.cnblogs.com/cloudwill/p/13648539.html">SpringAOP私有方法导致@Autowire注入失败原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> spring原理 </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,spring原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP基础概念</title>
      <link href="/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#san-chong-aop-lei-xing">三种AOP类型</a><ul><li><a href="#jing-tai-aop">静态AOP：</a></li><li><a href="#dong-tai-aop">动态AOP：</a></li><li><a href="#java-zi-dai-de-aop">java自带的AOP：</a></li></ul><ul><li><a href="#aop-gai-nian">AOP概念</a><ul><li><a href="#joinpoint-qie-ru-dian">Joinpoint 切入点</a></li><li><a href="#pointcut">PointCut</a></li><li><a href="#advice">Advice</a></li></ul></li><li><a href="#aspectpointcut">Aspectpointcut</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]<br>OOP(面向对象)无法解决系统需求（即所有业务模块的通用需求）的实现在系统中各处散落的问题</p><p>AOP： 面向切面编程</p><p><img src="/images/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/c202d80ab64f3b6840f064a267a68a99c312ee05.png" alt="c202d80ab64f3b6840f064a267a68a99c312ee05"></p><h1><span id="san-chong-aop-lei-xing">三种AOP类型</span><a href="#san-chong-aop-lei-xing" class="header-anchor">#</a></h1><h3><span id="jing-tai-aop">静态AOP：</span><a href="#jing-tai-aop" class="header-anchor">#</a></h3><p>第一代AOP，  AspectJ.<br>优点： 直接以Java字节码编译到java类中，不会对系统造成性能损失，<br>缺点：不够灵活，如果需要修改插入位置，就要重新编译。</p><h3><span id="dong-tai-aop">动态AOP：</span><a href="#dong-tai-aop" class="header-anchor">#</a></h3><p>在系统运行后插入到系统中， 且织入信息以外部XML文件格式保存。<br>缺点：性能有问题。但已经可以容忍这种损失j</p><h3><span id="java-zi-dai-de-aop">java自带的AOP：</span><a href="#java-zi-dai-de-aop" class="header-anchor">#</a></h3><ol><li>动态代理 缺点：只针对接口有效，且必须实现接口，有局限性<br>2.  动态字节码增强： 修改class文件的字节码来插入一些操作缺点： 如果要扩展的类或者方法声明为final，就不能进行子类化扩展<br>3. java代码生成， 通过工具生成代码部署到原代码中早起EJF容器使用最多，现在已经不用了<br>4. 自定义类加载器在类加载的时候，通过类加载器，修改读入的class字节码数据缺点：某些服务器可能不支持自定义或者本身类加载器会控制整个类加载体系，导致冲突<br>5. AOL扩展：直接用AOL这个语言去做。这个最强，也最难用。</li></ol><h2><span id="aop-gai-nian">AOP概念</span><a href="#aop-gai-nian" class="header-anchor">#</a></h2><h4><span id="joinpoint-qie-ru-dian">Joinpoint 切入点</span><a href="#joinpoint-qie-ru-dian" class="header-anchor">#</a></h4><p>切入点的位置选择共有7处：</p><ul><li>方法调用 ： 外部调用时的位置，还没进去</li><li>方法执行： 调用方法的内部的之前，  在方法调用之后</li><li>构造方法调用</li><li>字段设置 set或者this.xxx=xxx</li><li>字段获取 getxxx</li><li>异常处理执行</li><li>类初始化</li></ul><h4><span id="pointcut">PointCut</span><a href="#pointcut" class="header-anchor">#</a></h4><p>我认为是joinPoint的集合描述即如何描述<br>属于同一批的joinpoint, 即切到哪些地方？怎么描述我要切入的点？<br>4种表述方式：</p><ol><li>直接指定joinpoint所在方法名称</li><li>正则表达式3</li><li>使用特定的表述语言</li><li>在1-3的基础上，进行pointcut计算</li></ol><h4><span id="advice">Advice</span><a href="#advice" class="header-anchor">#</a></h4><p>代表你要怎么织入到joinpoint，即合适执行切面方法的策略， 在之前还是之后，还是其他。</p><ol><li><p><strong>beforAdvice</strong><br>在joinpoint指定位置之前执行<br>不会中断程序执行流程</p></li><li><p><strong>AfterAdvice</strong><br>在连接点之后执行的advice类型。还可以细分<br>① After return Advice 只有连接点完全执行完后，且无异常，才执行切面方法<br>②After throwing advice  只有抛出异常才执行<br>③After Advice ①和②的结合。<br><img src="http://doc.minidown.cn/emzqqy/assets/55b7e304a004c8a0a9c266fb2fa416bea8c747a4.png" alt="55b7e304a004c8a0a9c266fb2fa416bea8c747a4"></p></li><li><p><strong>Aroud Advice</strong><br>可以在joinpoint的之前之后都进行执行设置，类似于进行了包裹</p></li><li><p><strong>Introduction</strong></p></li></ol><p>根据jointPoint可以完成的功能来区分</p><h2><span id="aspectpointcut">Aspectpointcut</span><a href="#aspectpointcut" class="header-anchor">#</a></h2><p>和advice定义的封装实体<br><img src="/images/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/79cf416c8cc6bba1c32c878c410338da309aaa4d.png" alt="79cf416c8cc6bba1c32c878c410338da309aaa4d"><br>包含以下内容</p><ul><li><p><strong>织入器</strong><br>通过什么方式去织入，即实现， 例如类加载器之类的</p></li><li><p><strong>目标对象</strong><br>符合pointCut条件，将被织入的对象，称为目标对象<br><img src="/images/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/cbabf8d110b5cb869c5d9b975860b831001151eb.png" alt="cbabf8d110b5cb869c5d9b975860b831001151eb"></p></li></ul><hr><p>AOP应用案例：<br>异常捕捉：<br><img src="/images/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/62e0eff9d85533f8e8d8fd0bee1708e3fbe6e50b.png" alt="62e0eff9d85533f8e8d8fd0bee1708e3fbe6e50b"><br>可针对unchecked excpetion进行Fault Barrier的切入</p><p>安全检查：<br><img src="/images/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1661957687639.png" alt="1661957687639"></p><p>调用每个方法前都做一下检查</p><p>缓存：<br><img src="/images/AOP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/63e8d127f0be72f456bf449370b9f5c2e8f9ce26.png" alt="63e8d127f0be72f456bf449370b9f5c2e8f9ce26"><br>key可以理解为输入参数？</p><p>不过Spring已经支持Caching产品了使用了</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> spring原理 </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,spring原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ApplicationContext原理</title>
      <link href="/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/ApplicationContext%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/ApplicationContext%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#xin-te-xing-yi-tong-yi-zi-yuan-jia-zai-ce-lue">新特性一：统一资源加载策略</a></li><li><a href="#xin-zeng-te-xing-er-guo-ji-hua-xin-xi-zhi-chi">新增特性二：国际化信息支持</a></li><li><a href="#xin-zeng-te-xing-san-rong-qi-nei-bu-shi-jian-fa-bu">新增特性三：容器内部事件发布</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p>ApplicationContext除了拥有 BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括<br>BeanFactoryPostProcessor、<br>BeanPostProcessor<br>其他特殊类型bean的自动识别<br>容器启动后bean实例的自动初始化<br>国际化的信息支持<br>容器内事件发布等</p><hr><p>3种ApplicationContext的实现<br>FileSystemXmlApplicationContext  :从文件系统加载bean<br>ClassPathXmlApplicationContext :从Classpath加载bean<br>XmlWebApplicationContext :用于Web应用程序的ApplicationContext实现</p><hr><h1><span id="xin-te-xing-yi-tong-yi-zi-yuan-jia-zai-ce-lue">新特性一：统一资源加载策略</span><a href="#xin-te-xing-yi-tong-yi-zi-yuan-jia-zai-ce-lue" class="header-anchor">#</a></h1><p>Spring提出了一套基于Resource和ResourceLoader接口的资源抽象和加载策略。</p><ul><li>ByteArrayResource  将字节（byte）数组提供的数据作为一种资源进行封装? ClassPathResource    从Java应用程序的ClassPath中加载具体资源并进行封装</li><li>FileSystemResource 以文件或者URL的形 式对该类型资源进行访问，只要能跟File打的交道</li><li>UrlResource 通过java.net.URL进行的具体资源查找定位的实现类，内部委派URL进行具 体的资源操作。</li><li>InputStreamResource  较为少用。</li></ul><p>ResourceLoader:查找和定位这些资源,资源定位器<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/2020121023542886.png" alt="在这里插入图片描述"><br>相关资源的ResourceLoader实现类：</p><ul><li><p>DefaultResourceLoader<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201210235440383.png" alt="在这里插入图片描述"></p></li><li><p>FileSystemResourceLoader<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201210235504403.png" alt="在这里插入图片描述"></p></li><li><p>ResourcePatternResolver（ResourceLoade的子接口）<br>是1个批量查找的ResourceLoader，会返回resource数组 实<br>可以根据指定的资源路径匹配模式， 每次返回多个Resource实例<br>支持基 于Ant风格的路径匹配模式（类似于**/<em>.suffix之类的路径形式），支持ResourcePatternResolver新 增加的classpath</em>:前缀等</p></li></ul><p>总关系图<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201210235550881.png" alt="在这里插入图片描述"><br>ApplicationContextt<strong>默认继承了ResourcePatternResolver</strong>，间接实现了ResourceLoader接口<br><strong>任何的ApplicationContext实现都可以看作是一个 ResourceLoader甚至ResourcePatternResolver</strong></p><ul><li>ApplicationContext的资源用法：<br>1.扮演ResourceLoader的角色<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201210235917941.png" alt="在这里插入图片描述"></li></ul><p>2.ResourceLoader类型的注入<br>ApplicationContext类型容器可以自动识别Aware接口<br>因此会自动把自己注入到需要ResourceLoader的实例中<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201210235924349.png" alt="在这里插入图片描述"></p><p>3.Resource类型的注入<br>BeanFactory如果想注入Resource类型的bean定义，就需要注册自定义的PropertyEditor到 BeanFactory容器<br>而Application- Context容器可以正确识别Resource类型并转换后注入相关对象<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201210235930895.png" alt="在这里插入图片描述"></p><ol start="4"><li>在特定情况下，ApplicationContext的Resource加载行为</li></ol><p>Spring扩展了协议前缀的集合。<br>ResourceLoader中增加了一种新 的资源路径协议——classpath:，<br>ResourcePatternResolver又增加了一种——classpath*:。<br>classpath*:与classpath:的唯一区别就在于，如果能够在classpath中找到多个指定的资源，则 返回多个</p><p>ClassPathXmlApplicationContext默认从classpath中加载bean定义配置文件<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000020650.png" alt="在这里插入图片描述"></p><p>FileSystemXmlApplicationContext默认尝试从文件系统中加载bean定义文件<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/2020121100002444.png" alt="在这里插入图片描述"></p><p>但通过加前缀file或者classpath，可以修改加载方式</p><h1><span id="xin-zeng-te-xing-er-guo-ji-hua-xin-xi-zhi-chi">新增特性二：国际化信息支持</span><a href="#xin-zeng-te-xing-er-guo-ji-hua-xin-xi-zhi-chi" class="header-anchor">#</a></h1><p>1.Java SE 提供的国际化支持：<br>不同的 Locale代表不同的国家和地区，每个国家和地区在Locale这里都有相应的简写代码表ResourceBundle用来保存特定于某个Locale的信息<br>通过结合ResourceBundle和Locale，我们就能够实现应用程序的国际化信息支持</p><ol start="2"><li></li></ol><p>Spring在Java SE的国际化支持的基础上，进一步抽象了国际化信息的访问接口，也就是 MessageSource<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000046282.png" alt="在这里插入图片描述"></p><p>ApplicationContext还 实现了MessageSource接口，<br>3种MessageSource实现<br>StaticMessageSource  。可以通过编程的方式添加信息条目，多用于测试，不应该用于正式的生产环境。<br>ResourceBundleMessage  是常用的、用于正式生产环境<br>ReloadableResourceBundleMessageSource  定期刷新并检查底层的properties资源文件是否有变更。</p><p>ApplicationContext 启动的时候，会自动识别容器中类型为MessageSourceAware的bean定义<br>并将自身作为MessageSource注入相应对象实例中<br>PS：看一下自己工程里怎么实现的</p><h1><span id="xin-zeng-te-xing-san-rong-qi-nei-bu-shi-jian-fa-bu">新增特性三：容器内部事件发布</span><a href="#xin-zeng-te-xing-san-rong-qi-nei-bu-shi-jian-fa-bu" class="header-anchor">#</a></h1><p>java自带事件发布：<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000125858.png" alt="在这里插入图片描述"><br>ApplicationContext 容器内部允许以ApplicationEvent的形式发布事件，。<br>容器内注册的ApplicationListener类型的bean定义会被ApplicationContext容器自动识别<br>一旦容器内发布ApplicationEvent及其子类型的事件， 注册到容器的ApplicationListener就会对这些事件进行处理。</p><p><strong>application自定义事件ApplicationEvent</strong><br>Spring提供了三个实现。</p><ul><li>ContextClosedEvent：ApplicationContext容器在即将关闭的时候发布的事件类型。</li><li>ContextRefreshedEvent：ApplicationContext容器在初始化或者刷新的时候发布的事件类 型。</li><li>RequestHandledEvent：Web请求处理后发布的事件，其有一子类ServletRequestHandled- Event提供特定于Java EE的Servlet相关事件。</li></ul><p><strong>application自定义监听器ApplicationListener</strong><br>在启动时，会自动识别并加载EventListener类型bean定义， 一旦容器内有事件发布，将通知这些注册到容器的EventListener</p><p><strong>application自定义发布者ApplicationContext</strong><br>ApplicationContext接口定义还继承了ApplicationEventPublisher接口</p><p>容器启动伊始，就会检查容器内是否存在名称为ApplicationEventMulticaster的 ApplicationEventMulticaster对象实例。<br>有的话就使用提供的实现，没有则默认初始化一个 SimpleApplicationEventMulticaster作为将会使用的ApplicationEventMulticaster<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000243358.png" alt="在这里插入图片描述"></p><p><strong>Spring的ApplicationContext容器内的事件发布机制，主要用于单一容器内的简单消息通知和处 理，并不适合分布式、多进程、多容器之间的事件通知</strong><br>发布步骤：<br>1.MethodExecutionEvent的改装<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000302141.png" alt="在这里插入图片描述"></p><p>2.MethodExecutionEventListener的改<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000306623.png" alt="在这里插入图片描述"></p><p>3.MethodExeuctionEventPublisher改造<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000310121.png" alt="在这里插入图片描述"></p><ol start="4"><li>注册到ApplicationContext容器<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000312873.png" alt="在这里插入图片描述"></li></ol><p>特性四：多配置模块加载的简化<br><img src="/images/ApplicationContext%E5%8E%9F%E7%90%86/20201211000326999.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> spring原理 </category>
          
          <category> Ioc注入机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,spring原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0831</title>
      <link href="/2022/08/31/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-31/"/>
      <url>/2022/08/31/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-31/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-shu-zu-wen-ti">第一题:数组问题</a></li><li><a href="#di-er-ti-lian-biao-dao-shu-di-k-ge-yong-2-ge-zhi-zhen-wei-hu-ji-ke">第二题： 链表倒数第k个，用2个指针维护即可</a></li><li><a href="#di-san-ti-zhan-de-yan-zheng">第三题: 栈的验证</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-shu-zu-wen-ti">第一题:数组问题</span><a href="#di-yi-ti-shu-zu-wen-ti" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-domino-rotations-for-equal-row/">1007. 行相等的最少多米诺旋转 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-31/1661956709671.png" alt="1661956709671"></p><p><img src="/images/2022-08-31/1661956718077.png" alt="1661956718077"></p><p>很简单，搞3个统计数量的数组即可， 一个是去重后的总数，一个是A中各数字的总数，一个是B中各数字的总数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDominoRotations</span><span class="params">(<span class="type">int</span>[] tops, <span class="type">int</span>[] bottoms)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="type">int</span>[] counts1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="type">int</span>[] counts2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tops.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tops[i] == bottoms[i]) &#123;</span><br><span class="line">                counts[tops[i]]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts[tops[i]]++;</span><br><span class="line">                counts[bottoms[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            counts1[tops[i]]++;</span><br><span class="line">            counts2[bottoms[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">6</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i] == tops.length) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">changeCount</span> <span class="operator">=</span> Math.min(tops.length - counts1[i], tops.length - counts2[i]);</span><br><span class="line">                res = Math.min(res, changeCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-er-ti-lian-biao-dao-shu-di-k-ge-yong-2-ge-zhi-zhen-wei-hu-ji-ke">第二题： 链表倒数第k个，用2个指针维护即可</span><a href="#di-er-ti-lian-biao-dao-shu-di-k-ge-yong-2-ge-zhi-zhen-wei-hu-ji-ke" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/">1721. 交换链表中的节点 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-31/1661956816895.png" alt="1661956816895"></p><p>求倒数第k个，那就是先走k步，然后再以起点为另一个指针，两边一起走，直到走到尾部即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapNodes</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> newHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> node1;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> node1.val;</span><br><span class="line">        node1.val = node2.val;</span><br><span class="line">        node2.val = tmp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-san-ti-zhan-de-yan-zheng">第三题:  栈的验证</span><a href="#di-san-ti-zhan-de-yan-zheng" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-31/1661957045969.png" alt="1661957045969"></p><p>数据结构很基础的题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( i2 = <span class="number">0</span>;i2 &lt; popped.length;i2++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> popped[i2];</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == pop) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i1 &lt; pushed.length &amp;&amp; pushed[i1] != pop) &#123;</span><br><span class="line">               stack.push(pushed[i1]);</span><br><span class="line">               i1++; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i1 == pushed.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ioc基本概念和原理</title>
      <link href="/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/BeanFactory%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/31/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/BeanFactory%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#beanfactory-ji-chu-gai-nian">beanFactory基础概念</a><ul><li><a href="#dai-ma-bian-xie-fang-shi">代码编写方式</a></li><li><a href="#2-wai-bu-pei-zhi-wen-jian">2.外部配置文件</a></li><li><a href="#3-zhu-jie-fang-shi">3.注解方式</a></li></ul></li><li><a href="#beanfactory-shi-xian-yuan-li">BeanFactory实现原理</a><ul><li><a href="#ioc-qi-dong-guo-cheng">Ioc启动过程</a><ul><li><a href="#rong-qi-qi-dong-jie-duan">容器启动阶段：</a></li><li><a href="#shi-li-hua-jie-duan-jian-dan-ban">实例化阶段（简单版)</a></li></ul><ul><li><a href="#bean-shi-li-hua-de-xiang-xi-guo-cheng">Bean实例化的详细过程：</a><ul><li><a href="#di-yi-bu-shi-li-hua-qie-fan-hui-bao-zhuang-lei">第一步： 实例化，且返回包装类：</a></li><li><a href="#di-er-bu-ji-yu-beanwrapper-she-zhi-cheng-yuan-shu-xing">第二步：基于BeanWrapper设置成员属性</a></li><li><a href="#di-san-bu-jian-cha-aware-jie-kou">第三步：检查Aware接口</a></li><li><a href="#di-si-bu-beanpostprocessor-chu-li">第四步：BeanPostProcessor处理</a></li><li><a href="#di-wu-bu-chu-shi-hua">第五步： 初始化</a></li><li><a href="#liu-bu-zhu-ce-xi-gou-fang-fa">六步：注册析构方法</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="beanfactory-ji-chu-gai-nian">beanFactory基础概念</span><a href="#beanfactory-ji-chu-gai-nian" class="header-anchor">#</a></h1><p>Spring Ioc容器体系除了IOC serviceProvider，还包括其他的东西。<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201130235654874.png" alt="在这里插入图片描述"><br>图上可以看到除了IocProvider， 还包括了AOP、线程管理、周期管理之类的。</p><hr><p>Spring提供2种容器 BeanFactory和ApplicationContext<br>区别：</p><ul><li>BeanFactory:   延迟化加载。适合轻量级场景</li><li>ApplicationContext:    给予BeanFacotry构建， 除了支持BeamFacotry所有功能，还提供了其他特性）<br>ApplicationContext所管理 的对象，在该类型容器启动之后，默认全部初始化并绑定完成</li></ul><p>区别就是 1个是要用的时候才加载， 另一个是直接全部扫描并加载好（有点像jvm的client模式和server模式区别）</p><hr><p>BeanFacotry是1个接口， 最重要的方法是getBean（name）<br>BeanFacotry的调用方式:<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/2020120100004469.png" alt="在这里插入图片描述"></p><hr><p>BeanFactory里的几个重要概念：<br>用图书馆的比喻在图里标注了一下<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201000348873.png" alt="在这里插入图片描述"></p><hr><p>BeanFactory如何明确依赖关系，绑定依赖?</p><h3><span id="dai-ma-bian-xie-fang-shi">代码编写方式</span><a href="#dai-ma-bian-xie-fang-shi" class="header-anchor">#</a></h3><p>通过BeanDefinitionRegistry（BeamFacotry的实现，）去手动注册，  但是手动注册必须实现BeanDefintionRegistry：<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201000056610.png" alt="在这里插入图片描述"><br>基于SpringBoot ，怎么拿到BeanFactory进行直接编码？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写一下项目里怎么拿到BeanFactory</span><br></pre></td></tr></table></figure><h3><span id="2-wai-bu-pei-zhi-wen-jian">2.外部配置文件</span><a href="#2-wai-bu-pei-zhi-wen-jian" class="header-anchor">#</a></h3><p>支持Properties文件格式和XML文件格式<br>Spring会实现1个BeanDefinitionReader类，用于进行 &quot;图书的入库读取操作”， 并注册到BeanDefinetionRegistry里<br>propetris:<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201000559804.png" alt="在这里插入图片描述"></p><p>需要注意的一点，就是$0和$1后面的 (ref)，(ref)用来表示所依赖的是引用对象，而不是普通的类型。如果不加(ref)， PropertiesBeanDefinitionReader会将djListener和djPersister作为简单的String类型 进行注入<br>调用方式：<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201000605174.png" alt="在这里插入图片描述"><br>把reader绑定到registry，然后变成BeanFactory</p><p>xml:<br>，Spring同样为XML 格式的配置文件提供了现成的BeanDefinitionReader实现，即XmlBeanDefinitionReader</p><ul><li>SpringBoot（serviceComb里），这种配置文件到哪去了呢？？</li></ul><h3><span id="3-zhu-jie-fang-shi">3.注解方式</span><a href="#3-zhu-jie-fang-shi" class="header-anchor">#</a></h3><p>@Autowired@Autowired是这里的主角，它的存在将告知Spring容器需要为当前对象注入哪些依赖对象。同时如果要使用这个注解，必须在spring配置中增加context:component-scan</p><p>这个太常见了。<br>SpringBoot里配置了context:component-scan吗？</p><hr><h1><span id="beanfactory-shi-xian-yuan-li">BeanFactory实现原理</span><a href="#beanfactory-shi-xian-yuan-li" class="header-anchor">#</a></h1><p>官方关于IOC的参考图：<img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201231716188.png" alt="在这里插入图片描述"><br>它会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息）<br>然后根据这些信息绑定整个系统的对象，终组装成 一个可用的基于轻量级容器的应用系统。</p><h2><span id="ioc-qi-dong-guo-cheng">Ioc启动过程</span><a href="#ioc-qi-dong-guo-cheng" class="header-anchor">#</a></h2><p>总共分为2个阶段：<br>容器启动和实例化阶段。<br>并且在这里2个阶段中，加入了足够多的可扩展点。<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201231804371.png" alt="在这里插入图片描述"></p><h4><span id="rong-qi-qi-dong-jie-duan">容器启动阶段：</span><a href="#rong-qi-qi-dong-jie-duan" class="header-anchor">#</a></h4><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201231818619.png" alt="在这里插入图片描述"><br>从图里可以看到， Ioc从配置中将需要加载的元素映射成BeanDefintion， 并一一注册到BeanDefinitionRegistry中。</p><h4><span id="shi-li-hua-jie-duan-jian-dan-ban">实例化阶段（简单版)</span><a href="#shi-li-hua-jie-duan-jian-dan-ban" class="header-anchor">#</a></h4><blockquote><p>当某个请求方通过容器的getBean方法明确地请求某个对象，或者<strong>因依赖关系容器 需要隐式地调用getBean方法时</strong>，就会触发第二阶段的活动。</p></blockquote><ul><li>上面这句话可以看到， 不仅仅是getBean会触发，因为依赖所引发的也会进行初始化（有点像Java的Class初始化机制，既可以class.forName()，也可以间接触发？）</li></ul><p>实例化的简单过程如下：<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201232231192.png" alt="在这里插入图片描述"><br>这张图的要点就是：</p><ol><li>已经初始化过的，就不会再初始化了。</li><li>如果有一些回调的接口，会去调用再初始化装备</li></ol><h3><span id="bean-shi-li-hua-de-xiang-xi-guo-cheng">Bean实例化的详细过程：</span><a href="#bean-shi-li-hua-de-xiang-xi-guo-cheng" class="header-anchor">#</a></h3><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201232817436.png" alt="在这里插入图片描述"></p><h5><span id="di-yi-bu-shi-li-hua-qie-fan-hui-bao-zhuang-lei">第一步： 实例化，且返回包装类：</span><a href="#di-yi-bu-shi-li-hua-qie-fan-hui-bao-zhuang-lei" class="header-anchor">#</a></h5><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201233547577.png" alt="在这里插入图片描述"></p><p>容器在内部实现的时候，采用“策略模式（Strategy Pattern）”来决定采用何种方式初始化bean实例。<br>通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类<br>下面是一些用于初始化Bean时里的接口或者实现类</p><blockquote><p>InstantiationStrategy是实例化的策略抽象接口<br>SimpleInstantiationStrategy是实现类，只能反射来实例化对象实例，但不支持方法注入方式的对象实例化<br>CglibSubclassingInstantiation通过CGLIB 的动态字节码生成功能，该策略实现类可以动态生成某个类的子类，进而满足了方法注入所需的对象 实例化需求。（默认都用这个）<br>PS：确认一下工作项目里用的是什么接口的</p></blockquote><ul><li>实例化不是直接返回构造完成的对象实例，<em><strong>而是以BeanWrapper对构造完成的对象实例 进行包裹，返回相应的BeanWrapper实例</strong></em></li></ul><h5><span id="di-er-bu-ji-yu-beanwrapper-she-zhi-cheng-yuan-shu-xing">第二步：基于BeanWrapper设置成员属性</span><a href="#di-er-bu-ji-yu-beanwrapper-she-zhi-cheng-yuan-shu-xing" class="header-anchor">#</a></h5><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201233553114.png" alt="在这里插入图片描述"></p><p>实例化BeanWrapper后，会做类似如下操作<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201233142888.png" alt="在这里插入图片描述"></p><ul><li>从这张图可以看到之前为什么说 set注入很好用<br>这里只要调用setPropertyValue(成员名， 成员) 即可进行注入， 不用去反射特定的方法。</li></ul><h5><span id="di-san-bu-jian-cha-aware-jie-kou">第三步：检查Aware接口</span><a href="#di-san-bu-jian-cha-aware-jie-kou" class="header-anchor">#</a></h5><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201233559827.png" alt="在这里插入图片描述"></p><p>如果检测到有这个接口，则将这些Aware接口定义中规定的依赖注入给当前对象实例，都是一些特殊元素的注入。</p><p>啥意思呢……就是指有一些和Ioc（Bean或BeanFactory）相关的属性，可以通过Aware放进你要实例化的实例中。 这个我记得后面有例子，先略过，只放下几个Spring里的经典Aware：</p><blockquote><ul><li>BeanNameAware 检测到当前对象实 例实现了该接口，会将该对象实例的bean定义对应的beanName设置到当前对象实例</li><li>BeanClassLoaderAware 会将对应加载当前bean的Classloader注入当前对象实例</li><li>BeanFactoryAware，BeanFactory容器会将自身（即BeanFactory）设置到当前对象实例。这样，当前对象 实例就拥有了一个BeanFactory容器的引用，并且可以对这个容器内允许访问的对象按照需要 进行访问</li></ul></blockquote><h5><span id="di-si-bu-beanpostprocessor-chu-li">第四步：BeanPostProcessor处理</span><a href="#di-si-bu-beanpostprocessor-chu-li" class="header-anchor">#</a></h5><p>BeanPostProcessor， yyds！<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201234008721.png" alt="在这里插入图片描述"><br>BeanPostProcessor 是容器提供的对象实例化阶段的强有力的扩展点。</p><blockquote><p>BeanPostProcessor和BeanFactoryPostProcessor的区别：<br>BeanPostProcessor是存在于对象实例化阶段<br>而BeanFactoryPostProcessor则是存在于容器启动阶段</p></blockquote><ul><li>BeanPostProcessor可进行实例前处理和后处理，方法为postProcessBeforeInitialization（）和postProcessAfterInitialization（）</li><li>通常比较常见的使用BeanPostProcessor的场景，是处理标记接口实现类，或者为当前对象提供 代理实现（<strong>注意这个代理，为后面的Aop做铺垫</strong>）</li></ul><p>例如有个叫ApplicationContextAwareProcessor的， 会做一些和ApplicationContext相关的Bean前置处理（但是注意这时候已经实例化好了，只是还没调用自定义init方法！）<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201234443692.png" alt="在这里插入图片描述"><br>之前用过ApplicationContextAware，来在容器启动时，获取AplicationContext，进行你需要的处理。</p><p>书里介绍了一下自定义的BeanPostProcessor步骤，我就贴下里面BeanProcessor的实现：<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201235157966.png" alt="在这里插入图片描述"><br>看他就是自己实现了个BeanPostProcessor，然后用instance去判断是不是自己要处理的对象（每个都扫描了一遍~~）</p><p>问题： SpringBoot里要自己用代码注册BeanPostProcessor或者写到applicationContext配置里吗？</p><h5><span id="di-wu-bu-chu-shi-hua">第五步： 初始化</span><a href="#di-wu-bu-chu-shi-hua" class="header-anchor">#</a></h5><p>“BeanPostProcessor之后，  会检查实例对象是否实现了InitializingBean接口，如果是，调用其afterProper- tiesSet()方法进一步调整对象实例的状态。</p><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201235423266.png" alt="在这里插入图片描述"></p><p>缺点：如果真的让我们的业务对象实现这个接口，则显得 Spring容器比较具有侵入性。<br>改进：用init-method属性在xml中配置， 选择调用某个已实现方法来做初始化操作，并且不需要初始化时可以剔除。</p><ul><li>注意init的顺序和BeanPostProcessor</li><li><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201235507786.png" alt="在这里插入图片描述"></li></ul><h5><span id="liu-bu-zhu-ce-xi-gou-fang-fa">六步：注册析构方法</span><a href="#liu-bu-zhu-ce-xi-gou-fang-fa" class="header-anchor">#</a></h5><p>例如数据池对象，需要在结束时，执行close操作<br><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201235528930.png" alt="在这里插入图片描述"></p><p>但Spring容器在关闭之前， 不会自动调用这些回调方法。<br>所以，需要我们告知容器，在哪个时间点来执行对象的自定义销 毁方法</p><p>对于BeanFactory容器来说，调用ConfigurableBeanFactory提供的 destroySingletons()方法销毁容器中管理的所有singleton类型的对象实例。</p><p><img src="/images/BeanFactory%E5%8E%9F%E7%90%86/20201201235533802.png" alt="在这里插入图片描述"></p><p>对于ApplicationContext容器来说  可用registerShutdownHook（涉及底层runtime方法）<br>保证在Java虚拟机退出之前，这些singtleton类型的bean对象 实例的自定义销毁逻辑会被执行</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> spring原理 </category>
          
          <category> Ioc注入机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,spring原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0830</title>
      <link href="/2022/08/30/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-30/"/>
      <url>/2022/08/30/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-30/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti">第一题：</a></li><li><a href="#di-er-ti-topk-wen-ti">第二题 topk问题</a></li><li><a href="#di-san-ti-shu-de-bian-li-he-cha-ru">第三题 树的遍历和插入</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti">第一题：</span><a href="#di-yi-ti" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/find-lucky-integer-in-an-array/">1394. 找出数组中的幸运数 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-30/1661875618698.png" alt="1661875618698"></p><p>哈希表？数组？没啥意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLucky</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">501</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : arr) &#123;</span><br><span class="line">            counts[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i] == i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="di-er-ti-topk-wen-ti">第二题 topk问题</span><a href="#di-er-ti-topk-wen-ti" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数 - 力扣（LeetCode）</a></p><p>topk问题别急着用sort，太简单</p><p>升级方法是堆（优先队列）， 要求最小的几个，那其实就要搞个大顶堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        Queue&lt;Integer&gt; pqueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(b-a));</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">                pqueue.offer(arr[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pqueue.peek() &gt; arr[i]) &#123;</span><br><span class="line">                pqueue.poll();</span><br><span class="line">                pqueue.offer(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k;i++) &#123;</span><br><span class="line">            res[i] = pqueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再升级的话用快排思想，每次划分后，挑可能有k的那一边继续划分，具体比较难理解就不管了，先放个答案在这，后面自己有空重写下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        randomizedSelected(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="type">int</span>[] vec = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">randomizedSelected</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> randomizedPartition(arr, l, r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> pos - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == num) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; num) &#123;</span><br><span class="line">            randomizedSelected(arr, l, pos - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            randomizedSelected(arr, pos + <span class="number">1</span>, r, k - num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于随机的划分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomizedPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(nums, r, i);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[r];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/solution/zui-xiao-de-kge-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1><span id="di-san-ti-shu-de-bian-li-he-cha-ru">第三题  树的遍历和插入</span><a href="#di-san-ti-shu-de-bian-li-he-cha-ru" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/submissions/detail/356972453/">最大二叉树 II - 提交记录 - 力扣（LeetCode）</a></p><p>sb题目，看不懂题意， 其实就是把要插入的值优先右边放，直到某个点比自己小，那就可以取代这个点的位置，把这个点当成自己的左节点即可 ，题意写的乱七八糟的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoMaxTree</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            newRoot.left = root;</span><br><span class="line">            <span class="keyword">return</span> newRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, val, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> val, TreeNode parent, <span class="type">boolean</span> isLeft)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val &lt; val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">                parent.left = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.left = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dfs(node.right, val, node, <span class="literal">false</span>)  ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非暴力沟通</title>
      <link href="/2022/08/30/%E9%9A%8F%E7%AC%94/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/"/>
      <url>/2022/08/30/%E9%9A%8F%E7%AC%94/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1><span id="cuo-wu-de-yu-yan-huo-zhe-biao-shu">错误的语言或者表述</span><a href="#cuo-wu-de-yu-yan-huo-zhe-biao-shu" class="header-anchor">#</a></h1><h2><span id="dao-de-ping-pan">道德评判</span><a href="#dao-de-ping-pan" class="header-anchor">#</a></h2><p>对他人或者他人的行为做出评判和批评</p><p>应该调整为  对具体事情或者非主体的概念描述自己的感受和看法， 不能去否认对方本身。</p><h2><span id="zuo-bi-jiao">作比较</span><a href="#zuo-bi-jiao" class="header-anchor">#</a></h2><p>被人拿去左比较一定会难受的</p><h2><span id="tui-xie-ze-ren">推卸责任</span><a href="#tui-xie-ze-ren" class="header-anchor">#</a></h2><p>我不得不那么做， 我必须这样，都是因为某某某我只能这么做</p><p>缺少自己的真实感受和实际期望</p><h2><span id="zong-shi-ti-yao-qiu">总是提要求</span><a href="#zong-shi-ti-yao-qiu" class="header-anchor">#</a></h2><h1><span id="zhu-yi-qu-fen-guan-cha-he-ping-lun">注意区分观察和评论</span><a href="#zhu-yi-qu-fen-guan-cha-he-ping-lun" class="header-anchor">#</a></h1><p>与人沟通或者描述某些人时，</p><p>注意不要使用 “评论”，即主观的形容词</p><p>例如  你太懒了， 你很不懂事，你时好人，你总是xxx</p><p>观察则是带有具体事实和事件的</p><p>例如你昨天做了什么什么，   他每周都有一次xxxx</p><p>和对方沟通应该以观察为主， 尽可能不要用评论对方的方式来提出自己的观点或者诉求</p><h1><span id="ti-hui-he-biao-da-gan-shou">体会和表达感受</span><a href="#ti-hui-he-biao-da-gan-shou" class="header-anchor">#</a></h1><h2><span id="qu-fen-xiang-fa-he-gan-shou">区分想法和感受</span><a href="#qu-fen-xiang-fa-he-gan-shou" class="header-anchor">#</a></h2><p>感受是心情上的描述词，是客观的自己的内在感受，例如我很难过，我很高兴，我很害怕</p><p>而想法是主观的，可能是错误推断的，比如我觉得我xxxx，我觉得你xxxx，你是xxx的，我是xxx的</p><p>xxx让我很生气，这也是想法，因为里面的重点在于生气的原因。 应该改成我感到生气</p><h1><span id="wei-zi-ji-de-gan-shou-fu-ze">为自己的感受负责</span><a href="#wei-zi-ji-de-gan-shou-fu-ze" class="header-anchor">#</a></h1><p>表达完自己的感受后，  应当紧接自己的内在需要，或者说自己出现这种感受的“原因”，而原因来源于需要或者自己的期望。</p><p>而这个原因的主题必须是自己，而不是能是别人，也不能是对别人不做某事的职责。</p><p>比如我感到生气， 因为你迟到了</p><p>改成</p><p>我感到生气，因为本来我是希望能做到前排的位置的</p><p>我感到生气，因为你把文件丢到了地上毛手毛脚的</p><p>改成</p><p>你把文件丢到地上，我会有点生气， 因为这些文件很重要，我希望能好好报关</p><p>我感到难过，因为你总是不肯工作一直不上进</p><p>改成</p><p>我感到难过， 因为我希望你能独立并过上你自己想要的生活，我的压力也能轻松一点</p><h1><span id="ti-chu-qing-qiu">提出请求</span><a href="#ti-chu-qing-qiu" class="header-anchor">#</a></h1><h2><span id="jin-liang-shi-yong-zheng-xiang-de-ju-ti-de-qing-qiu-yu-yan-er-fei-fan-xiang-de-mo-hu-yu-yan">尽量使用正向的、具体的请求语言，而非反向的、模糊语言</span><a href="#jin-liang-shi-yong-zheng-xiang-de-ju-ti-de-qing-qiu-yu-yan-er-fei-fan-xiang-de-mo-hu-yu-yan" class="header-anchor">#</a></h2><p>你不要做xxx 改成我希望你做xxxx</p><p>你要像某某某热门 改成 你希望你 做某某某具体的事情</p><p>我希望你不要再喝酒了 改成 除了喝酒，有没有其他的方式可以替代？</p><h2><span id="jin-liang-shi-yong-ju-ti-de-qing-qiu-yu-yan-er-fei-mo-hu-de-qing-qiu">尽量使用具体的请求语言，而非模糊的请求</span><a href="#jin-liang-shi-yong-ju-ti-de-qing-qiu-yu-yan-er-fei-mo-hu-de-qing-qiu" class="header-anchor">#</a></h2><p>我希望你理解我  改成 能不能告诉我在你听来，我说的是什么意思</p><p>我希望你尊重我的隐私  改成 我希望你进门时先敲门</p><h2><span id="bu-neng-zhi-ti-gan-shou-bu-shuo-qing-qiu-ye-bu-neng-zhi-shuo-qing-qiu-bu-shuo-gan-shou">不能只提感受不说请求，也不能只说请求不说感受</span><a href="#bu-neng-zhi-ti-gan-shou-bu-shuo-qing-qiu-ye-bu-neng-zhi-shuo-qing-qiu-bu-shuo-gan-shou" class="header-anchor">#</a></h2><h2><span id="wei-liao-fang-zhi-wu-jie-qing-qiu-ke-yi-rang-bie-ren-fu-shu-yi-xia-shi-fou-li-jie-liao">为了防止误解请求，可以让别人复述一下是否理解了</span><a href="#wei-liao-fang-zhi-wu-jie-qing-qiu-ke-yi-rang-bie-ren-fu-shu-yi-xia-shi-fou-li-jie-liao" class="header-anchor">#</a></h2><h2><span id="ti-chu-qing-qiu-hou-ke-yi-xiang-dui-fang-suo-yao-ta-ci-ke-de-gan-shou">提出请求后， 可以向对方索要他此刻的感受</span><a href="#ti-chu-qing-qiu-hou-ke-yi-xiang-dui-fang-suo-yao-ta-ci-ke-de-gan-shou" class="header-anchor">#</a></h2><p>即你提出请求，对方统一后， 可以问一下他的感受，避免他为了过分顾及他们而不说话</p><h2><span id="qu-fen-qing-qiu-he-yao-qiu">区分请求和要求</span><a href="#qu-fen-qing-qiu-he-yao-qiu" class="header-anchor">#</a></h2><p>如果对方没有给出你想要的回应，你就生气、不高兴，说你简直是xxx，你怎么可以这样，那就是要求， 是会引发逆反的</p><p>但如果是请求，在对方没有给出想要的回应时，往往会先去体会对方的感受和需求，尝试询问对方拒绝的原因 ，而不是直接不开心并把不开心表现给对方看。</p><h1><span id="tong-li-xin">同理心</span><a href="#tong-li-xin" class="header-anchor">#</a></h1><h2><span id="qing-ting">倾听</span><a href="#qing-ting" class="header-anchor">#</a></h2><p>面对伤心的人， 避免以下任何选项</p><ul><li>给建议：你应该怎么做</li><li>比惨：我也xxxx</li><li>无用的安慰：你尽力了，你是最好的</li><li>讲故事：我曾经balabla</li><li>同情：</li><li>询问：</li><li>纠正</li></ul><p>应该做的，是<strong>用心</strong>聆听他们的 观察(发生的事实）、感受、需要和请求。</p><p>一个人生气或者伤心， 一定是因为某种需要没有被满足，满足需求则一定对应这某个请求！</p><p>因此在你做出行动前，必须好好倾听！</p><h2><span id="fu-shu">复述</span><a href="#fu-shu" class="header-anchor">#</a></h2><ul><li>复述事实：  我看发生了这事情，你说的是这个对吧？</li><li>感受： 你现在感觉很伤心，因为你希望xxx</li><li>请求：你是不是希望我能做xxxx</li></ul><p>避免没有具体内容、过于宽泛的的问题</p><p>例如”你说的是什么事？“、”你想我怎么做“</p><p>我们需要给他的是一个 判断题，让他自己决定我们复述的正确或者错误</p><p>如果对方实在说不清楚，我们不懂它的感受和需要，那就先以自己的感受为前提为他提出请求</p><p>”我很困惑，我希望你能告诉我你指的是哪件事“</p><p>要是询问， 避免下结论， 例如”哦你现在就是因为这个xxxx才对吧“， 这种语气不合适！</p><p>要注意倾听，不要着急做同理的询问</p><h1><span id="dang-dui-fang-shuo-bu">当对方说”不“</span><a href="#dang-dui-fang-shuo-bu" class="header-anchor">#</a></h1><p>当对方拒绝我们时，一定是她的需要和我们的请求不满足， 这时候应该去思考对方的感受并提出询问</p><h1><span id="da-duan-luo-suo-dui-hua">打断啰嗦对话</span><a href="#da-duan-luo-suo-dui-hua" class="header-anchor">#</a></h1><p>当对方复述自己过去悲惨的经历让你很不耐烦时，可以直接用同理的方式表达对她的理解，让他不要再往下讲了</p><h1><span id="fei-bao-li-gou-tong-shan-dai-zi-ji">非暴力沟通善待自己</span><a href="#fei-bao-li-gou-tong-shan-dai-zi-ji" class="header-anchor">#</a></h1><p>把自己觉得不得不的事情都列出来， 尝试改成是处于自己内在的需求所选择的！</p><p>避免以下几种：</p><ul><li>为了钱</li><li>为了他人的评价和认可</li><li>为了免受惩罚、内疚、羞愧</li><li>为了“应该”、“不应该”的职责</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔,心理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0829</title>
      <link href="/2022/08/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-29/"/>
      <url>/2022/08/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-29/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-zhao-gui-lu-ti">第一题：找规律题</a></li><li><a href="#di-er-ti-zhao-chong-fu-shu-zi-jiu-yao-ji-de-li-yong-wei-yun-suan-yi-huo">第二题：找重复数字就要记得利用位运算异或</a></li><li><a href="#di-san-ti-shuang-zhi-zhen-chu-li-tui-ge-wen-ti">第三题：双指针处理退格问题</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-zhao-gui-lu-ti">第一题：找规律题</span><a href="#di-yi-ti-zhao-gui-lu-ti" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-29/1661791574759.png" alt="1661791574759"></p><p>就是找规律</p><p>从左往右，确认前后是否满足x&lt;=y，是就继续往下遍历</p><p>当发现不满足时， 要么是2466111这种有2个6，要么是2456111这种有1个6</p><p>前者要变成2459999， 后者变成2455999</p><p>可以看到就是找到6的最左边，把他变成6-1之后， 后面的全是9即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">is9</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is9) &#123;</span><br><span class="line">                cs[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; s.length() &amp;&amp; num &gt; s.charAt(i+<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 往前面找到可以满足减1的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;num == s.charAt(j) - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i = j;</span><br><span class="line">                cs[i] = (<span class="type">char</span>)(s.charAt(i) - <span class="number">1</span>);</span><br><span class="line">                is9 = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cs[i] = (<span class="type">char</span>)(num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                max = Math.max(num, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(<span class="keyword">new</span> <span class="title class_">String</span>(cs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="di-er-ti-zhao-chong-fu-shu-zi-jiu-yao-ji-de-li-yong-wei-yun-suan-yi-huo">第二题：找重复数字就要记得利用位运算异或</span><a href="#di-er-ti-zhao-chong-fu-shu-zi-jiu-yao-ji-de-li-yong-wei-yun-suan-yi-huo" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/set-mismatch/">645. 错误的集合 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-29/1661791743394.png" alt="1661791743394"></p><p>有时间O(nlogn)的排序解法（排序的时候求丢失的数字也很麻烦）</p><p>也有空间O（n)的哈希表解法</p><p>最佳应该是时间O(N)空间O(1)，即利用位运算特点</p><p>将当前数组和1~n数组合并成1个新数组</p><p>那么丢失的数字a只有1个， 重复的数字b则有3个， 其他的都是2个</p><p>通过异或得到a^b的值</p><p>那么就是经典的分组方法， 先找到a^b中不相同的某一位， 然后进行划分分组， 基于划分后的分组再做异或，就能得到2个值了。</p><p>再遍历一次就能知道谁丢了谁重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findErrorNums(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">xorSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">           xorSum ^= (i+<span class="number">1</span>);</span><br><span class="line">           xorSum ^= nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">diffBit</span> <span class="operator">=</span> xorSum &amp; (-xorSum);</span><br><span class="line">       <span class="type">int</span> <span class="variable">sum0</span> <span class="operator">=</span> <span class="number">0</span>, sum1 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((nums[i] &amp; diffBit) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               sum1 ^= nums[i];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sum0 ^= nums[i];</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (((i+<span class="number">1</span>) &amp; diffBit) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               sum1 ^= (i+<span class="number">1</span>) ;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sum0 ^= (i+<span class="number">1</span>) ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">           <span class="keyword">if</span> (num == sum1) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;sum1, sum0&#125;;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == sum0)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;sum0, sum1&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="di-san-ti-shuang-zhi-zhen-chu-li-tui-ge-wen-ti">第三题：双指针处理退格问题</span><a href="#di-san-ti-shuang-zhi-zhen-chu-li-tui-ge-wen-ti" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-29/1661791931016.png" alt="1661791931016"></p><p>最佳解法肯定是双指针， 空间O1， 不要用栈， 从右往左遍历即可</p><p>但是边界条件处理比较恶心，记得在while循环里判断，别放到外面搞，比较麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> s.length()-<span class="number">1</span>, ti = t.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">spopCount</span> <span class="operator">=</span> <span class="number">0</span>, tpopCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(si &gt;=<span class="number">0</span> &amp;&amp; (s.charAt(si) == <span class="string">&#x27;#&#x27;</span> || spopCount &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(si) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    spopCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    spopCount--;</span><br><span class="line">                &#125;</span><br><span class="line">                si--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(ti &gt;=<span class="number">0</span> &amp;&amp; (tpopCount &gt;<span class="number">0</span> || t.charAt(ti) == <span class="string">&#x27;#&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(ti) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    tpopCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tpopCount--;</span><br><span class="line">                &#125;</span><br><span class="line">                ti--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (si ==-<span class="number">1</span> &amp;&amp; ti == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (si == -<span class="number">1</span> || ti == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (si &gt;=<span class="number">0</span> &amp;&amp; ti &gt;= <span class="number">0</span> &amp;&amp; s.charAt(si) != t.charAt(ti)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            si--;</span><br><span class="line">            ti--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/08/29/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/08/29/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-yi-huo-you-na-xie-xing-zhi">Q: 异或^有哪些性质？</a></li><li><a href="#kuai-su-zhi-bao-liu-mo-wei-de-1-qi-ta-quan-zhi-0-li-ru-1010100-0000100">快速只保留末尾的1，其他全置0（例如1010100-&gt;0000100）</a></li><li><a href="#kuai-su-ti-chu-mo-wei-de-1-qi-ta-bao-liu-li-ru-1010100-1010000">快速剔除末尾的1，其他保留(例如1010100-&gt;1010000)</a></li><li><a href="#ru-he-kuai-su-qiu-0000100-de-1-shi-di-ji-ge-wei-zhi">如何快速求0000100的1是第几个位置？</a></li><li><a href="#li-yong-bu-tong-de-wei-jin-xing-fen-zu">利用不同的位进行分组</a></li><li><a href="#xiang-guan-ti-mu">相关题目</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="q-yi-huo-you-na-xie-xing-zhi">Q: 异或^有哪些性质？</span><a href="#q-yi-huo-you-na-xie-xing-zhi" class="header-anchor">#</a></h1><p>A:<br>a^a = 0<br>如果知道a<sup>b</sup>c<br>那么a = (a<sup>b</sup>c) <sup>(b</sup>c)</p><hr><h1><span id="kuai-su-zhi-bao-liu-mo-wei-de-1-qi-ta-quan-zhi-0-li-ru-1010100-gt-0000100">快速只保留末尾的1，其他全置0（例如1010100-&gt;0000100）</span><a href="#kuai-su-zhi-bao-liu-mo-wei-de-1-qi-ta-quan-zhi-0-li-ru-1010100-gt-0000100" class="header-anchor">#</a></h1><p>b &amp;(-b)</p><hr><h1><span id="kuai-su-ti-chu-mo-wei-de-1-qi-ta-bao-liu-li-ru-1010100-gt-1010000">快速剔除末尾的1，其他保留(例如1010100-&gt;1010000)</span><a href="#kuai-su-ti-chu-mo-wei-de-1-qi-ta-bao-liu-li-ru-1010100-gt-1010000" class="header-anchor">#</a></h1><p>b &amp;(b-1)<br>这个操作可以用来快速遍历位数组中的1。</p><p>[判断数字是否是2的幂](</p><h1><span id="ru-he-kuai-su-qiu-0000100-de-1-shi-di-ji-ge-wei-zhi">如何快速求0000100的1是第几个位置？</span><a href="#ru-he-kuai-su-qiu-0000100-de-1-shi-di-ji-ge-wei-zhi" class="header-anchor">#</a></h1><p>A:<br>java的Integer.bigCount可以快速计算1的数量<br>那么减1就变成了0000011<br>int digit = Integer.bitCount(digitMask - 1); 得到是第2位。</p><hr><hr><p><a href="https://leetcode-cn.com/problems/power-of-two/submissions/">https://leetcode-cn.com/problems/power-of-two/submissions/</a>)</p><hr><h1><span id="li-yong-bu-tong-de-wei-jin-xing-fen-zu">利用不同的位进行分组</span><a href="#li-yong-bu-tong-de-wei-jin-xing-fen-zu" class="header-anchor">#</a></h1><p>可能的位运算问题，可以考虑“各位的数量&quot;<br>例如只有1个数字是1个，其他都是3个3个出现，那么可以从每位的1的个数，推断出那个数字（其他肯定要么是1的3倍或者0倍，加起来）<br>例题：<a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a><br>上面的状态变化也可以用数字电路的卡诺图进行处理，每次都是一次明确的位状态变更，不需要遍历32次。</p><p>也可也i注意利用a^b的结果，找到其中第一个不同的位进行分组（可以用b &amp;(-b)）</p><hr><hr><h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独 用位运算可以节省空间</a></p><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 算法大全 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2022/08/28/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/08/28/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#gai-nian-he-chang-jing">概念和场景</a></li><li><a href="#zuo-fa">做法</a></li><li><a href="#mo-ban">模板</a><ul><li><a href="#jian-yi-ban-ben-n-1000">简易版本（n&lt;=1000)</a></li><li><a href="#dai-dui-lie-de-gao-xing-neng-ban-ben-dan-rong-yi-xie-cuo">带队列的高性能版本（但容易写错）</a></li></ul></li><li><a href="#xiang-guan-ti-mu">相关题目</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="gai-nian-he-chang-jing">概念和场景</span><a href="#gai-nian-he-chang-jing" class="header-anchor">#</a></h1><h1><span id="zuo-fa">做法</span><a href="#zuo-fa" class="header-anchor">#</a></h1><p>拓扑排序算法步骤：</p><ol><li>得到所有节点的相邻点列表</li><li>得到所有节点的入度数量数组（切记，不可用相邻点列表代替入度数量，会炸的，因为过程中会改变，很麻烦的）</li><li>每次选入度为0的点做处理，对相邻点的入度数量做更新，减1</li><li>如果每次选很费时间，可以引入队列，队列时，每次要把队列里的全取出来再处理，而不是依次处理。每次出队的那一堆都是临时答案。</li></ol><h1><span id="mo-ban">模板</span><a href="#mo-ban" class="header-anchor">#</a></h1><h2><span id="jian-yi-ban-ben-n-lt-1000">简易版本（n&lt;=1000)</span><a href="#jian-yi-ban-ben-n-lt-1000" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] inCount = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">List&lt;Integer&gt;[] outLists = <span class="keyword">new</span> <span class="title class_">List</span>[k+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=k;i++) &#123;</span><br><span class="line">    outLists[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] row : rowConditions) &#123;</span><br><span class="line">    inCount[row[<span class="number">1</span>]]++;</span><br><span class="line">    outLists[row[<span class="number">0</span>]].add(row[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[k+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inCount.length; </span><br><span class="line"><span class="keyword">while</span> (n--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inCount[i]  &gt; <span class="number">0</span> || vis[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> out : outLists[i]) &#123;</span><br><span class="line">            inCount[out]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录这个点</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="dai-dui-lie-de-gao-xing-neng-ban-ben-dan-rong-yi-xie-cuo">带队列的高性能版本（但容易写错）</span><a href="#dai-dui-lie-de-gao-xing-neng-ban-ben-dan-rong-yi-xie-cuo" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">    List&lt;Integer&gt; needDeleteNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    needDeleteNodes.addAll(queue);</span><br><span class="line">    queue.clear();</span><br><span class="line">    <span class="comment">// 要每次都更新这个result</span></span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> needDeleNode : needDeleteNodes) &#123;</span><br><span class="line">        result.add(needDeleNode);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nextNode : nextNodes[needDeleNode]) &#123;</span><br><span class="line">            <span class="comment">// 不能delete</span></span><br><span class="line">            edgCounts[nextNode]--;</span><br><span class="line">            <span class="keyword">if</span> (edgCounts[nextNode] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.offer(nextNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/build-a-matrix-with-conditions/">6163. 给定条件下构造矩阵 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 算法大全 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法,排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第308场周赛-357名-4题</title>
      <link href="/2022/08/28/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/"/>
      <url>/2022/08/28/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701435825.png" alt="1661701435825"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>注意拓扑排序的板子，别写错了重复判断的问题，别瞎搞一个inCount[i] = -1这种，不如老实弄个vis</li></ol><hr><p><a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/">6160. 和有限的最长子序列 - 力扣（LeetCode）</a></p><p>排个序就好了，没啥难的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum + nums[j] &gt; queries[i]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/removing-stars-from-a-string/">6161. 从字符串中移除星号 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701444253.png" alt="1661701444253"></p><p>既然每次要移除最左边， 我就从右往左边遍历， 碰到星号，说明下次碰到字母时要变星号，记录一个数字即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeStars</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] bs = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">needDeduceCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                needDeduceCount++;</span><br><span class="line">                bs[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needDeduceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                needDeduceCount--;</span><br><span class="line">                bs[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bs[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/">6162. 收集垃圾的最少总时间 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701543477.png" alt="1661701543477"></p><p>这种题目啥情况，啥算法也不用，直接3次遍历即可，主要是得计算到最后一个有这个垃圾的房子时就要截至了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">garbageCollection</span><span class="params">(String[] garbage, <span class="type">int</span>[] travel)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">realSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; garbage.length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">garba</span> <span class="operator">=</span> garbage[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> g : garba.toCharArray()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == c) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sum += count;</span><br><span class="line">                    realSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != garbage.length-<span class="number">1</span>) &#123;</span><br><span class="line">                    sum += travel[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += realSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/build-a-matrix-with-conditions/">6163. 给定条件下构造矩阵 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701601482.png" alt="1661701601482"></p><p><img src="/images/%E7%AC%AC308%E5%9C%BA%E5%91%A8%E8%B5%9B-357%E5%90%8D-4%E9%A2%98/1661701607970.png" alt="1661701607970"></p><p>想了半太天才意识到是拓扑排序，  越是叶子的，越可以放前面， 越是根的，越可以放后面</p><p>早点想到的话应该20分钟就做出来了，拓扑还是很简单的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] buildMatrix(<span class="type">int</span> k, <span class="type">int</span>[][] rowConditions, <span class="type">int</span>[][] colConditions) &#123;</span><br><span class="line">        <span class="type">int</span>[] rows = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] cols = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!sort(k, rowConditions, rows) </span><br><span class="line">                ||  !sort(k, colConditions, cols)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[k][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=k;i++) &#123;</span><br><span class="line">            res[rows[i]][cols[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[][] rowConditions, <span class="type">int</span>[] rows)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] inCount = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">        List&lt;Integer&gt;[] outLists = <span class="keyword">new</span> <span class="title class_">List</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=k;i++) &#123;</span><br><span class="line">            outLists[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : rowConditions) &#123;</span><br><span class="line">            inCount[row[<span class="number">1</span>]]++;</span><br><span class="line">            outLists[row[<span class="number">0</span>]].add(row[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inCount[i]  &gt; <span class="number">0</span> || vis[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> out : outLists[i]) &#123;</span><br><span class="line">                    inCount[out]--;</span><br><span class="line">                &#125;</span><br><span class="line">                rows[i] = y;</span><br><span class="line">                y++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == k+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inCount[i] &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ioc基本概念和原理</title>
      <link href="/2022/08/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/Ioc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/Spring/Ioc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wei-shi-me-wo-men-xu-yao-ioc">为什么我们需要IOC</a></li><li><a href="#3-chong-zhu-ru-fang-shi">3种注入方式：</a><ul><li><a href="#q-gou-zao-zhu-ru-he-set-zhu-ru-na-ge-geng-hao-wei-shi-me">Q: 构造注入和set注入，哪个更好，为什么？</a></li><li><a href="#q-spring-jie-jue-xun-huan-yi-lai-de-guo-cheng">Q: spring解决循环依赖的过程？</a></li></ul></li><li><a href="#ioc-serviceprovider">IOC ServiceProvider</a></li><li><a href="#ioc-seviceproverdier-de-3-chong-guan-li-fang-shi">IOC SeviceProverdier的3种管理方式：</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="wei-shi-me-wo-men-xu-yao-ioc">为什么我们需要IOC</span><a href="#wei-shi-me-wo-men-xu-yao-ioc" class="header-anchor">#</a></h1><blockquote><blockquote><blockquote><p>IoC是随着近年来轻量级容器（Lightweight Container)的兴起而逐渐被很多人提起的一个名词，它 的全称为Inversion of Control，中文通常翻译为“控制反转”，它还有一个别名叫做依赖注入（Dependency Injection）</p></blockquote></blockquote></blockquote><p>本质上就是：<br>如果某个Java对象里有一些成员<br>那么尽量不要把这些成员写死（例如某个成员的类型是A， 不要写死成A=new A1()或者A=new A2()）<br>而要通过 构造器 或者get、set来注入进来</p><p>换句话说，<strong>在这个对象的实现中，我们看不到成员对象的具体赋值， 一切都通过外部来决定恒成员是什么</strong></p><p>而在Spring里，这个构造器和get、set都通过IOC SerivceProvider来提供<br>这个图很经典<br><img src="/images/Ioc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/20201130000819415.png" alt="在这里插入图片描述"></p><h1><span id="3-chong-zhu-ru-fang-shi">3种注入方式：</span><a href="#3-chong-zhu-ru-fang-shi" class="header-anchor">#</a></h1><ul><li><p>构造方法注入：Ioc用构造方法去注入。<br>好处是一旦构造好了，就可以马上用。 而且只需要对应类名和参数列表。缺点是参数多的话会很麻烦。</p></li><li><p>setter方法注入： Ioc用setXXX去注入成员。<br>良好。易扩展。通过set去设置成员。</p></li><li><p>接口注入： 必须要实现接口，然后接口里方法的参数为真正传入的成员对象。这个方式不提倡，有侵入性，一旦新增，其他全要开</p></li></ul><p>接口注入看了好几遍才想明白是啥意思，换个通俗易懂的解释:</p><ul><li>构造方法注入：  Ioc只要知道类名和构造参数， 即可给你用反射传进去，。</li><li>set方法注入: Ioc只要类名和你有哪些成员， 即可写反射的代码给你注入，都是setXXX，处理方式不会有变动。</li><li>接口方注入： Ioc <strong>必须知道你有哪些注入接口</strong>，才能给你注入。 比如你用Init(A a)来注入， 于是Ioc必须也指定init这个方法， 再加参数，才给给你注入<br>明显接口注入，如果init方法改名了，可能会造成大面积的注入修改（因为其他地方可能都用了Init去构造了，然后爆炸）<br>而构造和set方式几乎都是相同的注入操作，只要改入参和类名即可。</li></ul><hr><h2><span id="q-gou-zao-zhu-ru-he-set-zhu-ru-na-ge-geng-hao-wei-shi-me">Q: 构造注入和set注入，哪个更好，为什么？</span><a href="#q-gou-zao-zhu-ru-he-set-zhu-ru-na-ge-geng-hao-wei-shi-me" class="header-anchor">#</a></h2><p>A:<br>set注入更好。因为可以解决循环依赖问题<br>A中有成员B， B中有成员A，  如果都用构造方法注入，则A和B new的过程就存在循环依赖。<br>但是用set的话，就可以先生成A和B的实体，再分别通过set注入到成员中。</p><hr><h2><span id="q-spring-jie-jue-xun-huan-yi-lai-de-guo-cheng">Q:  spring解决循环依赖的过程？</span><a href="#q-spring-jie-jue-xun-huan-yi-lai-de-guo-cheng" class="header-anchor">#</a></h2><p>A:</p><ol><li><p>开始初始化对象A<br>singletonFactories：（刚构造完，也没人用过）<br>earlySingletonObjects：(如果构造过且被别人依赖过，都放进ealy中）<br>singletonObjects：（已经完全构建和注入完成）<br>这3个缓存选取的优先顺序是从下往上。</p></li><li><p>调用A的构造，把A放入singletonFactories<br>singletonFactories：A<br>earlySingletonObjects：<br>singletonObjects：</p></li><li><p>开始注入A的依赖，发现A依赖对象B</p></li><li><p>开始初始化对象B</p></li><li><p>调用B的构造，把B放入singletonFactories<br>singletonFactories：A,B<br>earlySingletonObjects：<br>singletonObjects：</p></li><li><p>开始注入B的依赖，发现B依赖对象A</p></li><li><p>开始初始化对象A，发现A在singletonFactories里有，则直接获取A，<br>并把A放入earlySingletonObjects，把A从singletonFactories删除<br>singletonFactories：B<br>earlySingletonObjects：A<br>singletonObjects：</p></li><li><p>对象B刚才拿到了A对象，依赖注入完成</p></li><li><p>对象B创建完成，把B放入singletonObjects(即完成创建了），<br>singletonFactories：<br>earlySingletonObjects：A<br>singletonObjects：B</p></li><li><p>对象B注入给A，继续注入A的其他依赖，直到A注入完成</p></li><li><p>对象A创建完成，把A放入singletonObjects，<br>singletonFactories：<br>earlySingletonObjects：<br>singletonObjects：A,B</p></li><li><p>循环依赖处理结束，A和B都初始化和注入完成<br>(Spring解决循环依赖的方法)[<a href="https://blog.csdn.net/lkforce/article/details/97183065">https://blog.csdn.net/lkforce/article/details/97183065</a>]</p></li></ol><h1><span id="ioc-serviceprovider">IOC ServiceProvider</span><a href="#ioc-serviceprovider" class="header-anchor">#</a></h1><p><img src="/images/Ioc%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86/2020113000205555.png" alt="在这里插入图片描述"></p><p>就是如何相当于服务员<br>对于业务类，不需要知道自己的成员具体是谁<br>而如何确定自己的真正成员，来自于IOC SeviceProverdier</p><p>。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或 者IoC容器实现<br>。Spring 的IoC容器就是一个提供依赖注入服务的IoC Service Provider</p><p>IOCSP的职责：<br>业务对象的构建管理，即怎么创建依赖对象<br>业务对象间 的依赖绑定， 即怎么确定谁依赖谁。</p><h1><span id="ioc-seviceproverdier-de-3-chong-guan-li-fang-shi">IOC SeviceProverdier的3种管理方式：</span><a href="#ioc-seviceproverdier-de-3-chong-guan-li-fang-shi" class="header-anchor">#</a></h1><pre><code>1. </code></pre><p>直接编码，例如写1个map来做   类-&gt;具体子类的对应关系。然后在写map.put. get之类的代码来自己主动注入<br>2.<br>文本文件（xml、配置文件），然后自己去getXMl或者getPropetris解析<br>3.<br>注解， 相当于不用自己写map的put、get，  而是通过某个框架的注解，确定注入方式，然后去在那个框架对应的代码或者配置文件中写就行了。 其实就是1、2的升级版，不用自己去做解析和存储操作，你只要去框架那里写对应依赖关系即可。</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> spring原理 </category>
          
          <category> Ioc注入机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,spring原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0827</title>
      <link href="/2022/08/27/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-27/"/>
      <url>/2022/08/27/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-27/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-er-cha-shu-jie-dian-zai-mou-ceng-shi-di-ji-ge-de-qiu-jie-fang-fa">第一题：二叉树节点在某层是第几个的求解方法</a></li><li><a href="#di-er-ti-ji-yu-shu-de-jian-dan-dong-tai-gui-hua">第二题 基于树的简单动态规划</a></li><li><a href="#di-san-ti-jian-dan-lian-biao-ha-xi-ti">第三题 简单链表+哈希题</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-er-cha-shu-jie-dian-zai-mou-ceng-shi-di-ji-ge-de-qiu-jie-fang-fa">第一题：二叉树节点在某层是第几个的求解方法</span><a href="#di-yi-ti-er-cha-shu-jie-dian-zai-mou-ceng-shi-di-ji-ge-de-qiu-jie-fang-fa" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-27/1661612722021.png" alt="1661612722021"></p><p>注意是某一层最左边和最右边节点的距离，不包含右边的null</p><p>那么只要知道如果是完全二叉树的话， 他是这一层的第几个即可。</p><p>那就是父亲节点列索引乘2或者乘2+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; minHIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> index, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!minHIndex.containsKey(h)) &#123;</span><br><span class="line">            minHIndex.put(h, index);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(index - minHIndex.get(h) + <span class="number">1</span>, res);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        dfs(node.left, index*<span class="number">2</span>, h+<span class="number">1</span>);</span><br><span class="line">        dfs(node.right, index*<span class="number">2</span>+<span class="number">1</span>, h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-er-ti-ji-yu-shu-de-jian-dan-dong-tai-gui-hua">第二题 基于树的简单动态规划</span><a href="#di-er-ti-ji-yu-shu-de-jian-dan-dong-tai-gui-hua" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/binary-trees-with-factors/">823. 带因子的二叉树 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-27/1661612958186.png" alt="1661612958186"></p><p>排个序，然后按顺序求每个节点作为根节点的情况数，并放入缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numFactoredBinaryTrees</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">numLeft</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                <span class="keyword">if</span> (big % numLeft != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">numRight</span> <span class="operator">=</span> big / numLeft;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(numRight)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">count1</span> <span class="operator">=</span> map.get(numLeft);</span><br><span class="line">                <span class="type">long</span> <span class="variable">count2</span> <span class="operator">=</span> map.get(numRight);</span><br><span class="line">                count += count1 * count2;</span><br><span class="line">                count %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(big, count);</span><br><span class="line">            res += count;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-san-ti-jian-dan-lian-biao-ha-xi-ti">第三题 简单链表+哈希题</span><a href="#di-san-ti-jian-dan-lian-biao-ha-xi-ti" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/">1836. 从未排序的链表中移除重复元素 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-27/1661612941375.png" alt="1661612941375"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicatesUnsorted</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(node.val, map.getOrDefault(node.val, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lastNode</span> <span class="operator">=</span> newHead;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(node.val) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                lastNode.next = node.next;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastNode = node;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0826</title>
      <link href="/2022/08/26/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-26/"/>
      <url>/2022/08/26/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-26/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-jian-dan-dfs">第一题简单dfs</a></li><li><a href="#di-er-ti-ji-yi-hua-sou-suo">第二题-记忆化搜索</a></li><li><a href="#di-san-ti-mei-ju-hui-wen-shu-zhi-yao-mei-ju-qian-yi-ban">第三题 枚举回文数，只要枚举前一半</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-jian-dan-dfs">第一题简单dfs</span><a href="#di-yi-ti-jian-dan-dfs" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/sZ59z6/">LCP 44. 开幕式焰火 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numColor</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(node.val);</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-er-ti-ji-yi-hua-sou-suo">第二题-记忆化搜索</span><a href="#di-er-ti-ji-yi-hua-sou-suo" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形 - 力扣（LeetCode）</a></p><p>用记忆化搜索有点长，看下答案的动态规划咋整的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] matchsticks)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(matchsticks).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">4</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] vis = <span class="keyword">new</span> <span class="title class_">int</span>[matchsticks.length];</span><br><span class="line">        Arrays.fill(vis,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(vis, </span><br><span class="line">            matchsticks, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(), <span class="number">0</span>, sum/<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] vis, <span class="type">int</span>[] matchsticks, Set&lt;Integer&gt; set, <span class="type">int</span> nowSum, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v :vis) &#123;</span><br><span class="line">            sum += v * k;</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nowSum == target) &#123;</span><br><span class="line">            nowSum = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nowSum &gt; target) &#123;</span><br><span class="line">          set.add(sum);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nowSum == <span class="number">0</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(sum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matchsticks.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(vis, matchsticks, set, nowSum + matchsticks[i], target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上不需要考虑某个火柴放在第0个边还是第4个边，直接按边摆</p><p>当你用了第1、3、7、9个火柴时，可以直接尝试往边上拼，正好拼满一个边就下一个</p><p>dp[状态压缩标志位]表示当前正在摆的那个边的长度</p><h1><span id="di-san-ti-mei-ju-hui-wen-shu-zhi-yao-mei-ju-qian-yi-ban">第三题 枚举回文数，只要枚举前一半</span><a href="#di-san-ti-mei-ju-hui-wen-shu-zhi-yao-mei-ju-qian-yi-ban" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/super-palindromes/">906. 超级回文数 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-26/1661531403264.png" alt="1661531403264"></p><p>18位回文数，但又要求是回文数的平方</p><p>所以开根号的值是9位， 且必须是回文数</p><p>那么9位回文数，最多只要求 前4位的数字，加中间可有可无的一个数字即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superpalindromesInRange</span><span class="params">(String left, String right)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="type">Long</span> <span class="variable">leftNum</span> <span class="operator">=</span> Long.valueOf(left);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">rightNum</span> <span class="operator">=</span> Long.valueOf(right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        res.add(<span class="number">1L</span>);</span><br><span class="line">        res.add(<span class="number">4L</span>);</span><br><span class="line">        res.add(<span class="number">9L</span>);</span><br><span class="line">        List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftIndex == -<span class="number">1</span> &amp;&amp; leftNum&lt;= list.get(i)) &#123;</span><br><span class="line">                leftIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightIndex == -<span class="number">1</span> &amp;&amp; rightNum &lt;= list.get(i)) &#123;</span><br><span class="line">                rightIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                    rightIndex = list.size();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;right=&quot;</span> + rightIndex + <span class="string">&quot;;left=&quot;</span> + leftIndex);</span><br><span class="line">        <span class="keyword">return</span> rightIndex - leftIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Long&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> index, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.valueOf(sb.toString()).toString();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>; i &lt;=<span class="string">&#x27;9&#x27;</span>;i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">newS</span> <span class="operator">=</span> s + i + <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString();</span><br><span class="line">                doPalid(newS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newS</span> <span class="operator">=</span> s + <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString();</span><br><span class="line">            doPalid(newS);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>; i &lt;=<span class="string">&#x27;9&#x27;</span>;i++) &#123;</span><br><span class="line">            dfs(index+<span class="number">1</span>, sb.append(i));</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPalid</span><span class="params">(String newS)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">newNum</span> <span class="operator">=</span> Long.valueOf(newS);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">mulNum</span> <span class="operator">=</span> newNum * newNum;</span><br><span class="line">        <span class="comment">// 看是否是回文数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mulNumS</span> <span class="operator">=</span> String.valueOf(mulNum);</span><br><span class="line">        <span class="keyword">if</span> (mulNumS.equals(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(mulNumS).reverse().toString())) &#123;</span><br><span class="line">            res.add(mulNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpc底层原理</title>
      <link href="/2022/08/26/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/grpc/grpc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/26/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/grpc/grpc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#grpc-xian-cheng-mo-xing">GRPC线程模型</a></li><li><a href="#grpc-xiao-xi-fa-song-quan-liu-cheng-xiang-jie">grpc消息发送全流程详解</a></li><li><a href="#q-wei-shi-me-bu-zai-netty-xian-cheng-li-zuo-xu-lie-hua-he-fan-xu-lie-hua">Q: 为什么不在Netty线程里做序列化和反序列话？</a></li><li><a href="#q-netty4-de-chuan-xing-hua-xian-cheng-mo-xing-shi-shi-me">Q: netty4的串行化线程模型是什么？</a></li><li><a href="#q-grpc-qi-dong-2-ge-ke-hu-duan-fang-wen-tong-yi-ge-duan-kou-hui-you-2-ge-lian-jie-ma">Q: grpc启动2个客户端，访问同一个端口，会有2个连接吗？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p><a href="https://www.jianshu.com/p/5baa47e5a443">grpc线程模型</a></p><h1><span id="grpc-xian-cheng-mo-xing">GRPC线程模型</span><a href="#grpc-xian-cheng-mo-xing" class="header-anchor">#</a></h1><p>gRPC 服务端线程模型整体上可以分为两大类：</p><ul><li><p>网络通信相关的线程模型，基于 Netty4.1 的线程模型实现<br>即HTTP/2 服务端创建、HTTP/2 请求消息的接入和响应发送都由 Netty 负责</p></li><li><p>服务接口调用线程模型，基于 JDK 线程池实现<br>即gRPC 消息的序列化和反序列化、以及应用服务接口的调用由 gRPC 的 SerializingExecutor 线程池负责。</p></li></ul><p><img src="/images/grpc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/177cdb317004eead36d0d20a2c7c723761179e43-1661445067947.png" alt="177cdb317004eead36d0d20a2c7c723761179e43"></p><hr><h1><span id="grpc-xiao-xi-fa-song-quan-liu-cheng-xiang-jie">grpc消息发送全流程详解</span><a href="#grpc-xiao-xi-fa-song-quan-liu-cheng-xiang-jie" class="header-anchor">#</a></h1><ol><li><p>服务端NIO  Selector 轮询，监听客户端连接</p></li><li><p>如果监听到客户端连接，则创建客户端 SocketChannel 连接，从 workerGroup 中随机选择一个 NioEventLoop 线程，将 SocketChannel 注册到该线程持有的 NIO-Selector</p></li><li><p>NioEventLoop 执行NIO的标记读取和read操作<br><img src="/images/grpc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/e1e0870117c36f6f75735174a48806629a7b6862.png" alt="e1e0870117c36f6f75735174a48806629a7b6862"></p></li><li><p>Netty 的 NioEventLoop 线程切换到 gRPC 的 SerializingExecutor，进行消息的反序列化、以及服务接口的调用</p></li><li><p>响应消息的发送，由 SerializingExecutor 发起，将响应消息头和消息体序列化，</p></li><li><p>调用 Netty NioSocketChannle 的 write 方法，发送到 Netty 的 ChannelPipeline 中，由 gRPC 的 NettyServerHandler 拦截之后，真正写入到 SocketChannel 中<br><img src="/images/grpc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/8e37664c02c4ec85a0d547f1123063cc428598c0.png" alt="8e37664c02c4ec85a0d547f1123063cc428598c0"><br>总结而言，就是网络处理线程 和 实际业务处理线程，分成2个了，这样网络IO和CPU计算可以分开处理，不会占用同一个线程。</p></li></ol><hr><h1><span id="q-wei-shi-me-bu-zai-netty-xian-cheng-li-zuo-xu-lie-hua-he-fan-xu-lie-hua">Q: 为什么不在Netty线程里做序列化和反序列话？</span><a href="#q-wei-shi-me-bu-zai-netty-xian-cheng-li-zuo-xu-lie-hua-he-fan-xu-lie-hua" class="header-anchor">#</a></h1><p>A:<br>序列化和反序列化操作，都是 CPU 密集型操作，更适合在业务应用线程池中执行，提升并发处理能力。因此，gRPC 并没有在 I/O 线程中做消息的序列化和反序列化。</p><hr><h1><span id="q-netty4-de-chuan-xing-hua-xian-cheng-mo-xing-shi-shi-me">Q: netty4的串行化线程模型是什么？</span><a href="#q-netty4-de-chuan-xing-hua-xian-cheng-mo-xing-shi-shi-me" class="header-anchor">#</a></h1><p>A:<br>Netty4 之后，对线程模型进行了优化，通过串行化的设计避免线程竞争：<br>（当系统在运行过程中，如果频繁的进行线程上下文切换，会带来额外的性能损耗）。<br>从消息的读取、编码以及后续 Handler 的执行，始终都由 I/O 线程 NioEventLoop 负责，这就意外着整个流程不会进行线程上下文的切换，数据也不会面临被并发修改的风险<br><img src="/images/grpc%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05f64b5536ba94add7b5fc11865d5762f7ae240f.png" alt="05f64b5536ba94add7b5fc11865d5762f7ae240f"></p><p>一个 NioEventLoop 聚合了一个多路复用器 Selector，因此可以处理成百上千的客户端连接，<br>Netty 的处理策略是每当有一个新的客户端接入，则从 NioEventLoop 线程组中顺序获取一个可用的 NioEventLoop</p><p>最终效果就是线程之间并没有交集，这样既可以充分利用多核提升并行处理能力，同时避免了线程上下文的切换和并发保护带来的额外性能损耗</p><hr><h1><span id="q-grpc-qi-dong-2-ge-ke-hu-duan-fang-wen-tong-yi-ge-duan-kou-hui-you-2-ge-lian-jie-ma">Q: grpc启动2个客户端，访问同一个端口，会有2个连接吗？</span><a href="#q-grpc-qi-dong-2-ge-ke-hu-duan-fang-wen-tong-yi-ge-duan-kou-hui-you-2-ge-lian-jie-ma" class="header-anchor">#</a></h1><p>A:<br>如果与路由选中的服务端之间没有可用的连接，则创建NettyClientTransport和NettyClientHandler，发起HTTP/2连接<br>客户端使用的work线程组并非通常意义的EventLoopGroup，而是一个EventLoop：即HTTP/2客户端使用的work线程并非一组线程（默认线程数为CPU内核 * 2），而是一个EventLoop线程。这个其实也很容易理解，一个NioEventLoop线程可以同时处理多个HTTP/2客户端连接，它是多路复用的，对于单个HTTP/2客户端，如果默认独占一个work线程组，将造成极大的资源浪费，同时也可能会导致句柄溢出（并发启动大量HTTP/2客户端）。<br>grpc连接池：</p><p><a href="https://www.cnblogs.com/xy-ouyang/p/10689908.html">https://www.cnblogs.com/xy-ouyang/p/10689908.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源代码 </category>
          
          <category> grpc远程调用框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源代码,grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpc双向流及应用</title>
      <link href="/2022/08/25/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/grpc/grpc%E5%8F%8C%E5%90%91%E6%B5%81%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/25/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/grpc/grpc%E5%8F%8C%E5%90%91%E6%B5%81%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ke-hu-duan-de-shuang-xiang-liu-diao-yong">客户端的双向流调用</a></li><li><a href="#fu-wu-duan-de-chu-li-fang-shi">服务端的处理方式：</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p><a href="http://doc.oschina.net/grpc?t=60134">http://doc.oschina.net/grpc?t=60134</a><br>一个 双向流式 RPC 是双方使用读写流去发送一个消息序列。<br>两个流独立操作，因此客户端和服务器 可以以任意喜欢的顺序读写：<br>比如， 服务器可以在写入响应前等待接收所有的客户端消息<br>或者可以交替 的读取和写入消息<br>或者其他读写的组合。</p><p>每个流中的消息顺序被预留。你可以通过在请求和响应前加 stream 关键字去制定方法的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accepts a stream of RouteNotes sent while a route is being traversed,</span></span><br><span class="line"><span class="comment">// while receiving other RouteNotes (e.g. from other users).</span></span><br><span class="line">rpc <span class="title function_">RouteChat</span><span class="params">(stream RouteNote)</span> returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure><h1><span id="ke-hu-duan-de-shuang-xiang-liu-diao-yong">客户端的双向流调用</span><a href="#ke-hu-duan-de-shuang-xiang-liu-diao-yong" class="header-anchor">#</a></h1><ol><li>定义一个reponseOberserver， 即响应观察者，用于定义如何处理服务端返回的消息。 一般都是把消息放到一个某个阻塞队列或者单容量队列SettableFuture中。</li><li>调用stub.sendMessage(reponseOberserver)，  即告诉grpc框架， 我要用这个reponseOberserver去处理sendMessage消息的响应。<br>注意，这个sendMesage方法名，取决于我们的proto中怎么定义的。</li><li>然后stub.sendMessage()方法回返回给我们一个requestObserver，让我们用这个观察者.onNext()去发送请求，可以任意发多次，都是立刻返回的。</li><li>当不需要再发送时，可以调用onCompleted告知对方可以结束了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">routeChat</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   info(<span class="string">&quot;*** RoutChat&quot;</span>);</span><br><span class="line">   <span class="keyword">final</span> SettableFuture&lt;Void&gt; finishFuture = SettableFuture.create();</span><br><span class="line">   <span class="comment">// 定义了如何处理收到的返回消息观察者</span></span><br><span class="line"><span class="type">StreamObserver</span> <span class="variable">reponseObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;RouteNote&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(RouteNote note)</span> &#123;</span><br><span class="line">           info(<span class="string">&quot;Got message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;</span>, note.getMessage(), note.getLocation()</span><br><span class="line">               .getLatitude(), note.getLocation().getLongitude());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">           finishFuture.setException(t);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 往finishFuture设置空时，说明完成了消息流关闭了</span></span><br><span class="line">           finishFuture.set(<span class="literal">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 框架返回给我一个请求流观察者，让我用这个观察者.onNext（message）去发请求， 返回结果和我传给他的responseServer绑定了。</span></span><br><span class="line">   StreamObserver&lt;RouteNote&gt; requestObserver =</span><br><span class="line">       asyncStub.routeChat();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     RouteNote[] requests =</span><br><span class="line">         &#123;newNote(<span class="string">&quot;First message&quot;</span>, <span class="number">0</span>, <span class="number">0</span>), newNote(<span class="string">&quot;Second message&quot;</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">             newNote(<span class="string">&quot;Third message&quot;</span>, <span class="number">1</span>, <span class="number">0</span>), newNote(<span class="string">&quot;Fourth message&quot;</span>, <span class="number">1</span>, <span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (RouteNote request : requests) &#123;</span><br><span class="line">       info(<span class="string">&quot;Sending message \&quot;&#123;0&#125;\&quot; at &#123;1&#125;, &#123;2&#125;&quot;</span>, request.getMessage(), request.getLocation()</span><br><span class="line">           .getLatitude(), request.getLocation().getLongitude());</span><br><span class="line">       requestObserver.onNext(request);</span><br><span class="line">     &#125;</span><br><span class="line">     requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">     finishFuture.get();</span><br><span class="line">     info(<span class="string">&quot;Finished RouteChat&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">     requestObserver.onError(t);</span><br><span class="line">     logger.log(Level.WARNING, <span class="string">&quot;RouteChat Failed&quot;</span>, t);</span><br><span class="line">     <span class="keyword">throw</span> t;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1><span id="fu-wu-duan-de-chu-li-fang-shi">服务端的处理方式：</span><a href="#fu-wu-duan-de-chu-li-fang-shi" class="header-anchor">#</a></h1><ol><li>我们建立服务端的时候，需要调用nettyServer，建立netty服务，并绑定一个xxxServiceImpl抽象类。 这个xxxServiceImpl就是我们在proto中定义的server结构，支持处理我们定义的消息。</li><li>xxxServiceImpl中， 有很多需要覆写的方法， 需要你定义如何处理收到的请求， 以及如何给客户端发送响应。发送响应的动作就是参数里的requestObserver.onNext(响应消息)</li><li>返回的xxxService类，会在第一步提供给netty以及grpc框架，  收到消息时，会通过他的异步机制，分隔网络线程和业务线程，走到这边执行的地方。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span><span class="title class_">xxxService</span> extend   xxxServiceImpl&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFeatures</span><span class="params">(Rectangle request, StreamObserver&lt;Feature&gt; responseObserver)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> min(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> max(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">      <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">      <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> min(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Feature feature : features) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!RouteGuideUtil.exists(feature)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lat</span> <span class="operator">=</span> feature.getLocation().getLatitude();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lon</span> <span class="operator">=</span> feature.getLocation().getLongitude();</span><br><span class="line">        <span class="keyword">if</span> (lon &gt;= left &amp;&amp; lon &lt;= right &amp;&amp; lat &gt;= bottom &amp;&amp; lat &lt;= top) &#123;</span><br><span class="line">          responseObserver.onNext(feature);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开源代码 </category>
          
          <category> grpc远程调用框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源代码,grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0825</title>
      <link href="/2022/08/25/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-25/"/>
      <url>/2022/08/25/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-25/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-shuang-zhi-zhen">第一题双指针</a></li><li><a href="#di-er-ti-bo-yi-lun-ji-yi-hua-sou-suo">第二题博弈论，记忆化搜索</a></li><li><a href="#di-san-ti-er-fen-cha-zhao">第三题二分查找</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-shuang-zhi-zhen">第一题双指针</span><a href="#di-yi-ti-shuang-zhi-zhen" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/XltzEq/">剑指 Offer II 018. 有效的回文 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-25/1661443175105.png" alt="1661443175105"></p><p>双指针，处理字符串比较麻烦</p><p>反正都是O(n)，不追求空间的话，用收集字符后反转再比较更块</p><p>双指针做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        <span class="comment">// todo:Character.isLetterOrDigit(s.charAt(right))可以代替</span></span><br><span class="line">         <span class="keyword">while</span>(left &lt;= right &amp;&amp; left &lt;s.length() &amp;&amp; !Character.isDigit(s.charAt(left)) &amp;&amp; !Character.isAlphabetic(s.charAt(left))) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; right &gt;=<span class="number">0</span> &amp;&amp; !Character.isDigit(s.charAt(right)) &amp;&amp; !Character.isAlphabetic(s.charAt(right))) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;   </span><br><span class="line">        <span class="keyword">while</span>(left &lt;right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; left &lt;s.length() &amp;&amp; !Character.isDigit(s.charAt(left)) &amp;&amp; !Character.isAlphabetic(s.charAt(left))) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; right &gt;=<span class="number">0</span> &amp;&amp; !Character.isDigit(s.charAt(right)) &amp;&amp; !Character.isAlphabetic(s.charAt(right))) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串翻转做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(c)) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(sb.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Character.isLetterOrDigit©就是判断是否是字母或者数字的意思</p><p>注意sb.reverse()会改变自身</p><h1><span id="di-er-ti-bo-yi-lun-ji-yi-hua-sou-suo">第二题博弈论，记忆化搜索</span><a href="#di-er-ti-bo-yi-lun-ji-yi-hua-sou-suo" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/stone-game-ii/">1140. 石子游戏 II - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-25/1661443467395.png" alt="1661443467395"></p><p>这种博弈论问题，请直接dfs+记忆化搜索好吧，别纠结动态规划了</p><p>而且直接考虑根据当前人的不同，选取最大或者最小值，不要考虑那个简化正负的那种策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Integer[][][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">stoneGameII</span><span class="params">(<span class="type">int</span>[] piles)</span> &#123;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>][piles.length][<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">1</span>, piles, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回alice能拿到的石头</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> m, <span class="type">int</span>[] piles, <span class="type">boolean</span> isAlice)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == piles.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[isAlice ? <span class="number">0</span> : <span class="number">1</span>][index][m] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[isAlice ? <span class="number">0</span> : <span class="number">1</span>][index][m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">needDfsRes</span> <span class="operator">=</span> (isAlice ? Integer.MIN_VALUE :</span><br><span class="line">                Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;index + <span class="number">2</span>*m &amp;&amp; i &lt; piles.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dfsRes</span> <span class="operator">=</span> dfs(i+<span class="number">1</span>, Math.max(i - index + <span class="number">1</span>, m),</span><br><span class="line">                    piles, !isAlice);</span><br><span class="line">            <span class="keyword">if</span> (isAlice) &#123;</span><br><span class="line">                sum += piles[i];</span><br><span class="line">                needDfsRes = Math.max(needDfsRes, sum + dfsRes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                needDfsRes = Math.min(needDfsRes, dfsRes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[isAlice ? <span class="number">0</span> : <span class="number">1</span>][index][m] = needDfsRes;</span><br><span class="line">        <span class="keyword">return</span> needDfsRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-san-ti-er-fen-cha-zhao">第三题二分查找</span><a href="#di-san-ti-er-fen-cha-zhao" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-25/1661443586836.png" alt="1661443586836"></p><p>要求O(logn)，显然不能用异或的那个方法了</p><p>既然是有序的，说明相同的2个数字一定是连在一起的</p><p>那么在目标左边的连体数字，一定是偶数索引开头</p><p>目标右边的连体数字，一定是奇数索引开头</p><p>搞定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> nums[mid];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; nums[mid-<span class="number">1</span>] == num1) &#123;</span><br><span class="line">                index1 = mid-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid+<span class="number">1</span>&lt;nums.length &amp;&amp; nums[mid+<span class="number">1</span>] == num1) &#123;</span><br><span class="line">                index1 = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index1 == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 相同2个数的第一个数的索引是偶数，说明那个要求的数字在右边</span></span><br><span class="line">            <span class="comment">// 如果第一个索引是奇书，说明前面被某个单个数字插入过，改变了索引情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 %<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpc基础概念</title>
      <link href="/2022/08/25/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/grpc/grpc%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/08/25/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/grpc/grpc%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-grpc-xiang-bi-http-de-you-shi">Q: GRPC相比HTTP的优势？</a></li><li><a href="#q-gang-cai-jiang-dao-liao-http2-neng-xiang-xi-shuo-xia-qu-bie-ma">Q: 刚才讲到了HTTP2/，能详细说下区别吗？</a></li><li><a href="#q-wei-shi-me-http-1-1-bu-neng-shi-xian-duo-lu-fu-yong-er-http2-0-ke-yi">Q: 为什么http/1.1不能实现多路复用而http2.0可以？ -</a></li><li><a href="#q-wei-shi-me-shuo-protobuf-bi-json-kuai">Q: 为什么说protobuf比json快？</a></li><li><a href="#q-grep-he-dubbo-zhe-ge-grpc-kuang-jia-de-dui-bi-na-ge-hao">Q: grep和dubbo这个grpc框架的对比？哪个好？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><p>RPC全程 Remote Procedure Call ，远程过程调用<br>gRpc是使用protobuf协议的RPC框架。</p><p>在服务端，服务器应用实现方法并启动一个gRPC服务器来处理客户端调用。<br>在客户端，客户端有一个叫做stub的组件（在很多语言中称为客户端），提供和服务端一致的方法。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/c8d8584b41419d707fe757fa64e38706b0219f5e.png" alt="c8d8584b41419d707fe757fa64e38706b0219f5e"></p><p>服务service器代码和stub客户端代码都可以通过protobuf自动生成。</p><p>因为使用protobuf做协议交换， 因此多语言都可以支持， python、java、golang、C++都有protobuf的实现。</p><hr><h1><span id="q-grpc-xiang-bi-http-de-you-shi">Q: GRPC相比HTTP的优势？</span><a href="#q-grpc-xiang-bi-http-de-you-shi" class="header-anchor">#</a></h1><p>A:</p><ol><li>底层使用HTTP/2协议， HTTP/2的长期实时通信支持比HTTP要好。、</li><li>，用的protocBuf对数据进行序列化，  是一种轻量级的消息格式， 成本是json是要小的。</li><li>多语言通用， python、C++、</li><li>逻辑上支持双向流，简化了操作便携度。</li><li>支持tcp多路复用，避免了频繁的tcp连接建立。</li></ol><hr><h1><span id="q-gang-cai-jiang-dao-liao-http2-neng-xiang-xi-shuo-xia-qu-bie-ma">Q: 刚才讲到了HTTP2/，能详细说下区别吗？</span><a href="#q-gang-cai-jiang-dao-liao-http2-neng-xiang-xi-shuo-xia-qu-bie-ma" class="header-anchor">#</a></h1><p>A;</p><ul><li>HTTP / 1.1使用文本数据，这通常在网络上效率较低。而HTTP / 2是二进制数据。</li><li>HTTP / 1.1的标头没有压缩，而HTTP / 2的标头是gzip压缩的。</li><li>在HTTP / 1.1中，服务器必须以接收请求的相同顺序发送响应。而，HTTP / 2是异步处理响应的</li><li>HTTP / 2允许同时在同一（单个）连接上发送多个请求和响应消息（多路复用）。某个请求任务耗时严重，不会影响到其它连接的正常执行</li><li>HTTP/2可以不需要响应必须先接请求，  而是可以自己响应（服务端主动推送）<br>比如你需要两个文件1.html,1.css，如果是http1.0则需要请求两次，服务端返回两次。但是http2.0则可以客户端请求一次，然后服务端直接回吐两次</li></ul><hr><h1><span id="q-wei-shi-me-http-1-1-bu-neng-shi-xian-duo-lu-fu-yong-er-http2-0-ke-yi">Q: 为什么http/1.1不能实现多路复用而http2.0可以？ -</span><a href="#q-wei-shi-me-http-1-1-bu-neng-shi-xian-duo-lu-fu-yong-er-http2-0-ke-yi" class="header-anchor">#</a></h1><p>A:</p><ul><li>在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，</li><li>这样分帧以后这些帧就可以乱序发送，然后根据每个帧首部的流标识符号进行组装</li><li>对比http/1.1， 因为http1.1是基于文本以换行符分割每一条key：value，则会有以下问题：</li></ul><ol><li>一次只能处理一个请求或者响应，因为这种以分隔符分割消息的数据，在完成之前不能停止解析</li><li>解析这种数据无法预知需要多少内存，会给服务端有很大压力</li></ol><hr><hr><h1><span id="q-wei-shi-me-shuo-protobuf-bi-json-kuai">Q: 为什么说protobuf比json快？</span><a href="#q-wei-shi-me-shuo-protobuf-bi-json-kuai" class="header-anchor">#</a></h1><p>A:<br>protobuf比json快6倍，原因如下：</p><ul><li>protobuf的存储格式为 tag-length-value，通过tag+length能快速对value进行解码。</li><li>通过length控制长度，不需要分隔符（逗号，双引号等）就能分隔字段</li><li>空字段会省略</li></ul><hr><h1><span id="q-grep-he-dubbo-zhe-ge-grpc-kuang-jia-de-dui-bi-na-ge-hao">Q: grep和dubbo这个grpc框架的对比？哪个好？</span><a href="#q-grep-he-dubbo-zhe-ge-grpc-kuang-jia-de-dui-bi-na-ge-hao" class="header-anchor">#</a></h1><p>A:<br>dubbo适合需要完整管理体系、高可靠性的分布式微服务调用体系。 它的配置方式多、负载均衡方式多、容错多、支持4种注册中心。</p><p>grep的话， 负载均衡和注册中心都要自己扩展实现，但有提供插拔接口等。<br>grpc只有api（代码配置）的方式，只有failover。<br>和dubbo相比， grpc的亮点在于http/2的高性能，以及protobuf的多语言兼容。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/146220bbd653f4c601a5ae989065ee0c1d01bd2b.png" alt="146220bbd653f4c601a5ae989065ee0c1d01bd2b"></p>]]></content>
      
      
      <categories>
          
          <category> 开源代码 </category>
          
          <category> grpc远程调用框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源代码,grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我们要学习TCP-IP</title>
      <link href="/2022/08/25/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/"/>
      <url>/2022/08/25/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#chun-jie-hou-de-1-ci-xiao-wen-ti">春节后的1次小问题</a></li><li><a href="#fan-si">反思</a></li><li><a href="#yi-xue-xi-xie-yi-ge-shi-de-chang-jian-she-ji-si-lu">一、学习协议格式的常见设计思路</a></li><li><a href="#er-xue-xi-tu-suan-fa-de-ying-yong">二、学习图算法的应用</a></li><li><a href="#san-xue-xi-ke-kao-xing-liu-cheng-de-she-ji">三、学习可靠性流程的设计</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="chun-jie-hou-de-1-ci-xiao-wen-ti">春节后的1次小问题</span><a href="#chun-jie-hou-de-1-ci-xiao-wen-ti" class="header-anchor">#</a></h1><p>春节假期之后，我回到工位，发现开发用的3台实验机器中，有1台使用EIP（外网ip）登不上了， 只能使用vpn去连接小网ip登录。<br>咨询了一下物理机管理员，说假期因为实验室维护,  重启了机器，线路正常， 应该是机器的网络配置之前只临时生效，重启后就没了，让我自己查查看。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/20210315002844629.png" alt="在这里插入图片描述"></p><p>于是只能努力从大脑里挖掘有关计算机网络的回忆， 发现没啥好思路，去内网搜了下类似问题，才知道路由会影响eip， 对比了1下失效机器 和其他正常机器的路由表配置， 才发现缺少到NAT网关的路由，导致报文无法往回发。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/20210315003852233.png" alt="在这里插入图片描述"><br>修改了一波路由配置后 便通了。</p><h1><span id="fan-si">反思</span><a href="#fan-si" class="header-anchor">#</a></h1><p>这时候我才发现删减改查的业务做得多了，很多经典知识都忘记了。<br>心想要不要去找本书系统回忆下网络知识？</p><p>但是又懒得去番以前的教材，谢老的《计算机网络》?<br>算了，学生时代它那从物理层开始，再到链路层的超长阴影记忆尤新。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/20210315002324250.png" alt="在这里插入图片描述"></p><p>于是整了本经典的《TCP/IP详解》，抱着学习者的心态重新学习了1下。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/20210315000102277.png" alt="在这里插入图片描述"></p><p>可是，决定开始看之前，又犹豫了一下：<br>业务需求写完了吗？sql性能优化到最佳了吗？ 模块可信、稳健了吗？有必要费时间看这些烂大街的，应届生们面经必背的常见知识？</p><p>换言之，作为浮于业务应用上层的java开发小兵，我需要去思考1个问题：<strong>当我们学习TCP/IP时，我们在学什么？</strong></p><p>抛去以往的功利、应试等心态，我抱着这个问题看完了全书，给了我自己的几个思考</p><h1><span id="yi-xue-xi-xie-yi-ge-shi-de-chang-jian-she-ji-si-lu">一、学习协议格式的常见设计思路</span><a href="#yi-xue-xi-xie-yi-ge-shi-de-chang-jian-she-ji-si-lu" class="header-anchor">#</a></h1><p>IP和TCP的章节里，分别花了大章节，讲述协议首部内容。<br>学生时代很反感这个东西，感觉就是为了出计算题和记忆题， 我们又不去改报文，看这啥用。<br>然而工作后，发现这是计算机初学者们，最早能接触到的通讯协议格式设计思想了。<br>以IP报文格式为例，  可以看到<br>有  首部长度、总长度，， 还有用于处理报文切分的字段，， 以及校验字段，避免首部错误。<br><img src="/images/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%B9%A0TCP-IP/20210315005616676.png" alt="在这里插入图片描述"><br>而如果自己需要设计一套以二进制流为基础的应用层通信协议，很大概率，也要包含以上的内容。<br>例如我们怎么确定数据多长，怎么保证数据不被篡改，怎么分多次而保证不会乱， 这些都是常见的协议设计重点问题。   而这些问题的解决思路，就可以从TCP、IP等经典协议中初见端倪。</p><h1><span id="er-xue-xi-tu-suan-fa-de-ying-yong">二、学习图算法的应用</span><a href="#er-xue-xi-tu-suan-fa-de-ying-yong" class="header-anchor">#</a></h1><p>数据结构里，最让很多人头疼的就是图那章了。然而图的内容却是应用最强力的东西。<br>IP层路由概念的设计，简直是图算法的完美应用常见：</p><ul><li>路由表就是很经典的图数据结构设计。</li><li>如何动态更新最短路， RIP和OSPF协议也分别给了我们思路</li></ul><p>甚至路由表里对子网最长匹配的应用，也用到了前缀树算法（线索树），让人感觉oj网站上算法题都亲切了不少。</p><h1><span id="san-xue-xi-ke-kao-xing-liu-cheng-de-she-ji">三、学习可靠性流程的设计</span><a href="#san-xue-xi-ke-kao-xing-liu-cheng-de-she-ji" class="header-anchor">#</a></h1><p>当重看TCP协议的握手挥手设计，以及重连机制，我还是会感到惊叹连连。<br>于是给自己提了个问题，如果不考虑TCP的可靠性，基于应用层，设计一套能稳定可靠的消息交互程序，我能想到有哪些要考虑的地方吗？基于那章，我大概想到了是以下几点</p><ol><li>如何能确保对方收到了我的信息？——TCP引入了ack响应</li><li>怎样算两边开始正式交互？——能够证明两边的网络通道都能通，所以你我各需要1次ack响应来相互证明。</li><li>怎么直到我的消息丢了？——每次消息发出，都有个定时器检查，超时时间内没收到，就会重发，直到到达次数上限，则认为超时</li><li>超时时间怎么确定？——根据每次的时间样本定时更新</li><li>超时后怎么办？——拥塞避免算法</li><li>发少了太慢，发多了会阻塞，怎么确定1次可以发多少？——慢启动算法</li></ol><p>可以看到TCP协议里，基本把上述可靠性的设计问题都考虑到了，而且到了及其细致的地步。当你有这类需求时，不妨第一时间回忆下TCP的优秀之处</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网之物理层详解</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wu-li-ceng-zuo-yong">物理层作用</a></li><li><a href="#ru-he-ping-jie-wu-li-ceng-jie-kou-hao-pi">如何评价物理层接口好坏</a></li><li><a href="#chuan-shu-mei-ti">传输媒体</a><ul><li><a href="#dao-yin-xing-chuan-shu-gu-ti-chuan-bo">导引型传输（固体传播）</a><ul><li><a href="#shuang-jiao-xian">双绞线</a></li><li><a href="#tong-zhou-dian-lan">同轴电缆</a></li><li><a href="#guang-lan">光缆</a></li><li><a href="#fei-dao-yin">非导引</a></li></ul></li></ul></li><li><a href="#qi-ta-te-xing">其他特性</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="wu-li-ceng-zuo-yong">物理层作用</span><a href="#wu-li-ceng-zuo-yong" class="header-anchor">#</a></h1><ul><li>在传输媒体上传输比特流</li><li>对链路层而言， 不需要关心通信手段、传输媒体的差异，因为这些东西都由物理层去处理</li><li>这个层面怎么优化？</li></ul><ol><li>提升线路质量，提升带宽</li><li>通信原理应用，如何设计电平传输波形， 频分、波分、码分</li></ol><h1><span id="ru-he-ping-jie-wu-li-ceng-jie-kou-hao-pi">如何评价物理层接口好坏</span><a href="#ru-he-ping-jie-wu-li-ceng-jie-kou-hao-pi" class="header-anchor">#</a></h1><ul><li>机械特性： 接线器大小、尺寸</li><li>电气特性： 电压范围高低</li><li>功能特性：某电平对应某个功能， 信号线。</li><li>过程特性：各事件顺序</li><li>传输方式转换</li></ul><h1><span id="chuan-shu-mei-ti">传输媒体</span><a href="#chuan-shu-mei-ti" class="header-anchor">#</a></h1><h2><span id="dao-yin-xing-chuan-shu-gu-ti-chuan-bo">导引型传输（固体传播）</span><a href="#dao-yin-xing-chuan-shu-gu-ti-chuan-bo" class="header-anchor">#</a></h2><h3><span id="shuang-jiao-xian">双绞线</span><a href="#shuang-jiao-xian" class="header-anchor">#</a></h3><ul><li>2根绝缘铜线并排校合，可以减少电磁干扰</li><li>电话到交换机就是这个</li><li>线要接的距离太长怎么办。总是衰减？</li></ul><ol><li>放大器——模拟电路方式，对信号简单放大，噪音也会变大</li><li>中继器（转发器)——数字电路方式， 对信号做再生， 扩大网络规模</li><li>多款口中继器： 一个输入，转发到其他所有端口<br>集线器Hub属于多款口中继器<br>可以和交换器连接</li></ol><h3><span id="tong-zhou-dian-lan">同轴电缆</span><a href="#tong-zhou-dian-lan" class="header-anchor">#</a></h3><ul><li>有线电视用这个</li><li>比双绞线要厚，抗干扰更强</li><li>包含内导体线、绝缘层、外导体屏蔽、保护外层</li></ul><h3><span id="guang-lan">光缆</span><a href="#guang-lan" class="header-anchor">#</a></h3><ul><li>抗雷抗噪</li><li>带宽大，100G/bits!</li><li>核心是那个反射率超低的包层，全反射</li><li>分为单模（细，远，贵）和多模（便宜，反射率比单模高一点，所以容易失真）</li></ul><h3><span id="fei-dao-yin">非导引</span><a href="#fei-dao-yin" class="header-anchor">#</a></h3><ul><li>短波/微波： 通过电离层反射</li><li>无线电微波： 卫星</li></ul><h1><span id="qi-ta-te-xing">其他特性</span><a href="#qi-ta-te-xing" class="header-anchor">#</a></h1><ul><li>通信原理相关性质和应用都在物理层体现</li><li>什么香农公式、奈式准则之类的</li><li>信息交换3种方式</li></ul><ol><li>电路交换： 类似拨号， 始终占用固定带宽， 拨号结束则才挂断</li><li>报文交换： 报文可以很大， 大报文会占据一整片带宽</li><li>分组交换：报文拆成分组发送，可以大家一起传。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网之链路层详解</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-lian-lu-ceng-gai-nian">1.链路层概念</a><ul><li><a href="#1-1-lian-lu-ceng-de-gong-neng">1.1链路层的功能</a></li><li><a href="#1-2-lian-lu-ceng-xie-yi-she-ji-de-3-ge-chong-yao-gai-nian">1.2链路层协议设计的3个重要概念</a></li></ul></li><li><a href="#2-chang-jian-xie-yi">2 常见协议</a><ul><li><a href="#2-1-ppp-xie-yi">2.1 PPP协议</a><ul><li><a href="#2-1-1-ppp-ru-he-jie-jue-zheng-ding-jie">2.1.1 PPP如何解决帧定界？</a></li><li><a href="#2-2-2-ppp-ru-he-jie-jue-tou-ming-chuan-shu">2.2.2 PPP如何解决透明传输？</a></li><li><a href="#2-1-3-ppp-ru-he-jie-jue-chai-cuo-kong-zhi">2.1.3 PPP如何解决差错控制？</a></li></ul></li><li><a href="#2-2-hdlc-gao-ji-lian-lu-kong-zhi-xie-yi">2.2 HDLC高级链路控制协议</a></li><li><a href="#2-3-csma-cd-xie-yi-yi-tai-wang">2.3 CSMA/CD协议（以太网）</a><ul><li><a href="#2-3-1-fang-chong-tu-ji-zhi">2.3.1 防冲突机制</a></li><li><a href="#2-3-2-yi-tai-wang-bao-wen">2.3.2 以太网报文</a></li><li><a href="#2-3-3-mac-ying-jian-di-zhi-gai-nian">2.3.3 mac硬件地址概念</a></li><li><a href="#2-3-4-yi-tai-wang-jiao-huan-ji">2.3.4 以太网交换机</a></li><li><a href="#2-3-5-xu-ni-ju-yu-wang-vlan">2.3.5 虚拟局域网VLAN</a></li></ul></li><li><a href="#2-4-csma-ca-wu-xian-wang">2.4 CSMA/CA（无线网）</a></li><li><a href="#2-5-pppoe">2.5 PPPOE</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="1-lian-lu-ceng-gai-nian">1.链路层概念</span><a href="#1-lian-lu-ceng-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-lian-lu-ceng-de-gong-neng">1.1链路层的功能</span><a href="#1-1-lian-lu-ceng-de-gong-neng" class="header-anchor">#</a></h2><ol><li>控制物理介质访问，把传输协议加到链路上</li><li>对传输的数据可做管理和控制，避免因为电平出错导致数据错误却无法发现</li></ol><h2><span id="1-2-lian-lu-ceng-xie-yi-she-ji-de-3-ge-chong-yao-gai-nian">1.2链路层协议设计的3个重要概念</span><a href="#1-2-lian-lu-ceng-xie-yi-she-ji-de-3-ge-chong-yao-gai-nian" class="header-anchor">#</a></h2><ol><li><p>帧定界问题<br>通过添加首部和尾部（例如SOH 0x01或者E OH0x04， 也称做界限符），把数据封装成一帧。<br>帧的最大帧长度叫MTU</p></li><li><p>透明传输问题<br>为了避免帧中数据也存在首部尾部导致获取时出错， 填充字符时，界限符需要做转义</p></li><li><p>差错控制问题<br>纠错：<br>为了避免传输过程因为电路波动存在问题，需要做检查。</p><ul><li>循环冗余CRC校验（ARQ方式中使用）</li><li>海明码纠错</li></ul></li></ol><p>防丢失：超时重发<br>防重复：编号</p><h1><span id="2-chang-jian-xie-yi">2 常见协议</span><a href="#2-chang-jian-xie-yi" class="header-anchor">#</a></h1><h2><span id="2-1-ppp-xie-yi">2.1 PPP协议</span><a href="#2-1-ppp-xie-yi" class="header-anchor">#</a></h2><p>用于与ISP通信所用协议<br>用来通过拨号或专线方式建立点对点连接发送数据,使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案<br>只可全双工</p><p>PPP也要解决上面提到的3个问题</p><h3><span id="2-1-1-ppp-ru-he-jie-jue-zheng-ding-jie">2.1.1 PPP如何解决帧定界？</span><a href="#2-1-1-ppp-ru-he-jie-jue-zheng-ding-jie" class="header-anchor">#</a></h3><p>PPP协议的帧格式如下：</p><table><thead><tr><th>7E</th><th>FF</th><th>03</th><th>0021/C021/8021</th><th>xxxx</th><th>???</th><th>7E</th></tr></thead><tbody><tr><td>帧首</td><td>地址地段</td><td>控制字段</td><td>协议，IP/LCP/NCP三选一</td><td>数据报部分</td><td>FCS校验码部分</td><td>帧尾</td></tr></tbody></table><p>从上面可以看到以下几点：</p><ul><li>PPP协议的帧首和帧尾都是7E(01111110)</li><li>地址字段和控制字段都是固定值，相当于已经废弃了（PPP是点对点协议，所以不需要MAC地址，因此地址字段是一个固定值）</li><li>PPP不止支持IP协议，海支持LCP\NCP</li></ul><h3><span id="2-2-2-ppp-ru-he-jie-jue-tou-ming-chuan-shu">2.2.2 PPP如何解决透明传输？</span><a href="#2-2-2-ppp-ru-he-jie-jue-tou-ming-chuan-shu" class="header-anchor">#</a></h3><p>有2种方式：</p><ol><li>异步传输时， 使用字节填充的方式：</li></ol><ul><li>当数据报部分出现0x7E时， 转成0x7D+0x5E</li><li>当出现0x7D时， 转成0x7D+0x5D</li><li>出现ASCll码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。<br>可以看到异步传输是用0x7D来识别和转义可能误解的字符， 拆解时根据0x7D去反转</li></ul><ol start="2"><li>同步传输时，使用零比特填充<br>帧首和帧尾都是0x7E(01111110）， 即6个1)<br>当数据报部分出现5个1时，会马上填充1个0（这样数据报中永远不会存在连续的6个1）<br>当拆解时， 发现连续的5个1，就会删除后面的1个0来恢复</li></ol><h3><span id="2-1-3-ppp-ru-he-jie-jue-chai-cuo-kong-zhi">2.1.3 PPP如何解决差错控制？</span><a href="#2-1-3-ppp-ru-he-jie-jue-chai-cuo-kong-zhi" class="header-anchor">#</a></h3><p>使用末尾的FCS校验码校验数据是否有0、1不正确。具体见CRC纠错原理。</p><h2><span id="2-2-hdlc-gao-ji-lian-lu-kong-zhi-xie-yi">2.2 HDLC高级链路控制协议</span><a href="#2-2-hdlc-gao-ji-lian-lu-kong-zhi-xie-yi" class="header-anchor">#</a></h2><p>HDLC是面向位协议，用&quot;数据位&quot;定义字段类型，而不用控制字符，通过帧中用&quot;位&quot;的组<br>合进行管理和控制。<br>帧格式为：<br>字段：开始标志 地址字段 控制字段 信息字段 校验序列 结束标志</p><p><em><strong>广域网使用PPP和HDLC协议进行远距离数据传输</strong></em></p><h2><span id="2-3-csma-cd-xie-yi-yi-tai-wang">2.3 CSMA/CD协议（以太网）</span><a href="#2-3-csma-cd-xie-yi-yi-tai-wang" class="header-anchor">#</a></h2><h3><span id="2-3-1-fang-chong-tu-ji-zhi">2.3.1 防冲突机制</span><a href="#2-3-1-fang-chong-tu-ji-zhi" class="header-anchor">#</a></h3><p><em><strong>以太网是采用CSMA/CD访问方法的局域网</strong></em></p><ul><li><p>无连接的工作方式，发出去就完事了</p></li><li><p>地理范围和站点数量有限</p></li><li><p>共用总线发送</p></li><li><p>为了避免同一时间多个电平碰撞引发数据混乱，使用了碰撞检测<br>其实就是看在争用期内，是否连续收到2端数据，如果收到了说明存在冲突，数据有问题。<br>争用期概念：</p></li></ul><blockquote><blockquote><p>以太网的端到端往返时延 2a 称为争用期，或碰撞窗口。通常，取 51.2 us 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节未发生冲突，则后续的数据就不会发生冲突。如果发生冲突，就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p></blockquote></blockquote><ul><li><p>发现碰撞，会重传,等待重传的时间使用二进制指数退避方法</p></li><li><p>存在最短帧长（64字节），就是为了能有效做碰撞检测，不足就会填充空白</p></li><li><p>使用<a href="https://blog.csdn.net/colesky/article/details/78788820">曼彻斯特编码</a></p></li></ul><p>详细见“<br><a href="https://blog.csdn.net/weixin_43941364/article/details/105639195">https://blog.csdn.net/weixin_43941364/article/details/105639195</a></p><h3><span id="2-3-2-yi-tai-wang-bao-wen">2.3.2 以太网报文</span><a href="#2-3-2-yi-tai-wang-bao-wen" class="header-anchor">#</a></h3><table><thead><tr><th>界限符</th><th>时钟同步码</th><th>目的地址</th><th>源地址</th><th>类型</th><th>数据报</th><th>FCS校验</th></tr></thead><tbody><tr><td>0xAB</td><td>7字节，与适配器时钟同步</td><td>6字节</td><td>6字节</td><td>2字节</td><td>最短46字节</td><td>4字节（CRC）</td></tr></tbody></table><p>从这个报文看到以下几点：</p><ol><li>最短数据报文字节46， 是由  64 - 16 得到的， 64是之前提到的最短帧长（为了做冲突检测）</li><li>不需要帧结束符（不会连续存在，如果连续存在那可能就是发生冲突）</li><li>数据报文可能会填充很多空白的</li><li>无效帧判定： FCS错误、 帧长不在64~1518范围内</li></ol><p>注意：快速以太网的最短帧总长46B</p><h3><span id="2-3-3-mac-ying-jian-di-zhi-gai-nian">2.3.3 mac硬件地址概念</span><a href="#2-3-3-mac-ying-jian-di-zhi-gai-nian" class="header-anchor">#</a></h3><ul><li>mac地址固化在ROM的地址中（网络适配器）。 如果更换适配器，则地址改变。 更换局域网，mac地址不变。</li><li>若一个网中有2个相同mac地址，则无法正常通信</li><li>1个路由器或者主机中可以配置多个mac地址</li><li>mac地址总共6个字节，前3个字节伪注册管理机构分配（第一位判断是单站还是组地址，最低第二位判断是全球管理还是本地管理）</li><li>后3个字节才是真正的地址</li></ul><h3><span id="2-3-4-yi-tai-wang-jiao-huan-ji">2.3.4 以太网交换机</span><a href="#2-3-4-yi-tai-wang-jiao-huan-ji" class="header-anchor">#</a></h3><ul><li>用于局域网，做多主机之间的数据交换，属于链路层的扩展道具</li><li>具有自学习功能：<br>第一次使用，内部无mac缓存，拿到未知mac时会给所有端口发，拿到响应后就会记录下来，后续直接转发<br>mac缓存有有效时间，不会一直存在</li><li>交换机可以分割冲突域（物理层）,但无法分隔广播域</li></ul><blockquote><blockquote><p>广播域就是说如果站点发出一个广播信号后能接收到这个信号的范围。通常来说一个局域网就是一个广播域。<br>冲突域指一个站点向另一个站点发出信号。除目的站点外，有多少站点能收到这个信号。这些站点就构成一个冲突域。<br>冲突域通过集线器连接，广播域则通过交换机。</p></blockquote></blockquote><h3><span id="2-3-5-xu-ni-ju-yu-wang-vlan">2.3.5 虚拟局域网VLAN</span><a href="#2-3-5-xu-ni-ju-yu-wang-vlan" class="header-anchor">#</a></h3><ul><li>可隔离广播域和冲突域</li></ul><h2><span id="2-4-csma-ca-wu-xian-wang">2.4 CSMA/CA（无线网）</span><a href="#2-4-csma-ca-wu-xian-wang" class="header-anchor">#</a></h2><ul><li></li><li>会事先避免冲突，会先侦听信道，等到预约到信道了再进入征用端口。</li></ul><p>存在自动重传请求ARQ机制，有3种方式：</p><ol><li>单帧滑动-停止等待协议<ul><li>一次只发一帧，1次只收一帧，并确认占有信道后才继续</li><li>发送端：收到ack确认后，才会发下一个，每个都有个定时器</li><li>接收端：序号不匹配递增的话都会丢弃。</li></ul></li><li>后退N帧GBN<ul><li>发送端：连续发送，无需等待上一帧完成，每个帧有个定时器判断ack超时</li><li>接收端：有序接收，1次只收1个，如果希望收4，却收到5，则丢弃，发送端会超时重发4</li></ul></li><li>选择重传SR<ul><li>发送端： 和2一样， 无需等待， 每个帧有定时器</li><li>接收端：乱序接收，存在窗口缓存，如果收到了2，而且缓存里有3和8，则会合并上交后，发ack8</li></ul></li></ol><h2><span id="2-5-pppoe">2.5 PPPOE</span><a href="#2-5-pppoe" class="header-anchor">#</a></h2><ul><li>属于PPP协议和以太网的结合，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的一种网络隧道协议。</li><li>我们的电脑宽带接入大网很多都是基于PPPOE的<br><a href="https://blog.csdn.net/u011857683/article/details/84703669">https://blog.csdn.net/u011857683/article/details/84703669</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0824</title>
      <link href="/2022/08/24/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-24/"/>
      <url>/2022/08/24/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-24/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-quan-pai-lie-wen-ti-zi-fu-chuan-chu-li-ma-fan">第一题：全排列问题，字符串处理麻烦</a></li><li><a href="#di-er-ti-jian-dan-dong-tai-gui-hua">第二题：简单动态规划</a></li><li><a href="#di-san-ti-tong-guo-shu-ju-fan-wei-jue-ding-yong-dong-tai-gui-hua-er-bu-shi-sou-suo">第三题：通过数据范围决定用动态规划而不是搜索</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-quan-pai-lie-wen-ti-zi-fu-chuan-chu-li-ma-fan">第一题：全排列问题，字符串处理麻烦</span><a href="#di-yi-ti-quan-pai-lie-wen-ti-zi-fu-chuan-chu-li-ma-fan" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/brace-expansion/">1087. 花括号展开 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-24/1661355892528.png" alt="1661355892528"></p><p>很常见的搜索全排列题</p><p>但是处理这个字符串折腾了我好久,看我下面这个也太麻烦了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">char</span>[]&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">String[] split = ss.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[split.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; split.length;j++)&#123;</span><br><span class="line">    cs[j] = split[j].charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">lists.add(cs);</span><br></pre></td></tr></table></figure><p>看看答案怎么做的，好像其他人都是逐个判断的。</p><p><img src="/images/2022-08-24/1661356015380.png" alt="1661356015380"></p><p>也是，频繁substring还是很耗时间的，不建议</p><p>我的答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String[] expand(String s) &#123;</span><br><span class="line">        List&lt;<span class="type">char</span>[]&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                lists.add(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;s.charAt(i)&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;&#125;&quot;</span>, i);</span><br><span class="line">                <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> s.substring(i+<span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">// todo:看下答案这里怎么取的比较好</span></span><br><span class="line">                String[] split = ss.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[split.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; split.length;j++)&#123;</span><br><span class="line">                    cs[j] = split[j].charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lists.add(cs);</span><br><span class="line">                i = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(lists, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), res);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;<span class="type">char</span>[]&gt; lists, <span class="type">int</span> index, StringBuilder sb, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == lists.size()) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : lists.get(index)) &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">            dfs(lists, index+<span class="number">1</span>, sb, res);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="di-er-ti-jian-dan-dong-tai-gui-hua">第二题：简单动态规划</span><a href="#di-er-ti-jian-dan-dong-tai-gui-hua" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/">2244. 完成所有任务需要的最少轮数 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-24/1661356069871.png" alt="1661356069871"></p><p>一眼想到动态规划，但就是要注意题意得先排序,还要注意溢出的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumRounds</span><span class="params">(<span class="type">int</span>[] tasks)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[tasks.length];</span><br><span class="line">        Arrays.sort(tasks);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">task</span> <span class="operator">=</span> tasks[i];</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;j&gt;=i-<span class="number">2</span> &amp;&amp; j &gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tasks[j] != task) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + (j-<span class="number">1</span>&gt;=<span class="number">0</span>?dp[j-<span class="number">1</span>]:<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[tasks.length-<span class="number">1</span>] &gt;=Integer.MAX_VALUE ? -<span class="number">1</span> : (<span class="type">int</span>)dp[tasks.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="di-san-ti-tong-guo-shu-ju-fan-wei-jue-ding-yong-dong-tai-gui-hua-er-bu-shi-sou-suo">第三题：通过数据范围决定用动态规划而不是搜索</span><a href="#di-san-ti-tong-guo-shu-ju-fan-wei-jue-ding-yong-dong-tai-gui-hua-er-bu-shi-sou-suo" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/D0F0SV/">剑指 Offer II 104. 排列的数目 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-24/1661356141861.png" alt="1661356141861"></p><p>看起来以为要搜索，结果一看数据范围：</p><p><img src="/images/2022-08-24/1661356155356.png" alt="1661356155356"></p><p>target最大1000，且都是正数，那么可以直接基于总和做动态规划了，因为不会有超过target的情况出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>; sum &lt;= target;sum++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum - num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[sum] += dp[sum - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础概念</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#hu-lian-wang-fa-zhan-jie-duan">互联网发展阶段</a></li><li><a href="#fen-ceng-mo-xing">分层模型</a><ul><li><a href="#osi-qi-ceng-mo-xing">OSI七层模型</a></li><li><a href="#tcp-ip-si-ceng-mo-xing">TCP/IP四层模型</a></li><li><a href="#jiao-ke-shu-wu-ceng-mo-xing">教科书五层模型</a></li></ul></li><li><a href="#yi-xie-qi-ta-gai-nian">一些其他概念</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="hu-lian-wang-fa-zhan-jie-duan">互联网发展阶段</span><a href="#hu-lian-wang-fa-zhan-jie-duan" class="header-anchor">#</a></h1><ol><li>分组交换网ARPANET——</li><li>美国国家基金会NSF——三级网络模型： 主干网、地区、校园/企业往</li><li>多层次 <em><strong>ISP</strong></em> 结构<br>ISP： 互联网服务提供商， 申请ip租给用户<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ja7k64lh-1613409272592)(en-resource://database/1830:1)]<br>IXP：  互联网交换点—— 可让2个网络直接相连，交换分组，用局域网互联。</li></ol><h1><span id="fen-ceng-mo-xing">分层模型</span><a href="#fen-ceng-mo-xing" class="header-anchor">#</a></h1><h2><span id="osi-qi-ceng-mo-xing">OSI七层模型</span><a href="#osi-qi-ceng-mo-xing" class="header-anchor">#</a></h2><p>应用层<br>表示层（数据信息变化）<br>会话层（建立进程间会话）<br>运输层<br>网络层<br>链路层<br>物理层</p><h2><span id="tcp-ip-si-ceng-mo-xing">TCP/IP四层模型</span><a href="#tcp-ip-si-ceng-mo-xing" class="header-anchor">#</a></h2><p>应用层（FTP\SMTP）<br>运输层（TCP\UDP）<br>网络层（IP、ICMP、IGMP）<br>网络接口层（MAC， 设备驱动，接口卡，以太网，令牌环）</p><ul><li>对应关系<br>OSI中的应用层、会话层、表示层对应TCP/IP中的应用层。<br>OSI中的数据链路层、物理层对应TCP/IP中网络接口层。</li></ul><h2><span id="jiao-ke-shu-wu-ceng-mo-xing">教科书五层模型</span><a href="#jiao-ke-shu-wu-ceng-mo-xing" class="header-anchor">#</a></h2><p>应用层——数据<br>运输层——数据报<br>网络层——分组/包<br>链路层——数据帧<br>物理层——比特，电流，电缆</p><h1><span id="yi-xie-qi-ta-gai-nian">一些其他概念</span><a href="#yi-xie-qi-ta-gai-nian" class="header-anchor">#</a></h1><ul><li><p>封装：从应用程序发出的数据，到链路层的过程种， 数据会不断变长，添加各种首部信息</p></li><li><p>分用：从链路传到应用程序时，会慢慢去掉首部</p></li><li><p>服务区别：<br>重复型服务： 来一个连接，处理一个， 处理完再接收下一个（UDP）<br>并发型服务： 来一个则生成一个服务器做处理，可同时处理多个（TCP）</p></li><li><p>Internet: 通过TCP/IP通信的主机集合</p></li><li><p>internet： 只所有的通信住机</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网之HTTP协议深度详解</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#http-chang-jian-wen-ti-he-gai-nian">HTTP常见问题和概念</a><ul><li><a href="#q-http-wei-shi-me-shi-wu-lian-jie-he-wu-zhuang-tai-de">Q: Http为什么是无连接 和无状态的？</a></li><li><a href="#q-1-1-2-na-me-http-de-chi-jiu-lian-jie-you-shi-zen-me-hui-shi">Q: 1.1.2 那么HTTP的持久连接又是怎么回事？</a></li><li><a href="#q-liu-lan-qi-cong-fa-song-dao-jie-shou-fa-sheng-liao-shi-me">Q: 浏览器从发送到接收，发生了什么？</a></li></ul></li><li><a href="#http-zhuang-tai-ma-he-chong-ding-xiang">HTTP状态码和重定向</a><ul><li><a href="#q-http-zhuang-tai-ma-you-na-xie">Q: HTTP状态码有哪些？</a></li><li><a href="#q-http-de-chong-ding-xiang-shi-shi-me">Q: HTTP的重定向是什么？</a></li><li><a href="#q-http-de-forward-he-redirect-you-shi-me-qu-bie">Q: HTTP的Forward和Redirect 有什么区别？</a></li></ul></li><li><a href="#https-an-quan">HTTPS安全</a><ul><li><a href="#q-jiang-yi-xia-https-shuang-xiang-ren-zheng-de-guo-cheng">Q: 讲一下HTTPS双向认证的过程？</a></li><li><a href="#q-md5-zai-shuang-xiang-ren-zheng-guo-cheng-zhong-you-shi-me-yong">Q: MD5 在双向认证过程中有什么用？</a></li><li><a href="#q-shi-me-shi-zheng-shu-lian">Q: 什么是证书链?</a></li></ul></li><li><a href="#http-yu-yi-post-he-get">HTTP语义——POST和GET</a><ul><li><a href="#q-post-he-get-de-qu-bie-shi-shi-me">Q: post和get的区别是什么？</a></li><li><a href="#q-shang-mian-ti-dao-liao-get-huan-cun-liu-lan-qi-zen-me-que-ding-huan-cun-shi-fou-yao-geng-xin">Q: 上面提到了get缓存， 浏览器怎么确定缓存是否要更新？</a></li><li><a href="#q-ru-guo-huan-cun-chao-qi-liao-dan-fu-wu-duan-zi-yuan-que-shi-mei-you-bian-hua-ru-he-bi-mian-ke-hu-duan-chong-fa-qing-qiu">Q: 如果缓存超期了，  但服务端资源确实没有变化，如何避免客户端重发请求？</a></li><li><a href="#q-shang-mian-ti-dao-de-liu-lan-qi-get-huan-cun-you-shi-me-ban-fa-bi-mian-huan-cun">Q: 上面提到的， 浏览器get缓存，有什么办法避免缓存？</a></li><li><a href="#q-chu-liao-post-he-get-qing-qiu-huan-you-na-xie-http-fang-fa">Q: 除了POST和GET请求， 还有哪些HTTP方法？</a></li><li><a href="#q-wo-ke-yi-zai-get-li-jia-body-me">Q: 我可以在get里加body么？</a></li><li><a href="#q-post-yi-ding-jiu-bi-get-an-quan-me">Q: post一定就比get安全么？</a></li></ul></li><li><a href="#http-e-wai-te-xing">HTTP额外特性</a><ul><li><a href="#q-http-de-keep-alive-he-tcp-de-keep-alive-you-shi-me-qu-bie">Q: HTTP的keep-alive和 TCP的keep-alive有什么区别？</a></li><li><a href="#q-shi-me-shi-http-liu-shui-xian-ji-zhu">Q: 什么是HTTP 流水线技术？</a></li><li><a href="#q-http-qing-qiu-tou-li-you-shi-me-dong-xi">Q: HTTP请求头里有什么东西？</a></li><li><a href="#q-cookie-you-shi-me-yong">Q: cookie有什么用？</a></li><li><a href="#q-cookie-zhong-hui-bao-han-na-xie-nei-rong">Q: cookie中会包含哪些内容？</a></li><li><a href="#q-cookie-he-session-de-qu-bie">Q: cookie和session的区别？</a></li><li><a href="#q-ke-hu-duan-liu-lan-qi-jiang-cookie-gong-neng-jin-yong-na-session-ke-yi-zen-me-ban">Q: 客户端浏览器将Cookie功能禁用, 那session可以怎么办？</a></li><li><a href="#q-fu-wu-duan-ru-he-she-ji-gao-ke-yong-de-session-te-xing">Q: 服务端如何涉及高可用的session特性？</a></li><li><a href="#q-token-you-shi-shi-me">Q: token又是什么？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><p>因为http是非常重要的东西，restful经常问道， 所以单独抽出一章节讲解。</p><p>这个最好看图解HTTP笔记里的内容。</p><hr><h1><span id="http-chang-jian-wen-ti-he-gai-nian">HTTP常见问题和概念</span><a href="#http-chang-jian-wen-ti-he-gai-nian" class="header-anchor">#</a></h1><h2><span id="q-http-wei-shi-me-shi-wu-lian-jie-he-wu-zhuang-tai-de">Q:  Http为什么是无连接 和无状态的？</span><a href="#q-http-wei-shi-me-shi-wu-lian-jie-he-wu-zhuang-tai-de" class="header-anchor">#</a></h2><p>A:</p><ul><li>一.无连接：每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接</li><li>二.无状态：</li></ul><ol><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li></ol><hr><h2><span id="q-1-1-2-na-me-http-de-chi-jiu-lian-jie-you-shi-zen-me-hui-shi">Q: 1.1.2 那么HTTP的持久连接又是怎么回事？</span><a href="#q-1-1-2-na-me-http-de-chi-jiu-lian-jie-you-shi-zen-me-hui-shi" class="header-anchor">#</a></h2><p>A:<br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。<br>实现长连接需要客户端和服务端都支持长连接。<br><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong><br>TCP短连接长连接都由客户端发起，而TCP长连接的保活功能主要为服务器应用提供。<br>如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。也因为短连接、长连接的实现在HTTP之外，与HTTP无关，从HTTP自身来看，HTTP依然是无连接的</p><hr><h2><span id="q-liu-lan-qi-cong-fa-song-dao-jie-shou-fa-sheng-liao-shi-me">Q: 浏览器从发送到接收，发生了什么？</span><a href="#q-liu-lan-qi-cong-fa-song-dao-jie-shou-fa-sheng-liao-shi-me" class="header-anchor">#</a></h2><p>A:<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/24d799de5436b49c1f29cf4c3b40aa7ef3baf1ac.png" alt="24d799de5436b49c1f29cf4c3b40aa7ef3baf1ac"></p><h1><span id="http-zhuang-tai-ma-he-chong-ding-xiang">HTTP状态码和重定向</span><a href="#http-zhuang-tai-ma-he-chong-ding-xiang" class="header-anchor">#</a></h1><hr><h2><span id="q-http-zhuang-tai-ma-you-na-xie">Q: HTTP状态码有哪些？</span><a href="#q-http-zhuang-tai-ma-you-na-xie" class="header-anchor">#</a></h2><p>A:<br>状态码分类表<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/90f8198400ce1f1b8f031e861471dbf36fd154c0.png" alt="90f8198400ce1f1b8f031e861471dbf36fd154c0"></p><p>各类别常见状态码：</p><ul><li>2xx （3种）</li></ul><p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p><p>204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；</p><p>206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</p><ul><li>3xx （5种）</li></ul><p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</p><p>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</p><p>301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）</p><p>303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；<br>302与303的区别：后者明确表示客户端应当采用GET方式获取资源</p><p>304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</p><p>307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p><ul><li>4xx （4种）</li></ul><p>400 Bad Request：表示请求报文中存在语法错误；</p><p>401 Unauthorized：未经许可，需要通过HTTP认证；</p><p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</p><p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p><ul><li>5xx （2种）</li></ul><p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p><p>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p><hr><h2><span id="q-http-de-chong-ding-xiang-shi-shi-me">Q: HTTP的重定向是什么？</span><a href="#q-http-de-chong-ding-xiang-shi-shi-me" class="header-anchor">#</a></h2><p>在 HTTP 协议中，重定向操作由服务器通过发送特殊的响应（即 redirects）而触发。HTTP 协议的重定向响应的状态码为 3xx 。</p><p>浏览器在接收到重定向响应的时候，会采用该响应提供的新的 URL ，并立即进行加载；大多数情况下，除了会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections">HTTP 的重定向</a></p><hr><h2><span id="q-http-de-forward-he-redirect-you-shi-me-qu-bie">Q: HTTP的Forward和Redirect 有什么区别？</span><a href="#q-http-de-forward-he-redirect-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A:<br>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于一个每个信息资源是共享的。</p><p>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p><p>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p><p>间接转发就相当于：“A找B借钱，B说没有，让A去找C借”。</p><p><a href="https://blog.csdn.net/zhanglifang_happy/article/details/52056504">代码实际应用</a></p><h1><span id="https-an-quan">HTTPS安全</span><a href="#https-an-quan" class="header-anchor">#</a></h1><hr><h2><span id="q-jiang-yi-xia-https-shuang-xiang-ren-zheng-de-guo-cheng">Q: 讲一下HTTPS双向认证的过程？</span><a href="#q-jiang-yi-xia-https-shuang-xiang-ren-zheng-de-guo-cheng" class="header-anchor">#</a></h2><p>A:</p><ol><li>服务端发送证书， 证书中包含网站信息、CA签名、网站公钥</li><li>客户端校验CA签名，确认是CA所签且来源方正是该网站。</li><li>客户端生成会话密钥</li><li>客户端用网站公钥对会话密钥进行加密，生成非对称的会话密钥密文</li><li>客户端发送会话密钥密文给服务端</li><li>服务端用私钥解密， 得到明文会话密钥。</li><li>二者使用会话密钥进行加密传输</li></ol><p><a href="https://bbs.huaweicloud.com/blogs/312712">故事+图文，一次性解决你对HTTPS认证过程的所有疑惑</a></p><hr><h2><span id="q-md5-zai-shuang-xiang-ren-zheng-guo-cheng-zhong-you-shi-me-yong">Q: MD5 在双向认证过程中有什么用？</span><a href="#q-md5-zai-shuang-xiang-ren-zheng-guo-cheng-zhong-you-shi-me-yong" class="header-anchor">#</a></h2><p>A:<br>对网址申请信息进行摘要， 避免签名内容过长。同时也避免了逆向推导原网址信息的过程。</p><hr><h2><span id="q-shi-me-shi-zheng-shu-lian">Q: 什么是证书链?</span><a href="#q-shi-me-shi-zheng-shu-lian" class="header-anchor">#</a></h2><p>A:</p><ul><li><p>一个证书或证书链的拆封操作，是为了<br>从中获得一个公钥。可示为X1p?X1&lt;<x2>&gt;,这为一个中缀操作，其左操作数为一个认证机构的公钥，<br>右操作数则为该认证机构所颁发的一个证书。如果能正确解开，输出结果为用户的公钥</x2></p></li><li><p>证书链验证的要求是，路径中每个证书从最终实体到根证书<br>都是有效的，并且每个证书都要正确地对应发行该证书的权威可信任性CA。操作表达式为 Ap?A&lt;<b>&gt;B&lt;<c>&gt;,<br>指出该操作使用A的公钥，从B的证书中获得B的公钥Bp，然后再通过 Bp来解封C的证书。操作的最终结果</c></b></p></li></ul><p>说人话就是下游证书解出来是上游父证书的密文公钥，然后继续解</p><p><a href="https://blog.csdn.net/junwua/article/details/80506399">理解证书和证书链</a></p><h1><span id="http-yu-yi-post-he-get">HTTP语义——POST和GET</span><a href="#http-yu-yi-post-he-get" class="header-anchor">#</a></h1><hr><h2><span id="q-post-he-get-de-qu-bie-shi-shi-me">Q: post和get的区别是什么？</span><a href="#q-post-he-get-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h2><p>A:</p><ul><li>GET参数包含在url中， post参数还包含在requestBody中。 所以不建议用get参数传递敏感信息。</li><li>get最大提交url为2k，即放在url里的参数有限制。 post的requestBody则比get大很多。</li><li>get一次只生成1个数据包（header和data一起发，返回200），  post会生成2个（先发header，响应100，再发data，返回200）。</li><li>get请求可以被浏览器主动缓存， post则不会，除非浏览器中主动设置缓存post</li><li>浏览器回退的时候，get没影响，但是post会再次提交数据，可能导致重复提交。<br><a href="https://www.cnblogs.com/logsharing/p/8448446.html">GET和POST两种基本请求方法的详细区别</a></li><li>get只接收ASCII码，post则可以在body中传输多种编码内容。</li><li>post比get更安全， 因为参数没有直接暴露在url里。</li></ul><hr><h2><span id="q-shang-mian-ti-dao-liao-get-huan-cun-liu-lan-qi-zen-me-que-ding-huan-cun-shi-fou-yao-geng-xin">Q: 上面提到了get缓存， 浏览器怎么确定缓存是否要更新？</span><a href="#q-shang-mian-ti-dao-liao-get-huan-cun-liu-lan-qi-zen-me-que-ding-huan-cun-shi-fou-yao-geng-xin" class="header-anchor">#</a></h2><p>A:<br>首先， 请求有个Cache-Control， 里面可以指定最大缓存时间。</p><hr><h2><span id="q-ru-guo-huan-cun-chao-qi-liao-dan-fu-wu-duan-zi-yuan-que-shi-mei-you-bian-hua-ru-he-bi-mian-ke-hu-duan-chong-fa-qing-qiu">Q: 如果缓存超期了，  但服务端资源确实没有变化，如何避免客户端重发请求？</span><a href="#q-ru-guo-huan-cun-chao-qi-liao-dan-fu-wu-duan-zi-yuan-que-shi-mei-you-bian-hua-ru-he-bi-mian-ke-hu-duan-chong-fa-qing-qiu" class="header-anchor">#</a></h2><p>A:<br>服务端的响应中，携带last-modified时间给客户端。<br>客户端缓存超期时，把last_modified这个时间传递过去， 服务端校验如果发现时间一致，则不做业务处理，直接返回304， 让客户端直接继续用本地缓存即可。</p><hr><h2><span id="q-shang-mian-ti-dao-de-liu-lan-qi-get-huan-cun-you-shi-me-ban-fa-bi-mian-huan-cun">Q: 上面提到的， 浏览器get缓存，有什么办法避免缓存？</span><a href="#q-shang-mian-ti-dao-de-liu-lan-qi-get-huan-cun-you-shi-me-ban-fa-bi-mian-huan-cun" class="header-anchor">#</a></h2><p>A: 给get请求的url中加个时间戳。或者设置no-cache指令<br><a href="http://www.manongjc.com/detail/12-ogbkxjractyospg.html">关于浏览器缓存的其他解答</a></p><hr><h2><span id="q-chu-liao-post-he-get-qing-qiu-huan-you-na-xie-http-fang-fa">Q: 除了POST和GET请求， 还有哪些HTTP方法？</span><a href="#q-chu-liao-post-he-get-qing-qiu-huan-you-na-xie-http-fang-fa" class="header-anchor">#</a></h2><p>A:</p><ul><li>HEAD：类似get请求， 返回的响应里不包含body，只给响应报头</li><li>PUT：发送的数据专门用于覆盖某数据</li><li>DELETE：请求服务器删除指定资源或者页面</li><li>TRACE： 回显服务起收到的请求， 用于测试或者诊断</li><li>CONNECT： HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS: 返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</li></ul><hr><h2><span id="q-wo-ke-yi-zai-get-li-jia-body-me">Q: 我可以在get里加body么？</span><a href="#q-wo-ke-yi-zai-get-li-jia-body-me" class="header-anchor">#</a></h2><p>A:<br>完全可以加，没有问题， GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 例如某些框架可能针对get和post做过封装来限制一些语义。</p><hr><h2><span id="q-post-yi-ding-jiu-bi-get-an-quan-me">Q: post一定就比get安全么？</span><a href="#q-post-yi-ding-jiu-bi-get-an-quan-me" class="header-anchor">#</a></h2><p>A:<br>如果用了HTTPS， 则post比get安全， 否则是一样的的，因为传输时都是明文传输。</p><hr><h1><span id="http-e-wai-te-xing">HTTP额外特性</span><a href="#http-e-wai-te-xing" class="header-anchor">#</a></h1><h2><span id="q-http-de-keep-alive-he-tcp-de-keep-alive-you-shi-me-qu-bie">Q: HTTP的keep-alive和 TCP的keep-alive有什么区别？</span><a href="#q-http-de-keep-alive-he-tcp-de-keep-alive-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A:<br>区别一：</p><ul><li>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；</li><li>TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；</li></ul><p>区别二：</p><ul><li>HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 HTTP 长连接</li><li>TCP 的 Keepalive 这东西其实就是 TCP 的保活机制<br>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文</li></ul><p>区别三：</p><ul><li>HTTP添加方式——请求头添加Connection: Keep-Alive</li><li>TCP添加方式——通过 socket 接口设置SO_KEEPALIVE<br><a href="https://zhuanlan.zhihu.com/p/431303367?utm_source=qq&amp;utm_medium=social&amp;utm_oi=682142273152749568">阿里一面：TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</a></li></ul><hr><h2><span id="q-shi-me-shi-http-liu-shui-xian-ji-zhu">Q: 什么是HTTP 流水线技术？</span><a href="#q-shi-me-shi-http-liu-shui-xian-ji-zhu" class="header-anchor">#</a></h2><p>A:<br>所谓的 HTTP 流水线，是客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应，可以减少整体的响应时间。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/3f834d8022663b7ee0ce1602133f09dcf0f8c5cf.png" alt="3f834d8022663b7ee0ce1602133f09dcf0f8c5cf"></p><hr><h2><span id="q-http-qing-qiu-tou-li-you-shi-me-dong-xi">Q: HTTP请求头里有什么东西？</span><a href="#q-http-qing-qiu-tou-li-you-shi-me-dong-xi" class="header-anchor">#</a></h2><p>A:</p><ul><li>Host: <a href="http://www.study.com">www.study.com</a>                // 请求的地址域名和端口，不包括协议</li><li>Connection: keep-alive　　　   // 连接类型，持续连接</li><li>Upgrade-Insecure-Requests：1  // http 自动升级到https，防止跨域问题但是域名端口都不同的不会提升</li><li>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36  //浏览器的用户代理信息</li><li>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<code>*/*</code>;q=0.8     //浏览器支持的请求类型</li><li>Accept-Encoding: gzip, deflate, sdch   //浏览器能处理的压缩代码</li><li>Accept-Language: zh-CN,zh;q=0.8,en;q=0.6  //浏览器当前设置语言<br>post新加的请求头：</li><li>Content-Length: 29                  //请求参数长度</li><li>Cache-Control: max-age=0      //强制要求服务器返回最新的文件内容,也就是不走缓存，返回的200</li><li>Origin: <a href="http://www.study.com">http://www.study.com</a>    //请求来源地址，包括协议</li><li>Referer: <a href="http://www.study.com/day02/01-login.html">http://www.study.com/day02/01-login.html</a>     //原始的url,不带锚点，比方说在谷歌打开百度，feferer显示的是谷歌的url</li></ul><hr><h2><span id="q-cookie-you-shi-me-yong">Q: cookie有什么用？</span><a href="#q-cookie-you-shi-me-yong" class="header-anchor">#</a></h2><p>A:<br>HTTP协议作为无状态协议，对于HTTP协议而言，无状态同样指每次request请求之前是相互独立的，当前请求并不会记录它的上一次请求信息。那么问题来了，既然无状态，那完成一套完整的业务逻辑，发送多次请求的情况数不胜数，使用http如何将上下文请求进行关联呢？机智的人类通过优化，找到了一种简单的方式记录http协议的请求信息.</p><ol><li>浏览器发送request请求到服务器，服务器除了返回请求的response之外，还给请求分配一个唯一标识ID，协同response一并返回给浏览器。</li><li>同时服务器在本地创建一个MAP结构，专门以key-value（请求ID-会话内容）形式将每个request进行存储</li><li>此时浏览器的request已经被赋予了一个ID，第二次访问时，服务器先从request中查找该ID，根据ID查找维护会话的content内容，该内容中记录了上一次request的信息状态。</li><li>根据查找出的request信息生成基于这些信息的response内容，再次返回给浏览器。如果有需要会再次更新会话内容，为下一次请求提供准备。</li></ol><p><strong>根据这个会话ID，以建立多次请求-响应模式的关联数据传递</strong>, 这就是cookie和session对无状态的http协议的强大作用。<br>服务端生成这个全局的唯一标识，传递给客户端用于唯一标记这次请求，也就是cookie；而服务器创建的那个map结构就是session。</p><hr><h2><span id="q-cookie-zhong-hui-bao-han-na-xie-nei-rong">Q: cookie中会包含哪些内容？</span><a href="#q-cookie-zhong-hui-bao-han-na-xie-nei-rong" class="header-anchor">#</a></h2><p>A:</p><ul><li>Domain：域，表示当前cookie所属于哪个域或子域下面。<br>对于服务器返回的Set-Cookie中，如果没有指定Domain的值，那么其Domain的值是默认为当前所提交的http的请求所对应的主域名的。比如访问 <a href="http://www.example.com">http://www.example.com</a>，返回一个cookie，没有指名domain值，<a href="http://xn--www-c88da6fy7pz3cm18kef0b2qler5b.example.com">那么其为值为默认的www.example.com</a>。</li><li>Path：表示cookie的所属路径。</li><li>Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。</li><li>secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。</li><li>httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/1f9ba53e2ef279db7a874a0a4ab4b0fcf312ddd8.png" alt="1f9ba53e2ef279db7a874a0a4ab4b0fcf312ddd8"><br><a href="https://www.cnblogs.com/bq-med/p/8603664.html">Http协议中Cookie详细介绍</a></li></ul><hr><h2><span id="q-cookie-he-session-de-qu-bie">Q: cookie和session的区别？</span><a href="#q-cookie-he-session-de-qu-bie" class="header-anchor">#</a></h2><p>A:<br>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。<br>常用的会话跟踪技术是Cookie与Session。</p><ol><li><p>Cookie通过在<strong>客户端</strong>记录信息确定用户身份，Cookie具有不可跨域名性<br>Session通过在<strong>服务器端</strong>记录信息确定用户身份。</p></li><li><p>Session需要使用Cookie作为识别标志</p></li><li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie</p></li></ol><blockquote><blockquote><p>Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p></blockquote></blockquote><p><a href="https://www.cnblogs.com/l199616j/p/11195667.html">cookie和session的详解与区别</a></p><hr><h2><span id="q-ke-hu-duan-liu-lan-qi-jiang-cookie-gong-neng-jin-yong-na-session-ke-yi-zen-me-ban">Q: 客户端浏览器将Cookie功能禁用, 那session可以怎么办？</span><a href="#q-ke-hu-duan-liu-lan-qi-jiang-cookie-gong-neng-jin-yong-na-session-ke-yi-zen-me-ban" class="header-anchor">#</a></h2><p>A:<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态</p><hr><h2><span id="q-fu-wu-duan-ru-he-she-ji-gao-ke-yong-de-session-te-xing">Q: 服务端如何涉及高可用的session特性？</span><a href="#q-fu-wu-duan-ru-he-she-ji-gao-ke-yong-de-session-te-xing" class="header-anchor">#</a></h2><p>A:<br>保证session一致性的架构设计常见方法：</p><ul><li>session同步法：多台web-server相互同步数据(代价高，无法水平扩容）</li><li>客户端存储法：session存到用户本地cookie中（带宽变大，不安全）</li><li>反向代理hash一致性：四层hash和七层hash都可以做，保证一个用户的请求落在一台web-server上</li><li>后端统一存储：存到redis集群或者数据库，web-server重启和扩容，session也不会丢失</li></ul><p>建议：<br><strong>web层、service层无状态</strong>是大规模分布式系统设计原则之一，session属于状态，不宜放在web层<br>让专业的软件做专业的事情，web-server存session？还是让cache去做这样的事情吧</p><p><a href="https://www.w3cschool.cn/architectroad/architectroad-session-consistency.html">session一致性架构设计实践</a></p><hr><h2><span id="q-token-you-shi-shi-me">Q: token又是什么？</span><a href="#q-token-you-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</p><p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。<br><a href="https://www.cnblogs.com/ella-li/p/12008069.html">Token 、Cookie和Session的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网之应用层详解</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-dns">1 DNS</a><ul><li><a href="#1-1-yu-ming">1.1 域名</a></li><li><a href="#1-2-yu-ming-fu-wu-qi">1.2 域名服务器</a></li><li><a href="#1-3-yu-ming-cha-zhao-ji-zhi">1.3 域名查找机制</a><ul><li><a href="#1-3-1-die-dai-cha-zhao-zui-chang-yong">1.3.1 迭代查找（最常用）</a></li><li><a href="#1-3-2-di-gui-cha-zhao-hen-shao">1.3.2 递归查找（很少）</a></li></ul></li></ul></li><li><a href="#2-ftp-wen-jian-chuan-song-xie-yi">2 FTP文件传送协议</a><ul><li><a href="#2-1-wen-jian-shang-chuan-guo-cheng">2.1 文件上传过程</a></li><li><a href="#2-2-wen-jian-xia-zai-guo-cheng">2.2 文件下载过程</a></li><li><a href="#3-tftp-jian-dan-wen-jian-chuan-song-xie-yi">3 TFTP 简单文件传送协议</a><ul><li><a href="#3-1-p2p-wen-jian-chuan-shu">3.1 P2P文件传输</a></li></ul></li></ul></li><li><a href="#4-smtp-dian-zi-you-jian-xie-yi">4 SMTP电子邮件协议</a><ul><li><a href="#4-1-zu-jian-gou-cheng">4.1 组件构成</a><ul><li><a href="#4-1-1-yong-hu-dai-li-ua-user-agent">4.1.1 用户代理UA（user agent)</a></li><li><a href="#4-1-2-you-jian-fu-wu-qi">4.1.2 邮件服务器</a></li><li><a href="#4-1-3-xie-yi">4.1.3 协议</a></li></ul></li><li><a href="#4-2-tong-xin-bu-zou">4.2 通信步骤</a><ul><li><a href="#4-2-1-lian-jie-jian-li">4.2.1 连接建立</a></li><li><a href="#4-2-2-you-jian-chuan-song">4.2.2 邮件传送</a></li><li><a href="#4-2-3-lian-jie-shi-fang">4.2.3 连接释放</a></li><li><a href="#4-2-4-pop-tui-song-gei-ke-hu-duan-ua">4.2.4 POP推送给客户端UA</a></li></ul></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="1-dns">1 DNS</span><a href="#1-dns" class="header-anchor">#</a></h1><ul><li>全称Domain Name System，  域名系统。</li><li>传输层使用UDP协议，端口为53</li></ul><p>Q: DNS为什么要使用UDP协议呢？<br>A:<br>DNS这个东西通信模式相当固定，报文基本上一个包搞定。大多数情况一问一答就结束了。<br>你三次握手来回3个包呢，人家一来一回就已经结速了，这种时候搞什么TCP？有必要中间连续穿好几次数据保证可靠性么？</p><h2><span id="1-1-yu-ming">1.1 域名</span><a href="#1-1-yu-ming" class="header-anchor">#</a></h2><ul><li><p>域名由 “标号.标号.标号”组成<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Rk1b92vm-1613753140851)(en-resource://database/2048:1)]</p></li><li><p>标号由字母和“-”组成。</p></li><li><p>标号不超过63个字符</p></li><li><p>总域名（标号之和）不能超过255</p></li><li><p>分为根、顶级、二级、三级<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004639910.png" alt="在这里插入图片描述"></p></li><li><p>顶级域名分类：</p><ol><li>国家顶级域名nTLD: 例如cn\us</li><li>通用顶级域名gTLD:例如com\net\gov</li><li>基础建设顶级域（arpa）<br>4.测试顶级域</li></ol></li><li><p>域名和ip可以是多对多的关系， 即1个域名可以对应多个ip（分布式多活）， 1个ip也可以被绑定成不同的域名。</p></li></ul><h2><span id="1-2-yu-ming-fu-wu-qi">1.2 域名服务器</span><a href="#1-2-yu-ming-fu-wu-qi" class="header-anchor">#</a></h2><ul><li>每个域名和ip的对应关系都会存在域名服务器中。</li><li>DNS采用分区的方式，解决域名服务器过多的问题，每个域名服务器管理一个区。</li><li>分布式部署，C/S模式<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004730567.png" alt="在这里插入图片描述"></li></ul><h2><span id="1-3-yu-ming-cha-zhao-ji-zhi">1.3 域名查找机制</span><a href="#1-3-yu-ming-cha-zhao-ji-zhi" class="header-anchor">#</a></h2><h3><span id="1-3-1-die-dai-cha-zhao-zui-chang-yong">1.3.1 迭代查找（最常用）</span><a href="#1-3-1-die-dai-cha-zhao-zui-chang-yong" class="header-anchor">#</a></h3><p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004747600.png" alt="在这里插入图片描述"></p><ol><li>查找域名时，会先根据缓存，再根据本机host文件</li><li>当本地都没有，就会启动dns域名查找机制。</li><li>迭代查找记住就是会以本地DNS服务器为关键节点， 先去根域名寻求顶级域名服务器的ip</li><li>再去顶级域名却寻二级域的位置， 最后再去权威DNS服务器查找最终位置。</li></ol><ul><li>注意像根域名服务器的位置一般也会做缓存，所以1、2、3这几步一般也是不用重复去做的，很可能查询一个陌生的域名时，直接在本地DNS那边定位到了4那一步。</li></ul><h3><span id="1-3-2-di-gui-cha-zhao-hen-shao">1.3.2 递归查找（很少）</span><a href="#1-3-2-di-gui-cha-zhao-hen-shao" class="header-anchor">#</a></h3><p>递归其实就是从根域名如果找不到， 则让根域名发起请求向顶级域名查询。<br>即发起请求的对象变了，这种显然会占用根域名服务器的客户端资源，明显不好。</p><h1><span id="2-ftp-wen-jian-chuan-song-xie-yi">2 FTP文件传送协议</span><a href="#2-ftp-wen-jian-chuan-song-xie-yi" class="header-anchor">#</a></h1><p>基于TCP传输，可靠性高。</p><h2><span id="2-1-wen-jian-shang-chuan-guo-cheng">2.1 文件上传过程</span><a href="#2-1-wen-jian-shang-chuan-guo-cheng" class="header-anchor">#</a></h2><p>客户端发送PASV命令<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004800504.png" alt="在这里插入图片描述"></p><p>可以看到FTP服务器会给每个连接建立相应独立的控制进程和数据进程。</p><h2><span id="2-2-wen-jian-xia-zai-guo-cheng">2.2 文件下载过程</span><a href="#2-2-wen-jian-xia-zai-guo-cheng" class="header-anchor">#</a></h2><p>其实就是发送了PORT命令：<br>PORT h1,h2,h3,h4,p1,p2 (h1-h4是IP地址，p1-p2是端口号)<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/2021022000481735.png" alt="在这里插入图片描述"></p><p>可以看到下载过程是FTP服务器向对方发起连接</p><hr><ul><li>注意上面发起会话时，会有身份认证的过程，同时也可以配置用户权限。</li><li>FTP不适合在2个计算机直接进行共享读写文件（因为会进行资源占用）， 只适合单次的上传和下载。</li><li></li></ul><h2><span id="3-tftp-jian-dan-wen-jian-chuan-song-xie-yi">3 TFTP 简单文件传送协议</span><a href="#3-tftp-jian-dan-wen-jian-chuan-song-xie-yi" class="header-anchor">#</a></h2><ul><li>使用UDP传输</li><li>支持文件传输但是无交互命令</li><li>应用层报文按序编号</li><li>熟知端口为69</li><li>代码轻量，程序占用小</li><li>传输过程类似于停止-等待协议:</li></ul><blockquote><blockquote><p>单帧滑动-停止等待协议</p><ul><li>一次只发一帧，1次只收一帧，并确认占有信道后才继续</li><li>发送端：收到ack确认后，才会发下一个，每个都有个定时器</li><li>接收端：序号不匹配递增的话都会丢弃。</li></ul></blockquote></blockquote><h3><span id="3-1-p2p-wen-jian-chuan-shu">3.1 P2P文件传输</span><a href="#3-1-p2p-wen-jian-chuan-shu" class="header-anchor">#</a></h3><p>FTP和TFTP，都可能是有人把文件存在一个集中的服务器上，大家去下载上传。</p><p>而P2P则是建立了主机和主机间的直接通信， 不需要依赖中间服务器</p><ul><li>类似于别人直接从你电脑的目录上下载文件而不是从百度网盘里下载</li></ul><h1><span id="4-smtp-dian-zi-you-jian-xie-yi">4 SMTP电子邮件协议</span><a href="#4-smtp-dian-zi-you-jian-xie-yi" class="header-anchor">#</a></h1><h2><span id="4-1-zu-jian-gou-cheng">4.1 组件构成</span><a href="#4-1-zu-jian-gou-cheng" class="header-anchor">#</a></h2><h3><span id="4-1-1-yong-hu-dai-li-ua-user-agent">4.1.1 用户代理UA（user agent)</span><a href="#4-1-1-yong-hu-dai-li-ua-user-agent" class="header-anchor">#</a></h3><p>其实就是邮件客户端，类似于foxmail、outlook、qq邮箱等exe程序，</p><h3><span id="4-1-2-you-jian-fu-wu-qi">4.1.2 邮件服务器</span><a href="#4-1-2-you-jian-fu-wu-qi" class="header-anchor">#</a></h3><ul><li>功能： 发送和接收邮件，报告邮件的传送情况</li><li>具备C/S工作模式：  发送邮件时是一个客户端，接收邮件时是一个服务端</li><li>不同邮件提供商有自己的服务器，但是他们之间可以互相通信。</li></ul><h3><span id="4-1-3-xie-yi">4.1.3 协议</span><a href="#4-1-3-xie-yi" class="header-anchor">#</a></h3><p>使用SMTP接收协议和POP读取服务完成整套邮件系统协议。</p><h2><span id="4-2-tong-xin-bu-zou">4.2 通信步骤</span><a href="#4-2-tong-xin-bu-zou" class="header-anchor">#</a></h2><h3><span id="4-2-1-lian-jie-jian-li">4.2.1 连接建立</span><a href="#4-2-1-lian-jie-jian-li" class="header-anchor">#</a></h3><ul><li>用户使用UA发送邮件到自己UA所属的邮件服务器</li><li>服务器定期扫描，发现有新的未发送邮件</li><li>向目的端服务器试图建立连接</li></ul><h3><span id="4-2-2-you-jian-chuan-song">4.2.2 邮件传送</span><a href="#4-2-2-you-jian-chuan-song" class="header-anchor">#</a></h3><ol><li>发送端发送MAIL命令</li><li>接收端回答“250 OK”，即准备好接收</li><li>发送端发送多个&quot;RCPT+ 收件人&quot;的命令， 以向对方确认是否可以接收</li><li>接收端逐一应答“250 ok”或者“550 no such user”</li><li>获得ok应答后，使用DATA命令发送邮件内容</li><li>接收端回复 354 xxx end xxx., 告知邮件接收结束</li></ol><h3><span id="4-2-3-lian-jie-shi-fang">4.2.3 连接释放</span><a href="#4-2-3-lian-jie-shi-fang" class="header-anchor">#</a></h3><p>发送端发送QUIT命令<br>接收端返回221同意释放连接</p><h3><span id="4-2-4-pop-tui-song-gei-ke-hu-duan-ua">4.2.4 POP推送给客户端UA</span><a href="#4-2-4-pop-tui-song-gei-ke-hu-duan-ua" class="header-anchor">#</a></h3><p>注意前面3步只是完成了从发送者到 接收者所属邮件服务器的步骤，还没有到接收者本地的邮箱应用。<br>接收者客户端会通过POP协议定期去拉取邮件。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基本名词和概念</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#mysql-fu-wu-qi-xiang-ying-yuan-li-dc40bbcdffcfae8017e64a957a15a800a640516e-images-e6-95-b0-e6-8d-ae-e5-ba-93-e5-9f-ba-e6-9c-ac-e5-90-8d-e8-af-8d-e5-92-8c-e6-a6-82-e5-bf-b5-dc40bbcdffcfae8017e64a957a15a800a640516e-png">mysql服务器响应原理<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/dc40bbcdffcfae8017e64a957a15a800a640516e.png" alt="dc40bbcdffcfae8017e64a957a15a800a640516e"></a></li><li><a href="#shi-wu-acid">事务ACID</a></li><li><a href="#3-chong-du-wen-ti">3种读问题</a></li><li><a href="#4-chong-ge-chi-ji-bie">4种隔离级别</a></li><li><a href="#shu-ju-ku-3-chong-wan-zheng-xing-yue-shu">数据库3种完整性约束</a></li><li><a href="#4-chong-fan-shi">4种范式</a></li><li><a href="#cun-chu-yin-qing-bi-jiao">存储引擎比较</a><ul><li><a href="#cun-chu-yin-qing-de-bi-jiao-innodb">存储引擎的比较InnoDB</a></li><li><a href="#myisam">MyISAM</a></li><li><a href="#qi-ta-yin-qing">其他引擎</a></li><li><a href="#q-bu-tong-chang-jing-xia-de-cun-chu-yin-qing-xuan-ze">Q: 不同场景下的存储引擎选择</a></li><li><a href="#q-mysql5-7-he-8-0-de-qu-bie">Q： mysql5.7和8.0的区别</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="mysql-fu-wu-qi-xiang-ying-yuan-li">mysql服务器响应原理<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/dc40bbcdffcfae8017e64a957a15a800a640516e.png" alt="dc40bbcdffcfae8017e64a957a15a800a640516e"></span><a href="#mysql-fu-wu-qi-xiang-ying-yuan-li" class="header-anchor">#</a></h1><hr><h1><span id="shi-wu-acid">事务ACID</span><a href="#shi-wu-acid" class="header-anchor">#</a></h1><ul><li>A是 atomicity原子性,     事务内的行为一次性执行完，要么就回退</li><li>C是consistency一致性    有a+b=c的限制条件，然后a变化的同时，b也必须跟着变化</li><li>I是isolation隔离性   事务隔离，即事务的中间执行过程，对另外一个事务不可见。</li><li>D是durability持久性  提交i成功后，修改不会改变，也会被记录。</li></ul><p>不同的存储引擎支持不同的事务处理<br>不支持事务的话，性能会高，但是可靠性就差。</p><h1><span id="3-chong-du-wen-ti">3种读问题</span><a href="#3-chong-du-wen-ti" class="header-anchor">#</a></h1><ul><li>脏读：数据被更新了，但是还没提交， 然后另一个事务读到了更新后的数据，结果事务回滚了，导致读的数据其实是脏数据，</li><li>不可重复读：  1个事务要读2次数据（注意是单条数据），结果第一次读和第二次读数据不一致了。<br>换个说法：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。（主要是update触发）</li><li>幻读： 1个事务按照某搜索条件读了2次 数据，发现2次的记录数不一致，可能多了或者少了记录（注意是多条记录的情况， 不可重复读只针对单条数据的内容变化）（主要是insert、delete触发）<br>换个说法，就是你发现数据莫名奇妙多了一条：<br>第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行</li></ul><h1><span id="4-chong-ge-chi-ji-bie">4种隔离级别</span><a href="#4-chong-ge-chi-ji-bie" class="header-anchor">#</a></h1><p>简易记法： RU\RC\RR\SE<br>第一个R是read， U是uncommit， C是uncommit， R是repeated， SE是顺序</p><ul><li>Read Uncommited  最低隔离级别。 写的时候可以被读取。 3个读问题都无法避免。<br>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据<br>注意，RU级别，是有写锁的，并不是什么都没做</li><li>Read Committed  大部分数据库的默认隔离级别。 只有在事务提交后，另一个事务才能看到同一笔数据更新后的结果。</li></ul><p>允许其他事务继续访问该行数据，但是<strong>未提交的写事务</strong>将会禁止其他事务访问该行，会对该写锁一直保持直到到事务提交。</p><p>区别就是写的时候，未提交的事务会禁止，相当于写的过程会让读不可见。</p><p>能解决脏读， RC隔离级别保证了对读取到的记录加锁(记录锁)</p><ul><li><p>Repeateable Read 保证同一笔数据在事务中，必须是相同的，不会让他变化。<br>能避免不可重复度和脏读，   “可能”避免幻读<br>RR隔离级别保证对读取到的记录加锁(记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入(间隙锁)。</p></li><li><p>Serializable  所有事务都必须依次顺序执行。 都能解决<br>所有的读操作都是当前读，读加读锁(S锁)，写加写锁(X锁)。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</p></li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/2486676b1dd91f04b79a37922663c2aada317781.png" alt="2486676b1dd91f04b79a37922663c2aada317781"></p><h1><span id="shu-ju-ku-3-chong-wan-zheng-xing-yue-shu">数据库3种完整性约束</span><a href="#shu-ju-ku-3-chong-wan-zheng-xing-yue-shu" class="header-anchor">#</a></h1><ul><li>域完整性（值约束）：域完整性是保证数据库字段取值的合理性</li><li>实体完整性（主键约束）：指关系的主关键字不能重复也不能取“空值&quot;。</li><li>参照完整性（外键约束）： 主关键字与外部关键字引用的约束条件。</li></ul><h1><span id="4-chong-fan-shi">4种范式</span><a href="#4-chong-fan-shi" class="header-anchor">#</a></h1><ol><li>第一范式比较简单，属性不可拆分。电话号码一个字段可以分为手机号码和座机号码两个字段。</li><li>第二范式不难理解，非主属性对候选键完全依赖，不能存在部分依赖。 即主键唯一时，能确定这个非主属性值。<br>候选键只有一个主属性时则一定符合第二范式。<br>候选键包含多个主属性时，可能出现不符合第二范式的情况，</li><li>第三范式去除冗余，非主属性只能存在一个表中，不应该存在多个表中，要去除无意义的数据冗余。</li><li>BC范式则不应存在关键字决定关键字的情况。也就是在关联关系表中，一个表有多个属性构成复合的候选键，主属性直接不应该有互相依赖。工号和身份证号是相互依赖。</li><li>第四范式，对于候选键只能存在不超过1个多值属性。要求把同一表内的多对多关系删除。</li></ol><p>简易版：</p><ul><li>第一范式：不可拆</li><li>第二范式：多个主键时，不能只用到1个主键。</li><li>第三范式：非主键属性不能冗余，最好集中到一个表</li><li>第四范式：不常问， 好象是1个主键只能对应一个属性值，不要多对多，到时候就说我也不太理解，很少用到吧。</li></ul><h1><span id="cun-chu-yin-qing-bi-jiao">存储引擎比较</span><a href="#cun-chu-yin-qing-bi-jiao" class="header-anchor">#</a></h1><h2><span id="cun-chu-yin-qing-de-bi-jiao-innodb">存储引擎的比较InnoDB</span><a href="#cun-chu-yin-qing-de-bi-jiao-innodb" class="header-anchor">#</a></h2><p>这是mysql的默认事务型引擎</p><p>用于处理短期事务（不常回滚的），但本质上还是事务型的存储引擎<br>数据存储在tablespace中（一堆又innoDB管理的文件，我们看不懂的那种文件）<br>使用MVCC支持高并发，实现4个隔离级别，  有间隙锁<br>使用聚簇索引</p><h2><span id="myisam">MyISAM</span><a href="#myisam" class="header-anchor">#</a></h2><p>MYSQL5.1之前，是默认的存储引擎<br>不支持事务和行级锁！也就是说不支持修复！<br>表存在2个文件中： 数据文件和索引文件<br>只能针对表加锁，不能针对行<br>有修复操作，但是用于修复表的错误（而不是回滚这种操作)<br>支持全文索引<br>如果表导入数据后不再更新，可以用MyISAM压缩表， 而且解压开销不大。</p><h2><span id="qi-ta-yin-qing">其他引擎</span><a href="#qi-ta-yin-qing" class="header-anchor">#</a></h2><p>Archive： 只支持insert和select、压缩写、支持行级锁、不是事务引擎<br>blackhole： 会丢弃所有插入的数据，但是会记录日志。（一般用于数据备份、日志审计）<br>csv：把csv文件当作mysql表。不支持索引<br>Federated： 是访问mysql的一个代理引擎。本质还是连接mysql。默认禁用<br>memory引擎：  希望快速访问不存盘， 重启后丢失也无所谓，可以i用这个，类似于H2内存数据库。<br>用作缓存非常不错。<br>NDB集群引擎： 分布式mysql集群</p><h2><span id="q-bu-tong-chang-jing-xia-de-cun-chu-yin-qing-xuan-ze">Q: 不同场景下的存储引擎选择</span><a href="#q-bu-tong-chang-jing-xia-de-cun-chu-yin-qing-xuan-ze" class="header-anchor">#</a></h2><p>A:</p><ul><li>日志记录：  要求插入快，可使用myisam</li><li>读多写少： InnoDB， 避免崩溃恢复问题。</li><li>订单处理： 事务时必须的，innoDB</li><li>电子公告牌：多数应用只有几个表保存数据，核心表的压力很大</li><li>大数据量： 数据仓库， infobright、NDB或者hive哈哈</li></ul><hr><h2><span id="q-mysql5-7-he-8-0-de-qu-bie">Q： mysql5.7和8.0的区别</span><a href="#q-mysql5-7-he-8-0-de-qu-bie" class="header-anchor">#</a></h2><p>A:</p><ul><li>新增INVISIBLE和VISIBLE语法， 以支持隐藏索引的功能，用于调试</li><li>MySQL 8 开始，数据库的缺省编码将改为 utf8mb4</li><li>支持用命令 SET PERSIST进行配置的修改，而不是登录后台修改。</li><li>新增窗口函数，支持先生成一个排序的窗口表，再做rank<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/4678c23a55172ed1d7db48f6a8f6765f97e66e74.png" alt="4678c23a55172ed1d7db48f6a8f6765f97e66e74"></li><li>更安全，支持SQL角色设置和权限设置</li></ul><p>更详细的：<a href="https://www.jianshu.com/p/7259a2f0e95a">MySQL5.7.X用的好好的，为什么要用MySQL8.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网之传输层（TCP/IP）详解</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-chuan-shu-ceng-he-wang-luo-ceng-de-qu-bie">1 传输层和网络层的区别：</a><ul><li><a href="#1-1-fu-ze-dui-xiang-de-bu-tong">1.1 负责对象的不同</a></li><li><a href="#1-2-xiao-yan-shang-de-bu-tong">1.2 校验上的不同</a></li></ul></li><li><a href="#2-duan-kou-hao">2 端口号</a><ul><li><a href="#2-1-duan-kou-hao-de-yi-yi">2.1 端口号的意义</a></li><li><a href="#2-2-duan-kou-hao-fan-wei">2.2 端口号范围</a></li></ul></li><li><a href="#3-tcp">3 TCP</a><ul><li><a href="#3-1-tcp-shou-bu">3.1 TCP首部</a><ul><li><a href="#q-jiang-yi-xia-tcp-bao-wen-du-you-sha-ke-yi-bu-an-shun-xu-jiang">Q: 讲一下TCP报文都有啥，可以不按顺序讲</a></li></ul></li><li><a href="#3-2-hua-dong-chuang-kou">3.2 滑动窗口</a><ul><li><a href="#3-2-1-fa-song-duan-chuang-kou">3.2.1发送端窗口</a></li><li><a href="#3-2-2-jie-shou-duan-chuang-kou">3.2.2 接收端窗口</a></li><li><a href="#3-2-3-jian-chi-ding-shi-qi">3.2.3 坚持定时器</a></li><li><a href="#3-2-4-hu-tu-chuang-kou">3.2.4 糊涂窗口</a></li></ul></li><li><a href="#3-3-tcp-lian-jie-liu-cheng">3.3 TCP连接流程</a><ul><li><a href="#3-3-1-wo-shou-he-hui-shou-liu-cheng">3.3.1 握手和挥手流程</a><ul><li><a href="#wei-shi-me-jian-li-yao-3-ci-wo-shou">为什么建立要3次握手？</a></li><li><a href="#wei-shi-me-jie-shu-lian-jie-yao-4-ci-hui-shou">为什么结束连接要4次挥手？</a></li><li><a href="#neng-fou-hui-shou-3-ci">能否挥手3次</a></li><li><a href="#si-ci-hui-shou-zhong-de-time-wait-zhuang-tai-zuo-yong">四次挥手中的TIME_WAIT状态作用？</a></li><li><a href="#liang-bian-tong-shi-xiang-hu-jian-li-lian-jie-hui-fa-sheng-shi-me">两边同时相互建立连接会发生什么？</a></li><li><a href="#liang-bian-tong-shi-guan-bi-lian-jie-hui-fa-sheng-shi-me">两边同时关闭连接会发生什么</a></li></ul></li><li><a href="#3-3-4-jiao-hu-shu-ju">3.3.4 交互数据</a><ul><li><a href="#nagle-suan-fa">nagle算法</a></li><li><a href="#q-shi-me-shi-tcp-nian-bao">Q: 什么是TCP粘包？</a></li><li><a href="#q-zao-cheng-nian-bao-de-yuan-yin-shi-shi-me">Q: 造成粘包的原因是什么？</a></li><li><a href="#q-shi-me-shi-hou-xu-yao-chu-li-nian-bao-xian-xiang">Q:什么时候需要处理粘包现象？</a></li><li><a href="#q-ru-he-chu-li-nian-bao-xian-xiang">Q: 如何处理粘包现象？</a></li><li><a href="#q-udp-hui-bu-hui-chan-sheng-nian-bao-wen-ti-ni">Q：UDP会不会产生粘包问题呢？</a></li></ul></li><li><a href="#3-3-5-yi-chang-qing-kuang">3.3.5 异常情况</a></li></ul></li><li><a href="#3-4-yong-sai-bi-mian-ji-zhi">3.4 拥塞避免机制</a><ul><li><a href="#q-jian-li-lian-jie-hou-mei-ci-fa-song-de-bao-wen-shu-liang-shi-gu-ding-de-ma-ji-mei-ci-du-fa-1-tiao-huo-zhe-10-tiao">Q: 建立连接后，每次发送的报文数量是固定的吗？即每次都发1条或者10条？</a></li><li><a href="#q-man-qi-dong-guo-cheng-zhong-na-me-fa-song-shu-liang-yong-sai-chuang-kou-shi-me-shi-hou-bu-zai-bei-zeng-shi-wu-xian-bei-zeng-ma">Q: 慢启动过程中，那么发送数量（拥塞窗口）什么时候不再倍增？是无限倍增吗？</a></li><li><a href="#q-na-me-dang-jin-ru-yong-sai-bi-mian-mei-ci-1-shi-shi-me-shi-hou-cai-hui-bu-zai-ji-xu-jia">Q:那么，当进入拥塞避免，每次+1时，什么时候才会不再继续加？</a></li><li><a href="#q-shang-mian-ti-dao-liao-chao-shi-na-me-tcp-ke-hu-duan-shi-zen-me-pan-duan-bao-wen-fa-song-chao-shi-de-ni">Q: 上面提到了超时， 那么TCP客户端是怎么判断报文发送超时的呢？</a></li><li><a href="#q-shang-mian-ti-dao-de-chao-shi-shi-jian-rto-shi-zen-me-lai-de-wan-yi-she-de-tai-da-ke-neng-dao-zhi-hen-chi-cai-neng-fan-ying-guo-lai-she-de-tai-xiao-ze-ke-neng-dao-zhi-mei-tiao-du-chao-shi">Q:上面提到的超时时间RTO是怎么来的？万一设得太大可能导致很迟才能反应过来， 设得太小则可能导致每条都超时</a></li><li><a href="#q-ru-guo-fa-sheng-chong-chuan-que-huan-shi-mei-you-shou-dao-ack-na-me-zui-xin-de-rtt-yang-ben-ying-gai-zen-me-suan-ji-ni-du-shou-bu-dao-zui-xin-de-ack-liao-rtt-nan-dao-qu-chao-shi-shi-jian-ma">Q: 如果发生重传，却还是没有收到ack，那么最新的RTT样本应该怎么算？即你都收不到最新的ack了， RTT难道取超时时间吗？</a></li><li><a href="#q-shang-mian-ti-dao-de-ack-chao-shi-pan-duan-hui-bu-hui-tai-jiu-liao-jia-ru-zhi-shi-fa-de-shi-hou-diu-liao-zhong-jian-bu-fen-bao-wen-er-yi-dan-da-bu-fen-bao-wen-ack-huan-neng-zheng-chang-fan-hui-ye-yao-yi-zhi-deng-chao-shi-ma">Q: 上面提到的ACK超时判断会不会太久了？ 假如只是发的时候丢了中间部分报文而已， 但大部分报文ACK还能正常返回，也要一直等超时吗？</a></li><li><a href="#q-qian-mian-chao-shi-chong-chuan-de-shi-hou-shi-bian-cheng-cong-1-kai-shi-man-qi-dong-wei-shi-me-zhe-ge-kuai-chong-chuan-que-shi-cong-ssthreshold-2-kai-shi-bing-qie-zou-yong-sai-bi-mian-wei-shi-me-hui-you-zhe-ge-qu-bie">Q: 前面“超时重传”的时候，是变成从1开始慢启动， 为什么这个“快重传”却是从ssthreshold/2开始，并且走拥塞避免？ 为什么会有这个区别？</a></li><li><a href="#q-wei-sha-fa-song-di-duo-liao-shu-ju-jiu-hui-bu-fen-diu-shi-zhe-ge-shi-zen-me-ge-yuan-li">Q: 为啥发送地多了，数据就会部分丢失？这个是怎么个原理？</a></li><li><a href="#q-tcp-chu-liao-shang-mian-de-chong-chuan-ding-shi-qi-hao-xiang-huan-you-ge-jian-chi-ding-shi-qi-qu-bie-shi-sha">Q: TCP除了上面的重传定时器， 好象还有个坚持定时器？区别是啥？</a></li></ul></li></ul></li><li><a href="#4-udp">4 UDP</a><ul><li><a href="#4-1-tcp-he-udp-de-qu-bie">4.1 TCP和UDP的区别：</a></li><li><a href="#4-2-udp-de-yi-xie-te-dian">4.2 UDP的一些特点</a></li><li><a href="#4-3-udp-de-ying-yong">4.3 UDP的应用</a></li><li><a href="#q-udp-ke-yi-shi-xian-ke-kao-chuan-shu-ma">Q: UDP可以实现可靠传输吗？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="1-chuan-shu-ceng-he-wang-luo-ceng-de-qu-bie">1 传输层和网络层的区别：</span><a href="#1-chuan-shu-ceng-he-wang-luo-ceng-de-qu-bie" class="header-anchor">#</a></h1><h2><span id="1-1-fu-ze-dui-xiang-de-bu-tong">1.1 负责对象的不同</span><a href="#1-1-fu-ze-dui-xiang-de-bu-tong" class="header-anchor">#</a></h2><ul><li>传输层负责建立进程间的通信（即只关心进程A和进程B的消息传递，不考虑底下的东西）</li><li>网络层负责建立主机间的通信（即只关心主机A怎么发给主机B）</li></ul><blockquote><blockquote><p>同理链路层就是物理上相邻的2个机器如何通信，物理层是电路上的通信</p></blockquote></blockquote><h2><span id="1-2-xiao-yan-shang-de-bu-tong">1.2 校验上的不同</span><a href="#1-2-xiao-yan-shang-de-bu-tong" class="header-anchor">#</a></h2><ul><li>传输层会对数据和首部一起做校验</li><li>网络层只对首部做校验，数据报部分不会关心。</li></ul><h1><span id="2-duan-kou-hao">2 端口号</span><a href="#2-duan-kou-hao" class="header-anchor">#</a></h1><p>端口号是传输层重要的概念。</p><h2><span id="2-1-duan-kou-hao-de-yi-yi">2.1 端口号的意义</span><a href="#2-1-duan-kou-hao-de-yi-yi" class="header-anchor">#</a></h2><p>① 为进程适应不同操作系统提供一个复用和分用的软件</p><blockquote><blockquote><p>复用：发送方不同进程都用同一种协议传输，目的端口号承担了这个工作<br>分用：接收方把IP报文组装交付时，通过端口号确认交付给谁</p><p>② 端口是进程的重要交互地址。<br>即由端口确定交给主机上的哪个进程。<br>③ 只具有本地意义，只对本机有效</p></blockquote></blockquote><h2><span id="2-2-duan-kou-hao-fan-wei">2.2 端口号范围</span><a href="#2-2-duan-kou-hao-fan-wei" class="header-anchor">#</a></h2><p>端口号共16位，因此最大为65535</p><ul><li><p>服务器端口号（做listen用的端口号）有2类：</p><ol><li>熟知端口号：0~1023</li></ol><blockquote><blockquote><p>熟知端口号有以下：<br>HTTP:80<br>HTTPS:443<br>DNS:53<br>FTP:21<br>TFTP:69<br>SNMP:161<br>TELNET:23<br>SMTP:25</p></blockquote></blockquote><ol start="2"><li>注册端口号: 1024~49151，也叫系统端口号。有许多服务绑定于这些端口。</li><li>动态和/或私有端口：49152~65535，理论上，不应为监听服务分配这些端口，一般是用于客户端的短暂端口号。</li></ol></li><li><p>UDP和TCP有各自的专属端口号，因此不会重复和干扰。</p></li></ul><h1><span id="3-tcp">3 TCP</span><a href="#3-tcp" class="header-anchor">#</a></h1><p>TCP全称<br>Transmission Control Protocol， 即传输控制协议。</p><p>基于套接字传输<br>套接字：IP+端口号</p><p>tcp的可靠性如下：</p><ol><li>数据被分隔成很多份合适的块来发送</li><li>有超时重传机制</li><li>会校验首部和数据内容。</li><li>会对收到的数据报文做排序，按顺序组装上交<br>5.会丢弃重复的数据<br>6.提供流量控制，发送主机不会一下子发送太快<br>7.每次传输都有序号和ack应答，全双工。</li></ol><h2><span id="3-1-tcp-shou-bu">3.1 TCP首部</span><a href="#3-1-tcp-shou-bu" class="header-anchor">#</a></h2><table><thead><tr><th>位数</th><th>含义</th><th>详情</th></tr></thead><tbody><tr><td>16</td><td>源端口</td><td>因此端口号最多16位</td></tr><tr><td>16</td><td>目的端口</td><td></td></tr><tr><td>32</td><td>报文序号</td><td>该报文的序号</td></tr><tr><td>32</td><td>确认号</td><td>期望收到的下一个报文序号。如果确认号位N，说明N-1都已经收到</td></tr><tr><td>4</td><td>数据偏移</td><td>数据部分的起始位置，可以理解为首部长度。单位是4字节。</td></tr><tr><td>6</td><td>保留位</td><td>没用，全部置成0</td></tr><tr><td>1</td><td>URG紧急指针标志</td><td>是否存在紧急数据</td></tr><tr><td>1</td><td>ACK标志</td><td>是否是确认报文</td></tr><tr><td>1</td><td>PSH推送标志</td><td>是否需要尽快上交进程</td></tr><tr><td>1</td><td>RST复位标志</td><td>是否需要重建连接</td></tr><tr><td>1</td><td>SYN同步建立连接标志</td><td>是不是连接建立期间的报文</td></tr><tr><td>1</td><td>FIN终止标志</td><td>是否是终止连接期间的报文</td></tr><tr><td>16</td><td>窗口</td><td>收到ack前对方可发送回来的数据量</td></tr><tr><td>16</td><td>校验和</td><td>校验首部+数据+伪首部（伪首部指携带了ip的首部）</td></tr><tr><td>16</td><td>紧急指针位置</td><td>紧急数据放在末尾，需要给出紧急数据的长度，便可推断位置</td></tr><tr><td>0-320</td><td>可变选项</td><td>一些TCP选项，例如 最大报文长度、时间戳等。最长40字节</td></tr><tr><td>?</td><td>填充位</td><td>保证首部长度为4字节整数倍</td></tr></tbody></table><p>从上面可以看到：</p><ol><li>TCP报文中不包含ip信息，只包含端口信息。</li><li>校验和中使用到了伪首部来做校验，即实际上是有ip信息被处理后包含在校验和中了。</li><li>TCP首部最小长度为20字节，最大长度为60字节，取决于可变选项。</li><li>首部长度必定是4字节整数倍，不足会填充，因为数据偏移里的单位设置是4字节。</li></ol><hr><h3><span id="q-jiang-yi-xia-tcp-bao-wen-du-you-sha-ke-yi-bu-an-shun-xu-jiang">Q:  讲一下TCP报文都有啥，可以不按顺序讲</span><a href="#q-jiang-yi-xia-tcp-bao-wen-du-you-sha-ke-yi-bu-an-shun-xu-jiang" class="header-anchor">#</a></h3><p>A:</p><ol><li>首先是首部长度（数据偏移），确定读到哪</li><li>重要的源端口 目的端口</li><li>TCP 可靠性机制关键的一些数字：<br>报文号、ACK号、窗口、 校验和</li><li>建连接、关连接用的标记<br>一堆标记（SYNC、FIN、RST之类的）</li><li>其他无关紧要的紧急指针位置、可变选项，填充位</li></ol><h2><span id="3-2-hua-dong-chuang-kou">3.2 滑动窗口</span><a href="#3-2-hua-dong-chuang-kou" class="header-anchor">#</a></h2><p>在TCP的发送端和接收端，有一个窗口的概念，直接用图片的方式简单明了回忆一下：</p><h3><span id="3-2-1-fa-song-duan-chuang-kou">3.2.1发送端窗口</span><a href="#3-2-1-fa-song-duan-chuang-kou" class="header-anchor">#</a></h3><p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011330509.png" alt="在这里插入图片描述"></p><hr><h3><span id="3-2-2-jie-shou-duan-chuang-kou">3.2.2 接收端窗口</span><a href="#3-2-2-jie-shou-duan-chuang-kou" class="header-anchor">#</a></h3><p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011340404.png" alt="在这里插入图片描述"></p><p>这里可以看到接收端一次性接收的缓存是有限的，所以进程出现问题迟迟没有接收数据，那么会在ack里告知还能发多少份。<br>这个叫通告窗口，即告知接收端还能收几份数据（TCP报文里的窗口位就是这个）</p><h3><span id="3-2-3-jian-chi-ding-shi-qi">3.2.3 坚持定时器</span><a href="#3-2-3-jian-chi-ding-shi-qi" class="header-anchor">#</a></h3><p>如果接收端的接收缓存用完，导致返回的ack报文里提示窗口为0，则发送端无法发送数据，此时会启动坚持定时器：<br>每隔5s发送1个字节的小报文，来查看对方窗口响应。当窗口不再为0，则结束坚持定时器</p><h3><span id="3-2-4-hu-tu-chuang-kou">3.2.4 糊涂窗口</span><a href="#3-2-4-hu-tu-chuang-kou" class="header-anchor">#</a></h3><p>上面提到的坚持定时器机制里，导致了每次只发一小点数据。<br>避免措施：<br>1. 接收方设定一个最小窗口阈值，不通告小窗口<br>2. 发送方设定一个最小窗口阈值，每次发送满一定长度的报文<br>3. 发送手头所有数据切不接收ack</p><h2><span id="3-3-tcp-lian-jie-liu-cheng">3.3 TCP连接流程</span><a href="#3-3-tcp-lian-jie-liu-cheng" class="header-anchor">#</a></h2><p>TCP通过三次握手建立连接，四次挥手结束连接</p><h3><span id="3-3-1-wo-shou-he-hui-shou-liu-cheng">3.3.1 握手和挥手流程</span><a href="#3-3-1-wo-shou-he-hui-shou-liu-cheng" class="header-anchor">#</a></h3><p>把这个图牢记于心就不会有问题：<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011409757.png" alt="在这里插入图片描述"></p><p>CLOSED状态：建立连接前的初始状态即关闭状态在建立连接前，先从CLOSED状态变成LISTEN状态（监听状态，表示可以传信号了）</p><ol><li>当客户首先发送SYN后，客户变成SYN_SENT状态。</li><li>当服务器接收到SYN后，服务器变成了SYN_REVD状态。</li><li>当服务器传给客户一个SYN和ACK后，变成了ESTABLISHED状态（表述开始进行数据传输）</li><li>当服务器接受到客户传来的ACK后，也变成ESTABLISHED状态。</li><li>当客户发送FIN（主动关闭）后，客户变成了FIN_WAIT1状态。服务器收到FIN后，执行被动关6. 闭，服务器变成了CLOSEWAIT状态。</li><li>服务器先发送ACK，客户收到ACK后变成FIN_WAIT2状态。</li><li>过了一段时间，服务器才发送FIN，这时候服务器变成LAST_ACK状态客户收到FIN后，变成了TIME_WAIT状态，同时发送ACK，进行2MSL等待。之后2者一起变为CLOSED状态</li></ol><hr><h4><span id="wei-shi-me-jian-li-yao-3-ci-wo-shou">为什么建立要3次握手？</span><a href="#wei-shi-me-jian-li-yao-3-ci-wo-shou" class="header-anchor">#</a></h4><p>建立握手3次原因：一方接收到syn报文后，需向对方回应一个ack。三次握手中，第一个是sync报文，第二个是ack、sync报文合在一起，第三个ack报文。这样就都回应了ack，需要3次。<br>关键在于最后一次需要一个对 接收端sync的ack响应。</p><hr><h4><span id="wei-shi-me-jie-shu-lian-jie-yao-4-ci-hui-shou">为什么结束连接要4次挥手？</span><a href="#wei-shi-me-jie-shu-lian-jie-yao-4-ci-hui-shou" class="header-anchor">#</a></h4><p>TCP中发送端发送fin后，就会将自己关闭。<br>但是接收端一方接收到fin报文后，数据可能还没发送完成。<br>所以需要先发完ack，再发fin，所以这里会多一次挥手。 最后ack是对fin的确认</p><hr><h4><span id="neng-fou-hui-shou-3-ci">能否挥手3次</span><a href="#neng-fou-hui-shou-3-ci" class="header-anchor">#</a></h4><p><strong>能</strong>。收到第一个fin报文后，它可能刚好没有数据要传输了，fin和ack报文一起回应，对方再回应ack，总共三次，挥手完毕。实际中抓报文，有很多这样的情况。</p><hr><h4><span id="si-ci-hui-shou-zhong-de-time-wait-zhuang-tai-zuo-yong">四次挥手中的TIME_WAIT状态作用？</span><a href="#si-ci-hui-shou-zhong-de-time-wait-zhuang-tai-zuo-yong" class="header-anchor">#</a></h4><p>A:</p><p>1.若最后一步客户发出的ACK丢失了，那么服务器将重发FIN，所以必须维持TIME_WAIT状态到可能的第二次重发FIN的时间。</p><p>2.为了避免在终止连接后再次重新建立新连接时，收到之前那次连接“迷路”的分组，要维持一个TIME_WAIT状态以便吸收掉迷路的分组。</p><hr><h4><span id="liang-bian-tong-shi-xiang-hu-jian-li-lian-jie-hui-fa-sheng-shi-me">两边同时相互建立连接会发生什么？</span><a href="#liang-bian-tong-shi-xiang-hu-jian-li-lian-jie-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p>2边同时发送SYNC<br>2边同时收到后， 就会发现自己在还没收到SYNC-ACK的情况下收到了新的SYNC，说明发生了&quot;同时打开&quot;的情况。<br>此时他会直接发送ack，并且不再等待sync-ack响应了，直接进入ESTABLISHED状态。所以此时仅需2次握手（当然整体上看是4次，一边各2次）</p><h4><span id="liang-bian-tong-shi-guan-bi-lian-jie-hui-fa-sheng-shi-me">两边同时关闭连接会发生什么</span><a href="#liang-bian-tong-shi-guan-bi-lian-jie-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4><p>当2者发生同时关闭，即同时发出FIN时，会进入CLOSING状态，收到相互的ACK后进入TIME_WAIT状态. 即此时需2次挥手（整体上看是4次）</p><h3><span id="3-3-4-jiao-hu-shu-ju">3.3.4 交互数据</span><a href="#3-3-4-jiao-hu-shu-ju" class="header-anchor">#</a></h3><p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011424408.png" alt="在这里插入图片描述"></p><p>每一个交互按键都会产生一个数据分组，每次从客户传到服务器的是一个字节的按键。而Rlogin需要远程系统回显客户键入的字符，这样就会产生4个报文段：<br>（1）来自客户的交互按键<br>（2）来自服务器的按键确认<br>（3）来自服务器的按键回显<br>（4）来自客户的按键回显确认</p><ul><li><h4><span id="nagle-suan-fa">nagle算法</span><a href="#nagle-suan-fa" class="header-anchor">#</a></h4><p>当数据交互很快时， 可能会有很多小分组。<br>开启nagle后，会把小分组做合并一起发送。</p></li></ul><hr><h4><span id="q-shi-me-shi-tcp-nian-bao">Q: 什么是TCP粘包？</span><a href="#q-shi-me-shi-tcp-nian-bao" class="header-anchor">#</a></h4><p>A:<br>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包<br>从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾<br>出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p><hr><h4><span id="q-zao-cheng-nian-bao-de-yuan-yin-shi-shi-me">Q: 造成粘包的原因是什么？</span><a href="#q-zao-cheng-nian-bao-de-yuan-yin-shi-shi-me" class="header-anchor">#</a></h4><p>A:<br>发送方原因： 开启了nagle算法<br>接收方原因：如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包</p><hr><h4><span id="q-shi-me-shi-hou-xu-yao-chu-li-nian-bao-xian-xiang">Q:什么时候需要处理粘包现象？</span><a href="#q-shi-me-shi-hou-xu-yao-chu-li-nian-bao-xian-xiang" class="header-anchor">#</a></h4><p>A:<br>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象<br>如果多个分组毫不相干，甚至是并列关系，导致应用层取出时无法识别各份数据，那么这个时候就一定要处理粘包现象了</p><hr><h4><span id="q-ru-he-chu-li-nian-bao-xian-xiang">Q: 如何处理粘包现象？</span><a href="#q-ru-he-chu-li-nian-bao-xian-xiang" class="header-anchor">#</a></h4><p>A:</p><ol><li>发送方<br>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</li><li>接收方<br>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</li><li>应用层<br>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</li></ol><ul><li>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束</li><li>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置</li></ul><hr><h4><span id="q-udp-hui-bu-hui-chan-sheng-nian-bao-wen-ti-ni">Q：UDP会不会产生粘包问题呢？</span><a href="#q-udp-hui-bu-hui-chan-sheng-nian-bao-wen-ti-ni" class="header-anchor">#</a></h4><p>A:<br>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。<br>举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p><h3><span id="3-3-5-yi-chang-qing-kuang">3.3.5 异常情况</span><a href="#3-3-5-yi-chang-qing-kuang" class="header-anchor">#</a></h3><ul><li><p>异常情况时，会把报文里的复位表示RST置为1。有3种情况会发送复位报文<br>①端口不存在<br>②进程异常终止<br>③客户端异常退出， 服务器没有收到任何fin，此时称为TCP<strong>半打开</strong>状态。如果TCP配置了心跳，则可以检测</p></li><li><p>半关闭<br>TCP的半关连接是指：TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据。</p></li><li><p>半连接<br>三次握手中，主动发起握手的一方不发最后一次ACK，使得服务器端阻塞在SYN_RECV状态半连接攻击（SYN攻击）：会耗尽服务器资源，使得真正的请求无法建立连接。</p></li></ul><h2><span id="3-4-yong-sai-bi-mian-ji-zhi">3.4 拥塞避免机制</span><a href="#3-4-yong-sai-bi-mian-ji-zhi" class="header-anchor">#</a></h2><p>这块概念很多很乱，我按问题整理了一下，一步步来<br>TCP的拥塞避免等机制对于初学者来说还是比较复杂的，工作中如果开发时偏应用层，那么大部分时候就会摸不到这个机制，感受也就没那么深了。<br>但如果你的开发过程涉及数据传输，一直在重传、超时之类的方案里有困惑的话，不妨重新学一学可靠性最精致的TCP协议。</p><p>所以这里我抛去死记硬背的那堆概念，用10个连续的问题来学习这个机制，注意看的时候先自己思考一下如果是自己，会怎么设计，再去看实际的TCP设计，来理解它的精妙之处。</p><hr><h3><span id="q-jian-li-lian-jie-hou-mei-ci-fa-song-de-bao-wen-shu-liang-shi-gu-ding-de-ma-ji-mei-ci-du-fa-1-tiao-huo-zhe-10-tiao">Q: 建立连接后，每次发送的报文数量是固定的吗？即每次都发1条或者10条？</span><a href="#q-jian-li-lian-jie-hou-mei-ci-fa-song-de-bao-wen-shu-liang-shi-gu-ding-de-ma-ji-mei-ci-du-fa-1-tiao-huo-zhe-10-tiao" class="header-anchor">#</a></h3><p>A:<br>不是。<br>建立连接后，会先只发1条， 然后发2条，接着再发4条，逐步增加。<br>这个过程叫 <strong>“慢启动”</strong>。<br>这个1、2、4递增的数量被称之为 <strong>拥塞窗口</strong> cwnd</p><p>可以理解为TCP希望刚开始，可以大胆点，不断加数量。但为了保险期间还是从1条还是倍增。</p><hr><h3><span id="q-man-qi-dong-guo-cheng-zhong-na-me-fa-song-shu-liang-yong-sai-chuang-kou-shi-me-shi-hou-bu-zai-bei-zeng-shi-wu-xian-bei-zeng-ma">Q: 慢启动过程中，那么发送数量（拥塞窗口）什么时候不再倍增？是无限倍增吗？</span><a href="#q-man-qi-dong-guo-cheng-zhong-na-me-fa-song-shu-liang-yong-sai-chuang-kou-shi-me-shi-hou-bu-zai-bei-zeng-shi-wu-xian-bei-zeng-ma" class="header-anchor">#</a></h3><p>A:<br>不会无限倍增。<br>当到达<strong>慢启动门限ssthreshold</strong>时，会变成每次都增加1条。<br>这个过程叫<strong>拥塞避免过程</strong>， 也有叫他拥塞避免算法的</p><p>可以理解为tcp感觉到有风险了，于是开始慢慢地、小心翼翼地1条1条地添加发送条数。</p><hr><h3><span id="q-na-me-dang-jin-ru-yong-sai-bi-mian-mei-ci-1-shi-shi-me-shi-hou-cai-hui-bu-zai-ji-xu-jia">Q:那么，当进入拥塞避免，每次+1时，什么时候才会不再继续加？</span><a href="#q-na-me-dang-jin-ru-yong-sai-bi-mian-mei-ci-1-shi-shi-me-shi-hou-cai-hui-bu-zai-ji-xu-jia" class="header-anchor">#</a></h3><p>A:<br>随着每次发送的数量越发越多， 最终会超出带宽限制，于是就会有某条报文发生超时。<br>有可能是发的中途丢了， 亦或者是返回的数据全阻塞住了，一条都回不来。</p><p>当发送端检测到发生超时时，就会让 <strong>慢启动门限ssthreshold = 当前拥塞窗口cwnd/2</strong><br>接着<strong>cwnd 重新置为1</strong>，从新开始 慢启动算法。</p><p>这样的好处在于可以检测到每次发送的上限，动态调整发送窗口。<br>上面的过程叫做 <strong>超时重传</strong>。<br>注意发生超时重传时， cwnd会重置成1。</p><hr><h3><span id="q-shang-mian-ti-dao-liao-chao-shi-na-me-tcp-ke-hu-duan-shi-zen-me-pan-duan-bao-wen-fa-song-chao-shi-de-ni">Q: 上面提到了超时， 那么TCP客户端是怎么判断报文发送超时的呢？</span><a href="#q-shang-mian-ti-dao-liao-chao-shi-na-me-tcp-ke-hu-duan-shi-zen-me-pan-duan-bao-wen-fa-song-chao-shi-de-ni" class="header-anchor">#</a></h3><p>A:<br>每次发送数据包的时候， 都会有一个相应的计时器，一旦超过 RTO(超时时间） 而没有收到 ACK， TCP就会重发该数据包。<br>没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除。</p><hr><h3><span id="q-shang-mian-ti-dao-de-chao-shi-shi-jian-rto-shi-zen-me-lai-de-wan-yi-she-de-tai-da-ke-neng-dao-zhi-hen-chi-cai-neng-fan-ying-guo-lai-she-de-tai-xiao-ze-ke-neng-dao-zhi-mei-tiao-du-chao-shi">Q:上面提到的超时时间RTO是怎么来的？万一设得太大可能导致很迟才能反应过来， 设得太小则可能导致每条都超时</span><a href="#q-shang-mian-ti-dao-de-chao-shi-shi-jian-rto-shi-zen-me-lai-de-wan-yi-she-de-tai-da-ke-neng-dao-zhi-hen-chi-cai-neng-fan-ying-guo-lai-she-de-tai-xiao-ze-ke-neng-dao-zhi-mei-tiao-du-chao-shi" class="header-anchor">#</a></h3><p>A:<br>通过“每次报文的往返时间样本”和“之前样本的偏差值”<strong>动态计算</strong>出来的。</p><ul><li>RTT ： 报文往返时间（指从发送到收到ack的时间）。每个报文发出后都有个定时器，收到后都会计算出一个RTT样本</li></ul><hr><ul><li>RTTs： 加权平均往返时间，类似于一个估算的往返时间，实时在变。<br>RTTs = （1-a) * RTTs + a * RTT最新样本<br>即每次得到RTT样本后， ?都会使用a这个占比去更新RTTs。</li></ul><hr><ul><li>RTTd: ?RTT偏差加权平均值（就是用来计算超时时间应该比RTT多多少）<br>RTTd = (1 - b) * RTTd + b*RTTs - RTT最新样本<br>即每次会用新的RTTs以b的占比去更新一下RTTd，并减去RTT样本</li></ul><hr><ul><li>RTO ： 超时重传时间<br>等于平均往返时间 加上 4倍偏差值<br>RTO = RTTs + 4*RTTd?</li></ul><hr><h3><span id="q-ru-guo-fa-sheng-chong-chuan-que-huan-shi-mei-you-shou-dao-ack-na-me-zui-xin-de-rtt-yang-ben-ying-gai-zen-me-suan-ji-ni-du-shou-bu-dao-zui-xin-de-ack-liao-rtt-nan-dao-qu-chao-shi-shi-jian-ma">Q: 如果发生重传，却还是没有收到ack，那么最新的RTT样本应该怎么算？即你都收不到最新的ack了， RTT难道取超时时间吗？</span><a href="#q-ru-guo-fa-sheng-chong-chuan-que-huan-shi-mei-you-shou-dao-ack-na-me-zui-xin-de-rtt-yang-ben-ying-gai-zen-me-suan-ji-ni-du-shou-bu-dao-zui-xin-de-ack-liao-rtt-nan-dao-qu-chao-shi-shi-jian-ma" class="header-anchor">#</a></h3><p>A:<br>会使用karn算法： 发生重传时，不更新这次的RTT样。选用后面收到的ack<br>修正karn： 为了避免发生重传后，实际RTT都变慢了，导致一下子所有请求都超时， 会在发生重传时，把RTO假大1倍。</p><hr><h3><span id="q-shang-mian-ti-dao-de-ack-chao-shi-pan-duan-hui-bu-hui-tai-jiu-liao-jia-ru-zhi-shi-fa-de-shi-hou-diu-liao-zhong-jian-bu-fen-bao-wen-er-yi-dan-da-bu-fen-bao-wen-ack-huan-neng-zheng-chang-fan-hui-ye-yao-yi-zhi-deng-chao-shi-ma">Q: 上面提到的ACK超时判断会不会太久了？ 假如只是发的时候丢了中间部分报文而已， 但大部分报文ACK还能正常返回，也要一直等超时吗？</span><a href="#q-shang-mian-ti-dao-de-ack-chao-shi-pan-duan-hui-bu-hui-tai-jiu-liao-jia-ru-zhi-shi-fa-de-shi-hou-diu-liao-zhong-jian-bu-fen-bao-wen-er-yi-dan-da-bu-fen-bao-wen-ack-huan-neng-zheng-chang-fan-hui-ye-yao-yi-zhi-deng-chao-shi-ma" class="header-anchor">#</a></h3><p>A:<br>如果能正常接收其他报文的ACK， 只是中间的部分报文丢了， 则有另一个办法。</p><p>接收端有一个冗余确认机制：</p><ol><li>发送端A 发送 1、2、3、4、5四条</li><li>但是B接收端只收到1、2、4、5，而3因为网络拥塞丢了。</li><li>于是B会发送ack=3而不是ack=5 给A。 <strong>这就是冗余确认机制，只发送缺失那部分的ack，后面的4和5都不管。</strong></li><li>A收到ack=3后， 继续发送3、4、5、6、7， 结果3还是丢了。</li><li>于是B又发送ack=3。</li></ol><p>当A发现连续3次收到了ack=3时，就会觉察到不对劲，我都发3次了你还是说没收到，可你又能正常返回其他ACK给我，是不是我发的太多了？</p><p>上面这个判断3次的重传算法叫“快重传”。</p><p>于是A会马上进入 “快速恢复”。<br>和之前类似，慢启动门限ssthreshold = 当前拥塞窗口cwnd/2<br>但是！！  新的拥塞窗口cwnd会设置成ssthreshold/2，  而不是1。<br>而且不会走慢启动倍增的那种，而是走拥塞避免， 逐步+1的那种。<br><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/1638808791348065758.png" alt="image.png"></p><hr><h3><span id="q-qian-mian-chao-shi-chong-chuan-de-shi-hou-shi-bian-cheng-cong-1-kai-shi-man-qi-dong-wei-shi-me-zhe-ge-kuai-chong-chuan-que-shi-cong-ssthreshold-2-kai-shi-bing-qie-zou-yong-sai-bi-mian-wei-shi-me-hui-you-zhe-ge-qu-bie">Q: 前面“超时重传”的时候，是变成从1开始慢启动， 为什么这个“快重传”却是从ssthreshold/2开始，并且走拥塞避免？ 为什么会有这个区别？</span><a href="#q-qian-mian-chao-shi-chong-chuan-de-shi-hou-shi-bian-cheng-cong-1-kai-shi-man-qi-dong-wei-shi-me-zhe-ge-kuai-chong-chuan-que-shi-cong-ssthreshold-2-kai-shi-bing-qie-zou-yong-sai-bi-mian-wei-shi-me-hui-you-zhe-ge-qu-bie" class="header-anchor">#</a></h3><p>A:<br>因为前面发生超时重传时，  是比较严重的情况， 超时时间内一个ACK都没收到。就好像来回数据都凭空消失了。</p><p>而快速重传发生时， 还是能收到部分ack的， 只是丢失了部分数据， 说明拥塞没那么严重，于是可以大胆一点将cwnd削减到1/4， 而不是直接从1开始。</p><p>到了这里，基本就能理清楚超时重传和快重传的区别了，重点是理解这2个区别是怎么来的。后面再补几个问题，避免你和其他概念搞混，但不会说得太深，具体需要你自己去扩展学习了。</p><h3><span id="q-wei-sha-fa-song-di-duo-liao-shu-ju-jiu-hui-bu-fen-diu-shi-zhe-ge-shi-zen-me-ge-yuan-li">Q: 为啥发送地多了，数据就会部分丢失？这个是怎么个原理？</span><a href="#q-wei-sha-fa-song-di-duo-liao-shu-ju-jiu-hui-bu-fen-diu-shi-zhe-ge-shi-zen-me-ge-yuan-li" class="header-anchor">#</a></h3><p>A:<br>路由器有缓存，IP分组接收过多时就会耗尽空间，丢弃数据。详细可以看路由器的数据转发原理。</p><hr><h3><span id="q-tcp-chu-liao-shang-mian-de-chong-chuan-ding-shi-qi-hao-xiang-huan-you-ge-jian-chi-ding-shi-qi-qu-bie-shi-sha">Q: TCP除了上面的重传定时器， 好象还有个坚持定时器？区别是啥？</span><a href="#q-tcp-chu-liao-shang-mian-de-chong-chuan-ding-shi-qi-hao-xiang-huan-you-ge-jian-chi-ding-shi-qi-qu-bie-shi-sha" class="header-anchor">#</a></h3><p>A:<br>坚持定时器和超时、网络拥塞没有关系， 和通告窗口即对端的接收能力有关。<br>简单来说， 就是对方的传输层缓冲区（接收端窗口）满了，告诉你别发了，我吃不下了，于是返回通告窗口为0。<br>但你想知道啥时候可以发，于是就启动一个坚持定时器，每隔5s发送1个字节的小报文，小小地试探下。当通告窗口不为0了，就重新开始发。</p><h1><span id="4-udp">4 UDP</span><a href="#4-udp" class="header-anchor">#</a></h1><p>网络层的多播和广播机制，需要依赖传输层的UDP。</p><h2><span id="4-1-tcp-he-udp-de-qu-bie">4.1 TCP和UDP的区别：</span><a href="#4-1-tcp-he-udp-de-qu-bie" class="header-anchor">#</a></h2><ul><li>TCP有连接， UDP无连接</li><li>TCP可靠， UDP不可靠，发出去不管了。也没有拥塞控制等机制。 不过UDP会做数据正确性校验。</li><li>UDP会一次性交付一个完整报文，不会做拆分，TCP可能会有小的分组。</li><li>UDP首部比较简单， 只有源端口、目的端口、报文长度、校验和、填充位。</li></ul><h2><span id="4-2-udp-de-yi-xie-te-dian">4.2 UDP的一些特点</span><a href="#4-2-udp-de-yi-xie-te-dian" class="header-anchor">#</a></h2><ul><li><p>每次调用程序里多播的接口时，都会产生1个UDP消息，没有那种可以复用的UDP连接。</p></li><li><p>UDP数据报的最大长度，和应用程序可读写的数据报最大长度有关，和TCP/IP内核有关。<br>当数据报长度大于程序可读写长度，会引发 数据截断。所以udp数据的长度必须要控制好，毕竟他无法根据MTU做分片。</p></li><li><p>怎么确认MTU多大？<br>可以用taceroute命令检测MTU， 本质上是把TCP报文设置成不分片，然后逐步增大，直到发生了ICMP不可达的报错。</p></li><li><p>如果一次性发送了6个UDP数据报， 并且在链路层有6次ARP请求， 接收端收到6个UDP后，只会发送一个ARP响应。</p></li><li><p>UDP一般用于本地小范围通信， 所以差错其实相比TCP还小一点。</p></li></ul><h2><span id="4-3-udp-de-ying-yong">4.3 UDP的应用</span><a href="#4-3-udp-de-ying-yong" class="header-anchor">#</a></h2><p>TFTP（小文件传输）<br>DNS（域名解析）<br>SNMP(简单网络管理协议）<br>IGMP<br>BOOTP（无盘系统引导）<br>RTP(实时传输协议)<br>多媒体应用</p><hr><h2><span id="q-udp-ke-yi-shi-xian-ke-kao-chuan-shu-ma">Q: UDP可以实现可靠传输吗？</span><a href="#q-udp-ke-yi-shi-xian-ke-kao-chuan-shu-ma" class="header-anchor">#</a></h2><p>A:<br>可以实现，但必须在应用层做改造。</p><ol><li>添加seq/ack机制，确保数据发送到对端</li><li>添加发送和接收缓冲区，主要是用户超时重传。</li><li>添加超时重传机制。</li></ol><ul><li><p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p></li><li><p>目前有多种开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网之网络层（IP协议）详解</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-ip-di-zhi">1.IP地址</a><ul><li><a href="#1-1-fen-lei-biao-shi-fa">1.1 分类表示法：</a><ul><li><a href="#1-1-2-fen-lei-biao-shi-di-zhi-de-qi-ta-shuo-ming">1.1.2 分类表示地址的其他说明</a></li></ul></li><li><a href="#1-2-wu-fen-lei-bian-zhi-cidr">1.2 无分类编址CIDR</a></li></ul></li><li><a href="#2-ip-shu-ju-bao-wen-ge-shi">2 IP数据报文格式</a><ul><li><a href="#q-ip-bao-wen-li-you-shi-me-ke-yi-bu-an-shun-xu-huo-zhe-zi-jie-lai-jiang-yi-jiang">Q: IP报文里有什么？可以不按顺序或者字节来讲一讲</a></li></ul></li><li><a href="#3-lu-you-gai-nian">3.路由概念</a><ul><li><a href="#3-1-lu-you-biao">3.1 路由表</a></li><li><a href="#3-2-lu-you-wang-luo-pi-pei">3.2 路由网络匹配</a></li><li><a href="#3-3-arp-jie-xi">3.3 ARP解析</a></li><li><a href="#3-4-rarp-ni-di-zhi-jie-xi-xie-yi">3.4 RARP逆地址解析协议</a></li></ul></li><li><a href="#4-icmp-xie-yi">4 ICMP协议</a></li><li><a href="#5-dhcp-xie-yi">5 DHCP协议</a></li><li><a href="#6-lu-you-biao-de-zui-you-xia-yi-tiao-di-zhi-ru-he-ji-suan">6.路由表的最优下一跳地址如何计算？</a><ul><li><a href="#6-1-rip-xie-yi">6.1 RIP协议</a></li><li><a href="#6-2-ospf-xie-yi">6.2 OSPF协议</a></li><li><a href="#6-3-bgp-xie-yi">6.3 BGP协议</a></li><li><a href="#q-rip-xie-yi-xia-lu-you-biao-shi-me-shi-hou-geng-xin">Q: RIP协议下路由表什么时候更新？</a></li><li><a href="#q-lu-you-zhong-du-shi-shi-me">Q: 路由中毒是什么？</a></li><li><a href="#q-shou-dao-zhong-du-lu-you-de-lu-you-qi-hui-zen-me-zuo">Q: 收到中毒路由的路由器会怎么做？</a></li></ul></li><li><a href="#7-duo-bo">7 多播</a><ul><li><a href="#7-1-igmp-xie-yi">7.1 IGMP协议</a></li><li><a href="#7-2-mospf-duo-bo-lu-you-xuan-ze-xie-yi">7.2 MOSPF多播路由选择协议</a></li></ul></li><li><a href="#8-qi-ta-wang-luo-ceng-gai-nian">8 其他网络层概念</a><ul><li><a href="#8-1-vpn">8.1 VPN</a></li><li><a href="#8-2-nat">8.2 NAT</a></li><li><a href="#8-3-yi-dong-ip">8.3 移动IP</a></li></ul></li><li><a href="#9-chang-jian-wang-luo-ceng-ming-ling">9 常见网络层命令</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="1-ip-di-zhi">1.IP地址</span><a href="#1-ip-di-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-fen-lei-biao-shi-fa">1.1 分类表示法：</span><a href="#1-1-fen-lei-biao-shi-fa" class="header-anchor">#</a></h2><p>分类表示法已经不常用了。</p><ul><li>A类地址：<br>格式为<br>1[7位网络号][24位主机号]<br>网络号全0指本网络<br>网络号全1用于环回地址（127.0.0.1）<br>主机号全0时指本住机所在网络<br>全1时指本网络所有主机（广播地址）<br>因此A类地址实际可选范围为1.x.x.x ~ 126.x.x.x</li></ul><hr><ul><li>B类地址<br>格式为<br>10[14位网络号][16位主机号]<br>网络号不可全0，但可以全1<br>范围为128.x.x.x~191.x.x.x</li></ul><hr><ul><li>C类地址<br>格式为<br>110[21位网络号][8位主机号]<br>网络号不可全0<br>范围为192.x.x.x~223.x.x.x</li></ul><hr><ul><li>D类地址（多播地址）<br>格式为<br>1110[28位多播地址]<br>范围为224.x.x.x~239.x.x.x<br>因此看到224以上的ip要注意</li></ul><hr><ul><li>E类地址<br>格式为11110[保留]<br>用于实验用，因此看到240以上的认定不是正常节点ip</li></ul><h3><span id="1-1-2-fen-lei-biao-shi-di-zhi-de-qi-ta-shuo-ming">1.1.2 分类表示地址的其他说明</span><a href="#1-1-2-fen-lei-biao-shi-di-zhi-de-qi-ta-shuo-ming" class="header-anchor">#</a></h3><ul><li><p>网络号全0，但主机号非全0的某个ip就是指本网络的某个主机</p></li><li><p>网络号不为全1，但主机号为1的ip，则指某个网络的广播地址</p></li><li><p>全0，指本网络的本主机</p></li><li><p>全1，指本网络的广播地址</p></li><li><p>环回地址，指127.0.0.1，在同一台主机上进行网络传输</p></li><li><p>私有地址，指不会参与路由器转发的地址,， 只会参与本局域网，发给本局域网的交换机：<br>A类： 10.0.0.0-10.25.255.255<br>B类： 172.16.0.0-172.31.0.0<br>C类： 192.168.0.0-192.168.255.255</p></li></ul><h2><span id="1-2-wu-fen-lei-bian-zhi-cidr">1.2 无分类编址CIDR</span><a href="#1-2-wu-fen-lei-bian-zhi-cidr" class="header-anchor">#</a></h2><p>Classless Inter-Domain Routing 无类型域间选路</p><ul><li>CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet路由器的负担。</li><li>该编址用于子网划分，子网号和上面提到的网络号是不同的。</li><li>IP地址 ::= {&lt;网络号&gt;， &lt;子网号&gt;， &lt;主机号&gt;}</li></ul><p>CIDR有三种编址方式：</p><ul><li>128.14.35.7/20  ， 完整ip加子网位数</li><li>10.0.0.0/10 -&gt; 10/10， 可省略末尾的0</li><li>00010100*， 即用星号代替子网后的主机号</li></ul><p>对于CIDR编址<br>子网号的全0和全1没有特殊含义，但不可设置成全0或者全1。<br>主机号的全0指本网络， 全1指广播。（网络号仍然遵从ABCD地址的规则）</p><ul><li>子网掩码：<br>值1的位置指该ip中该位置是网络号和子网号区域<br>值0的位置指该ip中该位置是主机号区域。<br>例子：111111100000000…， 那么前面8个1就是网络号+子网号，后面都代表了主机号</li><li>路由寻址时，一般先比较网络号，再比较子网号，再比较主机。<br>子网掩码可以简化先比网络再比子网的过程。</li></ul><h1><span id="2-ip-shu-ju-bao-wen-ge-shi">2 IP数据报文格式</span><a href="#2-ip-shu-ju-bao-wen-ge-shi" class="header-anchor">#</a></h1><p>IP报文的首部至少有20个字节（160位），首部如下：</p><table><thead><tr><th>位数</th><th>含义</th><th>详情</th></tr></thead><tbody><tr><td>4</td><td>版本</td><td>IPV4或者IPV6</td></tr><tr><td>4</td><td>首部长度</td><td>单位是字（4字节</td></tr><tr><td>8</td><td>区分服务</td><td>设置服务的时延、吞吐量、可靠性，一般不用</td></tr><tr><td>16</td><td>IP报文总长度</td><td>单位字节</td></tr><tr><td>16</td><td>报文标识</td><td>用于分片后的同报文组装。相同报文的不同分片，该值相同</td></tr><tr><td>3</td><td>分片标志</td><td>判断是否可分片或者是否是分配最后一个</td></tr><tr><td>13</td><td>片偏移</td><td>用于按顺序组装同报文的分片</td></tr><tr><td>8</td><td>生存时间TTL</td><td>该报文最大跳数，每经过一次转发就减一</td></tr><tr><td>8</td><td>协议类型</td><td>ICMP/IGMP/TCP/UDP</td></tr><tr><td>16</td><td>首部校验和</td><td>用于和首部做校验，看首部是否正确</td></tr><tr><td>32</td><td>源IP地址</td><td></td></tr><tr><td>32</td><td>目的IP地址</td><td></td></tr><tr><td>？</td><td>任选项</td><td>很少被使用，最多40字节</td></tr></tbody></table><p>上面可以看到IP报文的以下限制：</p><ol><li>首部长度字段可以看出首部长度最多可以位60字节，所以任选项最多40字节</li><li>报文总长度最大为65535， 但是由于MTU的限制（链路层防冲突机制导致的），一般都要做分片， 分片后就会用上分片标识和片偏移了。</li></ol><hr><h2><span id="q-ip-bao-wen-li-you-shi-me-ke-yi-bu-an-shun-xu-huo-zhe-zi-jie-lai-jiang-yi-jiang">Q: IP报文里有什么？可以不按顺序或者字节来讲一讲</span><a href="#q-ip-bao-wen-li-you-shi-me-ke-yi-bu-an-shun-xu-huo-zhe-zi-jie-lai-jiang-yi-jiang" class="header-anchor">#</a></h2><p>A:</p><ul><li>首先要知道报文多长，  首部长度+报文长度</li><li>为了校验首部，还需要校验首部和</li><li>很重要的源ip 目的ip<br>那么如何确定ip类型？这就需要 ipv版本，来确认是ip4还是ip6。</li><li>ip支持分片，那么就需要<br>分片id、是否是最后分片标记、分片偏移</li><li>协议类型（icmp、igmp）</li><li>TTL生存</li><li>其他任选项（40字节）</li></ul><h1><span id="3-lu-you-gai-nian">3.路由概念</span><a href="#3-lu-you-gai-nian" class="header-anchor">#</a></h1><ul><li>路由器可分隔广播域，指的是不同网络号的地址，路由器不会转发广播报文</li></ul><blockquote><blockquote><p>Hub集线器在同一个冲突域通信无法分割；交换机在同一个广播域通信，可分割冲突域；路由器实现不同广播域间通信，可分隔广播域。</p></blockquote></blockquote><ul><li>IP报文在传输中不会被改变，但是链路层报文的mac地址会不断变化。</li><li>当2个主机在不同的子网时，必须要借助路由才能通信</li></ul><h2><span id="3-1-lu-you-biao">3.1 路由表</span><a href="#3-1-lu-you-biao" class="header-anchor">#</a></h2><p>假设某个路由器在N1网络，他的路由表如下：</p><table><thead><tr><th>目的网络</th><th>下一跳地址</th><th>解释</th><th>到目的网络距离</th></tr></thead><tbody><tr><td>N1</td><td>0.0.0.0</td><td>假设目的网络就是路由器所在网络，说明可以直接交付给本网络的主机了，不用再转发，所以地址为全0</td><td>0</td></tr><tr><td>N2</td><td>R2</td><td>如果为N2，则会发给R2路由</td><td>4</td></tr><tr><td>0.0.0.0</td><td>R1默认路由</td><td>如果路由表找不到目的网络，则会默认转给R1处理，0.0.0.0是默认转发网络的标识</td><td>？</td></tr><tr><td>特定IP地址</td><td>R3</td><td>这种特定地址的选择是管理员配置的</td><td>3</td></tr></tbody></table><ul><li>特定IP地址的子网掩码为全1，所以一般都是x.x.x.x/32</li><li>DNS服务器一般会配置在路由表中的特定IP地址</li><li>未知网络在路由表里的目的网络被写为0.0.0.0， 如果么有，则就是未设置默认路由</li><li>路由器不会转发私有地址。</li><li>距离指的是跨越路由器的数量，而不是实际长度单位</li></ul><h2><span id="3-2-lu-you-wang-luo-pi-pei">3.2 路由网络匹配</span><a href="#3-2-lu-you-wang-luo-pi-pei" class="header-anchor">#</a></h2><p>如果路由表中的目的网络由很多，怎么确定IP和路由表中的目的网络是匹配的？<br>使用 最长前缀匹配， 即前缀匹配得最多的就是目的网络。<br>优化算法可用二叉线索树来确认最长前缀。</p><hr><p>Q： 为什么要用二叉线索树来 判断最长匹配前缀？ 字典树不可以吗？<br>A:</p><h2><span id="3-3-arp-jie-xi">3.3 ARP解析</span><a href="#3-3-arp-jie-xi" class="header-anchor">#</a></h2><p>全称Address Resolution Protocol，地址解析协议。</p><p>从主机发给路由， 或者路由发给路由时，底层还是得封装一层mac地址然后往下交给交换机。<br>那么ip和mac地址的对应关系， 是怎么得知的？<br>答案就是ARP协议</p><p>本质就是当mac缓存表里没有ip和mac的对应关系时， 主机或者路由会广播ARP报文， 对应ip方向的交换机会把报文发送回来，这时候就直到mac地址和ip的对饮关系了。</p><ul><li>arp -a可以检查ARP告诉缓存</li><li>ARP缓存有超时时间</li><li>目的主机不存在时，会反复发送，有个超期期限的存在。</li><li>主机发送ARP查找自己的Mac地址称为“免费ARP&quot;</li><li>发送给某1主机的arp请求被中间路由器接收了，则称为“ARP代理”， 发送者不管不管你是中间路由还是目的ip主机，只知道这个ip需要发给这个mac。</li></ul><h2><span id="3-4-rarp-ni-di-zhi-jie-xi-xie-yi">3.4 RARP逆地址解析协议</span><a href="#3-4-rarp-ni-di-zhi-jie-xi-xie-yi" class="header-anchor">#</a></h2><p>由mac地址反取ip。<br>因为ip不存在，无法直接转给给路由。所以会比ARP难。<br>过程：<br>1）将源设备和目标设备的MAC地址字段都设为发送者的MAC地址和IP地址，发送主机发送一个本地的RARP广播，能够到达网络上的所有设备，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；<br>? 2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；<br>? 3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；如果不存在，RARP服务器对此不做任何的响应；<br>? 4） 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p><h1><span id="4-icmp-xie-yi">4 ICMP协议</span><a href="#4-icmp-xie-yi" class="header-anchor">#</a></h1><p>全称Internet control message protocl，网络控制报文协议<br>他会包装在IP的数据报文中，并把首部的协议类型改成ICMP那个数字。</p><p>首部总共8个字节，分别为<br>2字节的ICMP类型<br>2字节的ICMP报文代码（类似错误码）<br>4字节的校验和<br>后面就是数据部分了。</p><p>常见的2种用途：</p><ol><li>发送网络层之间的差错报告，例如：<ul><li>源点抑制——发送网络拥塞</li><li>终点不可达——无法找到对应ip交付地点</li><li>时间超时——报文种的TTL降为0，或者分片一直没收集完</li><li>参数错误——首部中字段有错</li><li>路由改变（重定向）——　主机把数据发给了路由器R2，但是路由器R2发现主机自己本来就可以直达了，于是发给主机该消息，告诉他你要更新路由表了。</li></ul></li></ol><p>差错报告有以下其他特点：<br>* ICMP自身出错时，不会再发ICMP差错报文<br>* 如果是报文分配后发生错误，则只会发1次，而不会每个分片发一次<br>* 不针对多播，不针对127.0.0.1、0.0.0.0等特殊的地址发送差错报文，不可广播（避免广播风暴）</p><p>​</p><ol start="2"><li>发送一些询问报文，例如：<ul><li>回送请求和应答——例如ping命令就是借助ICMP</li><li>超时报文——traceroute就是用这个，把TTL从1慢慢增加，发好多份，通过TTL为0时的差错报告，定位跟踪路上有哪些路由</li><li>时间戳请求——同步时间</li></ul></li></ol><h1><span id="5-dhcp-xie-yi">5 DHCP协议</span><a href="#5-dhcp-xie-yi" class="header-anchor">#</a></h1><p>全称Dynamic Host Configuration Protocol， 动态主机配置协议</p><p>当某个局域网内新增了一台主机，这个主机的ip是怎么生成的呢？这就会用到DHCP协议</p><p>主机所在网内会有一台DCHP服务器。<br>当新主机加入时，发生如下之事：</p><ol><li>主机先“广播”自己，告诉大家“我来了，谁给我一个IP地址”（他一开始不知道DHCP在哪）</li><li>DCHP服务器收到后，会分配一个IP地址，但因为不知道发给谁，所以也只能“广播”，告诉大家“我这有个ip，刚才谁要的，自己来领一下”</li><li>主机收到DHCP广播的报文后，就能知道自己的ip和dhcp服务器位置了。于是给DCHP服务器发送请求，告诉他“我收到了你发来的ip了”</li><li>DCHP收到后，确认了他的信息，并加入到DHCP本地的数据库中，后面分配新ip时就会排除掉这个ip了。</li></ol><p>有以下几个注意点：</p><ol><li>如果有多个主机同时应答了DHCP的广播， 则会选择最先到达的做分配。</li><li>分配的ip是临时的</li></ol><p><strong>DCHP可以认为是基于UDP的应用层协议，但本质是为了寻求新主机的动态ip地址</strong></p><h1><span id="6-lu-you-biao-de-zui-you-xia-yi-tiao-di-zhi-ru-he-ji-suan">6.路由表的最优下一跳地址如何计算？</span><a href="#6-lu-you-biao-de-zui-you-xia-yi-tiao-di-zhi-ru-he-ji-suan" class="header-anchor">#</a></h1><p>可以理解为 在一个复杂的拓扑图下， 怎么选择最优的一个路由做目的地址的下一跳。<br>有2种方式：</p><h2><span id="6-1-rip-xie-yi">6.1 RIP协议</span><a href="#6-1-rip-xie-yi" class="header-anchor">#</a></h2><p>全称Routing Information Protocol,路由信息协议<br>是一种动态路由信息协议。</p><ul><li><p>路由只会和相邻的其他路由交换信息。</p></li><li><p>交换的是路由表的信息，关键在于目的网络和距离</p></li><li><p>之前路由表里知道了表里会存储 到目的网络的距离即跨越路由数量，那么只要拿到周边所有路由的距离表，  看下哪个方向最小， 然后把下一跳地址选为最小的那个路由方向即可。</p></li><li><p>使用UDP广播，把自己的路由报文发给周边的其他路由。</p></li><li><p>当路径不可达时，会导致2个路由之间不断叠加该目的地址的距离，直到16时，会被设置成不可达。</p></li></ul><p>所以RIP本质也是基于UDP的应用层协议，但是目的是为了网络层的最优路由选取。</p><h2><span id="6-2-ospf-xie-yi">6.2 OSPF协议</span><a href="#6-2-ospf-xie-yi" class="header-anchor">#</a></h2><p>open shortest path first，开放最短路径优先协议<br>指路由器里有全网的拓扑结构，使用最短路算法计算最优路由<br>因此路由会把自己的连接情况通过OSPF协议发给所有其他路由，以建立拓扑图。<br>这个是属于IP层的协议，不借助UDP。</p><hr><p>RIP和OSPF是自治网络系统AS里的选路措施。<br>AS里的选路措施被称作IGP（内部网关协议）<br>1个AS里只会有一种选路措施。</p><p>而跨自治系统的协议叫EGP（外部网关协议）<br>通常使用BGP协议</p><hr><h2><span id="6-3-bgp-xie-yi">6.3 BGP协议</span><a href="#6-3-bgp-xie-yi" class="header-anchor">#</a></h2><p>Border Gateway Protocol边界网关协议</p><ul><li>每个AS都知道自己为了到达网络N，需要经过哪些AS（相当于知道以AS为节点的拓扑图）</li><li>每个AS都有一个BGP发言人,会与其他BGP网络之间交换自身的AS拓扑信息，从而构建全局连通图</li><li>使用TCP 179端口工作</li></ul><hr><h2><span id="q-rip-xie-yi-xia-lu-you-biao-shi-me-shi-hou-geng-xin">Q: RIP协议下路由表什么时候更新？</span><a href="#q-rip-xie-yi-xia-lu-you-biao-shi-me-shi-hou-geng-xin" class="header-anchor">#</a></h2><p>A:</p><ul><li>正常情况下，路由器会基于更新计时器每30s将路由表发送给邻居路由器，而触发更新是立刻发送路由更新信息</li><li>触发更新就是当检测到网络拓扑发生变动时，路由器会立即发送一个更新信息给邻居路由器，并依次产生触发更新通知它们的邻居路由器，此过程就叫触发更新</li></ul><hr><h2><span id="q-lu-you-zhong-du-shi-shi-me">Q:  路由中毒是什么？</span><a href="#q-lu-you-zhong-du-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>路由中毒是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息。 然后再将中毒路由信息发布出去，当相邻的路由器收到该中毒路由就可以通过其度量值是16，说明该路由是无效的。</p><p>??因为RIP协议中的度量值其实就是跳数，而RIP协议的跳数最大是15，大于15的目的地被认为是不可达，所以当其度量值为16，就表示这是一个无效路由，这就是所谓的路由中毒，这个数字在限制了网络大小的同时也防止了一个叫做“记数到无穷大”的问题。</p><hr><h2><span id="q-shou-dao-zhong-du-lu-you-de-lu-you-qi-hui-zen-me-zuo">Q: 收到中毒路由的路由器会怎么做？</span><a href="#q-shou-dao-zhong-du-lu-you-de-lu-you-qi-hui-zen-me-zuo" class="header-anchor">#</a></h2><p>A:<br>收到中毒路由信息的相邻的路由器会发送一个毒性逆转的信息，表示已经收到中毒路由信息。</p><p>??那么为什么收到中毒路由的路由器为什么要回复一个毒性逆转的信息？这是因为如果不回复的话，那么发送中毒路由的路由器就会一直以广播的形式发送中毒路由，直到相邻的路由器收到并回复一个毒性逆转的信息。</p><h1><span id="7-duo-bo">7 多播</span><a href="#7-duo-bo" class="header-anchor">#</a></h1><p>UDP的时候会用到多播</p><h2><span id="7-1-igmp-xie-yi">7.1 IGMP协议</span><a href="#7-1-igmp-xie-yi" class="header-anchor">#</a></h2><p>internet group message protol，  网络组管理协议<br>负责收集和解释一个网络中的组成员信息<br>IGMP协议应用于路由器</p><ul><li>某主机加入新的多播组时，发送报文，并转发多播的关系给其他相邻主机或者路由</li><li>会周期性探寻，确认自身这个主机是否还在多播组内</li><li>无法直到总成员数</li><li>IGMP属于网络层的协议</li></ul><h2><span id="7-2-mospf-duo-bo-lu-you-xuan-ze-xie-yi">7.2 MOSPF多播路由选择协议</span><a href="#7-2-mospf-duo-bo-lu-you-xuan-ze-xie-yi" class="header-anchor">#</a></h2><p>多播开放最短通路优先（Multicast Open Shortest PathFirst，MOSPF）协议是OSPF协议的扩展<br>使用多播链路状态路由选择来创建源点基准树。<br>这个协议需要一个新的链路状态更新分组，把主机的单播地址和组地址或主机负责的地址联系起来，这个分组就称为组成员关系LSA。<br>此外，这个数可以保存在高速缓存中，以便以后有同样源点/组地址对的分组可以使用它。<br>多播的其他更详细概念见<a href="https://blog.csdn.net/williananjhon/article/details/94166311">链接</a></p><h1><span id="8-qi-ta-wang-luo-ceng-gai-nian">8 其他网络层概念</span><a href="#8-qi-ta-wang-luo-ceng-gai-nian" class="header-anchor">#</a></h1><h2><span id="8-1-vpn">8.1 VPN</span><a href="#8-1-vpn" class="header-anchor">#</a></h2><p>需要建立专用通道<br>当专用A试图向专用B通信时，会先加密，再通过加密隧道发到对方内网，具体报文内容不会和互联网直接接触。</p><h2><span id="8-2-nat">8.2 NAT</span><a href="#8-2-nat" class="header-anchor">#</a></h2><p>内外网转换用的一个东西， 公网ip和内网ip互转。</p><h2><span id="8-3-yi-dong-ip">8.3 移动IP</span><a href="#8-3-yi-dong-ip" class="header-anchor">#</a></h2><p>ip从子网A变道子网B。<br>在本网时，按TCP通信<br>要漫游到外网时， 注册一个转交地址<br>本地代理接收地址，开启隧道<br>数据发送到外网<br>在外网时，使用代理ip发送数据<br>回到本地时，会注册并转交之前的地址</p><h1><span id="9-chang-jian-wang-luo-ceng-ming-ling">9 常见网络层命令</span><a href="#9-chang-jian-wang-luo-ceng-ming-ling" class="header-anchor">#</a></h1><ul><li>ifconfig　可显示本机的IP地址</li><li>netstat　－ｒ可显示路由表</li><li>tcpdump　可显示硬件地址</li><li>ping　测试另一个主机是否可达</li><li>traceroute　利用ICMP跟踪途径的所有路由</li><li>route　命令可查看和修改路由表</li><li>gated可查看IGP（内部网关协议）和EGP（外部网关协</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础,计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL力扣练习题集合</title>
      <link href="/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>/2022/08/24/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p>[toc]</p><hr><p>limit 1 offset 1 不存在却要求返回null时， 可以用子查询，或者IFNULL(临时表结果或字段， NULL)<br>子查询是select结果作为字段，例如 select (select xx) 而不是 select xxx from (select xxx)。  当select中的字段结果不存在，会自动返回NULL</p><hr><p>如果排名问题要去重，记得加 distinct</p><hr><p>CREATE FUNCTION中<br>可以set N:=N-1: 进行变量更新。 不能在return中进行更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N :<span class="operator">=</span> N<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">RETURN</span> (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      <span class="keyword">select</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> salary <span class="keyword">from</span> Employee </span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>  </span><br><span class="line">      limit <span class="number">1</span> <span class="keyword">offset</span> N) </span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><hr><p>要做排名时给出序号时，有两种方式<br>简单方式：<br>利用子查询字段，注意子查询字段的特点等同于摘出一个字段，再做一次额外查询，得到唯一的一个结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  a.score, (</span><br><span class="line">    # 拿a.score重新重新去检索一次表，得到<span class="built_in">count</span>(<span class="keyword">distinct</span> b.score)<span class="operator">+</span><span class="number">1</span>，得到自己的排名</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> b.score)<span class="operator">+</span><span class="number">1</span> <span class="keyword">from</span> Scores b <span class="keyword">where</span>  a.score<span class="operator">&lt;</span>b.score</span><br><span class="line">    ) <span class="keyword">as</span> `rank` </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> Scores a <span class="keyword">order</span> <span class="keyword">by</span> a.score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>但效率太慢。<br>高速的序号方法：<br>使用dense_rank() over(order by xxx) 可以得到序号，1 1 2 3 3 4，不会跳序号<br>其他序号方式：<br>row_number()  over(order by xxx)     就是简单的12345这种，不考虑重复<br>rank()  over(order by xxx)   如果重复了，1 1 3 4 4 6</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  score, </span><br><span class="line">(<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) ) <span class="keyword">as</span> `rank` </span><br><span class="line"><span class="keyword">from</span> Scores </span><br></pre></td></tr></table></figure><hr><p>寻找3个连续出现的数字，如果id是连续的，则可以自联结，即自己和自己join， 构造where <a href="http://a.id">a.id</a> = b.id-1 and <a href="http://b.id">b.id</a> = c.id-1 这样的情况。非常好理解</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.num <span class="keyword">as</span> ConsecutiveNums <span class="keyword">from</span> </span><br><span class="line">logs a,logs b, logs c</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">a.id <span class="operator">=</span> b.id<span class="number">-1</span></span><br><span class="line"><span class="keyword">and</span> b.id <span class="operator">=</span> c.id<span class="number">-1</span></span><br><span class="line"><span class="keyword">and</span> a.num <span class="operator">=</span> b.num <span class="keyword">and</span> b.num <span class="operator">=</span> c.num</span><br></pre></td></tr></table></figure><hr><p>善用自join联结解决一些表内成员互相比较的复杂问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询收入超过他经理的员工名字。</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"> a.name <span class="keyword">as</span> Employee </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Employee  a , Employee  b</span><br><span class="line"><span class="keyword">where</span> b.id <span class="operator">=</span> a.managerId <span class="keyword">and</span> a.salary <span class="operator">&gt;</span> b.salary</span><br></pre></td></tr></table></figure><hr><p>group分组后， 可以用having进行组内聚合情况的过滤， 剔除不想要的组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找 Person 表中所有重复的电子邮箱。</span><br><span class="line"><span class="keyword">select</span> email <span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> email </span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line"><span class="built_in">count</span>(email) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><p>表a在 表b中不存在记录， 用left join + where xxx is null 来处理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.name <span class="keyword">as</span> Customers </span><br><span class="line"><span class="keyword">from</span> Customers c  <span class="keyword">left</span> <span class="keyword">join</span>  Orders  o</span><br><span class="line"><span class="keyword">on</span> c.id <span class="operator">=</span> o.CustomerId <span class="keyword">where</span> o.id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><hr><p>in 的用法  where a in(1,2,3,4)<br>或者 where a in (select aaa from xxx)</p><p>in也支持二元组形式<br>where (a,b) in (select aaa,bbb from xxx)</p><p>每组最大值的人选的情况，可以用join + in（分组结果）的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查找每个部门中薪资最高的员工，先join，再用in获取符合组+最大值的行</span><br><span class="line">select </span><br><span class="line">b.name as Department , a.name   as Employee ,  a.salary as Salary</span><br><span class="line">from Employee  a </span><br><span class="line">join</span><br><span class="line">Department  b</span><br><span class="line">on a.departmentId  = b.id  </span><br><span class="line"><span class="title function_">and</span> <span class="params">(a.departmentId, a.salary)</span> in (</span><br><span class="line">    select departmentId, max(salary)</span><br><span class="line">    from Employee</span><br><span class="line">    group by departmentId </span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p>找某薪水是组内前几位的情况， 擅用自查询， 即join后， 拿某条记录在where中遍历一遍,  然后根据count(distinct xxx)来确认自己的排名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 找出每个部门获得前三高工资的所有员工</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">b.name <span class="keyword">as</span> Department , a.name   <span class="keyword">as</span> Employee ,  a.salary <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span> Employee  a </span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">Department  b</span><br><span class="line"><span class="keyword">on</span> a.departmentId  <span class="operator">=</span> b.id</span><br><span class="line"># 比自己这行记录salary大， 且在同一组内的数量小于<span class="number">3</span>，则满足前<span class="number">3</span>  </span><br><span class="line"><span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> e.salary) <span class="keyword">from</span> Employee e <span class="keyword">where</span> a.DepartmentId  <span class="operator">=</span> e.DepartmentId  <span class="keyword">and</span> a.salary <span class="operator">&lt;</span> e.salary</span><br><span class="line"> ) <span class="operator">&lt;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><ul><li>分组后， SUM(IF(x=y,1,0) 可以统计组内x=y的个数<br>那么SUM(IF(x=y,1,0) ） / COUNT(x)  就能得到组内x=y的比率</li><li>ROUND(xxx, 2) 可以保留两位小数。</li><li>between的用法： between ‘2013-10-01’ AND ‘2013-10-03’</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 写一段 <span class="keyword">SQL</span> 语句查出?&quot;2013-10-01&quot;?至?&quot;2013-10-03&quot;?期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 banned 为 <span class="keyword">No</span> 的用户，禁止用户即 banned 为 Yes 的用户。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> request_at <span class="keyword">as</span> <span class="keyword">DAY</span>, ROUND(</span><br><span class="line">    <span class="built_in">SUM</span>(IF(status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(status), <span class="number">2</span></span><br><span class="line">) <span class="keyword">as</span> `Cancellation Rate`</span><br><span class="line"> <span class="keyword">from</span> </span><br><span class="line">Trips t, Users u1, Users u2</span><br><span class="line"><span class="keyword">where</span> (t.client_id  <span class="operator">=</span> u1.users_id</span><br><span class="line"><span class="keyword">and</span> t.driver_id <span class="operator">=</span> u2.users_id)</span><br><span class="line"><span class="keyword">and</span> u1.banned <span class="operator">=</span> <span class="string">&#x27;No&#x27;</span> <span class="keyword">and</span> u2.banned <span class="operator">=</span> <span class="string">&#x27;No&#x27;</span> </span><br><span class="line"><span class="keyword">and</span>  request_at <span class="keyword">between</span> <span class="string">&#x27;2013-10-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2013-10-03&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> request_at</span><br></pre></td></tr></table></figure><hr><p>求3个或3个以上连续id的记录，直接自联结，然后用3个or条件判断<br><a href="http://t1.id">t1.id</a> <a href="http://t2.id">t2.id</a> <a href="http://t3.id">t3.id</a><br><a href="http://t2.id">t2.id</a> <a href="http://t1.id">t1.id</a> <a href="http://t3.id">t3.id</a><br><a href="http://t2.id">t2.id</a> <a href="http://t3.id">t3.id</a> <a href="http://t1.id">t1.id</a><br>然后取每种连接表的t1即可</p><p>注意distinct 可以用于星号<br>distinct s1.*<br>也可用于多列  distict s1.a,s1.b,s1.completed</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 找出每行的人数大于或等于 <span class="number">100</span> 且 id 连续的三行或更多行记录。</span><br><span class="line"># 返回按 visit_date 升序排列的结果表</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">distinct</span> s1.id,s1.visit_date , s1.people            </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Stadium s1, Stadium s2,Stadium s3</span><br><span class="line"><span class="keyword">where</span> s1.people  <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">and</span> s2.people <span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> s3.people <span class="operator">&gt;=</span> <span class="number">100</span> </span><br><span class="line"><span class="keyword">and</span> (</span><br><span class="line">    (s1.id <span class="operator">=</span> s2.id<span class="number">-1</span> <span class="keyword">and</span> s2.id <span class="operator">=</span> s3.id<span class="number">-1</span> ) <span class="keyword">or</span></span><br><span class="line">(s2.id <span class="operator">=</span> s1.id<span class="number">-1</span> <span class="keyword">and</span> s1.id <span class="operator">=</span> s3.id<span class="number">-1</span> ) <span class="keyword">or</span></span><br><span class="line">(s2.id <span class="operator">=</span> s3.id<span class="number">-1</span> <span class="keyword">and</span> s3.id <span class="operator">=</span> s1.id<span class="number">-1</span> )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s1.id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL常用命令集合</title>
      <link href="/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
      <url>/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#show-ming-ling">SHOW命令</a><ul><li><a href="#xian-shi-dang-qian-suo-you-de-ke-yong-shu-ju-ku">显示当前所有的可用数据库</a></li><li><a href="#xian-shi-dang-qian-shu-ju-ku-nei-ke-yong-biao">显示当前数据库内可用表</a></li><li><a href="#xian-shi-mou-ge-biao-zhong-de-suo-you-shu-xing-xin-xi">显示某个表中的所有属性信息</a></li></ul></li><li><a href="#jian-suo-ming-ling">检索命令</a><ul><li><a href="#jian-suo-dan-ge-lie">检索单个列</a></li><li><a href="#jian-suo-duo-ge-lie">检索多个列</a></li><li><a href="#jian-suo-suo-you-lie">检索所有列</a></li><li><a href="#jian-suo-chu-bu-chong-fu-de-xing">检索出不重复的行</a></li><li><a href="#fan-hui-mou-xie-xing">返回某些行</a></li></ul></li><li><a href="#pai-xu-ming-ling">排序命令</a><ul><li><a href="#an-dan-lie-pai-xu">按单列排序</a></li><li><a href="#an-duo-ge-lie-pai-xu">按多个列排序</a></li><li><a href="#jiang-xu-pai-xu">降序排序</a></li></ul></li><li><a href="#tiao-jian-cha-xun">条件查询</a><ul><li><a href="#zhao-chu-price-2-de-ren">找出price=2的人</a></li><li><a href="#bu-pi-pei-jian-cha-gei-chu-id-bu-shi-1003-de-ren-zhi-zao-de-chan-pin">不匹配检查： 给出id不是1003的人制造的产品</a></li><li><a href="#fan-wei-zhi-jian-cha">范围值检查：</a></li><li><a href="#kong-zhi-jian-cha">空值检查</a></li><li><a href="#duo-ge-guo-lu-tiao-jian-and-shi-qie-or-shi-huo">多个过滤条件（AND是且， OR是或）</a></li><li><a href="#and-he-or-de-zu-he">AND和OR的组合</a></li><li><a href="#qu-te-ding-zhi-ji-id-1002-1003-1004-de-zhi-jie-ke">取特定值，即id=1002、1003、1004的值皆可</a></li><li><a href="#fou-ding-tiao-jian-not-tiao-jian-ze-qu-bu-man-zu-zhe-ge-tiao-jian-de-xing">否定条件 NOT 条件，  则取不满足这个条件的行</a></li></ul></li><li><a href="#tong-pei-fu">通配符</a><ul><li><a href="#pei-he-zi-fu-chuan-pi-pei-he-like-shi-yong">配合字符串匹配和LIKE使用</a></li><li><a href="#xia-hua-xian-tong-pei-fu-gai-fu-hao-zhi-neng-dai-biao-1-ge-ren-yi-zi-fu">下划线通配符， 该符号只能代表1个任意字符</a></li><li><a href="#shi-yong-tong-pei-fu-de-zhu-yi-shi-xiang">使用通配符的注意事项</a></li><li><a href="#zheng-ze-biao-da-shi-ban-sui-zhao-regexp-shi-yong">正则表达式，伴随着REGEXP使用</a></li></ul></li><li><a href="#te-shu-udf">特殊UDF</a><ul><li><a href="#fen-zu-ju-he">分组+聚合</a></li><li><a href="#fan-hui-jie-ge-de-ping-jun-zhi">返回价格的平均值</a></li><li><a href="#ji-suan-de-shu-liang-bao-gua-null">计算的数量，包括NULL</a></li><li><a href="#zhi-ding-bu-tong-yuan-su-de-tong-ji">指定不同元素的统计</a></li><li><a href="#fen-chu-5-ge-id-ji-suan-ge-id-dui-ying-chan-pin-de-shu-liang">分出5个id，计算各id对应产品的数量</a></li><li><a href="#guo-lu-fen-zu">过滤分组</a></li><li><a href="#lie-chu-ju-you-2-ge-yi-shang-jie-ge-wei-10-de-chan-pin">列出具有2个以上价格为10的产品</a></li></ul></li><li><a href="#zi-cha-xun">子查询</a><ul><li><a href="#zhao-chu-ding-gou-liao-wu-pin-tnt2-de-suo-you-ke-hu-id">找出订购了物品TNT2的所有客户id</a></li></ul></li><li><a href="#ddl">DDL</a><ul><li><a href="#chuang-jian-biao">创建表：</a></li><li><a href="#tian-jia-lie">添加列：</a></li><li><a href="#shan-chu-lie">删除列：</a></li><li><a href="#shan-chu-biao">删除表：</a></li><li><a href="#chong-ming-ming-biao">重命名表：</a></li><li><a href="#cha-ru-xing">插入行：</a></li><li><a href="#shan-chu-shu-ju">删除数据：</a></li><li><a href="#biao-zhong-shan-chu-zhu-jian-wei">表中删除主键为：</a></li><li><a href="#biao-zhong-zeng-jia-zhu-jian-wei">表中增加主键为：</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="show-ming-ling">SHOW命令</span><a href="#show-ming-ling" class="header-anchor">#</a></h1><h2><span id="xian-shi-dang-qian-suo-you-de-ke-yong-shu-ju-ku">显示当前所有的可用数据库</span><a href="#xian-shi-dang-qian-suo-you-de-ke-yong-shu-ju-ku" class="header-anchor">#</a></h2><p>SHOW DATABASE;</p><hr><h2><span id="xian-shi-dang-qian-shu-ju-ku-nei-ke-yong-biao">显示当前数据库内可用表</span><a href="#xian-shi-dang-qian-shu-ju-ku-nei-ke-yong-biao" class="header-anchor">#</a></h2><p>SHOW TABLES ;</p><hr><h2><span id="xian-shi-mou-ge-biao-zhong-de-suo-you-shu-xing-xin-xi">显示某个表中的所有属性信息</span><a href="#xian-shi-mou-ge-biao-zhong-de-suo-you-shu-xing-xin-xi" class="header-anchor">#</a></h2><p>SHOW COLUMNS FORM 表名</p><p>SHOW STATUS 显示广泛的服务器状态<br>SHOW CREATE DATABASE/TABLE  显示创建库或表的SQL语句是啥<br>SHOW GRANTS 显示授权用户<br>SHOW ERRORS SHOW WARNINGS  显示服务器错误或警告消息</p><hr><h1><span id="jian-suo-ming-ling">检索命令</span><a href="#jian-suo-ming-ling" class="header-anchor">#</a></h1><h2><span id="jian-suo-dan-ge-lie">检索单个列</span><a href="#jian-suo-dan-ge-lie" class="header-anchor">#</a></h2><p>SELECT prod_name<br>FROM products</p><hr><h2><span id="jian-suo-duo-ge-lie">检索多个列</span><a href="#jian-suo-duo-ge-lie" class="header-anchor">#</a></h2><p>SELECT id,name,price<br>FROM products</p><hr><h2><span id="jian-suo-suo-you-lie">检索所有列</span><a href="#jian-suo-suo-you-lie" class="header-anchor">#</a></h2><p>SELECT *<br>FROM products</p><hr><h2><span id="jian-suo-chu-bu-chong-fu-de-xing">检索出不重复的行</span><a href="#jian-suo-chu-bu-chong-fu-de-xing" class="header-anchor">#</a></h2><p>SELECT DISTINCT id<br>FROM products</p><hr><h2><span id="fan-hui-mou-xie-xing">返回某些行</span><a href="#fan-hui-mou-xie-xing" class="header-anchor">#</a></h2><p>SELECT name<br>FROM products<br>LIMIT  begin,len  //即开始行，和行数<br>注意： 行从0开始，  故LIMIT1，返回的是第二行</p><hr><h1><span id="pai-xu-ming-ling">排序命令</span><a href="#pai-xu-ming-ling" class="header-anchor">#</a></h1><h2><span id="an-dan-lie-pai-xu">按单列排序</span><a href="#an-dan-lie-pai-xu" class="header-anchor">#</a></h2><p>SELECT name,age<br>FROM products<br>ORDER BY age<br>找出年龄最小的？ 加个LIMIT 1即可</p><hr><h2><span id="an-duo-ge-lie-pai-xu">按多个列排序</span><a href="#an-duo-ge-lie-pai-xu" class="header-anchor">#</a></h2><p>先按price排，再按name排<br>SELECT id,price,name<br>FROM products<br>ORDER BY price, name</p><hr><h2><span id="jiang-xu-pai-xu">降序排序</span><a href="#jiang-xu-pai-xu" class="header-anchor">#</a></h2><p>按price降序排，再按name升序排<br>SELECT id,price,name<br>FROM products<br>ORDER BY price DEC, name</p><hr><h1><span id="tiao-jian-cha-xun">条件查询</span><a href="#tiao-jian-cha-xun" class="header-anchor">#</a></h1><h2><span id="zhao-chu-price-2-de-ren">找出price=2的人</span><a href="#zhao-chu-price-2-de-ren" class="header-anchor">#</a></h2><p>SELECT name, price<br>FROM products<br>WHERE price = 2<br>注意： ORDER BY 排序语句应该放在WHERE的后面</p><p>SQL做where字符匹配时，不区分大小写。</p><hr><h2><span id="bu-pi-pei-jian-cha-gei-chu-id-bu-shi-1003-de-ren-zhi-zao-de-chan-pin">不匹配检查： 给出id不是1003的人制造的产品</span><a href="#bu-pi-pei-jian-cha-gei-chu-id-bu-shi-1003-de-ren-zhi-zao-de-chan-pin" class="header-anchor">#</a></h2><p>SELECT id,name<br>FROM products<br>WHERE id &lt;&gt; 1003;   //或者 id != 1003</p><hr><h2><span id="fan-wei-zhi-jian-cha">范围值检查：</span><a href="#fan-wei-zhi-jian-cha" class="header-anchor">#</a></h2><p>SELECT name,price<br>FROM products<br>WHERE price BETWEEN 5 AND 10</p><hr><h2><span id="kong-zhi-jian-cha">空值检查</span><a href="#kong-zhi-jian-cha" class="header-anchor">#</a></h2><p>WHERE price IS NULL</p><hr><h2><span id="duo-ge-guo-lu-tiao-jian-and-shi-qie-or-shi-huo">多个过滤条件（AND是且， OR是或）</span><a href="#duo-ge-guo-lu-tiao-jian-and-shi-qie-or-shi-huo" class="header-anchor">#</a></h2><p>WHERE id=1003 AND price &lt;10 AND age &lt; 18</p><hr><h2><span id="and-he-or-de-zu-he">AND和OR的组合</span><a href="#and-he-or-de-zu-he" class="header-anchor">#</a></h2><p>WHERE id=1002 OR id=1003 AND price&gt;10<br>根据SQL的规则， AND优先于OR，变成了<br>WHERE id=1002 OR （id=1003 AND price&gt;10）<br>所以最好在OR和AND组合时，加上括号<br>WHERE （id=1002 OR id=1003） AND price&gt;10</p><hr><h2><span id="qu-te-ding-zhi-ji-id-1002-1003-1004-de-zhi-jie-ke">取特定值，即id=1002、1003、1004的值皆可</span><a href="#qu-te-ding-zhi-ji-id-1002-1003-1004-de-zhi-jie-ke" class="header-anchor">#</a></h2><p>WHERE id IN (1002,1003,1004)</p><hr><h2><span id="fou-ding-tiao-jian-not-tiao-jian-ze-qu-bu-man-zu-zhe-ge-tiao-jian-de-xing">否定条件       NOT 条件，  则取不满足这个条件的行</span><a href="#fou-ding-tiao-jian-not-tiao-jian-ze-qu-bu-man-zu-zhe-ge-tiao-jian-de-xing" class="header-anchor">#</a></h2><p>WHERE id NOT IN (1002,1003,1004)</p><hr><h1><span id="tong-pei-fu">通配符</span><a href="#tong-pei-fu" class="header-anchor">#</a></h1><h2><span id="pei-he-zi-fu-chuan-pi-pei-he-like-shi-yong">配合字符串匹配和LIKE使用</span><a href="#pei-he-zi-fu-chuan-pi-pei-he-like-shi-yong" class="header-anchor">#</a></h2><p>百分号通配符，查找以jet开头的任何名字<br>WHERE name LIKE  ‘jet%’<br>包含有anvil的名字<br>WHERE name LIKE  ‘%anvil%’<br>查找以s起头，e结尾的所有名字<br>WHERE name LIKE ‘s%e’</p><hr><h2><span id="xia-hua-xian-tong-pei-fu-gai-fu-hao-zhi-neng-dai-biao-1-ge-ren-yi-zi-fu">下划线通配符， 该符号只能代表1个任意字符</span><a href="#xia-hua-xian-tong-pei-fu-gai-fu-hao-zhi-neng-dai-biao-1-ge-ren-yi-zi-fu" class="header-anchor">#</a></h2><p>不能匹配0个字符，即该处必须有1个字符<br>WHERE name LIKE ‘_ton anvil’</p><hr><h2><span id="shi-yong-tong-pei-fu-de-zhu-yi-shi-xiang">使用通配符的注意事项</span><a href="#shi-yong-tong-pei-fu-de-zhu-yi-shi-xiang" class="header-anchor">#</a></h2><p>1.不要过度使用通配符<br>2.不要把通配符用在搜索模式的开始处<br>3.注意通配符的位置</p><hr><h2><span id="zheng-ze-biao-da-shi-ban-sui-zhao-regexp-shi-yong">正则表达式，伴随着REGEXP使用</span><a href="#zheng-ze-biao-da-shi-ban-sui-zhao-regexp-shi-yong" class="header-anchor">#</a></h2><p>LIKE匹配的是整个串，REGEXP只要出现了类似的即可，即有子串即可<br>例如LIKE ‘abc’ ，只能返回abc。<br>REGEXP ‘abc’， 则可以返回 abcd</p><hr><p>.可以匹配任意一个字符<br>WHERE name REGEXP ‘.000’</p><hr><p>搜索2个串, |类似于或OR<br>WHERE name REGEXP ‘1000|2000’<br>注意：  ‘1|2|3 Ton’ 指代的是1或2或3 Ton， 故不要连续用|后又跟字符，而应该用[]</p><hr><p>匹配几个字符中的一个即可<br>WHERE name REGEXP ‘[123] TON’<br>则可返回  1 Ton 和 2 Ton</p><hr><p>匹配1-9加a-z<br>WHERE name REGEXP  ‘[1-9] [a-z]’</p><hr><p>匹配 正则符号模样的特殊字符<br>用\作为前导<br>WHERE name REGEXP ‘\.’<br>则找到匹配.的， 此时.不代表任意字符</p><hr><p>匹配某个字符的0个或1个<br>WHERE name REGEXP ‘sticks?’<br>则可匹配stick或者sticks</p><hr><p>指定匹配数目 {n}<br>不少于指定数目的匹配 {n,}<br>匹配n到m数目的匹配 {n,m}</p><hr><p>WHERE name REGEXP ‘[[:digit:]]{4}’<br>则匹配4个任意数字</p><hr><p>^定位为文本的开始，$定位为文本的结束<br>注意： ^有另外一个用途，可以用来否定集合[]</p><hr><h1><span id="te-shu-udf">特殊UDF</span><a href="#te-shu-udf" class="header-anchor">#</a></h1><p>在SQL中测试自己写的正则表达式对不对<br>SELECT ‘hello’ REGEXP ‘abc’<br>若正确，则返回1，否则返回0。 显然这个例子返回0</p><hr><p>计算字段<br>SELECT Concat(name, ‘(’ , country, ‘)’ )</p><hr><p>则返回的行里的每个值为<br>LSX(CHINA)<br>CRISTINA(USA)</p><hr><p>RTrim(name)可以删除name中多余的右边空格，常可以用在拼接中</p><hr><p>给计算字段取别名<br>SELECT Concat(name, ‘(’ , country, ‘)’ ) AS newtitle<br>则列名叫newtitle</p><hr><p>执行算数计算<br>SELECT id, num, price, num*price AS sumProfit<br>则多返回一个列，叫做总利润</p><hr><p>测试拼接字段<br>SELECT 3*2+5,  则返回11<br>SELECT Now(),  则返回数据库的当前时间</p><hr><p>数据处理函数<br>Select name, Upper(name) AS upcase_name       都转为大写</p><hr><h2><span id="fen-zu-ju-he">分组+聚合</span><a href="#fen-zu-ju-he" class="header-anchor">#</a></h2><h2><span id="fan-hui-jie-ge-de-ping-jun-zhi">返回价格的平均值</span><a href="#fan-hui-jie-ge-de-ping-jun-zhi" class="header-anchor">#</a></h2><p>SELECT AVG(price) AS avg_price<br>FROM products<br>WHERE id = 1003</p><hr><h2><span id="ji-suan-de-shu-liang-bao-gua-null">计算的数量，包括NULL</span><a href="#ji-suan-de-shu-liang-bao-gua-null" class="header-anchor">#</a></h2><p>SELECT COUNT（*） AS num_cust<br>计算num的数量，不包括NULL<br>SELECT COUTN（num） AS num_cust<br>还有MAX,MIN,SUM</p><hr><h2><span id="zhi-ding-bu-tong-yuan-su-de-tong-ji">指定不同元素的统计</span><a href="#zhi-ding-bu-tong-yuan-su-de-tong-ji" class="header-anchor">#</a></h2><p>SELECT AVG（DISTINCT price） AS avg_price</p><hr><h2><span id="fen-chu-5-ge-id-ji-suan-ge-id-dui-ying-chan-pin-de-shu-liang">分出5个id，计算各id对应产品的数量</span><a href="#fen-chu-5-ge-id-ji-suan-ge-id-dui-ying-chan-pin-de-shu-liang" class="header-anchor">#</a></h2><p>SELECT id, COUNT(*) AS id_num<br>FROM products<br>GROUP BY id<br>1.除了聚集计算语句外， SELECT中出现的每个列都必须出现在GROUP BY中<br>2.GROUP BY 必须出在 ORDER BY 之前</p><hr><h2><span id="guo-lu-fen-zu">过滤分组</span><a href="#guo-lu-fen-zu" class="header-anchor">#</a></h2><p>SELECT id， COUNT(<em>) AD orders<br>FROM orders<br>GROUP BY id<br>HAVING COUNT(</em>) &gt;= 2</p><hr><h2><span id="lie-chu-ju-you-2-ge-yi-shang-jie-ge-wei-10-de-chan-pin">列出具有2个以上价格为10的产品</span><a href="#lie-chu-ju-you-2-ge-yi-shang-jie-ge-wei-10-de-chan-pin" class="header-anchor">#</a></h2><p>SELECT id, COUNT(<em>) AS  num<br>FROM products<br>WHERE price &gt;= 10<br>GROUP BY id<br>HAVING COUNT(</em>) &gt;=2<br>顺序：先WHERE过滤， 在COUNT过滤</p><blockquote><blockquote><p>语句使用顺序<br>SELECT<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>ORDER BY<br>LIMIT</p></blockquote></blockquote><h1><span id="zi-cha-xun">子查询</span><a href="#zi-cha-xun" class="header-anchor">#</a></h1><h2><span id="zhao-chu-ding-gou-liao-wu-pin-tnt2-de-suo-you-ke-hu-id">找出订购了物品TNT2的所有客户id</span><a href="#zhao-chu-ding-gou-liao-wu-pin-tnt2-de-suo-you-ke-hu-id" class="header-anchor">#</a></h2><p>SELECT cus_id<br>FROM orders<br>WHERE sail_id IN （SELECT sail_id<br>FROM orderitem<br>WHERE prod_id = ‘TNT2’）<br>即先从产品表中，找到产品id为INT2的所有订单<br>再从订单表中，找到订单id匹配的所有客户。</p><p>检索出上述客户id的所有信息<br>SELECT cus_name, cus_age<br>FROM customer<br>WHERE  cus_id IN (SELECT cus_id<br>FROM orders<br>WHERE sail_id IN （SELECT sail_id<br>FROM orderitem<br>WHERE prod_id = ‘TNT2’））<br>显示每个客户的订单总数<br>SELECT name, state, (SELECT COUNT(*)<br>FROM orders<br>WHERE orders.cus_id = cus.cus_id ) AS orders<br>FROM customers<br>ORDER BY name<br>对于customer中的每一个客户id， 都从订单表中进行检索，找出每个id的订单数量。</p><h1><span id="ddl">DDL</span><a href="#ddl" class="header-anchor">#</a></h1><h2><span id="chuang-jian-biao">创建表：</span><a href="#chuang-jian-biao" class="header-anchor">#</a></h2><p>CREATE TABLE 表名<br>（<br>列名   数据类型   列属性<br>……<br>PRIMARY KEY (主键列1，主键列2……)<br>）ENGINE=InnoDB</p><h2><span id="tian-jia-lie">添加列：</span><a href="#tian-jia-lie" class="header-anchor">#</a></h2><p>ALTER TABLE 表名<br>ADD 列名 数据类型</p><h2><span id="shan-chu-lie">删除列：</span><a href="#shan-chu-lie" class="header-anchor">#</a></h2><p>ALTER TABLE 表名<br>DROP COLUMN 列名</p><h2><span id="shan-chu-biao">删除表：</span><a href="#shan-chu-biao" class="header-anchor">#</a></h2><p>DROP TABLE 表名</p><h2><span id="chong-ming-ming-biao">重命名表：</span><a href="#chong-ming-ming-biao" class="header-anchor">#</a></h2><p>RENAME TABLE 旧表名 TO 新表名</p><h2><span id="cha-ru-xing">插入行：</span><a href="#cha-ru-xing" class="header-anchor">#</a></h2><p>INSERT INTO 表名(<br>列名1<br>列名2<br>……<br>)<br>VALUES（<br>数据1<br>数据2<br>……<br>），<br>（<br>数据3<br>数据4<br>）;<br>这样就插入了2行</p><p>更新数据：<br>UPDATE 表名<br>SET  列名1=数据1<br>列名2=数据2<br>WHERE 查询条件</p><h2><span id="shan-chu-shu-ju">删除数据：</span><a href="#shan-chu-shu-ju" class="header-anchor">#</a></h2><p>DELETE FROM 表名<br>WHERE 查询条件</p><h2><span id="biao-zhong-shan-chu-zhu-jian-wei">表中删除主键为：</span><a href="#biao-zhong-shan-chu-zhu-jian-wei" class="header-anchor">#</a></h2><p>alert table table_test drop primary key;</p><h2><span id="biao-zhong-zeng-jia-zhu-jian-wei">表中增加主键为：</span><a href="#biao-zhong-zeng-jia-zhu-jian-wei" class="header-anchor">#</a></h2><p>alert table table_test add primary key(id);</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0823</title>
      <link href="/2022/08/23/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/"/>
      <url>/2022/08/23/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-shu-xue-gui-lu-ti-mei-xiang-tong">第一题:数学规律题(没想通)</a></li><li><a href="#di-er-ti-ju-zhen-qian-zhui-he-ying-yong">第二题:矩阵前缀和应用</a></li><li><a href="#di-san-ti-shu-he-di-gui">第三题:树和递归</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-shu-xue-gui-lu-ti-mei-xiang-tong">第一题:数学规律题(没想通)</span><a href="#di-yi-ti-shu-xue-gui-lu-ti-mei-xiang-tong" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/transform-to-chessboard/">782. 变为棋盘 - 力扣（LeetCode）</a></p><p>看答案也没看懂，主要是没有深入研究规律，没精力了，先放着</p><p><img src="/images/2022-08-23/1661270748809.png" alt="1661270748809"></p><p><img src="/images/2022-08-23/1661270976714.png" alt="1661270976714"></p><h1><span id="di-er-ti-ju-zhen-qian-zhui-he-ying-yong">第二题:矩阵前缀和应用</span><a href="#di-er-ti-ju-zhen-qian-zhui-he-ying-yong" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/O4NDxx/">剑指 Offer II 013. 二维子矩阵的和 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-23/1661270797124.png" alt="1661270797124"></p><p>做过好几次了， 维护一个dp[y][x]， 表示（y，x）到(0,0)的矩形和，这个和可以提前遍历一次得到</p><p>然后再通过加减矩阵的方式得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="type">int</span> ylen;</span><br><span class="line">    <span class="type">int</span> xlen;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        ylen = matrix.length;</span><br><span class="line">        xlen = matrix[<span class="number">0</span>].length;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[ylen][xlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;y&lt;ylen;y++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen; x++) &#123;</span><br><span class="line">                sum += matrix[y][x];</span><br><span class="line">                dp[y][x] = sum + (y-<span class="number">1</span>&gt;=<span class="number">0</span>?dp[y-<span class="number">1</span>][x]:<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(row2, col2) - sum(row2, col1-<span class="number">1</span>) - sum(row1-<span class="number">1</span>, col2) + sum(row1-<span class="number">1</span>, col1-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;<span class="number">0</span> || x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1><span id="di-san-ti-shu-he-di-gui">第三题:树和递归</span><a href="#di-san-ti-shu-he-di-gui" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-23/1661270915678.png" alt="1661270915678"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span> + tree2str(root.left) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span> + tree2str(root.right) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.length() == <span class="number">2</span> &amp;&amp; right.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            left = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            right = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(left.length() != <span class="number">2</span> &amp;&amp; right.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            right = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val + left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL表字段定义和优化建议</title>
      <link href="/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
      <url>/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#xuan-ze-shu-ju-lei-xing-de-yuan-ze">选择数据类型的原则：</a></li><li><a href="#zheng-shu-lei-xing">整数类型：</a></li><li><a href="#shi-shu-lei-xing-dai-xiao-shu-dian-de-lei-xing">实数类型（带小数点的类型）</a></li><li><a href="#zi-fu-chuan-lei-xing">字符串类型</a><ul><li><a href="#varchar">varchar</a></li><li><a href="#char">char</a></li><li><a href="#binary-he-varbinary">binary 和varbinary</a></li></ul></li><li><a href="#blob-he-text">BLOB和TEXT</a></li><li><a href="#mei-ju-enum">枚举enum</a></li><li><a href="#ri-qi-he-shi-jian-lei-xing">日期和时间类型</a><ul><li><a href="#datetime">DATETIME</a></li><li><a href="#timestamp">TIMESTAMP</a></li></ul></li><li><a href="#wei-lei-xing">位类型</a><ul><li><a href="#bit-n">bit（n)</a></li><li><a href="#set">set</a></li></ul></li><li><a href="#zhu-jian-de-xuan-ze">主键的选择</a></li><li><a href="#schema-she-ji-shi-de-xian-jing">schema设计时的陷阱</a></li><li><a href="#fan-shi-de-kao-liang">范式的考量</a></li><li><a href="#cha-xun-de-huan-cun">查询的缓存</a></li><li><a href="#alter-table-xing-neng-wen-ti">alter table性能问题</a></li><li><a href="#fen-qu-de-xian-zhi">分区的限制</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="xuan-ze-shu-ju-lei-xing-de-yuan-ze">选择数据类型的原则：</span><a href="#xuan-ze-shu-ju-lei-xing-de-yuan-ze" class="header-anchor">#</a></h1><ul><li>越小越好。 如果后续因为业务需求要alter增大范围， 会很耗时。</li><li>简单数据类型， 比如用整数而不是字符串去存ip。</li><li>尽量NOT NULL。原因:索引列如果存在null， 会需要一个额外的字节，? ?索引统计也变复杂了。</li></ul><h1><span id="zheng-shu-lei-xing">整数类型：</span><a href="#zheng-shu-lei-xing" class="header-anchor">#</a></h1><ul><li>mediumint是24位的， 其他分别是8、16、32、64对应tiny、small、int、big</li><li>支持unsigned属性</li><li>int(11)不代表用11位存储， 限定只是在客户端工具中只显示11位字符。</li></ul><h1><span id="shi-shu-lei-xing-dai-xiao-shu-dian-de-lei-xing">实数类型（带小数点的类型）</span><a href="#shi-shu-lei-xing-dai-xiao-shu-dian-de-lei-xing" class="header-anchor">#</a></h1><ul><li>有时候不一定是为了小数才选实数。  比如选decima而不是bigint是因为decimal可以存储比bigint还要大的数字</li><li>float和double就是标准的16、32浮点运算</li><li>decimal存储精确的小数和精确计算（精确计算只在mysql5.0之后）</li><li>浮点比decimal要的存储空间更小， decimal(18.9）会用掉9个字节（4小数点前+4小数点后+1小数点本身）</li><li>只有精确计算才用到decimal， 如果数据太多，为了节省空间， 可以改成用bigint（只要把小数点部分乘10的倍数，去掉小数点即可），毕竟decimal比较耗空间。</li></ul><h1><span id="zi-fu-chuan-lei-xing">字符串类型</span><a href="#zi-fu-chuan-lei-xing" class="header-anchor">#</a></h1><h2><span id="varchar">varchar</span><a href="#varchar" class="header-anchor">#</a></h2><ul><li>存储可变长字符串。（例外： 用ROW_FORMAT=FIXED创建的话，varchar的空间会固定）</li><li>可变长的概念：<br>char是固定长度的，例如你定义了12，插入了&quot;aa&quot;，后面它会给你补10个空。如果是varchar，那么&quot;aa&quot;就是&quot;aa&quot;不会给你补</li><li>varchar(N)代表的N是最大长度</li><li>需要1-2个额外字节， 来保存字符串长度<br>varchar(n）需要的最大存储空间长度=  n + (n&lt;=255?1:2)</li><li>2种情况不适合用varchar</li></ul><ol><li>最大长度比平均长度要大</li><li>列的更新很少</li></ol><ul><li>varchar(5)相比于varchar(200)的优势：  mysql会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或者操作时会特别糟糕？？ 不懂</li></ul><h2><span id="char">char</span><a href="#char" class="header-anchor">#</a></h2><ul><li>char是定长的，因此总是会预留足够的空间</li><li>char存储时，会删除字符串末尾的空格。 即’  abc  ‘存入后，会变成’  abc’</li><li>char相比varchar的优势： 字符串很短时， 需要的空间比varchar少(varchar需要额外空间存储长度)</li></ul><h2><span id="binary-he-varbinary">binary 和varbinary</span><a href="#binary-he-varbinary" class="header-anchor">#</a></h2><ul><li>存储的是二进制字符串（字节码，0x77那种）</li><li>binary 采用\0而不是空格来填充</li><li>二进制字节码比较的速度比字符快</li></ul><h1><span id="blob-he-text">BLOB和TEXT</span><a href="#blob-he-text" class="header-anchor">#</a></h1><ul><li>为了存储超大的数据而设计的字符串类型</li><li>mysql把他们当作独立的对象处理，专门使用外部的存储区域来存储， 内部存储指针。</li><li>BLOB和TEXT的区别： 一个是二进制，一个带有字符集规则</li><li>mysql对这2个类型做排序时， 只对前max_sort_length字节做排序</li><li>因此不能将这2个类型的字段做索引</li></ul><h1><span id="mei-ju-enum">枚举enum</span><a href="#mei-ju-enum" class="header-anchor">#</a></h1><p>create table enum_test(e ENUM(‘a’,‘b’,‘c’) NOT NULL)</p><ul><li>实际上存储的不是’a’这个字符串，而是1\2\3 这类数字</li><li>按照定义顺序分配数字</li><li>排序时也按照实际数字排序，而不是枚举的字典序</li><li>枚举作为主键也优于字符串， 毕竟她本质是数字。但是比数字会差一点。</li></ul><h1><span id="ri-qi-he-shi-jian-lei-xing">日期和时间类型</span><a href="#ri-qi-he-shi-jian-lei-xing" class="header-anchor">#</a></h1><h2><span id="datetime">DATETIME</span><a href="#datetime" class="header-anchor">#</a></h2><ul><li>从1001到9999年， 精度为秒</li><li>与时区无关</li><li>使用8个字节存储</li></ul><h2><span id="timestamp">TIMESTAMP</span><a href="#timestamp" class="header-anchor">#</a></h2><ul><li>从1970.1.1至今的秒数</li><li>只使用4个字节</li><li>显示依赖时区，服务端、客户端都需要配置时区，然后timeStamp的展示就会不同。</li><li>TIMESTAMP默认为NOT NULL</li><li>插入时会自动设置这个列的值为“当前时间”</li></ul><p>如果想存毫秒怎么办？ 可以使用bigint来存储毫秒级时间戳。</p><h1><span id="wei-lei-xing">位类型</span><a href="#wei-lei-xing" class="header-anchor">#</a></h1><p>通常用于存储acl权限</p><h2><span id="bit-n">bit（n)</span><a href="#bit-n" class="header-anchor">#</a></h2><ul><li>mysql把bit当作字符串而不是数字类型</li><li>存储00111001并且检索时， 得到的ASCII为57的字符串（即’9’)。  在数字上下文场景却是数字57</li><li>因为这个特性，慎用bit</li></ul><h2><span id="set">set</span><a href="#set" class="header-anchor">#</a></h2><ul><li>如果字段内容就是一堆true或者false的位，可以放到set类型种</li><li>替代方式： 用tinyint类型来替代， 就是比太好理解。</li></ul><hr><h1><span id="zhu-jian-de-xuan-ze">主键的选择</span><a href="#zhu-jian-de-xuan-ze" class="header-anchor">#</a></h1><ul><li>整数是坠好的</li><li>enum和set是糟糕的选择。</li><li>字符串类型也尽量避免。空间大，检索慢</li><li>避免随机生成的主键字符串，原因:</li></ul><ol><li>插入值会随机写到索引的不同位置</li><li>select语句会变慢</li><li>随机值导致缓存失效( 局部性原理gg）<br>因此最好不要用string类型的UUID，  而是转为数字。</li></ol><hr><h1><span id="schema-she-ji-shi-de-xian-jing">schema设计时的陷阱</span><a href="#schema-she-ji-shi-de-xian-jing" class="header-anchor">#</a></h1><ul><li>太长的列且列中有变长的字段， 可能会导致转换成行数据结构时要消耗很大的CPU。（从行缓冲种将编码过的列转成行数据的缘故）</li><li>表的关联表太多会有问题。 建议查询最好在12个表内做关联。</li><li>防止过度使用枚举。 枚举的缺点:<br>① 可能会有人搞一个enum(‘-1’,‘0’,‘1’,‘2’)这种误导人的枚举<br>② 每次要新增枚举必须alter table，会阻塞表</li><li>set中的元素如果每次只能出现一个， 应该改成枚举。</li><li>mysql会在索引中存储null，但是oracle不会。</li><li>尽量不要用null，而是用空字符串、默认值替代，除非没有可以用的默认值，宁愿用null去引起调用方注意</li></ul><hr><h1><span id="fan-shi-de-kao-liang">范式的考量</span><a href="#fan-shi-de-kao-liang" class="header-anchor">#</a></h1><p>范式设计： 每个数据一般只会出现一次，没有冗余或者重复数据<br>反范式： 与范式相反。</p><p>范式的优点：</p><ul><li>更新操作快，因为重复的记录少</li><li>表更小，可以更好地放到内存里</li><li>很少需要做distinct、groupby， 因此一般都是1对1的关系</li></ul><p>缺点：<br>查询时经常需要关联，当关联后的另外一个表需要做条件判断，可能会消耗一定性能</p><p>反范式的优缺点和范式正好相反。</p><hr><h1><span id="cha-xun-de-huan-cun">查询的缓存</span><a href="#cha-xun-de-huan-cun" class="header-anchor">#</a></h1><ul><li>有时候会弄一个叫缓存表或者汇总表的东西， 避免每次查询所有记录来得到一个区间的结果</li><li>计数器表，如果表里只有1行，可能导致并发效率低。 可以弄100行，然后大家更新时随机更新。  统计结果时直接sum即可</li></ul><hr><h1><span id="alter-table-xing-neng-wen-ti">alter table性能问题</span><a href="#alter-table-xing-neng-wen-ti" class="header-anchor">#</a></h1><ul><li>mysql中，  alter table的原理一般是  用新的结构创建一个新表，然后把数据导入到新表中。</li><li>有一些操作可以只修改表的.frm文件来达到修改结构的作用。<br>比如 alter column修改默认值，  移除列的auto_increment属性， 或者修改enum、set的常量 （可以通过弄一个新表，然后只修改新表的属性，接着进入数据库后端直接替换tablename.frm文件</li></ul><h1><span id="fen-qu-de-xian-zhi">分区的限制</span><a href="#fen-qu-de-xian-zhi" class="header-anchor">#</a></h1><p>MySQL分区的限制</p><ul><li><p>一个表最多只能有1024个分区。</p></li><li><p>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</p></li><li><p>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</p></li><li><p>分区表中无法使用外键约束。</p></li><li><p>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</p></li></ul><p><a href="https://blog.csdn.net/qq_35190486/article/details/108758205">分区详细用法</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL语句调优手段</title>
      <link href="/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/"/>
      <url>/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#cha-xun-wei-shi-me-hui-man">查询为什么会慢？</a></li><li><a href="#ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun">应用逻辑上处理低效查询</a><ul><li><a href="#ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju">应用层逻辑上，是不是返回了太多会被自己抛弃的数据</a></li><li><a href="#mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu">mysql中，是否在扫描额外的记录</a></li></ul></li><li><a href="#chong-gou-cha-xun-yu-ju">重构查询语句</a><ul><li><a href="#limit-qie-fen-cha-xun">limit切分查询</a></li><li><a href="#guan-lian-cha-xun-join-fen-jie">关联查询（join）分解</a></li><li><a href="#you-hua-in-cha-xun">优化In查询</a></li><li><a href="#you-hua-union-jia-limit">优化UNION加limit</a></li><li><a href="#suo-yin-he-bing-you-hua">索引合并优化</a></li><li><a href="#deng-zhi-chuan-di">等值传递</a></li><li><a href="#bing-xing-zhi-xing">并行执行？</a></li><li><a href="#ha-xi-guan-lian">哈希关联</a></li><li><a href="#song-san-suo-yin-sao-miao">松散索引扫描</a></li><li><a href="#zui-da-he-zui-xiao-zhi-you-hua">最大和最小值优化</a></li><li><a href="#tong-biao-cha-xun-he-geng-xin">同表查询和更新</a></li><li><a href="#you-hua-count">优化Count()</a></li><li><a href="#guan-lian-cha-xun-you-hua">关联查询优化</a></li><li><a href="#group-by-you-hua">Group by优化</a></li><li><a href="#you-hua-limit-fen-ye">优化LIMIT分页</a></li><li><a href="#ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye">如何知道是否有下一页?分多少页？</a></li><li><a href="#you-hua-union">优化UNION</a></li><li><a href="#shi-yong-zi-ding-yi-bian-liang-you-hua">使用自定义变量优化</a></li><li><a href="#yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua">用特殊关键字控制执行计划</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="cha-xun-wei-shi-me-hui-man">查询为什么会慢？</span><a href="#cha-xun-wei-shi-me-hui-man" class="header-anchor">#</a></h1><ul><li>查询的生命周期<br>客户端发送-&gt;服务器接收-&gt;服务器解析sql-&gt;生成执行计划-&gt;执行-&gt;返回结果<br>其中最耗时的就是执行了。</li><li>查询执行时耗费的时间：</li></ul><ol><li>网络</li><li>CPU计算</li><li>生成统计信息</li><li>锁等待</li><li>IO操作</li></ol><h1><span id="ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun">应用逻辑上处理低效查询</span><a href="#ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun" class="header-anchor">#</a></h1><h2><span id="ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju">应用层逻辑上，是不是返回了太多会被自己抛弃的数据</span><a href="#ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju" class="header-anchor">#</a></h2><p>这个主要和 返回的数据有关</p><ul><li>sql里写的是返回所有行， 却在代码里只取resultSet的前10行。</li><li>sql里写的是返回select *，  代码里却只需要特定几列。</li><li>每次查询肯定是相同的结果，却没有做缓存。</li></ul><h2><span id="mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu">mysql中，是否在扫描额外的记录</span><a href="#mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu" class="header-anchor">#</a></h2><p>这个主要和查询的过程有关（返回的数据已经优化到最优了)</p><ul><li>扫描的行数/返回的行数的比值越小越好</li><li>EXPLAIN分析中有几个type，从坏到好分别是</li></ul><ol><li>全表扫描All</li><li>索引扫描ref</li><li>范围扫描</li><li>唯一索引查询</li><li>常数引用<br>EXPLANIN里会显示扫描的行数row， 你可以和返回的行数做对比</li></ol><ul><li>mysql中有3种方式来使用where条件，从好到坏分别是</li></ul><ol><li>在索引中直接做where判断来过滤，然后返回底层数据，这个需要在存储引擎层完成</li><li>索引覆盖扫描，直接在索引中返回数据，没有走到底层的数据处，这个在服务器层完成即可，不用走到底层存储引擎</li><li>先从存储引擎返回数据， 然后再在服务器层做where判断来过滤</li></ol><ul><li>为了减少扫描的行数，常见优化方式：</li></ul><ol><li>使用索引覆盖扫描</li><li>使用汇总表（就是每次做一些操作就会触发更新，不要再去重复查询了）</li><li>重写复杂查询(联结等）</li></ol><h1><span id="chong-gou-cha-xun-yu-ju">重构查询语句</span><a href="#chong-gou-cha-xun-yu-ju" class="header-anchor">#</a></h1><h2><span id="limit-qie-fen-cha-xun">limit切分查询</span><a href="#limit-qie-fen-cha-xun" class="header-anchor">#</a></h2><ul><li>指的是用limit等分页手段来切分，分多次执行</li><li>适用于一些可能会锁表的大批量操作。</li><li>比如删除某10w条数据， 最好先查询+limit 1w，分10次执行，中间间隔一些时间， 避免长时间的锁表。</li></ul><h2><span id="guan-lian-cha-xun-join-fen-jie">关联查询（join）分解</span><a href="#guan-lian-cha-xun-join-fen-jie" class="header-anchor">#</a></h2><ul><li>如果一个语句中join多次， 看下能不能在应用层分3个select依次执行，每次取前一次select的结果加入自己的条件中</li><li>好处：</li></ul><ol><li>分解后条件变简单了，就有可能利用mysql的缓存。</li><li>也因为条件变简单且是单表，可能会利用上索引</li><li>减少锁的竞争</li><li>每个表相当于只查询了一次， 减少了重复访问。</li></ol><h2><span id="you-hua-in-cha-xun">优化In查询</span><a href="#you-hua-in-cha-xun" class="header-anchor">#</a></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> b <span class="keyword">where</span> b.xx<span class="operator">&lt;</span>y)</span><br></pre></td></tr></table></figure><p>注意上面并不是先计算in子表返回的内容，然后作为条件去做检查<br>而是变成一个关联查询</p><p>select * from a where exist(select * from b where b.xx&lt;y and <a href="http://a.id=b.id">a.id=b.id</a>))</p><p>会先对file表做全表扫描，然后再进行条件查询。这这会很慢</p><ul><li>改进：</li></ul><ol><li>用inner join改写成内联</li><li>用GROUP_CONCAT生成一个列表，再提供给IN去使用。<br>P 224-225</li></ol><h2><span id="you-hua-union-jia-limit">优化UNION加limit</span><a href="#you-hua-union-jia-limit" class="header-anchor">#</a></h2><p>（select …） UNION ALL (select …) limit 20<br>这句话本质上会把需要联合的表全部取出，做合并之后，再limit，如果表很大，limit相当于没有他本该的作用。<br>可以改成 在内部都加上一个limit来减少union时的量</p><h2><span id="suo-yin-he-bing-you-hua">索引合并优化</span><a href="#suo-yin-he-bing-you-hua" class="header-anchor">#</a></h2><h2><span id="deng-zhi-chuan-di">等值传递</span><a href="#deng-zhi-chuan-di" class="header-anchor">#</a></h2><p>IN（）列表可能会被复制到关联的各个表中， 列表很大就会导致执行变慢</p><h2><span id="bing-xing-zhi-xing">并行执行？</span><a href="#bing-xing-zhi-xing" class="header-anchor">#</a></h2><p>mysql都是单线程进行查询</p><h2><span id="ha-xi-guan-lian">哈希关联</span><a href="#ha-xi-guan-lian" class="header-anchor">#</a></h2><ul><li>mysql不支持哈希关联， 关联都是通过 嵌套循环关联的。</li><li>除非用之前提过的自定义哈希索引部分（弄一个触发器来生成哈希索引）</li></ul><h2><span id="song-san-suo-yin-sao-miao">松散索引扫描</span><a href="#song-san-suo-yin-sao-miao" class="header-anchor">#</a></h2><p>指没有用到第一列索引，却需要用第二列索引时，按照下面的方式去查：<br><img src="/images/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/7276f16be3c71df35198c15d8fdcab0a8032bf14.png" alt="7276f16be3c71df35198c15d8fdcab0a8032bf14"><br>select * from xxx where B = xxx group by A;<br>添加 group by 字段后，会先根据 A 索引分组后，会在每个 A 的范围内使用索引进行快速查询定位所需要的 B 列，这就叫做松散索引扫描，比新建一个索引的效率会慢 A 的 distinct 倍，但省去了新索引的消耗</p><h2><span id="zui-da-he-zui-xiao-zhi-you-hua">最大和最小值优化</span><a href="#zui-da-he-zui-xiao-zhi-you-hua" class="header-anchor">#</a></h2><p>如果你MIN（）的是主键，且where中没有用到索引， 那么MYQL就进行全表顺序扫描。<br>扫描时按理应当满足第一个可行的值时，就是最小值（主键按顺序排列）<br>但是mysql不支持。<br>可以用limit 1来优化，不要用MIN或者MAX， 如果你要统计的是主键的值的话。</p><h2><span id="tong-biao-cha-xun-he-geng-xin">同表查询和更新</span><a href="#tong-biao-cha-xun-he-geng-xin" class="header-anchor">#</a></h2><p>mysql不允许 在同一张表进行查询和更新<br><img src="/images/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/177fdc92efb7933bd40b061f64dc615480e891e7.png" alt="177fdc92efb7933bd40b061f64dc615480e891e7"></p><h2><span id="you-hua-count">优化Count()</span><a href="#you-hua-count" class="header-anchor">#</a></h2><ul><li>count(列或列的表达式) 会过滤掉无值或者null的情况。 而count(*)直接统计所有行数</li><li>count(*)的性能好一点， 因为他不用过滤和比较是否为空，可以直接用存储引擎记录的一些信息直接得到。</li><li>count(*) 不带where非常快，  如果带了where，就要遍历。</li><li>一种优化： 如果统计where id&gt;5， 而id&gt;5很多，&lt;5却很少，可以反向求接，改成<br>select (select count(<em>) from city) - count(</em>) from t where id &lt; 5。<br>毕竟不带where的是很快的。</li><li>如果对计数要求不是那么精确， 可以用汇总表去处理总和的问题，每隔一段时间更新一次。</li><li>注意这种用法<br>select count(color=‘blue’ OR NULL) AS bule, count(color=‘red’ OR NULL) as red from items;<br>可以求红色和蓝色的个数并展示在同一行中，无需分组。</li></ul><h2><span id="guan-lian-cha-xun-you-hua">关联查询优化</span><a href="#guan-lian-cha-xun-you-hua" class="header-anchor">#</a></h2><ul><li>确保ON或者USING的列上有索引</li><li>如果B join A， 那么A上有索引足够了。因为联结是是遍历B的每一行，拿B的joinKey 去A里面搜索，所以真正用到的是A的索引（除非执行计划做了优化）</li><li>优化GROUP BY 或者DISTINCT</li></ul><h2><span id="group-by-you-hua">Group by优化</span><a href="#group-by-you-hua" class="header-anchor">#</a></h2><ul><li>分组时，要么利用文件要么利用内存做临时表，你可以用优化器的提示去控制用内存还是文件</li><li>join后再分组， 分组里的列尽量用join的key，  比如你虽然是要按名字分组并栈式的，但名字和id是一一对应的，所以按id分组并展示名字是ok的</li><li>不要用分组去展示非分组列（即不是聚合结果也不是分组列）</li><li>分组时，会自动对分组后的结果按分组列排序，消耗一定时间。  如果不希望排序，可以加一个ORDER BY NULL</li></ul><h2><span id="you-hua-limit-fen-ye">优化LIMIT分页</span><a href="#you-hua-limit-fen-ye" class="header-anchor">#</a></h2><ul><li>对于“LIMIT 100000,10”     里面存在100000的偏移，而偏移本质上得扫描掉前面的100020条记录。</li><li>有3种优化方式：</li></ul><ol><li>构造一个联结临时表，临时表里做索引覆盖查询+limit（即select的只有limit列），然后再拿得到的id做联结，获取你需要的列。</li><li>如果确定是某个limit的范围，且为索引，则用where 索引范围来代替</li><li>或者where xx&lt;100020 ORDER BY XX DESC LIMIT 20来反向求。</li></ol><h2><span id="ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye">如何知道是否有下一页?分多少页？</span><a href="#ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye" class="header-anchor">#</a></h2><ol><li>LIMIT的时候加上SQL_CALC_FOUND_ROWS。这样会返回除去LIMIT之外的其他行数，相当于剩下还需要的行数。</li><li>每次LIMIT X+1， 应用层只拿X行， 如果有多一行，说明还有下一页</li><li>每次LIMIT 10X， 然后10X作为缓存，应用层每次取X作为一页展示。</li></ol><h2><span id="you-hua-union">优化UNION</span><a href="#you-hua-union" class="header-anchor">#</a></h2><ul><li>UNION的本质是创建并填充临时表</li><li>用UNION ALL， 否则会默认加上DISTINCT关键字进行唯一性检查，消耗性能</li></ul><h2><span id="shi-yong-zi-ding-yi-bian-liang-you-hua">使用自定义变量优化</span><a href="#shi-yong-zi-ding-yi-bian-liang-you-hua" class="header-anchor">#</a></h2><p>见6.4自定义变量</p><h2><span id="yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua">用特殊关键字控制执行计划</span><a href="#yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua" class="header-anchor">#</a></h2><ul><li>High_Priority/low_priority<br>多个语句同时操作一个表时， 可以用这个来控制语句的优先级。</li><li>Delayed<br>对插入和更新操作而言， 他会直接返回响应给客户端，然后把数据缓存下来，等服务器空闲了再去插</li><li>Straight_join<br>可以用这个关键字控制 join顺序，而不是用优化器的join顺序</li><li>SQL_small_result<br>告诉优化器 结果集很小，你可以搞个内存临时表做排序</li><li>SQL_big_result<br>告诉优化器 结果集很大， 可以提早准备磁盘排序而不是等发现不够了采用磁盘。</li><li>SQL_CACHE<br>结果集是否应该缓存。</li><li>SQL_CALC_FOUND_ROWS<br>让返回的结果集包含更多信息（例如limit 10,结果集里却有个总数信息）</li><li>For update / Lock in share ode<br>提示优化器加行锁</li><li>Use/ignore/force Index</li><li>告诉优化器要不要用索引，如果是force，即使where里没有索引，也会去用索引。 如果是ignore，则就是不用，傲娇</li><li>optimizer_search_depth<br>dfs搜索计划时的最大深度</li><li>optimizer_prune_level<br>根据扫描的行数来决定是否跳过执行计划？</li><li>optimizer_switch<br>选择是否关闭某些优化器特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL执行和内部优化原理</title>
      <link href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#mysql-zhi-xing-cha-xun-de-guo-cheng">mysql执行查询的过程</a><ul><li><a href="#yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li">一、客户端发查询请求到服务端之间的原理</a></li><li><a href="#er-you-xian-cha-xun-huan-cun">二、优先查询缓存</a></li><li><a href="#san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li">三、查询前做语句优化处理</a><ul><li><a href="#1-yu-fa-jie-xi-qi-he-yu-chu-li">1.语法解析器和预处理</a></li><li><a href="#2-cha-xun-you-hua-qi-chong-dian">2.查询优化器(重点）</a><ul><li><a href="#mysql-de-you-hua-lei-xing">mysql的优化类型</a></li></ul></li><li><a href="#3-shu-ju-he-suo-yin-de-tong-ji-xin-xi">3.数据和索引的统计信息</a></li><li><a href="#4-mysql-dui-guan-lian-cha-xun-de-zhi-xing">4.MYSQL对关联查询的执行</a></li><li><a href="#5-zhi-xing-shu-you-hua">5. 执行树优化</a></li><li><a href="#6-guan-lian-cha-xun-you-hua-qi">6. 关联查询优化器</a></li><li><a href="#7-pai-xu-you-hua">7.排序优化</a></li></ul></li><li><a href="#si-zhen-zheng-zhi-xing-cha-xun-ji-hua">四、真正执行查询计划</a></li><li><a href="#wu-fan-hui-jie-guo-gei-ke-hu-duan">五、返回结果给客户端</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="mysql-zhi-xing-cha-xun-de-guo-cheng">mysql执行查询的过程</span><a href="#mysql-zhi-xing-cha-xun-de-guo-cheng" class="header-anchor">#</a></h1><p><img src="/images/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/d07d12af7b4cd173bb9275fd8ef0e6e6ea2a8aca.png" alt="d07d12af7b4cd173bb9275fd8ef0e6e6ea2a8aca"></p><ol><li>客户端先发送查询语句给服务器</li><li>服务器检查缓存，如果存在则返回</li><li>进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划</li><li>根据执行计划，调用存储引擎的API来执行查询</li><li>将结果返回给客户端。</li></ol><p>下面是详解</p><h2><span id="yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li">一、客户端发查询请求到服务端之间的原理</span><a href="#yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li" class="header-anchor">#</a></h2><ul><li>客户端和服务端之间是半双工的， 即一个通道内只能一个在发一个接收， 不能同时互相发互相接收</li><li>客户端只会发送一个数据包给服务端，并不会在应用层拆成2个数据包去发（max_allowed_packet可以设置数据包最大长）， 这关系到sql语句不能太长。</li><li>服务端返回给客户端可以有多个数据包， 但是客户端必须完整接收，不能接到一半停掉连接或用连接去做其他事（UI界面可以操作，不同的线程）</li><li>例如java，如果没设置fetchSize，那么都是一次性把结果读进内存。当你使用resultSet的时候，其实已经全部进来了，而不是一条条从服务端获取。————使用fetch Size边读边处理的坏处： 服务端占用的资源时间变久了。</li></ul><p><strong>查询mysql服务此时的状态：</strong></p><p>使用 <em><strong>show full processlist</strong></em> 命令可以查看mysql服务端某些线程的状态</p><ul><li>Sleep  正在等待客户端发送新的请求</li><li>Query 正在执行查询， 或者发结果发给客户端</li><li>Locked  正在等待表锁（注意表锁是服务器层的， 而行锁是存储引擎层的，行锁时状态为query）</li><li>Analyzing and statistics  正在生成查询的计划或者收集统计信息</li><li>copying to tmp table  临时表操作，一般是正在做group by等操作</li><li>sorting result  正在对结果集做排序</li><li>sending data 正在服务器线程之间传数据</li></ul><h2><span id="er-you-xian-cha-xun-huan-cun">二、优先查询缓存</span><a href="#er-you-xian-cha-xun-huan-cun" class="header-anchor">#</a></h2><ul><li>缓存的查询在sql解析之前进行。</li><li>缓存的查找通过一个 对大小写敏感的哈希表实现，即直接比对sql字符串。</li><li>因此只要有一个字节不同，都不会匹配中。（毕竟还没开始解析，大小写什么的他也不知道要不要区分）</li><li>第7章中有更详细的查询缓存。</li></ul><h2><span id="san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li">三、查询前做语句优化处理</span><a href="#san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li" class="header-anchor">#</a></h2><h3><span id="1-yu-fa-jie-xi-qi-he-yu-chu-li">1.语法解析器和预处理</span><a href="#1-yu-fa-jie-xi-qi-he-yu-chu-li" class="header-anchor">#</a></h3><ul><li>这里就是把sql做解析， 变成一个解析树。解析时会做mysql语法规则验证。</li><li>语法解析器: 检查关键字错误、关键字顺序、引号匹配</li><li>预处理：和元数据关联校验， 检查数据表和列是否存在，解析名字和别名。</li><li>权限校验</li></ul><h3><span id="2-cha-xun-you-hua-qi-chong-dian">2.查询优化器(重点）</span><a href="#2-cha-xun-you-hua-qi-chong-dian" class="header-anchor">#</a></h3><ul><li>mysql可能会生成多种计划， 他会分别计算一个预测成本值，然后选一个成本最小的计划</li><li>计算信息来自于 表的页面个数、索引分布、长度、个数、数据行长度</li><li>因为多种原因，可能不会选择到最优的计划，有偏差</li><li>静态优化和动态优化的区别：<br>静态优化类似“编译期优化”，只和语句结构有关，和具体值无关<br>动态优化是在运行中去优化的，需要依赖索引行数、where取值，执行次数可能比静态优化要多。</li></ul><h4><span id="mysql-de-you-hua-lei-xing">mysql的优化类型</span><a href="#mysql-de-you-hua-lei-xing" class="header-anchor">#</a></h4><ul><li>关联表（join）的顺序可能会变</li><li>outer join可能会变成内连接</li><li>优化条件表达式， 例如 5=5 AND a&gt;5被简化成a&gt;5</li><li>优化MAX\MIN， 如果是MAX(索引），那么直接拿B+树的第一条或者最后一条即可。</li><li>当发现某个查询或者表达式的结果是可以提前计算出来的时候，就会优化成常数</li><li>索引覆盖，如果只要返回索引列，就不会走到最底层去。</li><li>子查询优化</li><li>提前终止查询（例如LIMIT）</li><li>等值传播： join中可能把左表的where 拿给右表一起用</li><li>IN(1,2,3,4,5,6)这个条件， 并不是简单遍历判断， 会先排序，然后用二分去判断是否存在。</li></ul><h3><span id="3-shu-ju-he-suo-yin-de-tong-ji-xin-xi">3.数据和索引的统计信息</span><a href="#3-shu-ju-he-suo-yin-de-tong-ji-xin-xi" class="header-anchor">#</a></h3><ul><li>统计信息是存储引擎去计算的，不同的存储引擎有不同的统计信息</li><li>服务器层生成查询计划时，会向存储引擎获取这些信息。</li></ul><h3><span id="4-mysql-dui-guan-lian-cha-xun-de-zhi-xing">4.MYSQL对关联查询的执行</span><a href="#4-mysql-dui-guan-lian-cha-xun-de-zhi-xing" class="header-anchor">#</a></h3><ul><li>join查询的本质其实是读取临时表做关联</li><li>例如a inner join b on <a href="http://a.id=b.id">a.id=b.id</a> where a.xx=y</li></ul><ol><li>遍历a的每一行（此时a表本质上是 select * from a where a.xx=y）</li><li>在那行中a的id被定下来， 那么就会去获取一个临时表，临时表为（select * from b where <a href="http://a.id">a.id</a> = id）</li><li>接着用这个临时表和a那一行拼接，输出多行。</li><li>然后再用这里的结果作为临时表，给更上层的关联去用（嵌套查询的含义）。</li></ol><ul><li>如果是left join，则就是临时表如果为空，则给a那一行拼接一个null。</li></ul><h3><span id="5-zhi-xing-shu-you-hua">5. 执行树优化</span><a href="#5-zhi-xing-shu-you-hua" class="header-anchor">#</a></h3><p><img src="/images/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/d8e575f3226ca6bd15ed537fc2af07a297ce5c7a.png" alt="d8e575f3226ca6bd15ed537fc2af07a297ce5c7a"></p><h3><span id="6-guan-lian-cha-xun-you-hua-qi">6. 关联查询优化器</span><a href="#6-guan-lian-cha-xun-you-hua-qi" class="header-anchor">#</a></h3><ul><li>join实际执行的顺序会关系到性能</li><li>例如a\b\c三个表关联， 可能先让a和b关联得到的临时表里的记录只有10条， 而如果让a和c先关联，会有10000条， 那么后面的效率就会截然不同</li><li>EXPLAIN EXTENDED可以展示关联的顺序</li><li>STRAIGHT_JOIN可以手动指定关联顺序</li><li>mysql自己会评估搜索一个最优的顺序， 但如果join表太多，则无法搜完所有结果（O(n!))， 那时候就会采用贪心。  是否使用贪心算法的边界值可以根据optimizer_seartch_depth去指定。</li></ul><h3><span id="7-pai-xu-you-hua">7.排序优化</span><a href="#7-pai-xu-you-hua" class="header-anchor">#</a></h3><ul><li>如果排序的量小，就用内存快速排序；如果排序的量大，就用文件排序</li><li>mysql有2种取排序数据的方式：</li></ul><ol><li>两次传输排序：  先取要排序的字段加行序号，按照字段排序好之后，再根据行索引一条条取读<br>优点: 排序时占用内存小。<br>缺点: 排序之后读的过程会很慢，根据行序号取读不是很方便</li><li>单次传输排序： 直接把行读出来（行里只有需要用的列，不一定是整行） ，然后排序<br>优点: 把全部行读出来相当于顺序IO，读取速度快<br>缺点: 可能会很大导致需要文件排序</li></ol><ul><li>关联查询order by的注意事项<br>如果order by的列 <em><strong>都</strong></em> 来自关联的 <em><strong>第一张</strong></em>  表，则直接第一张表join的时候就排序了。<br>除此之外！！ 都是全部join完，再排序！ 就算用了limit，也是全部join+排序后， 再limit的！</li></ul><h2><span id="si-zhen-zheng-zhi-xing-cha-xun-ji-hua">四、真正执行查询计划</span><a href="#si-zhen-zheng-zhi-xing-cha-xun-ji-hua" class="header-anchor">#</a></h2><ul><li>执行计划是一个数据结构</li></ul><h2><span id="wu-fan-hui-jie-guo-gei-ke-hu-duan">五、返回结果给客户端</span><a href="#wu-fan-hui-jie-guo-gei-ke-hu-duan" class="header-anchor">#</a></h2><ul><li>用tcp封包并逐步传送，而不是全部准备好再发送。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表</title>
      <link href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#chui-zhi-fen-biao">垂直分表</a><ul><li><a href="#q-shi-me-shi-chui-zhi-fen-biao-yi-ban-zen-me-fen-de">Q： 什么是垂直分表？ 一般怎么分的？</a></li><li><a href="#q-shi-me-qing-kuang-xia-xu-yao-fen-biao-ti-sheng-shi-shi-me">Q: 什么情况下需要分表， 提升是什么？</a></li><li><a href="#q-wei-shi-me-da-zi-duan-de-xiao-lu-di-ni">Q ： 为什么大字段的效率低呢？</a></li></ul></li><li><a href="#shui-ping-fen-biao">水平分表</a><ul><li><a href="#q-chui-zhi-fen-biao-he-shui-ping-fen-biao-de-qu-bie">Q: 垂直分表和水平分表的区别？</a></li><li><a href="#q-shui-ping-fen-biao-de-hao-chu">Q: 水平分表的好处？</a></li></ul></li><li><a href="#chui-zhi-fen-ku">垂直分库</a><ul><li><a href="#q-yi-jing-zuo-liao-chui-zhi-fen-biao-liao-wei-shi-me-huan-yao-chui-zhi-fen-ku">Q: 已经做了垂直分表了，为什么还要垂直分库？</a></li><li><a href="#q-chui-zhi-fen-ku-de-hao-chu">Q: 垂直分库的好处</a></li></ul></li><li><a href="#shui-ping-fen-ku">水平分库</a><ul><li><a href="#q-ru-guo-shui-ping-fen-ku-hou-you-bu-gou-yong-liao-shu-ju-yao-zuo-qian-yi-ma-ji-zen-me-zuo-ping-hua-kuo-zhan">Q: 如果水平分库后，又不够用了，数据要做迁移吗？即怎么做平滑扩展</a></li><li><a href="#q-cong-ku-qian-yi-zhong-cong-ku-zhong-you-zhi-qian-bei-fen-de-shu-ju-zen-me-ban">Q: 从库迁移中， 从库中有之前备份的数据，怎么办？</a></li><li><a href="#q-yi-zhi-xing-ha-xi-you-liao-jie-ma-he-shui-ping-fen-ku-you-shi-me-guan-xi">Q: 一致性哈希有了解吗？ 和水平分库有什么关系？</a></li></ul></li><li><a href="#fen-ku-fen-biao-she-ji-wen-ti">分库分表设计问题</a><ul><li><a href="#q-fen-ku-fen-biao-hui-dai-lai-shi-me-fu-mian-ying-xiang">Q: 分库分表会带来什么负面影响？</a></li><li><a href="#q-na-ni-de-chan-pin-yao-yin-ru-fen-ku-fen-biao-de-hua-zen-me-shi-xian-zi-ji-xie-dai-ma-ma">Q: 那你的产品要引入分库分表的话， 怎么实现？ 自己写代码吗？</a></li><li><a href="#q-fen-ku-fen-biao-zhi-hou-quan-ju-qie-lian-xu-de-wei-yi-id-ru-he-sheng-cheng">Q: 分库分表之后，   全局且连续的唯一id如何生成？</a></li><li><a href="#q-fen-ku-fen-biao-zhi-hou-ke-neng-yi-ge-biao-bei-chai-cheng-duo-ge-biao-dan-shi-yuan-xian-mou-ge-ye-wu-cha-xun-sql-she-ji-liao-qi-zhong-de-duo-ge-tiao-jian-sou-suo-bian-de-fei-chang-man-ying-gai-zen-me-chu-li">Q: 分库分表之后， 可能一个表被拆成多个表， 但是原先某个业务查询sql涉及了其中的多个条件， 搜索变得非常慢，应该怎么处理？</a></li><li><a href="#q-chui-zhi-fen-biao-hou-ke-neng-hui-chan-sheng-rong-yu-biao-ji-fen-cheng-mai-jia-biao-he-mai-jia-biao-hou-ta-men-biao-li-du-xu-yao-ding-dan-xin-xi-yin-ci-ding-dan-xin-xi-xu-yao-tong-bu-2-ci-gei-2-ge-biao-zhe-ge-guo-cheng-ni-hui-ru-he-she-ji">Q: 垂直分表后， 可能会产生 冗余表，  即分成卖家表和买家表后，  他们表里都需要订单信息， 因此订单信息需要同步2次给2个表。  这个过程你会如何设计？</a></li><li><a href="#q-da-biao-zen-me-fen-ye-cha-xun">Q: 大表怎么分页查询？</a></li><li><a href="#q-fen-ku-fen-biao-hou-zen-me-zuo-fen-ye-cha-xun">Q: 分库分表后，怎么做分页查询？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="chui-zhi-fen-biao">垂直分表</span><a href="#chui-zhi-fen-biao" class="header-anchor">#</a></h1><h2><span id="q-shi-me-shi-chui-zhi-fen-biao-yi-ban-zen-me-fen-de">Q： 什么是垂直分表？ 一般怎么分的？</span><a href="#q-shi-me-shi-chui-zhi-fen-biao-yi-ban-zen-me-fen-de" class="header-anchor">#</a></h2><p>A:<br>将一个表按照字段分成多表，每个表存储其中一部分字段。<br>垂直分表原则：</p><ul><li>把不常用的字段单独放在一张表;</li><li>把text，blob等大字段拆分出来放在附表中;</li><li>经常组合查询的列放在一张表中;</li></ul><hr><h2><span id="q-shi-me-qing-kuang-xia-xu-yao-fen-biao-ti-sheng-shi-shi-me">Q: 什么情况下需要分表， 提升是什么？</span><a href="#q-shi-me-qing-kuang-xia-xu-yao-fen-biao-ti-sheng-shi-shi-me" class="header-anchor">#</a></h2><p>当有些字段内容比较大，且访问频次比较低时， 可能会导致表的大小非常大，但是用途很小。<br>例如 商品信息表里， 商品详情表可能字段更多文字也更多，倾向于将详情表单独拆一个出来。 这样业务层可以在真正需要用到详情表的时候，再根据商品id去查就行了。</p><p>提升：<br>1.为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响<br>2.充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。</p><hr><h2><span id="q-wei-shi-me-da-zi-duan-de-xiao-lu-di-ni">Q ： 为什么大字段的效率低呢？</span><a href="#q-wei-shi-me-da-zi-duan-de-xiao-lu-di-ni" class="header-anchor">#</a></h2><p>A：</p><ol><li>由于数据量本身大，读取整行记录需要更长的读取时间；</li><li>跨页，页是数据库存储单位，很多查找及定位操作都是以页为单位，单页内的数据行越多数据库整体性能越好。而大字段占用空间大，单页内存储行数少，因此IO效率较低。</li><li>数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</li></ol><h1><span id="shui-ping-fen-biao">水平分表</span><a href="#shui-ping-fen-biao" class="header-anchor">#</a></h1><p><strong>水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</strong><br>以商品表为例：<br>商品信息及商品描述被分成了两套表。</p><ul><li>如果商品ID为双数，将此操作映射至商品信息1表；</li><li>如果商品ID为单数，将操作映射至商品信息2表。此操作要访问表名称的表达式为商品信息[商品ID%2 + 1]</li></ul><hr><h2><span id="q-chui-zhi-fen-biao-he-shui-ping-fen-biao-de-qu-bie">Q: 垂直分表和水平分表的区别？</span><a href="#q-chui-zhi-fen-biao-he-shui-ping-fen-biao-de-qu-bie" class="header-anchor">#</a></h2><p>A:<br>垂直分表，是对字段列做划分。   而水平分表，是对数据行做划分。<br>其实可以把表成下面这种结构，就明白垂直和水平的区别了<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/6b23dd1e12e6caf0d30c041053c2394121985e64.png" alt="6b23dd1e12e6caf0d30c041053c2394121985e64"><br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/5068231bca3cd42e8adcada6089c94b6aff2e510.png" alt="5068231bca3cd42e8adcada6089c94b6aff2e510"></p><hr><h2><span id="q-shui-ping-fen-biao-de-hao-chu">Q: 水平分表的好处？</span><a href="#q-shui-ping-fen-biao-de-hao-chu" class="header-anchor">#</a></h2><p>A:</p><ul><li>优化单一表数据量过大而产生的性能问题</li><li>避免IO争抢并减少锁表的几率</li></ul><p>库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能。</p><hr><h1><span id="chui-zhi-fen-ku">垂直分库</span><a href="#chui-zhi-fen-ku" class="header-anchor">#</a></h1><p>和垂直分表类似， 只不过根据业务类型，将不同业务的表放到的不同的数据库<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/fdff28f7d2056a9764cd57d685fe3a5a2dced46f.png" alt="fdff28f7d2056a9764cd57d685fe3a5a2dced46f"></p><p><strong>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用</strong></p><hr><h2><span id="q-yi-jing-zuo-liao-chui-zhi-fen-biao-liao-wei-shi-me-huan-yao-chui-zhi-fen-ku">Q: 已经做了垂直分表了，为什么还要垂直分库？</span><a href="#q-yi-jing-zuo-liao-chui-zhi-fen-biao-liao-wei-shi-me-huan-yao-chui-zhi-fen-ku" class="header-anchor">#</a></h2><p>A:<br>通过垂直分表性能得到了一定程度的提升，但是还没有达到要求， 当两类表的数据量持续增加时，磁盘空间肯定会不够，毕竟数据还是始终限制在一台服务器（例如用户和商品持续增长）。</p><p>即库内垂直分表只解决了单一表数据量过大的问题，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。</p><hr><h2><span id="q-chui-zhi-fen-ku-de-hao-chu">Q: 垂直分库的好处</span><a href="#q-chui-zhi-fen-ku-de-hao-chu" class="header-anchor">#</a></h2><p>A:</p><ul><li>解决业务层面的耦合，业务清晰</li><li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li><li>高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</li><li>垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题。</li></ul><h1><span id="shui-ping-fen-ku">水平分库</span><a href="#shui-ping-fen-ku" class="header-anchor">#</a></h1><p>当业务上无法再进行垂直拆分时，但是库的容量不够时，就只能水平分库了。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/9c58b49fc2e06dcdee8de126e164e9729bac18ec.png" alt="9c58b49fc2e06dcdee8de126e164e9729bac18ec"><br><strong>水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上，但是不影响表结构</strong></p><hr><ul><li>例子：<br>操作某条数据，先分析这条数据所属的店铺ID。如果店铺ID为双数，将此操作映射至RRODUCT_DB1(商品库1)；如果店铺ID为单数，将操作映射至RRODUCT_DB2(商品库2)。此操作要访问数据库名称的表达式为RRODUCT_DB[店铺ID%2 + 1]</li></ul><hr><p>好处：</p><ul><li>解决了单库大数据，高并发的性能瓶颈。</li><li>提高了系统的稳定性及可用性。</li></ul><hr><h2><span id="q-ru-guo-shui-ping-fen-ku-hou-you-bu-gou-yong-liao-shu-ju-yao-zuo-qian-yi-ma-ji-zen-me-zuo-ping-hua-kuo-zhan">Q:  如果水平分库后，又不够用了，数据要做迁移吗？即怎么做平滑扩展</span><a href="#q-ru-guo-shui-ping-fen-ku-hou-you-bu-gou-yong-liao-shu-ju-yao-zuo-qian-yi-ma-ji-zen-me-zuo-ping-hua-kuo-zhan" class="header-anchor">#</a></h2><p>A:<br><a href="https://my.oschina.net/u/1859679/blog/1577049">水平分库如何做到平滑扩展</a></p><ol><li>停服迁移。<br>适用于特定时间段用户几乎无法登录或者操作的产品，或者有权限控制用户不允许使用的。</li><li>从库升级。<br>可以理解为原本作为容灾的从库， 直接升级为可以被哈希映射的主库， 加入到水平分库的哈希映射中。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/2a8096dba7c51d1d0346b0c6719af6c6b8f7592a.png" alt="2a8096dba7c51d1d0346b0c6719af6c6b8f7592a"></li><li>双写迁移<br>用于未设置从库，或者必须新增更多的库时（从库一次只能*2）。</li></ol><ol><li>设置新的分片库，要求库内为空。 同时记录一下当前时间或者当前记录号。</li><li>业务层增加逻辑，将相同哈希的数据多写一份到新库（注意此时新库只能被写，但是不能被读）</li><li>将老记录通过工具迁移到新库，尽量全部迁移</li><li>迁移完成后，校验，确保两边已经完全一致(其实类似于生成了一个从库）</li><li>开放新的分片规则。 去除冗余数据。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/efb650d32882f059b32735a5142c68c14f0a8231.png" alt="efb650d32882f059b32735a5142c68c14f0a8231"></li></ol><hr><h2><span id="q-cong-ku-qian-yi-zhong-cong-ku-zhong-you-zhi-qian-bei-fen-de-shu-ju-zen-me-ban">Q: 从库迁移中， 从库中有之前备份的数据，怎么办？</span><a href="#q-cong-ku-qian-yi-zhong-cong-ku-zhong-you-zhi-qian-bei-fen-de-shu-ju-zen-me-ban" class="header-anchor">#</a></h2><p>A:<br>备份数据不影响使用，只要哈希正确，冗余数据不会干扰。<br>但可以安排一个特定时间进行冗余数据清理， 且清理过程不会影响自己所映射的数据一致性。</p><hr><h2><span id="q-yi-zhi-xing-ha-xi-you-liao-jie-ma-he-shui-ping-fen-ku-you-shi-me-guan-xi">Q:  一致性哈希有了解吗？ 和水平分库有什么关系？</span><a href="#q-yi-zhi-xing-ha-xi-you-liao-jie-ma-he-shui-ping-fen-ku-you-shi-me-guan-xi" class="header-anchor">#</a></h2><p>A:<br>如果是简单哈希， 上面提到的扩容中，可能一次变动就要所有的库都涉及迁移。<br>但我可能只想增加一台呢？ 也要全部都变动吗？</p><p>为了尽可能少迁移，只迁移1-2个库，引入一致性哈希。 这样只要改动哈希空间中相邻的即可<br>具体原理这里有提到<a href="http://doc.minidown.cn/gmoqrq/">服务缓存设计</a></p><hr><h1><span id="fen-ku-fen-biao-she-ji-wen-ti">分库分表设计问题</span><a href="#fen-ku-fen-biao-she-ji-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-fen-ku-fen-biao-hui-dai-lai-shi-me-fu-mian-ying-xiang">Q: 分库分表会带来什么负面影响？</span><a href="#q-fen-ku-fen-biao-hui-dai-lai-shi-me-fu-mian-ying-xiang" class="header-anchor">#</a></h2><p>A:</p><ul><li>无法使用部分外键约束</li><li>多表join连接的sql查询，可能需要改造成多次单表查询（注意，分库分表场景下，尽量都用多次单表查询，可读性提高， 牺牲少数性能而已）</li><li>无法继续使用数据库自身提供的方法生成全局唯一id。</li></ul><hr><h2><span id="q-na-ni-de-chan-pin-yao-yin-ru-fen-ku-fen-biao-de-hua-zen-me-shi-xian-zi-ji-xie-dai-ma-ma">Q: 那你的产品要引入分库分表的话， 怎么实现？ 自己写代码吗？</span><a href="#q-na-ni-de-chan-pin-yao-yin-ru-fen-ku-fen-biao-de-hua-zen-me-shi-xian-zi-ji-xie-dai-ma-ma" class="header-anchor">#</a></h2><p>A:<br>不需要，有完善的分库分表中间件。<br>Shark、mycat、tddl。</p><p>以shark为例 ，  shark依赖于spring，  只需要通过依赖注入方式配置shark的各种属性、分库分表路由算法，即可使用<br>业务层调用dao的代码不需要任何变化。<br>基于AOP拦截jdbcTemplate中除了batch()方法以外的所有读/写方法<br>利用druid的sqlparse完成sql语句的解析工作。</p><hr><h2><span id="q-fen-ku-fen-biao-zhi-hou-quan-ju-qie-lian-xu-de-wei-yi-id-ru-he-sheng-cheng">Q:  分库分表之后，   全局且连续的唯一id如何生成？</span><a href="#q-fen-ku-fen-biao-zhi-hou-quan-ju-qie-lian-xu-de-wei-yi-id-ru-he-sheng-cheng" class="header-anchor">#</a></h2><p>A:<br>如果不考虑连续，  则生成时结合uuid、机器ip、时间戳等多个维度因素生成即可。<br>如果要考虑连续，有两种方式</p><ol><li>利用分表中间件的id生成器， 例如shark，可以配置一个单点id数据库，  需要id时， 应用里的shark会去这个id数据库申请一批id， 缓存在本地。<br>利用了行锁保证了并发环境下的数据一致性。</li><li>建立一个id生成服务，  需要的时候走这个单点服务去申请（单点服务自身有个mysql），代价比较大。</li></ol><hr><h2><span id="q-fen-ku-fen-biao-zhi-hou-ke-neng-yi-ge-biao-bei-chai-cheng-duo-ge-biao-dan-shi-yuan-xian-mou-ge-ye-wu-cha-xun-sql-she-ji-liao-qi-zhong-de-duo-ge-tiao-jian-sou-suo-bian-de-fei-chang-man-ying-gai-zen-me-chu-li">Q: 分库分表之后， 可能一个表被拆成多个表， 但是原先某个业务查询sql涉及了其中的多个条件， 搜索变得非常慢，应该怎么处理？</span><a href="#q-fen-ku-fen-biao-zhi-hou-ke-neng-yi-ge-biao-bei-chai-cheng-duo-ge-biao-dan-shi-yuan-xian-mou-ge-ye-wu-cha-xun-sql-she-ji-liao-qi-zhong-de-duo-ge-tiao-jian-sou-suo-bian-de-fei-chang-man-ying-gai-zen-me-chu-li" class="header-anchor">#</a></h2><p>A:<br>可以把数据导入到solr中， 让solr进行分词搜索。<br>另外如果有比较耗时的like查询，也可以导入给solr让solr做like模糊查询。</p><hr><h2><span id="q-chui-zhi-fen-biao-hou-ke-neng-hui-chan-sheng-rong-yu-biao-ji-fen-cheng-mai-jia-biao-he-mai-jia-biao-hou-ta-men-biao-li-du-xu-yao-ding-dan-xin-xi-yin-ci-ding-dan-xin-xi-xu-yao-tong-bu-2-ci-gei-2-ge-biao-zhe-ge-guo-cheng-ni-hui-ru-he-she-ji">Q:   垂直分表后， 可能会产生 冗余表，  即分成卖家表和买家表后，  他们表里都需要订单信息， 因此订单信息需要同步2次给2个表。  这个过程你会如何设计？</span><a href="#q-chui-zhi-fen-biao-hou-ke-neng-hui-chan-sheng-rong-yu-biao-ji-fen-cheng-mai-jia-biao-he-mai-jia-biao-hou-ta-men-biao-li-du-xu-yao-ding-dan-xin-xi-yin-ci-ding-dan-xin-xi-xu-yao-tong-bu-2-ci-gei-2-ge-biao-zhe-ge-guo-cheng-ni-hui-ru-he-she-ji" class="header-anchor">#</a></h2><p>A:</p><ol><li><p>自己在业务层实现双写逻辑。  订单服务写入买家表之前， 把卖家表的请求扔给异步消息队列， 这样就是一边异步一边同步，加快速度。<br>而卖家表如果插入成功了， 就再发一个响应消息给消息队列， 订单服务消费到这个响应后，才能确认写入成功，短时间内收不到则就进行数据补偿类似于重发。 （也叫线上检测补偿）</p></li><li><p>借助某些已经实现的中间件做mysql数据库的binlog增量同步。（阿里的canal）。<br>它会伪装salve节点，向master节点索要binlog， 然后解析binlog后，完成冗余表的数据增量同步，就不需要业务层写代码了，配置canal中间件即可。</p></li></ol><hr><h2><span id="q-da-biao-zen-me-fen-ye-cha-xun">Q: 大表怎么分页查询？</span><a href="#q-da-biao-zen-me-fen-ye-cha-xun" class="header-anchor">#</a></h2><p>A:<br>给时间加索引，然后利用offset+limit即可<br>select * from t_msg order by time offset 200 limit 100</p><hr><h2><span id="q-fen-ku-fen-biao-hou-zen-me-zuo-fen-ye-cha-xun">Q: 分库分表后，怎么做分页查询？</span><a href="#q-fen-ku-fen-biao-hou-zen-me-zuo-fen-ye-cha-xun" class="header-anchor">#</a></h2><p>以offset 900 limit 60，  3个库为例<br>A:<br>4种方法。</p><ol><li><p>全局视野法<br>用于数据量不大的情况<br>每次直接取limit 960， 然后在服务端进行排序后手动算出offset 900的位置。</p></li><li><p>禁止跳页。<br>只提供下一页。这也可以用全局视野拿到第一页后， 记录此时选到的时间。<br>下一页的时候， 用3个库里记录的那个时间做排序再去取第二页即可。</p></li><li><p>模糊查询<br>当数据获取要求的精确度不高，且数据确定是均匀分布的<br>则直接按offset 300 limit 20去取3份合成一页即可。</p></li><li><p>二次查询法<br>比较复杂。</p></li></ol><ul><li>① 先分别offset 300 limit 60， 得到3份数据。</li><li>② 得到3份数据中的最小时间tmin， 这个时间的前面300份是可以被“肯定的”</li><li>③ 记录另外2个库（就是没取到最小时间的那2个）的时间最大值tmax1, tmax2</li><li>④ 按  time&gt;tmin and time &lt; tmax1   和   time&gt;tmin and time&lt;tmax2  的where索引查询再取2份数据。</li><li>⑤ 这也就能知道tmin 在3个库里的相对位置是多少了，  例如在库1里排300名，在库2里排250名， 在库3里排270名。</li><li>⑥ timin排820名，而刚才取的数据合并起来后，再取个80条，就能找到limit 900的位置了。<br>也有缺点， 就是极端情况下还是不太好用，例如库2和库3的分布机器不均匀。<br><a href="https://www.w3cschool.cn/architectroad/architectroad-cross-database-paging.html">业界难题-“跨库分页”的四种方案</a></li></ul><hr><p><a href="https://blog.csdn.net/weixin_44062339/article/details/100491744">彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三种日志原理详解</title>
      <link href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shu-ju-ku-ri-zhi-fen-lei">数据库日志分类</a><ul><li><a href="#q-shu-ju-ku-you-na-san-chong-log">Q: 数据库有哪三种log？</a></li><li><a href="#q-binlog-he-relog-du-you-na-xie-qu-bie-ni">Q: binlog和relog都有哪些区别呢？</a></li></ul></li><li><a href="#relog">relog</a><ul><li><a href="#q-relog-shua-ri-zhi-dao-ci-pan-you-na-ji-chong-fang-shi">Q: relog刷日志到磁盘有哪几种方式？</a></li><li><a href="#q-relog-ri-zhi-kuai-de-ge-shi-shi-zen-me-yang-de">Q: relog日志块的格式是怎么样的？</a></li></ul></li><li><a href="#binlog">binlog</a><ul><li><a href="#q-binlog-de-ge-shi-you-shi-zen-me-yang-de">Q: binlog的格式又是怎么样的？</a></li></ul></li><li><a href="#undolog">undolog</a><ul><li><a href="#q-undolog-de-ri-zhi-ge-shi">Q: undolog的日志格式？</a></li><li><a href="#q-checkpoint-shi-zuo-shi-me-de">Q: checkpoint是做什么的？</a></li><li><a href="#q-lsn-cheng-wei-ri-zhi-de-luo-ji-xu-lie-hao-ju-ti-shi-zen-me-sheng-xiao-de">Q: LSN称为日志的逻辑序列号, 具体是怎么生效的？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="shu-ju-ku-ri-zhi-fen-lei">数据库日志分类</span><a href="#shu-ju-ku-ri-zhi-fen-lei" class="header-anchor">#</a></h1><h2><span id="q-shu-ju-ku-you-na-san-chong-log">Q: 数据库有哪三种log？</span><a href="#q-shu-ju-ku-you-na-san-chong-log" class="header-anchor">#</a></h2><p>A:</p><ul><li><p>redo log<br>和大多数关系型数据库一样，InnoDB记录了对数据文件的物理更改，并保证总是<strong>日志先行</strong>，也就是所谓的WAL<br>即在持久化数据文件前，保证之前的redo日志已经写到磁盘。<br>mysql重新启动时会检查redo log的日志，把由于mysql异常退出导致没有刷新到磁盘的数据页从redo log中恢复。<br>innodb_log_group_home_dir表示redo log的目录；innodb_log_file_size表示redo log文件的大小；innodb_log_files_in_group表示redo log文件个数。<br>redo log文件以ib_logfile[number]命名。</p></li><li><p>undo log<br>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方就是undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用undo Log中的备份将数据恢复到事务开始之前的状态。<br><a href="https://www.cnblogs.com/f-ck-need-u/p/9010872.html">详细分析MySQL事务日志(redo log和undo log)</a></p></li><li><p>bin log(二进制日志）<br>记录sql语句，可用于主从复制。<br>二进制日志只在事务提交的时候一次性写入(基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入<br>[查询日志、二进制日志详解](<a href="https://www.cnblogs.com/f-ck-need-u/p/9001061.html">https://www.cnblogs.com/f-ck-need-u/p/9001061.html</a></p></li></ul><hr><h2><span id="q-binlog-he-relog-du-you-na-xie-qu-bie-ni">Q: binlog和relog都有哪些区别呢？</span><a href="#q-binlog-he-relog-du-you-na-xie-qu-bie-ni" class="header-anchor">#</a></h2><p>A:</p><ol><li>层次不同。<br>bin二进制日志是在存储引擎的上层产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改</li><li>记录的东西不同。<br>二进制日志记录操作的方法是逻辑性的语句。本质也还是逻辑的SQL设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中具体到每个页的修改。</li><li>写日志的时机不同。<br>二进制日志只在每次事务提交的时候一次性写入缓存中的日志&quot;文件&quot;(对于非事务表的操作，则是每次执行语句成功后就直接写入)。<br>而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作</li><li>一次事务生成的日志记录数不同。<br>二进制日志一次提交对应一次记录。<br>而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。</li></ol><blockquote><p>例如事务T1，可能在redo log中记录了 T1-1,T1-2,T1-3，T1* 共4个操作，其中 T1* 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1* 对应的操作结果</p></blockquote><ol start="5"><li>幂等性不同<br>二进制日志不具有幂等性。重复执行多次会造成数据错误。<br>redolog具有幂等性， 因为始终是对页做覆盖，不会出错</li></ol><hr><h1><span id="relog">relog</span><a href="#relog" class="header-anchor">#</a></h1><p>relog刷磁盘时，存在应用层logBuffer、 操作系统层面的buffer、日志文件。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/408b231580c2619c1e253d461789312de00d6bd5.png" alt="408b231580c2619c1e253d461789312de00d6bd5"></p><h2><span id="q-relog-shua-ri-zhi-dao-ci-pan-you-na-ji-chong-fang-shi">Q: relog刷日志到磁盘有哪几种方式？</span><a href="#q-relog-shua-ri-zhi-dao-ci-pan-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h2><p>A:<br>MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1</p><ul><li>当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。。</li><li>当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</li><li>当设置为2的时候，每次提交都写入到os buffer，并且是每秒调用fsync()将os buffer中的日志写入到log file on disk。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/47fae1c3b36b7192457b99d4a8ea432bf05b7117.png" alt="47fae1c3b36b7192457b99d4a8ea432bf05b7117"></li></ul><hr><h2><span id="q-relog-ri-zhi-kuai-de-ge-shi-shi-zen-me-yang-de">Q: relog日志块的格式是怎么样的？</span><a href="#q-relog-ri-zhi-kuai-de-ge-shi-shi-zen-me-yang-de" class="header-anchor">#</a></h2><p>A:</p><ul><li>redo log以块为单位进行存储的，每个块占512字节，这称为redo log block。（不管是log buffer中还是os buffer中以及redo log file on disk中，都是这样以512字节的块存储的）</li><li>组成部分：</li></ul><ol><li>日志块头（包含buffer中的位置id、已记录log大小、涉及分拆日志块时的偏移位置、检查点信息）</li><li>日志块尾</li><li>日志主体<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/c1feeeef68511ecef418c32a6113910de4bbb137.png" alt="c1feeeef68511ecef418c32a6113910de4bbb137"></li></ol><blockquote><blockquote><p>有时候一个数据页产生的日志量超出了一个日志块，这是需要用多个日志块来记录该页的相关日志。例如，某一数据页产生了552字节的日志量，那么需要占用两个日志块，第一个日志块占用492字节，第二个日志块需要占用60个字节，那么对于第二个日志块来说，它的第一个log的开始位置就是73字节(60+12)</p></blockquote></blockquote><hr><h1><span id="binlog">binlog</span><a href="#binlog" class="header-anchor">#</a></h1><h2><span id="q-binlog-de-ge-shi-you-shi-zen-me-yang-de">Q: binlog的格式又是怎么样的？</span><a href="#q-binlog-de-ge-shi-you-shi-zen-me-yang-de" class="header-anchor">#</a></h2><p>A:<br>mysql binlog日志有三种格式，分别为Statement,MiXED,以及ROW！<br>可以用命令查看自己的mysql用的是什么模式。</p><ul><li><p>statement  只记录更新的sql语句<br>缺点：<br>像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题</p></li><li><p>Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改，仅需要记录那一条记录被修改成什么了。<br>一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大</p></li><li><p>Mixedlevel：以上两种level的混合使用。MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种</p></li></ul><p>Mysql默认是使用Statement日志格式，推荐使用MIXED.</p><hr><h1><span id="undolog">undolog</span><a href="#undolog" class="header-anchor">#</a></h1><h2><span id="q-undolog-de-ri-zhi-ge-shi">Q: undolog的日志格式？</span><a href="#q-undolog-de-ri-zhi-ge-shi" class="header-anchor">#</a></h2><p>A:<br>对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型<br>一种是 INSERT_UNDO（INSERT操作），记录插入的唯一键值；<br>一种是 UPDATE_UNDO（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。<br>因此update/delete操作的undolog数据会比insert操作的数据多<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/c1a931eb22c5bddff24bac883b757d7f04b76e12.png" alt="c1a931eb22c5bddff24bac883b757d7f04b76e12"></p><hr><h2><span id="q-checkpoint-shi-zuo-shi-me-de">Q:  checkpoint是做什么的？</span><a href="#q-checkpoint-shi-zuo-shi-me-de" class="header-anchor">#</a></h2><p>A:<br>“检查点”会创建一个已知的正常点，在意外关闭或崩溃后进行恢复的过程中， SQL Server 数据库引擎 可以从该点开始应用日志中所包含的更改。<br><a href="https://blog.csdn.net/xiaobluesky/article/details/50285775">检查点（Checkpoint）的本质</a></p><hr><h2><span id="q-lsn-cheng-wei-ri-zhi-de-luo-ji-xu-lie-hao-ju-ti-shi-zen-me-sheng-xiao-de">Q: LSN称为日志的逻辑序列号, 具体是怎么生效的？</span><a href="#q-lsn-cheng-wei-ri-zhi-de-luo-ji-xu-lie-hao-ju-ti-shi-zen-me-sheng-xiao-de" class="header-anchor">#</a></h2><p>A:</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0822</title>
      <link href="/2022/08/22/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-22/"/>
      <url>/2022/08/22/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-22/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#di-yi-ti-zhan-de-ying-yong">第一题:栈的应用</a></li><li><a href="#di-er-ti-bfs">第二题:bfs</a></li><li><a href="#di-san-ti-ha-xi-biao-yi-ji-shu-ju-fan-wei-que-ren-xi-guan">第三题:哈希表以及数据范围确认习惯</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="di-yi-ti-zhan-de-ying-yong">第一题:栈的应用</span><a href="#di-yi-ti-zhan-de-ying-yong" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks-lcci/submissions/">面试题 03.04. 化栈为队 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-22/1661184354147.png" alt="1661184354147"></p><p>要出队或者要用到队头的时候，移动到另一个栈里，就能反向取了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty()) &#123;</span><br><span class="line">            q2.push(q1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> q2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty()) &#123;</span><br><span class="line">            q2.push(q1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() &amp;&amp; q2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1><span id="di-er-ti-bfs">第二题:bfs</span><a href="#di-er-ti-bfs" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-22/1661184446769.png" alt="1661184446769"></p><p>一个简单题，我用bfs写了半天，确实累，是不是应该搞点bfs的模板了？下次比赛直接用上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] floodFill(<span class="type">int</span>[][] image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color) &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ylen</span> <span class="operator">=</span> image.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xlen</span> <span class="operator">=</span> image[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[ylen][xlen];</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;sr,sc&#125;);</span><br><span class="line">        vis[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startColor</span> <span class="operator">=</span> image[sr][sc];</span><br><span class="line">        image[sr][sc] = color;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] p = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> dir[<span class="number">0</span>] + y;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> dir[<span class="number">1</span>] + x;</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= xlen || ny &gt;= ylen || vis[ny][nx]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (startColor != image[ny][nx]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[ny][nx]= <span class="literal">true</span>;</span><br><span class="line">                image[ny][nx] = color;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ny, nx&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-san-ti-ha-xi-biao-yi-ji-shu-ju-fan-wei-que-ren-xi-guan">第三题:哈希表以及数据范围确认习惯</span><a href="#di-san-ti-ha-xi-biao-yi-ji-shu-ju-fan-wei-que-ren-xi-guan" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-22/1661184586227.png" alt="1661184586227"></p><p>看起来很简单，直接一个数组搞定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnique</span><span class="params">(String astr)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: astr.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[c-<span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[c-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这题究竟想考察什么呢？ 看一下下面这段话：</p><blockquote><p>如果我是面试官，会考虑主要考察什么，就我的工作经验看，大多数主要是招聘工程师的，面试者如果什么问题都没有，直接写个二重循环搞定，会首先给个50分，如果能写点判断字符串是否为null的，60分。</p><p>直接上手什么bitset，什么位运算的，我会先问他，题目中有没有交代字符串的字符一定是26个英文字母？如果是unicode环境，你是不是要准备2^16/8个字节的空间？在实际项目中，风险可控，结果可期更重要，绝大多数时候不在乎那点时间和资源。</p><p>所以我期望面试者不要急于解答，我希望他先问我问题：</p><ol><li>字符串的字符范围，如果我告诉他，26个小写英文字母，那可能一开头直接判断如果字符长度&gt;26, 直接返回False，做到这一点的，80分</li><li>如果我告诉他ascii字符集，然后他的代码里有边界检查，并且针对不同的范围有不同的侧重点，比如说ascii字符集，那也就是128个可能性，16个字节的位运算比较好</li><li>如果我告诉他是unicode，没有字符范围，老老实实排序再判断是比较符合我对工程师的要求的，因为算法性能稳定，没有额外资源要求，一眼看出没什么不可预见的风险，100分。</li></ol><p>就是说，有些东西，没想到或者一时没想到根本不是问题，日常工作中稍微提示一下即可，但是缜密的思维对于程序员来说更重要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数（排列组合）</title>
      <link href="/2022/08/22/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/2022/08/22/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#c-k-n-de-o-min-k-n-k-jie-fa">C（k,n)的O(Min(k,n-k)）解法：</a></li><li><a href="#yang-hui-san-jiao-da-biao-fa">杨辉三角打表法：</a><ul><li><a href="#ru-guo-yong-o-n-de-fu-za-du-o-1-de-kong-jian-qiu-jie-c-n-m">如果用O(N)的复杂度，O（1）的空间求解C(n,m)?</a></li></ul></li><li><a href="#chao-da-zu-he-shu-she-ji-qu-yu">超大组合数（涉及取余）</a></li><li><a href="#xiang-guan-ti-mu">相关题目</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="c-k-n-de-o-min-k-n-k-jie-fa">C（k,n)的O(Min(k,n-k)）解法：</span><a href="#c-k-n-de-o-min-k-n-k-jie-fa" class="header-anchor">#</a></h1><p>快速回想组合数解法：<br>C(8,3) = 8 * 7 * 6 /(321) = 6 / 1 * 7 / 2 * 8 / 3<br>即分子和分母的个数是一样的<br>然后你要从小的开始逐步做乘和除的操作，就能求出来了，且一定能保证整除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// y/x * (y+1)/(x+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> k+<span class="number">1</span>, x= <span class="number">1</span>;y&lt;=n &amp;&amp; x&lt;=k;y++,x++) &#123;</span><br><span class="line">        <span class="comment">// (result*y)一定能被x整除</span></span><br><span class="line">        result = (result * y) / x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="yang-hui-san-jiao-da-biao-fa">杨辉三角打表法：</span><a href="#yang-hui-san-jiao-da-biao-fa" class="header-anchor">#</a></h1><p>如果空间没要求， 但是要求每次快速获取，则可以用杨辉三角提前打表<br><img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/5f59a1dcf0b46aa3f87ac7f2be142b73b028938a.png" alt="5f59a1dcf0b46aa3f87ac7f2be142b73b028938a"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">c[i][j]=(c[i-<span class="number">1</span>][j]+c[i-<span class="number">1</span>][j-<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>``</p><h2><span id="ru-guo-yong-o-n-de-fu-za-du-o-1-de-kong-jian-qiu-jie-c-n-m">如果用O(N)的复杂度，O（1）的空间求解C(n,m)?</span><a href="#ru-guo-yong-o-n-de-fu-za-du-o-1-de-kong-jian-qiu-jie-c-n-m" class="header-anchor">#</a></h2><p>杨辉三角里，某行某列的值等同于C(n,m)<br><img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/bfd6af87785723cdb1ec6016b0af14e01ccc863a.png" alt="bfd6af87785723cdb1ec6016b0af14e01ccc863a"><br><img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/8fb6b5d2b9e4533c76fab309ba111ce6762fab7b.png" alt="8fb6b5d2b9e4533c76fab309ba111ce6762fab7b"></p><p>因此可以很短的复杂度得到值<br>也可以缓存<br><img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/38d0ada716a6c8ab7289296c68d19f3c264c86db.png" alt="38d0ada716a6c8ab7289296c68d19f3c264c86db"></p><h1><span id="chao-da-zu-he-shu-she-ji-qu-yu">超大组合数（涉及取余）</span><a href="#chao-da-zu-he-shu-she-ji-qu-yu" class="header-anchor">#</a></h1><p>超纲题</p><ul><li>乘法逆元+快速幂+阶乘</li><li>Lucas定理</li></ul><p><a href="https://blog.csdn.net/qq_45404210/article/details/96422543">总结组合数的几种求法（模板）</a></p><hr><h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1><p><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径 需要空间为1时，必须用组合数</a><br><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II O(1)空间求某行某列，用组合数性质</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 算法大全 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引详解</title>
      <link href="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#suo-yin-de-ji-ben-gai-nian">索引的基本概念</a><ul><li><a href="#suo-yin-de-you-dian">索引的优点</a></li><li><a href="#suo-yin-lei-xing">索引类型</a><ul><li><a href="#ha-xi-suo-yin">哈希索引</a><ul><li><a href="#zi-ding-yi-ha-xi-suo-yin">自定义哈希索引</a></li></ul></li><li><a href="#kong-jian-shu-ju-suo-yin-r-tree">空间数据索引（R-Tree)</a></li><li><a href="#quan-wen-suo-yin">全文索引</a></li></ul></li><li><a href="#san-xing-suo-yin-de-ping-jie">三星索引的评价</a></li></ul></li><li><a href="#suo-yin-yuan-li">索引原理</a><ul><li><a href="#b-tree-shi-xian">B+ tree实现</a></li><li><a href="#q-wei-shi-me-bu-xuan-ze-shi-yong-b-shu-er-shi-shi-yong-b-shu">Q: 为什么不选择使用B树， 而是使用B+树？</a></li><li><a href="#q-na-wei-shi-me-bu-xuan-yong-hong-hei-shu">Q: 那为什么不选用红黑树？</a></li><li><a href="#q-na-wei-shi-me-bu-yong-ha-xi-biao">Q: 那为什么不用哈希表？</a></li></ul></li><li><a href="#gao-xing-neng-de-suo-yin-ce-lue">高性能的索引策略</a><ul><li><a href="#du-li-de-lie-de-wen-ti">独立的列的问题</a></li><li><a href="#qian-zhui-suo-yin-you-hua">前缀索引优化</a><ul><li><a href="#qian-zhui-suo-yin-de-chuang-jian">前缀索引的创建</a></li><li><a href="#que-ding-qian-zhui-chang-du">确定前缀长度</a></li><li><a href="#ru-he-zuo-hou-zhui-suo-yin">如何做后缀索引？</a></li></ul></li><li><a href="#duo-lie-suo-yin">多列索引</a></li><li><a href="#ru-he-que-ding-suo-yin-lie-shun-xu">如何确定索引列顺序</a></li></ul></li><li><a href="#ju-cu-suo-yin">聚簇索引</a><ul><li><a href="#ju-cu-he-fei-ju-cu-de-qu-bie">聚簇和非聚簇的区别</a></li><li><a href="#ju-cu-de-you-dian">聚簇的优点</a></li><li><a href="#ju-cu-de-que-dian">聚簇的缺点</a></li><li><a href="#ju-cu-he-fei-ju-cu-de-dui-bi">聚簇和非聚簇的对比</a></li><li><a href="#q-shi-me-shi-hui-biao">Q: 什么是回表？</a></li><li><a href="#q-na-me-dang-fa-sheng-hui-biao-shi-zen-me-bi-mian-ni">Q: 那么当发生回表时，怎么避免呢？</a></li><li><a href="#q-fei-zhu-jian-suo-yin-a-zuo-where-a-3-shi-neng-chong-fen-li-yong-suo-yin-zuo-jian-dan-de-fan-wei-du-qu-me">Q: 非主键索引a， 做where a&gt;3时， 能充分利用索引做简单的范围读取么？</a></li><li><a href="#er-ji-suo-yin-he-zhu-jian">二级索引和主键</a></li><li><a href="#q-zhu-jian-suo-yin-he-wei-yi-suo-yin-you-shi-me-qu-bie-ni">Q: 主键索引和唯一索引有什么区别呢？</a></li><li><a href="#q-que-ding-bu-neng-you-duo-ge-zhu-jian-suo-yin-ma-na-fan-shi-li-ti-dao-de-duo-ge-zhu-jian-shi-zen-me-hui-shi-ni">Q: 确定不能有多个主键索引吗？那泛式里提到的多个主键是怎么回事呢？</a></li></ul></li><li><a href="#suo-yin-de-cha-ru">索引的插入</a><ul><li><a href="#suo-yin-cha-ru-de-gui-fan">索引插入的规范</a></li><li><a href="#q-wei-shi-me-zi-zeng-id-ke-neng-hui-chu-xian-bu-lian-xu-de-qing-kuang">Q: 为什么自增id可能会出现不连续的情况？</a></li><li><a href="#q-wei-shi-me-zi-zeng-id-bu-neng-hui-gun-ni">Q: 为什么自增id不能回滚呢？</a></li></ul></li><li><a href="#qi-ta-suo-yin">其他索引</a><ul><li><a href="#fu-gai-suo-yin">覆盖索引</a></li><li><a href="#yong-suo-yin-zuo-pai-xu">用索引做排序</a></li><li><a href="#ya-suo-qian-zhui-suo-yin">压缩（前缀索引）</a></li><li><a href="#chong-fu-suo-yin">重复索引</a></li><li><a href="#rong-yu-suo-yin">冗余索引</a></li><li><a href="#wei-shi-yong-de-suo-yin">未使用的索引</a></li><li><a href="#suo-yin-he-suo">索引和锁</a></li></ul></li><li><a href="#suo-yin-ying-yong">索引应用</a><ul><li><a href="#duo-chong-guo-lu-tiao-jian-you-hua">多种过滤条件优化</a></li><li><a href="#bi-mian-duo-ge-fan-wei-tiao-jian">避免多个范围条件</a></li><li><a href="#q-xie-ru-biao-de-shi-hou-wei-shi-me-yi-ban-jian-yi-zi-zeng-de-zhu-jian-id-lai-xie-ru">Q: 写入表的时候， 为什么一般建议自增的主键id来写入？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="suo-yin-de-ji-ben-gai-nian">索引的基本概念</span><a href="#suo-yin-de-ji-ben-gai-nian" class="header-anchor">#</a></h1><h2><span id="suo-yin-de-you-dian">索引的优点</span><a href="#suo-yin-de-you-dian" class="header-anchor">#</a></h2><ol><li>大大减少服务器需要扫描的数据量（本来O(n)的扫描，在B-Tree或者哈希索引的帮助下， 变成O(logn)或者O(1)）</li><li>避免了不必要的排序或者临时表（order by和排序需要先弄一个临时存储的表）</li><li>把随机IO改成为了顺序IO，IO速度加快</li></ol><h2><span id="suo-yin-lei-xing">索引类型</span><a href="#suo-yin-lei-xing" class="header-anchor">#</a></h2><hr><ul><li>支持的类型</li></ul><ol><li>全值匹配——key中所有索引列全部匹配中，单个的</li><li>匹配最左索引——匹配key中的第一个索引值</li><li>匹配列前缀——可以只匹配某个索引的前缀（适用于字符串的情况）</li><li>可以匹配最左索引+列前缀——可以只匹配  索引1、索引2加上索引3的前缀。</li></ol><ul><li>注意上面的匹配，都是从左往右的匹配， 因此不支持只匹配中间那个索引的情况。</li><li>如果有一列索引用了范围， 那么后面的列都不能再用来匹配了。</li><li>B-Tree也可用于排序或者group by key，会加快速度，毕竟默认都是排好序的了。</li></ul><h3><span id="ha-xi-suo-yin">哈希索引</span><a href="#ha-xi-suo-yin" class="header-anchor">#</a></h3><ul><li>指的是把 索引列计算出一个哈希值， 存到一个哈希表中， key是哈希值，val是行指针。</li><li>只有Memory引擎支持（key using hash(索引值） ）， inndb不支持。</li><li>因为不是按照顺序存的， 所以不可用于优化排序， 只能优化查询。</li><li>不支持部分索引匹配， 因为哈希值是根据全索引计算的。</li><li>也不支持范围。</li><li>如果有哈希冲突，且很多，就可能造成性能变慢，</li></ul><h4><span id="zi-ding-yi-ha-xi-suo-yin">自定义哈希索引</span><a href="#zi-ding-yi-ha-xi-suo-yin" class="header-anchor">#</a></h4><ul><li>可以利用B-tree弄一个自定义的哈希索引</li><li>例如想哈希的列是url， 于是我弄了一个hash_url的列,  里面的值是url经过CRC32(url）后的值， 然后把hash_url这一列作为索引。</li><li>然后select语句的时候，  where url = ‘xx’ and hash_url=CRC32(‘xx’)  ，即可 快速定位。</li><li>hash_url的值可以通过insert触发器，每次插入url的时候进行更新</li><li>查询时必须带上哈希前原本的值（就是上面的url = ‘xxx’)，否则可能会因为哈希冲突返回多行。</li><li>不可用SHA1和MDK做哈希函数。</li></ul><h3><span id="kong-jian-shu-ju-suo-yin-r-tree">空间数据索引（R-Tree)</span><a href="#kong-jian-shu-ju-suo-yin-r-tree" class="header-anchor">#</a></h3><ul><li>只有MyISAM才支持</li><li>从所有维度来索引数据，用于地理信息存储之类的</li></ul><h3><span id="quan-wen-suo-yin">全文索引</span><a href="#quan-wen-suo-yin" class="header-anchor">#</a></h3><ul><li>查找文本中的关键词</li><li>可以同时创建全文索引和基于值的B-Tree索引</li></ul><h2><span id="san-xing-suo-yin-de-ping-jie">三星索引的评价</span><a href="#san-xing-suo-yin-de-ping-jie" class="header-anchor">#</a></h2><ul><li>一星：需要拿的记录都放到同一行（即不用再关联其他表）</li><li>二星：索引数据顺序和查找顺序一致</li><li>三星: 索引的列包含了查询中需要的全部的列（即不用去返回行中所有顺序，直接返回key就好了）</li></ul><h1><span id="suo-yin-yuan-li">索引原理</span><a href="#suo-yin-yuan-li" class="header-anchor">#</a></h1><h2><span id="b-tree-shi-xian">B+ tree实现</span><a href="#b-tree-shi-xian" class="header-anchor">#</a></h2><ul><li>如果没有指明类型，基本上都是用的B+ tree索引</li><li>B+ tree结构</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/6969d29b8468739b7480fa2315ed0478c0ad46d3.png" alt="6969d29b8468739b7480fa2315ed0478c0ad46d3"><br>里面的key就是 你选定的索引值<br>然后按照范围，指向后面其他的范围，直到定位到具体的叶子节点即行所对应的值。<br>同时因为最后叶子都是按照顺序连起来的，所以也很适合按照范围返回数据。</p><ul><li>B+tree里的key可以包含多个列的值， 并且这些列匹配时有顺序关系，按照定义key时的优先级来排序。（就是说可以多个key组成一个节点，里面自定义了对应的判定顺序）<br><img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/0856365975e56e39b87ec59c6e52c6c2260027e1.png" alt="0856365975e56e39b87ec59c6e52c6c2260027e1"></li></ul><hr><h2><span id="q-wei-shi-me-bu-xuan-ze-shi-yong-b-shu-er-shi-shi-yong-b-shu">Q: 为什么不选择使用B树， 而是使用B+树？</span><a href="#q-wei-shi-me-bu-xuan-ze-shi-yong-b-shu-er-shi-shi-yong-b-shu" class="header-anchor">#</a></h2><p>A:<br>数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题<br>正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历<br>在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作，或者说效率太低。</p><p>另外B树的索引节点上也存了数据，导致搜索过程种读了很多不必要的数据，加大了磁盘IO时间</p><hr><h2><span id="q-na-wei-shi-me-bu-xuan-yong-hong-hei-shu">Q: 那为什么不选用红黑树？</span><a href="#q-na-wei-shi-me-bu-xuan-yong-hong-hei-shu" class="header-anchor">#</a></h2><p>A:<br>红黑树往往出现由于树的深度过大。<br>磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写</p><hr><h2><span id="q-na-wei-shi-me-bu-yong-ha-xi-biao">Q: 那为什么不用哈希表？</span><a href="#q-na-wei-shi-me-bu-yong-ha-xi-biao" class="header-anchor">#</a></h2><p>A:<br>哈希表没法做范围查询以及前缀索引匹配查询。</p><hr><h1><span id="gao-xing-neng-de-suo-yin-ce-lue">高性能的索引策略</span><a href="#gao-xing-neng-de-suo-yin-ce-lue" class="header-anchor">#</a></h1><h2><span id="du-li-de-lie-de-wen-ti">独立的列的问题</span><a href="#du-li-de-lie-de-wen-ti" class="header-anchor">#</a></h2><ul><li>索引列不可以作为表达式的一部分， 必须是独立的<br>例如 where id+1=5 或者 where Func(id) &lt; 5 都是错误的<br>应该改成<br>where id = 5-1 或者  where id &lt; uFunc(5)</li></ul><h2><span id="qian-zhui-suo-yin-you-hua">前缀索引优化</span><a href="#qian-zhui-suo-yin-you-hua" class="header-anchor">#</a></h2><ul><li>索引列如果是text之类特别长的，必须使用前缀索引， 不可以用完整长度去做索引，mysql不支持。</li></ul><h4><span id="qian-zhui-suo-yin-de-chuang-jian">前缀索引的创建</span><a href="#qian-zhui-suo-yin-de-chuang-jian" class="header-anchor">#</a></h4><p>… KEY(city(7)),   那么你按照city去where时，就会用city的前缀去索引了。</p><h4><span id="que-ding-qian-zhui-chang-du">确定前缀长度</span><a href="#que-ding-qian-zhui-chang-du" class="header-anchor">#</a></h4><ul><li>前缀索引的选择性 =   不重复的个数/记录总数</li><li>如何确定较优的前缀长度？</li></ul><p>全列选择性：</p><p>SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;</p><p>某一长度前缀的选择性：</p><p>SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;</p><p>当你不断调整prefix_length，让前缀的选择性越接近全列选择性的时候，索引效果越好。如果发现继续增加prefi_length，变动幅度不大了，则选取那个值</p><ul><li>也要注意前缀最大值， 例如该长度n下，平均选择性不高，但是有1-2个前缀数量特别大，也不行。</li></ul><h4><span id="ru-he-zuo-hou-zhui-suo-yin">如何做后缀索引？</span><a href="#ru-he-zuo-hou-zhui-suo-yin" class="header-anchor">#</a></h4><p>存储的时候把字符串 <em><strong>翻转</strong></em> 存进表里，然后再做前缀索引</p><h2><span id="duo-lie-suo-yin">多列索引</span><a href="#duo-lie-suo-yin" class="header-anchor">#</a></h2><ul><li>多列索引指的是 多个独立的索引。就是给表定义了Key(a), key(b) ， 而不是Key(a,b)</li><li>如果在多列索引的情况下，要where a=1 or b= 2， 且要性能好， 需要改成  union(a,b) 即查询union的形式。 mysql5.0之后都会优化成union， 简称 <em><strong>索引合并</strong></em></li><li>上述默认优化的缺点:  联合操作会耗费大量的CPU和内存。 可是统计时间时又不会统计进来，导致低估时间成本。</li><li>可以通过explanin sql语句， 查看extra中是否有using union(a,b)来判断是否有索引合并的情况</li></ul><h2><span id="ru-he-que-ding-suo-yin-lie-shun-xu">如何确定索引列顺序</span><a href="#ru-he-que-ding-suo-yin-lie-shun-xu" class="header-anchor">#</a></h2><ul><li>这里指的是如何确定key(a,b,c)里abc的顺序</li><li>通用法则：把选择性最高的那个列放前面</li><li>选择性计算：  distinct(列)/count(*)  越大，选择性越好。</li><li>因为这样的话，可以减少在叶子节点上的遍历。</li><li>特殊情况：  某场景下突然表里的username都变成了一样的用户名， 然后对username索引做查询时， 就很慢， 因为相当于在叶子节点上遍历去查了，O(n)的复杂度。</li><li>对于特殊场景，要尽量在数据输入避免， 或者查询避免（例如避免在那个时间段去查询那个统一的username）</li></ul><hr><h1><span id="ju-cu-suo-yin">聚簇索引</span><a href="#ju-cu-suo-yin" class="header-anchor">#</a></h1><ul><li>聚簇索引是一种存储结构，而不是索引类型。</li><li>InnoDb默认使用主键列做聚簇索引</li><li>如果没有主键，则用第一个非空not NULL unique的索引作为聚簇索引</li><li>如果没主键没索引，则会创建一个隐藏的行id作为聚簇索引（毕竟他总要搞一个B+树)</li></ul><h2><span id="ju-cu-he-fei-ju-cu-de-qu-bie">聚簇和非聚簇的区别</span><a href="#ju-cu-he-fei-ju-cu-de-qu-bie" class="header-anchor">#</a></h2><ul><li>聚簇索引其实就是指，当你搜索到B+树的叶子之后， 叶子里存的就是数据行了，因此叶子的左右都是与自己索引值相邻的数据行，可以串起来直接一起获取。</li><li>而非聚簇索引时， 当你搜到叶子时， 叶子里依然只有索引值， 而后面的指针才指向真正的位置， 这意味着数据行的存放是不连续的， 没有办法用一根线串起来。</li></ul><h2><span id="ju-cu-de-you-dian">聚簇的优点</span><a href="#ju-cu-de-you-dian" class="header-anchor">#</a></h2><ol><li>可以一次性读取到 某主键范围的所有行，减少磁盘IO</li><li>相比非聚簇，少跑一层（就是最后一层）。</li></ol><h2><span id="ju-cu-de-que-dian">聚簇的缺点</span><a href="#ju-cu-de-que-dian" class="header-anchor">#</a></h2><ol><li>如果数据都放在内存中，就没优势了，毕竟非聚簇通过指针一样很快。</li><li>更新聚簇索引会很慢，因为会重新组织B+树重新移动。</li><li>B+树插入新行时，可能导致叶子节点的页出现分裂，导致更多的空间。（聚簇索引的叶子非常大！）<br>非聚簇的话都是指针，数据不放在叶子中，也就不会出现那种大叶子的分裂。</li></ol><h2><span id="ju-cu-he-fei-ju-cu-de-dui-bi">聚簇和非聚簇的对比</span><a href="#ju-cu-he-fei-ju-cu-de-dui-bi" class="header-anchor">#</a></h2><p>Innodb都是聚簇索引，叶子节点一般就是数据，数据按顺序存储了。<br>MyIsam都是非聚簇索引， 叶子节点还是索引，凌乱指向存储位置。<br><img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/c29493c31974255e9ce7dbb32c788130b5de1b76.png" alt="c29493c31974255e9ce7dbb32c788130b5de1b76"></p><hr><h2><span id="q-shi-me-shi-hui-biao">Q:  什么是回表？</span><a href="#q-shi-me-shi-hui-biao" class="header-anchor">#</a></h2><p>A:<br>非聚簇索引查询时， 因为最终只查到的是主键值，最终还需要经过聚簇索引找到数据行<br><img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/93d013b61925f7f744e0aad9bdb1062b32874881.png" alt="93d013b61925f7f744e0aad9bdb1062b32874881"><br>如粉红色路径，需要扫码两遍索引树：</p><ol><li>先通过普通索引定位到主键值id=5；</li><li>在通过聚集索引定位到行记录；<br>这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低</li></ol><hr><h2><span id="q-na-me-dang-fa-sheng-hui-biao-shi-zen-me-bi-mian-ni">Q: 那么当发生回表时，怎么避免呢？</span><a href="#q-na-me-dang-fa-sheng-hui-biao-shi-zen-me-bi-mian-ni" class="header-anchor">#</a></h2><p>A:<br>把普通索引列升级到联合主键中。<br>例如将单列索引(name)升级为联合索引(name, sex)，即可避免回表(代价是name要放到第一个，或者sex in ‘男，女’）</p><hr><h2><span id="q-fei-zhu-jian-suo-yin-a-zuo-where-a-gt-3-shi-neng-chong-fen-li-yong-suo-yin-zuo-jian-dan-de-fan-wei-du-qu-me">Q: 非主键索引a， 做where a&gt;3时， 能充分利用索引做简单的范围读取么？</span><a href="#q-fei-zhu-jian-suo-yin-a-zuo-where-a-gt-3-shi-neng-chong-fen-li-yong-suo-yin-zuo-jian-dan-de-fan-wei-du-qu-me" class="header-anchor">#</a></h2><p>A:<br>不能。<br>因为非主键索引最终还是要做回表， 到主键（聚簇）索引树中进行查询。此时a&gt;3是无法直接取出一堆数据的。</p><p>mysql5.5之前， 是每个a&gt;3的记录都进行随机回表读取数据。<br>mysql5.5之后，做了一个MR2优化</p><ol><li>当a&gt;3的记录不是很多时， 会读取到内存中</li><li>接着按照主键id（聚簇索引）进行排序</li><li>然后根据id排序后的情况进行回表， 如果有一堆id都是挤在一起的，就对这一批id进行范围查询。</li></ol><hr><h2><span id="er-ji-suo-yin-he-zhu-jian">二级索引和主键</span><a href="#er-ji-suo-yin-he-zhu-jian" class="header-anchor">#</a></h2><ul><li>注意， 如果有1个key(xx)加一个primKey(yy)，  相当于有2个索引（主键默认索引）<br>而这2个索引的意思是指：<br><em><strong>建立了2个B+树！！</strong></em><br>对于主键的B+树， 数据就放在叶子<br>而对于另一个索引的B+树， 叶子节点是主键+索引，  后面才是指向数据</li><li>即对于聚簇索引，如果存在主键和二级索引，则选择主键做聚簇， 二级索引和非聚簇索引的B+树没两样。</li></ul><hr><h2><span id="q-zhu-jian-suo-yin-he-wei-yi-suo-yin-you-shi-me-qu-bie-ni">Q:  主键索引和唯一索引有什么区别呢？</span><a href="#q-zhu-jian-suo-yin-he-wei-yi-suo-yin-you-shi-me-qu-bie-ni" class="header-anchor">#</a></h2><p>A:</p><ol><li>主键索引一定是唯一索引， 但唯一索引不一定是主键。</li><li>主键索引列默认不支持空值，  而唯一索引本身没有这个限制。</li><li>主键产生唯一的聚集索引（即聚集索引和主键相关），非主键唯一索引产生唯一的非聚集索引</li><li>唯一索引可以有多个， 但是主键只能有一个。</li></ol><hr><h2><span id="q-que-ding-bu-neng-you-duo-ge-zhu-jian-suo-yin-ma-na-fan-shi-li-ti-dao-de-duo-ge-zhu-jian-shi-zen-me-hui-shi-ni">Q:  确定不能有多个主键索引吗？那泛式里提到的多个主键是怎么回事呢？</span><a href="#q-que-ding-bu-neng-you-duo-ge-zhu-jian-suo-yin-ma-na-fan-shi-li-ti-dao-de-duo-ge-zhu-jian-shi-zen-me-hui-shi-ni" class="header-anchor">#</a></h2><p>A:</p><ol><li><p>数据库的每张表只能有一个主键，不可能有多个主键。</p></li><li><p>所谓的一张表多个主键，我们称之为联合主键。</p></li></ol><p>注：联合主键：就是用多个字段一起作为一张表的主键。</p><ol start="3"><li>主键的主键的作用是保证数据的唯一性和完整性，同时通过主键检索表能够增加检索速度。</li></ol><hr><h1><span id="suo-yin-de-cha-ru">索引的插入</span><a href="#suo-yin-de-cha-ru" class="header-anchor">#</a></h1><h2><span id="suo-yin-cha-ru-de-gui-fan">索引插入的规范</span><a href="#suo-yin-cha-ru-de-gui-fan" class="header-anchor">#</a></h2><ul><li>尽量保证在插入时是按索引的顺序插入的</li><li>如果没按顺序插入，会导致经常性的中间分页，移动数据。性能可以差距四倍以上。</li><li>所以尽量选用自增的id做索引，尽量不要用随机的UUID做大批量插入的操作。</li><li>如果用了UUID做插入，插入之后还要要用一个命令<br>Optimize Table 表名<br>来重建表并优化页的填充</li><li>什么时候顺序主键的插入是不好的？<br>同一时刻并发插入（非单线程插入）的情况<br>这会导致在 数据表末尾发生激烈的竞争冲突（如果是随机的反而可以避免这个情况） P171</li></ul><hr><h2><span id="q-wei-shi-me-zi-zeng-id-ke-neng-hui-chu-xian-bu-lian-xu-de-qing-kuang">Q: 为什么自增id可能会出现不连续的情况？</span><a href="#q-wei-shi-me-zi-zeng-id-ke-neng-hui-chu-xian-bu-lian-xu-de-qing-kuang" class="header-anchor">#</a></h2><p>A:<br>插入时，如果insert语句中不包含id，但是id设成了自增<br>mysql此时就会从某个自增表中申请一个主键，当申请成功之后，就会拿着这个主键+1去做真实的Insert操作。（注意，是先申请，再插入）<br>如果主键/唯一键冲突，或者事务回滚， <em><strong>这个自增id不会回滚</strong></em>。 下一次会继续主键+1使用。<br>因此</p><hr><h2><span id="q-wei-shi-me-zi-zeng-id-bu-neng-hui-gun-ni">Q: 为什么自增id不能回滚呢？</span><a href="#q-wei-shi-me-zi-zeng-id-bu-neng-hui-gun-ni" class="header-anchor">#</a></h2><p>A:<br>为什么不回退，是避免回退导致重复的冲突，也为了避免太大范围的锁</p><ul><li>避免回退导致多个id同时插入引发重复的冲突，也为了避免太大范围的锁</li><li>自增主键比较大的作用是避免页分割，我们只需要数据是递增而无需连续</li></ul><hr><hr><h1><span id="qi-ta-suo-yin">其他索引</span><a href="#qi-ta-suo-yin" class="header-anchor">#</a></h1><h2><span id="fu-gai-suo-yin">覆盖索引</span><a href="#fu-gai-suo-yin" class="header-anchor">#</a></h2><p>指查询语句中 只有索引相关的列。</p><ul><li>这样的话，可以不需要回表访问聚簇索引树了， 直接拿索引节点里的索引结果返回，效率非常高。</li><li>全覆盖的情况比较少见，一般用于<br>先用覆盖索引的查询语句得到一个小表<br>再利用这个小表的结果对原表做查询（相当于省去了一些条件里的判断）</li><li>Explanin 解析时，如果extra显示 using index，则说明使用了覆盖索引。</li></ul><h2><span id="yong-suo-yin-zuo-pai-xu">用索引做排序</span><a href="#yong-suo-yin-zuo-pai-xu" class="header-anchor">#</a></h2><ul><li>索引和排序语句写对的话，可以不需要弄临时表做排序，直接按照顺序取出返回即可。</li><li>索引列的顺序， 必须和order by中声明的索引顺序一致</li><li>即你的key是(a,b,c)， 那么oder by a b c才行，不能打乱顺序</li><li>order by 索引满足 前缀定理，  即必须是  a 或者 a+b或者  a+b前缀</li><li>特例： 如果where中定义了a=‘某个常量’，  那么order by中只需要b和c也满足 前缀定义。</li><li>如果是范围就不行了</li></ul><h2><span id="ya-suo-qian-zhui-suo-yin">压缩（前缀索引）</span><a href="#ya-suo-qian-zhui-suo-yin" class="header-anchor">#</a></h2><ul><li>就是把索引在存储的做压缩，减少字节数</li><li>例如第一个索引是perform， 第二个是performance， 那么第二个存储的时候就表示为7,ance</li><li>可以在Create Table语句中指定PACK_KEYS来控制索引压缩</li><li>压缩索引主要是为了减少磁盘和内存占用量， 但因为压缩了，每次到节点时要先解开压缩再计算（即只有用到才解压），再去查找，会降低性能。</li></ul><h2><span id="chong-fu-suo-yin">重复索引</span><a href="#chong-fu-suo-yin" class="header-anchor">#</a></h2><p>primary key、 unique(key)、 index(key）这3个本质上都会形成索引，很容易有人定义了主键后， 又给主键加个索引， 这就会出现多个相同的B+树。</p><h2><span id="rong-yu-suo-yin">冗余索引</span><a href="#rong-yu-suo-yin" class="header-anchor">#</a></h2><ul><li>创建了索引（A，B）之后， 又创建了（A）， 那么就是冗余， 因为（A，B） 可以实现单独A的索引功能。</li><li>所以尽量修改索引，而不是去新增索引， 新增索引容易出现冗余索引。</li><li>修改索引的缺陷:  可能导致一些老的查询语句的性能下降。<br>例如本来是用索引（A） + 主键ID排序做查询，  那个脚本一直在跑很正常， 后来改成了索引（A.B）  + 主键ID排序， 于是原先的脚本性能GG， 因为A和ID被B分开了（只是我们看不到ID放在我们定义的key里）</li></ul><h2><span id="wei-shi-yong-de-suo-yin">未使用的索引</span><a href="#wei-shi-yong-de-suo-yin" class="header-anchor">#</a></h2><ul><li>就是定义了但是平时不用的索引！</li><li>定位未使用索引的方法：  打开userstates变量， 然后让服务器运行几天之后， 查询INFORMATION_SCHEMA.INDEX_STATISTICS用来查看索引的使用频率。</li><li>具体见P188</li></ul><h2><span id="suo-yin-he-suo">索引和锁</span><a href="#suo-yin-he-suo" class="header-anchor">#</a></h2><ul><li>索引能够减少访问的行数，从而减少锁的数量</li></ul><hr><h1><span id="suo-yin-ying-yong">索引应用</span><a href="#suo-yin-ying-yong" class="header-anchor">#</a></h1><h2><span id="duo-chong-guo-lu-tiao-jian-you-hua">多种过滤条件优化</span><a href="#duo-chong-guo-lu-tiao-jian-you-hua" class="header-anchor">#</a></h2><ul><li>如果我们的索引是 sex country age， 但是我们的查询里不关心sex，怎么办？ 如果不走sex，索引就失效了<br>可以在where中加入  sex in (‘m’,‘f’)  这样就能用到sex了</li><li>原则1：<br>枚举少的放前面， 这样可以用in方式来处理</li><li>原则2：<br>经常范围性查询的索引列放后面 ，例如age， 毕竟范围查的话，后面的索引就肯定用不了了。</li></ul><h2><span id="bi-mian-duo-ge-fan-wei-tiao-jian">避免多个范围条件</span><a href="#bi-mian-duo-ge-fan-wei-tiao-jian" class="header-anchor">#</a></h2><ul><li>mysql会把in(1,2,3)和 &gt;1 and &lt; 3 都认为是range的type，  不过在索引的使用，  in之后还可以接其他索引，  但是大于1小于3就不行了</li><li>如果出现了  lastoneline  &gt; xxx  and age  between x and y<br>这种2个范围的索引查询，就会导致age索引失效</li><li>一种优化的办法：  如果lastoneline &gt; xxx 仅仅是表示 这个用户是否未过期，则可以新增一个经常维护的字段active，来吧lasttime&gt;xxx的这个条件转成true和false这两种值。</li><li>那么后面就可以改成lastline = true and age between… 了， 用等值的话，就不会影响后面的索引</li></ul><hr><h2><span id="q-xie-ru-biao-de-shi-hou-wei-shi-me-yi-ban-jian-yi-zi-zeng-de-zhu-jian-id-lai-xie-ru">Q: 写入表的时候， 为什么一般建议自增的主键id来写入？</span><a href="#q-xie-ru-biao-de-shi-hou-wei-shi-me-yi-ban-jian-yi-zi-zeng-de-zhu-jian-id-lai-xie-ru" class="header-anchor">#</a></h2><p>A:<br>因为底层的索引本质上是B+树<br>有页分裂<br>如果id随机，则写入时会碎片化，无法做到顺序写</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第307场周赛-1232名-3题</title>
      <link href="/2022/08/21/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/"/>
      <url>/2022/08/21/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661066854478.png" alt="1661066854478"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>N种东西组成最大字典序回文时，先把成双的都处理掉，每组留下1个或者0个， 最后再考虑怎么拼接这些</li><li>子序列和第K个，可以考虑从最小数字开始， 每次保留当前数字，选下一个数字， 或者废弃当前数字，选下一个数字，  并都放入堆中， 这样每次可更新得到最小的子序列。</li></ol><hr><p><a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/">6152. 赢得比赛需要的最少训练时长 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661066882187.png" alt="1661066882187"></p><p>最开始有点事情，解决完之后发现脑子很乱，这题目其实很简答</p><p>对于精力，可以提前算出需要的精力， 而经验可以在每次对战时判断是否要再增加。</p><p>但这题就是条件容易看漏，导致错了2次：</p><p><strong>需要在经验和精力上都</strong> <strong>严格超过对手才能击败他们</strong></p><p>严格超过意味着不能等于，导致很多地方得+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, <span class="type">int</span>[] energy, <span class="type">int</span>[] experience)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> initialExperience;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(energy).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, sum + <span class="number">1</span> - initialEnergy);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; experience.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exp &lt;  experience[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                res += experience[i] - exp + <span class="number">1</span>;</span><br><span class="line">                exp = experience[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exp += experience[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/largest-palindromic-number/">6166. 最大回文数字 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661067068832.png" alt="1661067068832"></p><p>这题也搞晕了，实际上很简单。</p><p>一堆已知数量的字母要组成回文数， 记住你先把所有成双成对的单独都按拿出来， 剩下的都是1个或者0个字母</p><p>然后成双的按大小顺序从外向内组成回文 ，  最后最里面那个单字母的用最大的。</p><p>我最开始直接把奇数个数的字母当整体去思考了，其实应该先剔除奇数个数字母中成双的部分，只留下单个的， 最后再去考虑他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestPalindromic</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] charCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">            charCounts[c-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小的字母且是奇数个数的选择放最后</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">endUseChar</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] oneChar = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>; i &gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            oneChar[i] = (charCounts[i] %<span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">            charCounts[i] /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == endUseChar) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> charCounts[i];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; sb1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sb1.append(c);</span><br><span class="line">                sb2.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oneChar[i]) &#123;</span><br><span class="line">                sb1.append((<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sb1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb1.append(sb2.reverse()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/">6154. 感染二叉树需要的总时间 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661067234487.png" alt="1661067234487"></p><p>很容易想到bfs， 先dfs一遍，把每个点的父节点也得到。</p><p>然后做bfs即可</p><p>另外二叉树的题目中如果涉及map或者set，最好还是直接用引用做key，不容易写错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        Map&lt;TreeNode,TreeNode&gt; parents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    TreeNode startNode;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">amountOfTime</span><span class="params">(TreeNode root, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        find(root, <span class="literal">null</span>, start);</span><br><span class="line">        queue.offer(startNode);</span><br><span class="line">        Set&lt;TreeNode&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        vis.add(startNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 全部出队</span></span><br><span class="line">            res++;</span><br><span class="line">            List&lt;TreeNode&gt; nowNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queue);</span><br><span class="line">            queue.clear();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : nowNodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; !vis.contains(node.left)) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    vis.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span> &amp;&amp; !vis.contains(node.right)) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    vis.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (parents.get(node) != <span class="literal">null</span> &amp;&amp; !vis.contains(parents.get(node))) &#123;</span><br><span class="line">                    queue.offer(parents.get(node));</span><br><span class="line">                    vis.add(parents.get(node));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode node, TreeNode parent, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parents.put(node, parent);</span><br><span class="line">        <span class="keyword">if</span> (node.val == start) &#123;</span><br><span class="line">            startNode = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find(node.left, node, start);</span><br><span class="line">        find(node.right, node, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">6155. 找出数组的第 K 大和 - 力扣（LeetCode）</a></p><p>这题好难，其实知道套路就可以了</p><p>我是已经想到先得到 正数的和sum， 然后以这个sum不断减去其他的值，这个减去的就是子序列而且要尽可能小， 同时负数要转整数， 到底是加还是减不需要我们关心。</p><p>但是怎么得到第K小的子序列和呢？</p><p>答案是用最小堆</p><p>先按从小到大排序</p><p>然后第0个数字肯定是最小的子序列</p><p>接着有2个选择：</p><p>① 保留第0个数字， 并继续选取第1个数字</p><p>② 废弃第0个数字， 并继续选取第1个数字</p><p>这样又得到2个子序列， 最小序列肯定在者2个里面</p><p>你会奇怪，者肯定是第②个最小啊？</p><p>但是继续走下去</p><p>当对于“废弃第0个数字， 并继续选取第1个数字”这个位置，你想废弃第1个数字，选第2个数字时，前面的“保留第0个数字， 并继续选取第1个数字”是可能比它小的， 所以要用堆进行保存，且这样的操作处理时不用考虑任何回溯或者重复的情况！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">kSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).filter(num -&gt; num &gt; <span class="number">0</span>).mapToLong(num -&gt; Long.valueOf(num)).sum();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length;i++) &#123;</span><br><span class="line">            nums[i] = Math.abs(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// [0]是选择剔除的子序列的和，[1]是当前这个子序列的最右边索引</span></span><br><span class="line">        <span class="comment">// 每次选最小的出来</span></span><br><span class="line">        Queue&lt;<span class="type">long</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] ? <span class="number">1</span> : -<span class="number">1</span>));</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, <span class="number">0L</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">subSum</span> <span class="operator">=</span> queue.peek()[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)queue.poll()[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (sum - subSum);</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= nums.length) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;subSum + nums[index], index+<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index -<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;subSum - nums[index - <span class="number">1</span>] + nums[index], index + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络威胁分析和应对方式</title>
      <link href="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#spoofing-fang-mou-ren-zheng">Spoofing 仿冒—&gt;认证</a></li><li><a href="#tampering-cuan-gai-wan-zheng-xing">Tampering 篡改—&gt;完整性</a></li><li><a href="#repudiation-di-lai-fou-ren-zuo-guo-de-shi-fang-di-lai">Repudiation 抵赖，否认做过的事—&gt;防抵赖</a></li><li><a href="#imformation-disclosure-xin-xi-xie-lu-ji-mi-xing">Imformation Disclosure 信息泄露—&gt;机密性</a></li><li><a href="#denial-of-service-ju-jue-fu-wu-ke-yong-xing">Denial of Service 拒绝服务—&gt;可用性</a></li><li><a href="#elevation-of-privilege-quan-xian-ti-sheng-shou-quan">Elevation of privilege 权限提升—&gt;授权</a></li><li><a href="#privacy-yin-si-tuo-min">Privacy隐私—&gt;脱敏</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="spoofing-fang-mou-gt-ren-zheng">Spoofing 仿冒—&gt;认证</span><a href="#spoofing-fang-mou-gt-ren-zheng" class="header-anchor">#</a></h1><p>搞一个克隆的手机号， 接入到公用wifi中看违反视频干违法之事，然后另一个人背锅了 （ 外部交互方）—— 手机短信验证码接入， 或者ssl证书双向认证</p><p>公用wifi被我替换成了仿冒的同名假wifi， 其他手机就误接进来了，我就能偷偷知道谁在下小黄片了 （处理过程）， 或者是搞了个假的淘宝，让别人点进来—— ssl双向认证</p><h1><span id="tampering-cuan-gai-gt-wan-zheng-xing">Tampering 篡改—&gt;完整性</span><a href="#tampering-cuan-gai-gt-wan-zheng-xing" class="header-anchor">#</a></h1><p>服务器的监听特性被纂改?（处理过程）—— 校验端口正确，配置文件mac对比，mac存到服务端</p><p>直接再数据库里修改你的个人信息或者金钱（存储）——acl权限控制</p><p>某app偷偷修改你的host，把你想发给华为的数据发送到黑客的服务器上了。（数据流) —— acl权限认证，host不可更改，或者文件mac对比</p><h1><span id="repudiation-di-lai-fou-ren-zuo-guo-de-shi-gt-fang-di-lai">Repudiation 抵赖，否认做过的事—&gt;防抵赖</span><a href="#repudiation-di-lai-fou-ren-zuo-guo-de-shi-gt-fang-di-lai" class="header-anchor">#</a></h1><p>有人用root登录后干了rm -rf 这事， 却说自己没做过，你查不到我（外部交互方) ——审计日志</p><p>修改日志记录函数（例如替换jar包之类的）， 日志故意不记录自己的名字 （ 处理过程）——认证</p><p>直接去存储的地方修改日志信息（存储过程， 只有日志会存盘才有可能）——认证</p><h1><span id="imformation-disclosure-xin-xi-xie-lu-gt-ji-mi-xing">Imformation Disclosure 信息泄露—&gt;机密性</span><a href="#imformation-disclosure-xin-xi-xie-lu-gt-ji-mi-xing" class="header-anchor">#</a></h1><p>从app的应用启动目录找到一个二进制文件，可以解密处密钥（处理过程）——加密</p><p>入侵数据库里。可以找到明文口令（存储过程）——加密</p><p>明文口令直接加在http中， 然后被人直接抓包拿到口令了（数据流）——加密</p><h1><span id="denial-of-service-ju-jue-fu-wu-gt-ke-yong-xing">Denial of Service 拒绝服务—&gt;可用性</span><a href="#denial-of-service-ju-jue-fu-wu-gt-ke-yong-xing" class="header-anchor">#</a></h1><p>服务器承载不住请求量，内存不足或者cpu爆满（处理过程） ——负载均衡</p><p>疯狂执行写操作，然后磁盘满了（存储过程）——缓存</p><p>故意拦截中间链路，导致数据流中断（数据流）——过滤</p><h1><span id="elevation-of-privilege-quan-xian-ti-sheng-gt-shou-quan">Elevation of privilege 权限提升—&gt;授权</span><a href="#elevation-of-privilege-quan-xian-ti-sheng-gt-shou-quan" class="header-anchor">#</a></h1><p>在处理过程中， 用户权限比实际的高（处理过程）——权限最小化\沙箱</p><h1><span id="privacy-yin-si-gt-tuo-min">Privacy隐私—&gt;脱敏</span><a href="#privacy-yin-si-gt-tuo-min" class="header-anchor">#</a></h1><p>外部交互方： 没有经过用户同意，就收集隐私—— 应该加勾选项告知用户</p><p>数据存储： 直接把用户数据存盘却没有加密或者脱敏—— 数据脱敏、匿名化</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2022/08/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/08/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#gai-nian">概念</a></li><li><a href="#he-xin-si-lu">核心思路：</a></li><li><a href="#dai-ma-mo-ban">代码模板</a></li><li><a href="#xiang-guan-ti-mu">相关题目</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor">#</a></h1><ul><li><p>谁和谁相互关联， 问你最终每个集体或者最多集体有多少人， 或者有多少个集体，用并查集即可。</p></li><li><p>区间合并问题直接上并查集，别整更新左区间，更新右区间这种玩意，很容易错。</p></li></ul><h1><span id="he-xin-si-lu">核心思路：</span><a href="#he-xin-si-lu" class="header-anchor">#</a></h1><ol><li>partent[k] 指k的父亲节点是什么</li><li>每次getParent(k)时， 要通过递归， 将其父节点更新成最上面的父节点，实现并查集的压缩，大大减少了复杂度</li><li>union时， 则随意选一方进行连接</li><li>如何涉及集合中的数量问题，尽量别在union中更新，容易写错，  建议最后全部遍历一边，得到集合中的数量或者价值总数。</li><li>如果一定要union更新，注意顺序，p[p1]] = p2的话，说明p1的父亲变成了p2，那么应该是p2作为被加方，即sum[p2] += sum[p1]，反过来了。且注意在getParent中不需要更新val</li></ol><h1><span id="dai-ma-mo-ban">代码模板</span><a href="#dai-ma-mo-ban" class="header-anchor">#</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">long</span>[] sums;</span><br><span class="line">   <span class="type">int</span>[] parent;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getParent(n1);</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getParent(n2);</span><br><span class="line">       parent[p1] = p2;</span><br><span class="line">       sums[p2] += sums[p1];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> parent[num];</span><br><span class="line">       <span class="keyword">if</span> (p == num) &#123;</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           p = getParent(p);</span><br><span class="line">       &#125;</span><br><span class="line">       parent[num] = p;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/maximum-segment-sum-after-removals/">6159. 删除操作后的最大子段和 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 算法大全 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第86场双周赛-376名-4题</title>
      <link href="/2022/08/20/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/"/>
      <url>/2022/08/20/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012250432.png" alt="1661012250432"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li><p>涉及边界问题一定要自己检查看是否写错了，花1分钟检查总好过避免WA浪费5分钟</p></li><li><p>取余问题一定要注意负数的情况，必须要用加上Mod值直到大于0才能去取余</p></li><li><p>区间合并问题直接上并查集，别整更新左区间，更新右区间这种玩意，很容易错。</p></li></ol><hr><p><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">6156. 得到 K 个黑块的最少涂色次数 - 力扣（LeetCode）</a></p><p>很简单，滑动窗口，而且因为数量够小，直接暴力解决即可，不用做滑动窗口的特殊处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumRecolors</span><span class="params">(String blocks, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blocks.length();i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; i+k &amp;&amp;  j &lt; blocks.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blocks.charAt(j) == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i+k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(count, min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/">6157. 二进制字符串重新安排顺序需要的时间 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012329860.png" alt="1661012329860"></p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012381790.png" alt="1661012381790"></p><p>首先花了几分钟，推断出来最多变化n次（因为每处理一次至少前缀1会增加1个）</p><p>那么直接暴力O(n2)即可</p><p>但是因为边界处理写急了导致出错，我应该自己提交前再检查一下的</p><p>下面是错误的地方：</p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012470616.png" alt="1661012470616"></p><p>i+1==s.length()了，怎么可能添加11， 最多添加1个1才对。</p><p>正确答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">secondsToRemoveOccurrences</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; (i+<span class="number">1</span>!=s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; (i+<span class="number">1</span> == s.length() || s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; (i+<span class="number">1</span> != s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s = sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/shifting-letters-ii/">6158. 字母移位 II - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012520347.png" alt="1661012520347"></p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012525774.png" alt="1661012525774"></p><p>做过这类题，和那种任务流的题目类似</p><p>直接记录每个位置有多少起点，多少终点，根据情况进行加或者减。</p><p>但是对于移位的处理有点问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">    count += startPlaces[i];</span><br><span class="line">    cs[i] = (<span class="type">char</span>)((s.charAt(i) -<span class="string">&#x27;a&#x27;</span> + count)%<span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    count += endPlaces[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似很对， 却忘记了 负数取余也是负数。。</p><p>对负数取余应当通过加上26的倍数让他大于0才对。于是改成下面这样得到移位后的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">getMod</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>  + count;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> num / <span class="number">26</span>;</span><br><span class="line">        num += (mul+<span class="number">2</span>)*<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num %= <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>)(num + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果还是错</p><p>因为我忘记了num是负数的时候，num/26也是负数。。应该要加一个Math.abs</p><p>正确做法如下getMod：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="title function_">getMod</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>  + count;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> Math.abs(num / <span class="number">26</span>);</span><br><span class="line">            num += (mul+<span class="number">1</span>)*<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num %= <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">char</span>)(num + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shiftingLetters</span><span class="params">(String s, <span class="type">int</span>[][] shifts)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] startPlaces = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] endPlaces = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shifts.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] shift = shifts[i];</span><br><span class="line">            startPlaces[shift[<span class="number">0</span>]] += (shift[<span class="number">2</span>] == <span class="number">1</span> ? <span class="number">1</span>: -<span class="number">1</span>);</span><br><span class="line">            endPlaces[shift[<span class="number">1</span>]] += (shift[<span class="number">2</span>] == <span class="number">0</span> ? <span class="number">1</span>: -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            count += startPlaces[i];</span><br><span class="line">            cs[i] = getMod(s.charAt(i), count);</span><br><span class="line">            count += endPlaces[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/maximum-segment-sum-after-removals/">6159. 删除操作后的最大子段和 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012916961.png" alt="1661012916961"></p><p><img src="/images/%E7%AC%AC86%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-376%E5%90%8D-4%E9%A2%98/1661012929643.png" alt="1661012929643">、</p><p>这题又是做过类似的题，删点的题目可以反过来变成加点。</p><p>即从后往前逐步遍历，新增，逐步合并区间</p><p>结果还是用了错误的方式去更新，想着直接更新左右两个索引的sum值即可</p><p>实际上你要更新的应该是左边索引的最左点， 右边索引的最右点才对，而且每次合并都要修改左右的最左点或者最右点，非常麻烦，如下中间那4个if， 绕来绕去，注定要搞一次WA才能知道问题，非常不对劲：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[] maximumSegmentSum(<span class="type">int</span>[] nums, <span class="type">int</span>[] removeQueries) &#123;</span><br><span class="line">        <span class="type">long</span>[] sums = <span class="keyword">new</span> <span class="title class_">long</span>[nums.length];</span><br><span class="line">        <span class="type">long</span>[] results = <span class="keyword">new</span> <span class="title class_">long</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] lefts = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] rights = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxNum</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> removeQueries.length-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> removeQueries[i];</span><br><span class="line">            <span class="type">long</span> <span class="variable">leftSum</span> <span class="operator">=</span> index-<span class="number">1</span> &gt;= <span class="number">0</span> ? sums[index-<span class="number">1</span>] :<span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">rightSum</span> <span class="operator">=</span> index + <span class="number">1</span> &lt; nums.length ? sums[index+<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> leftSum + rightSum + nums[index];</span><br><span class="line">            lefts[index] = rights[index] = index;</span><br><span class="line">            sums[index] = sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lefts[index] = lefts[index-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rights[index] = rights[index+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rights[lefts[index]] = rights[index];</span><br><span class="line">                sums[lefts[index]] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lefts[rights[index]] = lefts[index];</span><br><span class="line">                sums[rights[index]] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            maxNum = Math.max(maxNum, sum);</span><br><span class="line">            results[i-<span class="number">1</span>] = maxNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种合并的题目就别取巧了， 直接并查集走起</p><p>注意并查集合并时，涉及val的合并， 在getParent中不需要更新val</p><p>在union中，注意顺序，p[p1]] = p2的话，说明p1的父亲变成了p2，那么应该是p2作为被加方，即sum[p2] += sum[p1]，反过来了</p><p>另外注意要先取变量，不要直接基于函数去搞，下面这样是错误的！因为第一步之后已经发生变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">    parent[getParent(n1)] = getParent(n2);</span><br><span class="line">    sums[getParent(n2)] += sums[getParent(n1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getParent(n1);</span><br><span class="line">    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getParent(n2);</span><br><span class="line">    parent[p1] = p2;</span><br><span class="line">    sums[p2] += sums[p1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并查集正确做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] sums;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[] maximumSegmentSum(<span class="type">int</span>[] nums, <span class="type">int</span>[] removeQueries) &#123;</span><br><span class="line">        <span class="type">long</span>[] results = <span class="keyword">new</span> <span class="title class_">long</span>[nums.length];</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">long</span>[nums.length];</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxNum</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parent.length;i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> removeQueries.length-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> removeQueries[i];</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">leftSum</span> <span class="operator">=</span> index-<span class="number">1</span> &gt;= <span class="number">0</span> ? sums[getParent(index-<span class="number">1</span>)] :<span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">rightSum</span> <span class="operator">=</span> index + <span class="number">1</span> &lt; nums.length ? sums[getParent(index+<span class="number">1</span>)] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            sums[index] = nums[index];</span><br><span class="line">            <span class="keyword">if</span> (leftSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                union(index-<span class="number">1</span>, index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                union(index, index+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            maxNum = Math.max(maxNum, sums[getParent(index)]);</span><br><span class="line">            results[i-<span class="number">1</span>] = maxNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getParent(n1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getParent(n2);</span><br><span class="line">        parent[p1] = p2;</span><br><span class="line">        sums[p2] += sums[p1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> parent[num];</span><br><span class="line">        <span class="keyword">if</span> (p == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = getParent(p);</span><br><span class="line">        &#125;</span><br><span class="line">        parent[num] = p;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全防护和认证措施</title>
      <link href="/2022/08/20/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E8%AE%A4%E8%AF%81%E6%8E%AA%E6%96%BD/"/>
      <url>/2022/08/20/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E8%AE%A4%E8%AF%81%E6%8E%AA%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#https-fang-hu-chang-jian-wen-ti">HTTPS防护常见问题</a><ul><li><a href="#q-jiang-yi-xia-https-shuang-xiang-ren-zheng-de-guo-cheng">Q: 讲一下HTTPS双向认证的过程？</a></li><li><a href="#q-wei-shi-me-bu-shi-yong-fei-dui-cheng-mi-yao-jia-mi-chuan-shu-shu-ju-er-yao-yong-dui-cheng-mi-yao-zhe-yang-rao-yi-da-quan">Q: 为什么不使用非对称密钥加密 传输数据， 而要用对称密钥这样绕一大圈？</a></li><li><a href="#q-wei-shi-me-shu-ju-kai-shi-chuan-shu-zhi-hou-bu-xu-yao-zai-zuo-yan-qian-nan-dao-zhe-zhong-jian-de-shu-ju-jiu-bu-hui-zai-bei-ren-cuan-gai-huo-zhe-ti-huan-ma">Q: 为什么数据开始传输之后不需要再做验签， 难道者中间的数据就不会再被人篡改或者替换吗？</a></li><li><a href="#q-ca-gen-zheng-shu-ke-neng-bei-zao-jia-ma">Q: CA根证书可能被造假吗？</a></li><li><a href="#q-hei-ke-ba-zhe-ge-fu-wu-duan-fan-hui-de-zheng-shu-bao-cun-xia-lai-ran-hou-xia-ci-bie-ren-fang-wen-hei-ke-de-diao-yu-wang-zhan-shi-hei-ke-ba-zhe-ge-zheng-shu-yuan-feng-bu-dong-fa-hui-qu-hui-tong-guo-yan-zheng-ma">Q: 黑客把这个服务端返回的证书， 保存下来，然后下次别人访问黑客的钓鱼网站时， 黑客把这个证书原封不动发回去，会通过验证吗？</a></li><li><a href="#q-md5-zai-shuang-xiang-ren-zheng-guo-cheng-zhong-you-shi-me-yong">Q: MD5 在双向认证过程中有什么用？</a></li><li><a href="#q-shi-me-shi-zheng-shu-lian">Q: 什么是证书链?</a></li></ul></li><li><a href="#token-ji-zhi">Token机制</a><ul><li><a href="#q-ru-he-she-ji-token">Q: 如何设计token？</a></li><li><a href="#q-token-xie-lu-zen-me-ban">Q: token泄露怎么办？</a></li></ul></li><li><a href="#yun-fu-wu-aksk">云服务AKSK</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="https-fang-hu-chang-jian-wen-ti">HTTPS防护常见问题</span><a href="#https-fang-hu-chang-jian-wen-ti" class="header-anchor">#</a></h1><p><a href="http://breakdawncoder.com/2022/08/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">HTTPS原理详解</a></p><h2><span id="q-jiang-yi-xia-https-shuang-xiang-ren-zheng-de-guo-cheng">Q: 讲一下HTTPS双向认证的过程？</span><a href="#q-jiang-yi-xia-https-shuang-xiang-ren-zheng-de-guo-cheng" class="header-anchor">#</a></h2><p>A:</p><ol><li><p>服务端发送证书， 证书中包含网站信息、CA签名、网站公钥</p></li><li><p>客户端校验CA签名，确认是CA所签且来源方正是该网站。</p></li><li><p>客户端生成会话密钥</p></li><li><p>客户端用网站公钥对会话密钥进行加密，生成非对称的会话密钥密文</p></li><li><p>客户端发送会话密钥密文给服务端</p></li><li><p>服务端用私钥解密， 得到明文会话密钥。</p></li><li><p>二者使用会话密钥进行加密传输</p><p><img src="http://breakdawncoder.com/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/913d97b11e50460681e99eae9f0e272d.jpg" alt="在这里插入图片描述"></p></li></ol><h2><span id="q-wei-shi-me-bu-shi-yong-fei-dui-cheng-mi-yao-jia-mi-chuan-shu-shu-ju-er-yao-yong-dui-cheng-mi-yao-zhe-yang-rao-yi-da-quan">Q: 为什么不使用非对称密钥加密 传输数据， 而要用对称密钥这样绕一大圈？</span><a href="#q-wei-shi-me-bu-shi-yong-fei-dui-cheng-mi-yao-jia-mi-chuan-shu-shu-ju-er-yao-yong-dui-cheng-mi-yao-zhe-yang-rao-yi-da-quan" class="header-anchor">#</a></h2><p>A:<br>对称算法的加解密性能比非对称算法快很多， 所以非对称只用于会话密钥的传输即可， 只需要一次。</p><hr><h2><span id="q-wei-shi-me-shu-ju-kai-shi-chuan-shu-zhi-hou-bu-xu-yao-zai-zuo-yan-qian-nan-dao-zhe-zhong-jian-de-shu-ju-jiu-bu-hui-zai-bei-ren-cuan-gai-huo-zhe-ti-huan-ma">Q:  为什么数据开始传输之后不需要再做验签， 难道者中间的数据就不会再被人篡改或者替换吗？</span><a href="#q-wei-shi-me-shu-ju-kai-shi-chuan-shu-zhi-hou-bu-xu-yao-zai-zuo-yan-qian-nan-dao-zhe-zhong-jian-de-shu-ju-jiu-bu-hui-zai-bei-ren-cuan-gai-huo-zhe-ti-huan-ma" class="header-anchor">#</a></h2><p>A:<br>不会，有3个原因保证：</p><ol><li>会话密钥是会话级别， 动态生成的，只有这一次连接才会用到。因此以前废弃的会话密钥不用担心被人拿去利用。</li><li>建立连接并传递会话密钥之前，已经通过验签确认过对方身份是可信的。</li><li>没有任何第三方知道会话密钥是什么。因此第三方攻击人无法用正确的会话密钥加密数据，即无法做到伪造会话密钥来欺骗接收者的目的。</li></ol><hr><h2><span id="q-ca-gen-zheng-shu-ke-neng-bei-zao-jia-ma">Q:  CA根证书可能被造假吗？</span><a href="#q-ca-gen-zheng-shu-ke-neng-bei-zao-jia-ma" class="header-anchor">#</a></h2><p>例如黑客修改了用户机器中的CA证书，导致CA的公钥被替换了，   后面访问了黑客所在的网址时，就会验签成功。</p><p>A:<br>如果真的能修改的话，那么是可行的。<br>但是操作系统基本会内置著名CA的公钥，除非黑客已经能直接触碰你的操作系统底层了，否则基本办不到。</p><hr><h2><span id="q-hei-ke-ba-zhe-ge-fu-wu-duan-fan-hui-de-zheng-shu-bao-cun-xia-lai-ran-hou-xia-ci-bie-ren-fang-wen-hei-ke-de-diao-yu-wang-zhan-shi-hei-ke-ba-zhe-ge-zheng-shu-yuan-feng-bu-dong-fa-hui-qu-hui-tong-guo-yan-zheng-ma">Q:  黑客把这个服务端返回的证书， 保存下来，然后下次别人访问黑客的钓鱼网站时， 黑客把这个证书原封不动发回去，会通过验证吗？</span><a href="#q-hei-ke-ba-zhe-ge-fu-wu-duan-fan-hui-de-zheng-shu-bao-cun-xia-lai-ran-hou-xia-ci-bie-ren-fang-wen-hei-ke-de-diao-yu-wang-zhan-shi-hei-ke-ba-zhe-ge-zheng-shu-yuan-feng-bu-dong-fa-hui-qu-hui-tong-guo-yan-zheng-ma" class="header-anchor">#</a></h2><p>A：<br>客户端会验证成功，<br>但是客户端做公钥时<br>于是对数据进行对称+非对称加密<br>重点来了<br>钓鱼网站接收到的数据，他没法用，他没有正规网站的私钥！ 因为客户端用的是正规网站签发的公钥才可以。<br>黑客做中间人两边相互拦截，把假的签发过的公钥+证书发给客户端<br>客户端验签过程就会发现端倪， 发现他这个证书不对劲， 不是自己这边持有的CA机构正常签发出来证书。</p><h2><span id="q-md5-zai-shuang-xiang-ren-zheng-guo-cheng-zhong-you-shi-me-yong">Q: MD5 在双向认证过程中有什么用？</span><a href="#q-md5-zai-shuang-xiang-ren-zheng-guo-cheng-zhong-you-shi-me-yong" class="header-anchor">#</a></h2><p>A:<br>对网址申请信息进行摘要， 避免签名内容过长。同时也避免了逆向推导原网址信息的过程。</p><h2><span id="q-shi-me-shi-zheng-shu-lian">Q: 什么是证书链?</span><a href="#q-shi-me-shi-zheng-shu-lian" class="header-anchor">#</a></h2><p>A:</p><ul><li><p>一个证书或证书链的拆封操作，是为了<br>从中获得一个公钥。可示为X1p?X1&lt;<x2>&gt;,这为一个中缀操作，其左操作数为一个认证机构的公钥，<br>右操作数则为该认证机构所颁发的一个证书。如果能正确解开，输出结果为用户的公钥</x2></p></li><li><p>证书链验证的要求是，路径中每个证书从最终实体到根证书<br>都是有效的，并且每个证书都要正确地对应发行该证书的权威可信任性CA。操作表达式为 Ap?A&lt;<b>&gt;B&lt;<c>&gt;,<br>指出该操作使用A的公钥，从B的证书中获得B的公钥Bp，然后再通过 Bp来解封C的证书。操作的最终结果</c></b></p></li></ul><p>说人话就是下游证书解出来是上游父证书的密文公钥，然后继续解</p><p><a href="https://blog.csdn.net/junwua/article/details/80506399">理解证书和证书链</a></p><h1><span id="token-ji-zhi">Token机制</span><a href="#token-ji-zhi" class="header-anchor">#</a></h1><h2><span id="q-ru-he-she-ji-token">Q:  如何设计token？</span><a href="#q-ru-he-she-ji-token" class="header-anchor">#</a></h2><p>A:<br>token进行加密处理，将请求 URL、时间戳、加密后的token、 三者进行合并加盐签名，因为盐值是保密的，所以其他人只是得到token的话，无法进行正确的签名，后端验证请求的签名值来判断请求是否有效。</p><hr><h2><span id="q-token-xie-lu-zen-me-ban">Q: token泄露怎么办？</span><a href="#q-token-xie-lu-zen-me-ban" class="header-anchor">#</a></h2><p>A:<br>每次请求可以将token和请求的对应的ip地址或设备id保存起来，放到数据库或者redis缓存中，如果后面请求token对应的ip地址或设备id不一样，则视为非法请求</p><p>HTTPS保护。</p><p>应用程序里用到的时候再解密。  如果支持TEE的话可以在TEE里进行解密。</p><p><a href="https://blog.csdn.net/junwua/article/details/80506399">理解证书和证书链</a></p><h1><span id="yun-fu-wu-aksk">云服务AKSK</span><a href="#yun-fu-wu-aksk" class="header-anchor">#</a></h1>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j远程调用漏洞详解</title>
      <link href="/2022/08/20/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/log4j%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/20/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/log4j%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-log4j-li-de-fu-hao-shi-shi-me-you-shi-me-yong">Q: log4j里的”${}“符号是什么？有什么用？</a></li><li><a href="#q-shang-mian-zhe-ge-da-yin-ben-ji-xin-xi-de-shi-lou-dong-de-yuan-yin-ma-kan-qi-lai-hao-xiang-ke-yi-zai-ji-qi-li-zhi-xing-qi-guai-de-ming-ling-huo-zhe-cha-kan-wen-jian-lu-jing">Q: 上面这个打印本机信息的是漏洞的原因吗？看起来好象可以在机器里执行奇怪的命令？或者查看文件路径？</a></li><li><a href="#q-shi-me-shi-jndi">Q: 什么是JNDI？</a></li><li><a href="#q-rmi-shi-shi-me">Q: RMI是什么？</a></li><li><a href="#q-rmi-ke-hu-duan-bu-xu-yao-guan-xin-fu-wu-duan-de-jian-ting-duan-kou-na-ke-hu-duan-cong-na-li-na-dao-stub-dui-xiang-ni-zong-bu-ke-neng-ping-kong-sheng-cheng-ba">Q:RMI客户端不需要关心服务端的监听端口？ 那客户端从哪里拿到stub对象呢？总不可能凭空生成吧</a></li><li><a href="#q-na-jndi-he-rmi-you-shi-shi-me-guan-xi-zen-me-jiu-lian-xi-dao-yi-qi-liao">Q: 那JNDI和RMI又是什么关系？怎么就联系到一起了</a></li><li><a href="#q-dan-shi-gang-cai-ti-dao-wo-men-zhi-hui-tong-guo-rmi-qu-na-dao-yi-ge-stub-stub-li-de-nei-rong-jin-jin-shi-tong-guo-te-ding-de-ip-port-qu-zuo-fa-song-dai-ma-shi-gu-ding-de-zai-zen-me-e-yi-de-ming-ling-ye-zhi-hui-zai-rmi-zhu-ce-zhong-xin-ji-hei-ke-de-fu-wu-qi-shang-zhi-xing-zen-me-jiu-zai-wo-zhe-bian-hong-fa-liao-gong-ji">Q: 但是刚才提到，我们只会通过RMI去拿到一个stub，stub里的内容仅仅是通过特定的ip+port去做发送， 代码是固定的，再怎么恶意的命令， 也只会在<strong>RMI注册中心即黑客的服务器</strong>上执行， 怎么就在我这边触发了攻击？</a></li><li><a href="#q-na-me-log4j-core-2-15-ban-ben-you-shi-zen-me-gai-de-ni">Q: 那么log4j-core 2.15版本又是怎么改的呢？</a></li><li><a href="#si-kao">思考</a></li></ul><!-- tocstop --></div> <p>[toc]<br>log4j 远程代码漏洞问题被大范围曝光后已经有一段时间了。</p><p>很多人只能看到一个“弹出一个计算器”的演示， 于是内心想着“哦，就是执行任意代码，启动个计算器” ， 却对这个漏洞的原理不甚了解。<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%20-%20%E5%89%AF%E6%9C%AC/1639878609478078932.png" alt="image.png"></p><p>而对于java开发应用不是非常深的同学来讲， jndi、rmi更是很陌生的名词。<br>这里会以不断提问的方式，逐步推进这个问题的解答， 一步步揭开这个漏洞的本质，并给出对这个漏洞的思考。</p><hr><h2><span id="q-log4j-li-de-fu-hao-shi-shi-me-you-shi-me-yong">Q: log4j里的”${}“符号是什么？有什么用？</span><a href="#q-log4j-li-de-fu-hao-shi-shi-me-you-shi-me-yong" class="header-anchor">#</a></h2><p>A:<br>可以通过$ { }的方式， 打印一些特殊的值到日志中。<br>例如$ {hostName} 就可以打印主机名<br>$ {java:vm} 打印jvm信息<br>$ {thread:threadName}就可以打印线程名</p><p>当你把这个值作为日志的参数， 就会打印出来这些值而非原参数名字。</p><p>可以理解为log4j的功能更强大了，不需要自己写java代码来打印这些信息，直接用一个字符串就能搞定这些打印。</p><p>上面这些都是要实现对应的Lookup类才能做的，即要么log4j内置，要么我们自己新增。</p><hr><h2><span id="q-shang-mian-zhe-ge-da-yin-ben-ji-xin-xi-de-shi-lou-dong-de-yuan-yin-ma-kan-qi-lai-hao-xiang-ke-yi-zai-ji-qi-li-zhi-xing-qi-guai-de-ming-ling-huo-zhe-cha-kan-wen-jian-lu-jing">Q:  上面这个打印本机信息的是漏洞的原因吗？看起来好象可以在机器里执行奇怪的命令？或者查看文件路径？</span><a href="#q-shang-mian-zhe-ge-da-yin-ben-ji-xin-xi-de-shi-lou-dong-de-yuan-yin-ma-kan-qi-lai-hao-xiang-ke-yi-zai-ji-qi-li-zhi-xing-qi-guai-de-ming-ling-huo-zhe-cha-kan-wen-jian-lu-jing" class="header-anchor">#</a></h2><p>A:<br>不是的。<br>上面这些lookup，都是事先定义好的一些loopup字符， 并不能做任意的事情！<br>而且就算你发了这些${java.vm}啥的， 也只能在服务端打印和收集，你作为攻击者，是收集不到这些信息的</p><p>真正的原因，是因为log4j 支持的  ${jndi:xxxx}， 即支持jndi进行lookup来寻找对象并打印。</p><hr><h2><span id="q-shi-me-shi-jndi">Q: 什么是JNDI？</span><a href="#q-shi-me-shi-jndi" class="header-anchor">#</a></h2><p>A:<br>Java Naming and Directory Interface（JAVA命名和目录接口）</p><p>简单说就是可以通过JNDI， 在java环境中用一个名字， 去lookup寻找一个东西使用。</p><p>例如可以直接在自己的Java环境中配置一个数据库连接，名字叫“java:MySqlDS”<br>然后别的java进程通过jndi 去查找”java:MysqlDs“, 接着就会得到一个数据库连接。<br>这样如果1个机器有多个进程，都要用同一个连接，  完全可以修改整个java环境的jndi数据库对象，然后其他进程就能同时生效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connection conn=<span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Context就是jdni的类</span></span><br><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(); </span><br><span class="line"><span class="comment">// jndi关键方法，通过loopup找一个对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">datasourceRef</span> <span class="operator">=</span> ctx.lookup(<span class="string">&quot;java:MySqlDS&quot;</span>); </span><br><span class="line"><span class="comment">//引用数据源 </span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (Datasource) datasourceRef; </span><br><span class="line">conn = ds.getConnection(); </span><br><span class="line">...... </span><br><span class="line">c.close(); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了数据库连接， 他还支持loopup找dns， 可以弄一个dnsContext然后寻找”<a href="http://sun.com">sun.com</a>“对应的dns对象<br><a href="https://blog.csdn.net/kyle_blog/article/details/800433">使用JNDI进行高级DNS查询</a></p><p>这样log4j里就可以通过  ${jndi:dns:huaweicloud.com}来获取当前机器中huaweicloud.com对应的域名对象进行打印，来确认网络请求失败时，是否是dns获取有问题。</p><p><strong>这也就是log4j为啥要引入jndi的原因,可以更方便地获取一些可打印的对象进行日志统计。</strong></p><p>然而， jndi还支持通过RMI/LDAP+url字符串， 来寻找并获取一个<strong>远程对象</strong>。<br>这个寻找远程对象的操作，就是此次漏洞的核心问题所在。</p><hr><p>这里只讲RMI。LDAP类似，就不再论述。</p><h2><span id="q-rmi-shi-shi-me">Q: RMI是什么？</span><a href="#q-rmi-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>RMI， Remote Method Invocation。<br>具体含义：</p><ul><li>远程服务器实现具体的Java方法并提供接口</li><li>客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法</li></ul><p>在RMI中，实际上就是返回了一个stub（桩）调用对象给客户端， 然后客户都用这个stub对象去做远程调用。</p><p>这样客户端就不用关心背后网络怎么写的<br><strong>甚至不用知道对方服务是什么端口或者ip</strong><br>因此也不需要写sokect的一堆方法搞半天了，也避免了总是修改访问的url啥的。<br>具体过程如下：<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%20-%20%E5%89%AF%E6%9C%AC/1639843409683014096.png" alt="image.png"></p><ol><li>Server端监听一个端口，这个端口是JVM随机选择的；</li><li>Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作；</li><li>Client端可以调用Stub上的方法；</li><li>Stub连接到Server端监听的通信端口并提交参数；</li><li>远程Server端上执行具体的方法，并返回结果给Stub；</li><li>Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样；</li></ol><hr><h2><span id="q-rmi-ke-hu-duan-bu-xu-yao-guan-xin-fu-wu-duan-de-jian-ting-duan-kou-na-ke-hu-duan-cong-na-li-na-dao-stub-dui-xiang-ni-zong-bu-ke-neng-ping-kong-sheng-cheng-ba">Q:RMI客户端不需要关心服务端的监听端口？ 那客户端从哪里拿到stub对象呢？总不可能凭空生成吧</span><a href="#q-rmi-ke-hu-duan-bu-xu-yao-guan-xin-fu-wu-duan-de-jian-ting-duan-kou-na-ke-hu-duan-cong-na-li-na-dao-stub-dui-xiang-ni-zong-bu-ke-neng-ping-kong-sheng-cheng-ba" class="header-anchor">#</a></h2><p>A:<br>服务端那边可以启动一个 RMI注册中心服务RMIRegistry， 端口设置为统一的1099， ip也是固定的。</p><p>然后当客户端希望拿到某个服务例如订单服务order的stub对象时， 就用”order“这个名字到RMI注册中心上去请求这个stub<br>这样的话，  客户端只需要知道RMI注册中心即可， 不需要知道其他服务的ip、端口，非常节省管理成本。</p><p>服务端代码长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一个订单服务通信桩</span></span><br><span class="line"><span class="type">OrderServerStub</span> <span class="variable">stub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServerStub</span>();</span><br><span class="line"><span class="comment">// 启动一个RMI注册中心, 端口为1099</span></span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="comment">// 把OrderServer这个桩，注册到rmi://0.0.0.0:1099/order这个url上</span></span><br><span class="line">Naming.bind(<span class="string">&quot;rmi://0.0.0.0:1099/order&quot;</span>, stub);</span><br></pre></td></tr></table></figure><p>客户端的代码长这样，可以看到一个loopup就把这个桩找过来了。<br>然后就能直接调用stub里的queryOrder方法查询订单了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;kingx_kali_host&quot;</span>,<span class="number">1099</span>);</span><br><span class="line"><span class="type">OrderServerStub</span> <span class="variable">stub</span> <span class="operator">=</span> (OrderServerStub) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">stub.queryOrder(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%20-%20%E5%89%AF%E6%9C%AC/1639843428034040405.png" alt="image.png"></p><hr><h2><span id="q-na-jndi-he-rmi-you-shi-shi-me-guan-xi-zen-me-jiu-lian-xi-dao-yi-qi-liao">Q: 那JNDI和RMI又是什么关系？怎么就联系到一起了</span><a href="#q-na-jndi-he-rmi-you-shi-shi-me-guan-xi-zen-me-jiu-lian-xi-dao-yi-qi-liao" class="header-anchor">#</a></h2><p>A:<br>上面的代码里， 可以看到RMI需要自己写一段Java代码执行。<br>如果以后你不用RMI来存这个通信对象了，而是用LDAP之类的，咋办？难道代码都要重新写然后部署一份吗？</p><p>而如果能用JNDI的方式，通过一个小小的字符串，就能拿到，那就简单了。<br>那么当我需要切换通信对象的获取方式时， 切换JDNI里的设置即可。</p><p>而RMI正好实现了JNDI的spi接口，以至于能支持用JNDI+ 字符串去获取对象<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%20-%20%E5%89%AF%E6%9C%AC/1639843506047036052.png" alt="image.png"></p><p>这里贴一下SPI的概念：</p><blockquote><blockquote><p>SPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。<br>这一机制为很多框架扩展提供了可能，比如在Dubbo、JDBC中都使用到了SPI机制</p></blockquote></blockquote><ul><li>说人话，spi就是框架方提供一个interface接口，然后只要有人在服务的class发现路径下写一个实现类，就能在代码里直接用上。</li></ul><p>而log4j里，正好就支持用${jndi:rmi:x.x.x.x:1099/path}的方式进行RMI对象的获取。</p><p>log4j开发者可能本意只是方便用jndi获取各种java容器内置对象，没想到忽略了rmi的获取方式。</p><p><strong>这就导致了 我们的服务可能会访问 黑客部署的RMI服务， 获取到一个不可信的远程调用对象。</strong></p><hr><h2><span id="q-dan-shi-gang-cai-ti-dao-wo-men-zhi-hui-tong-guo-rmi-qu-na-dao-yi-ge-stub-stub-li-de-nei-rong-jin-jin-shi-tong-guo-te-ding-de-ip-port-qu-zuo-fa-song-dai-ma-shi-gu-ding-de-zai-zen-me-e-yi-de-ming-ling-ye-zhi-hui-zai-rmi-zhu-ce-zhong-xin-ji-hei-ke-de-fu-wu-qi-shang-zhi-xing-zen-me-jiu-zai-wo-zhe-bian-hong-fa-liao-gong-ji">Q: 但是刚才提到，我们只会通过RMI去拿到一个stub，stub里的内容仅仅是通过特定的ip+port去做发送， 代码是固定的，再怎么恶意的命令， 也只会在<strong>RMI注册中心即黑客的服务器</strong>上执行， 怎么就在我这边触发了攻击？</span><a href="#q-dan-shi-gang-cai-ti-dao-wo-men-zhi-hui-tong-guo-rmi-qu-na-dao-yi-ge-stub-stub-li-de-nei-rong-jin-jin-shi-tong-guo-te-ding-de-ip-port-qu-zuo-fa-song-dai-ma-shi-gu-ding-de-zai-zen-me-e-yi-de-ming-ling-ye-zhi-hui-zai-rmi-zhu-ce-zhong-xin-ji-hei-ke-de-fu-wu-qi-shang-zhi-xing-zen-me-jiu-zai-wo-zhe-bian-hong-fa-liao-gong-ji" class="header-anchor">#</a></h2><p>而且这个stub对象的class文件在我们服务器本地并没有， 难道不会报classNotFind异常吗？</p><p>A:<br>某个讲RMI注入的文章里这样说道：</p><blockquote><blockquote><p>RMI服务端除了直接绑定远程对象之外，还可以通过References引用类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。<br>绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p></blockquote></blockquote><p>​</p><ul><li>说人话，就是RMI允许客户端的java环境中没有这个stub对象</li><li>RMI服务端（那个1099端口的服务）他会返回给你一个factory（序列化传过来）， 让你调用这个factory做转换。而这个可被序列化生成的factory就是问题的根本原因。</li></ul><p>整个利用流程如下：</p><ol><li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li><li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；</li><li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li><li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li><li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；</li></ol><hr><h2><span id="q-na-me-log4j-core-2-15-ban-ben-you-shi-zen-me-gai-de-ni">Q: 那么log4j-core 2.15版本又是怎么改的呢？</span><a href="#q-na-me-log4j-core-2-15-ban-ben-you-shi-zen-me-gai-de-ni" class="header-anchor">#</a></h2><p>A:<br>限定jndi使用的协议，  禁止在jndi中用ldap、rmi去调用一些远端的服务。</p><hr><h2><span id="si-kao">思考</span><a href="#si-kao" class="header-anchor">#</a></h2><p>说实话，这个漏洞影响之所以这么大， 就是因为原理太过简单， 随便发一段rmi注册中心的demo和客户端调用demo给别人，他就能复现，甚至用这个方式去攻击。</p><p>为什么log4j的设计者当时没有考虑到呢？<br>很大概率可能是因为jndi的spi机制扩展性太强。<br>也许最初，jndi只支持dns、数据库driver等对象的命名获取</p><p>但是后来随着版本更新， JNDP通过SPI机制， 支持了RMI、LDAP等实现， 而这个是log4j开发者当时没考虑到的。</p><p>换句话说， 这是<strong>java高可扩展性和安全性的一次冲突</strong>， 因此JNDI的调用方式， 未来应该会被更加谨慎地使用了。</p><hr><p>参考文章：<br><a href="https://y4er.com/post/attack-java-jndi-rmi-ldap-1/">https://y4er.com/post/attack-java-jndi-rmi-ldap-1/</a></p><p><a href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html">https://kingx.me/Exploit-Java-Deserialization-with-RMI.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0819</title>
      <link href="/2022/08/19/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-19/"/>
      <url>/2022/08/19/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-19/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p><a href="https://leetcode.cn/problems/super-ugly-number/">313. 超级丑数 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-19/1660927304363.png" alt="1660927304363"></p><p>这个好难啊</p><p>之前做264的时候，我是直接用bfs+优先队列做的</p><p>但这一题里n很大，质因数也很大， 所以bfs要么超时要么内存溢出，这是我写的超时bfs：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span> &#123;</span><br><span class="line">        Queue&lt;Long&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">1L</span>);</span><br><span class="line">        Set&lt;Long&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>)num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> prim : primes) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">newNum</span> <span class="operator">=</span> prim * num;</span><br><span class="line">                <span class="keyword">if</span> (vis.contains(newNum)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vis.add(newNum);</span><br><span class="line">                queue.offer(newNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题我是只能看了答案才知道怎么做，甚至看答案还研究了半天，好累。</p><p>前置题目： <a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II - 力扣（LeetCode）</a> ， 里面的质因数只有[2,3,5]，以这个为例</p><p>相当于对于1~x个丑数而言，想要求第x+1个丑数</p><p>首先知道下面这个概念：</p><ul><li><p>当第8个丑数被2乘了之后，下一个可以尝试被2乘的且尽可能小的，一定是第9个丑数，不可能跳级到第10个丑数，即乘2的动作，应当<strong>按顺序</strong>发生在之前已经算出来的丑数上。</p></li><li><p>3和5都同理</p></li><li><p>且每个丑数（注意是丑数而不是非丑数）都可以被2、3、5乘一次</p></li></ul><p>那我就维护2、3、5的三个指针，每次从 各指针位置丑数 * （2或3或5） 选出最小值， 然后更新指针即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] pIndex = <span class="keyword">new</span> <span class="title class_">int</span>[primes.length];</span><br><span class="line">        Arrays.fill(pIndex, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            List&lt;Integer&gt; selectPis = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 找到最小值以及符合的指针</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">0</span>;pi&lt; primes.length;pi++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[pIndex[pi]] * primes[pi] &lt; min) &#123;</span><br><span class="line">                    min = dp[pIndex[pi]] * primes[pi];</span><br><span class="line">                    selectPis.clear();</span><br><span class="line">                    selectPis.add(pi);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[pIndex[pi]] * primes[pi] == min) &#123;</span><br><span class="line">                    selectPis.add(pi);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min;</span><br><span class="line">            <span class="comment">// 也可以先得到最小值，再逐个排除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> selectPi : selectPis) &#123;</span><br><span class="line">                pIndex[selectPi]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/partition-list-lcci/">面试题 02.04. 分割链表 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-19/1660927840571.png" alt="1660927840571"></p><p>设置2个头节点，按x的值区分处理即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> h1,node2 = h2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.val &lt; x) &#123;</span><br><span class="line">                node1.next = node;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node2.next = node;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = h2.next;</span><br><span class="line">        node2.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> h1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/bracket-lcci/">面试题 08.09. 括号 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-19/1660927848000.png" alt="1660927848000"></p><p>直接dfs即可，不会有重复，无需记忆化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, n, n, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> leftInStackCount, <span class="type">int</span> leftRealCount, <span class="type">int</span> rightRealCount, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rightRealCount == <span class="number">0</span>) &#123;</span><br><span class="line">            results.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftInStackCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            dfs(leftInStackCount-<span class="number">1</span>, leftRealCount, rightRealCount - <span class="number">1</span>, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftRealCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            dfs(leftInStackCount+<span class="number">1</span>, leftRealCount-<span class="number">1</span>, rightRealCount, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务架构从小到大演变过程</title>
      <link href="/2022/08/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/08/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-dan-ji-jia-gou">1、 单机架构</a></li><li><a href="#2-ji-qun-jia-gou-shui-ping-kuo-chong">2、 集群架构（水平扩充）</a></li><li><a href="#3-chui-zhi-chai-fen">3、 垂直拆分</a><ul><li><a href="#q-ye-wu-luo-ji-quan-bu-ou-he-zai-yi-ge-fu-wu-zhong-you-shi-me-que-dian">Q: 业务逻辑全部耦合在一个服务中有什么缺点？</a></li><li><a href="#da-xing-dian-shang-de-chai-fen-luo-ji-ju-li">大型电商的拆分逻辑举例</a></li><li><a href="#q-ye-wu-chai-fen-de-yue-xi-yue-hao-ma-hui-you-shi-me-wen-ti">Q: 业务拆分得越细越好吗， 会有什么问题？</a></li></ul></li><li><a href="#4-fu-wu-hua-jia-gou">4、服务化架构</a><ul><li><a href="#shi-me-shi-fu-wu-hua">什么是服务化？</a></li><li><a href="#mian-xiang-fu-wu-de-jia-gou">面向服务的架构</a></li><li><a href="#q-ji-qun-he-fen-bu-shi-de-qu-bie-shi-shi-me">Q: 集群和分布式的区别是什么？</a></li><li><a href="#q-wei-fu-wu-he-fen-bu-shi-de-qu-bie-shi-shi-me">Q: 微服务和分布式的区别是什么？</a></li><li><a href="#q-apig-wang-guan-jie-ru-ceng-de-zuo-yong-shi-shi-me">Q: APIG网关接入层的作用是什么？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="1-dan-ji-jia-gou">1、 单机架构</span><a href="#1-dan-ji-jia-gou" class="header-anchor">#</a></h1><p>server、文件、mysql都在同一台物理服务器上。<br>用于前期研发测试、或者访问量较小的内部管理页网站等。</p><h1><span id="2-ji-qun-jia-gou-shui-ping-kuo-chong">2、 集群架构（水平扩充）</span><a href="#2-ji-qun-jia-gou-shui-ping-kuo-chong" class="header-anchor">#</a></h1><p>这里的集群，是指各节点服务的处理能力完全一致，单纯提升业务的水平处理能力。</p><p>集群架构需要做以下重点改造：</p><ol><li>业务处理服务器 server 无状态化+集群化， 部署多台对等节点。</li><li>设置负载均衡调度服务，用于专门的负载均衡，例如ngnix自带负载均衡设置</li><li>负载均衡调度服务也要可靠， 可利用公共的公网流量接入组件（apig、elb、slb）来负责做负载均衡服务的dns轮询。</li><li>缓存使用设置分布式redis</li><li>mysql数据库做到主从分离。</li><li>静态文件下放到cdn节点， 由ISP互联网服务提供商进行下发，提升响应速度。</li></ol><h1><span id="3-chui-zhi-chai-fen">3、 垂直拆分</span><a href="#3-chui-zhi-chai-fen" class="header-anchor">#</a></h1><h2><span id="q-ye-wu-luo-ji-quan-bu-ou-he-zai-yi-ge-fu-wu-zhong-you-shi-me-que-dian">Q: 业务逻辑全部耦合在一个服务中有什么缺点？</span><a href="#q-ye-wu-luo-ji-quan-bu-ou-he-zai-yi-ge-fu-wu-zhong-you-shi-me-que-dian" class="header-anchor">#</a></h2><p>A：某个无关紧要的业务，可能因为请求量突然过大，导致影响了所有业务的使用 。  例如ths的cs里同时包含了用户埋点数据采集转发的业务逻辑， 如果这块流量突然过大， 可能导致正常行情数据都无法使用。</p><hr><h2><span id="da-xing-dian-shang-de-chai-fen-luo-ji-ju-li">大型电商的拆分逻辑举例</span><a href="#da-xing-dian-shang-de-chai-fen-luo-ji-ju-li" class="header-anchor">#</a></h2><p>首页、用户、搜索、广告、购物、订单、商品、收益结算<br><img src="/images/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/2bf084dadd4bdf645c9643d71b5a8d76e11a7855.png" alt="2bf084dadd4bdf645c9643d71b5a8d76e11a7855"></p><hr><h2><span id="q-ye-wu-chai-fen-de-yue-xi-yue-hao-ma-hui-you-shi-me-wen-ti">Q: 业务拆分得越细越好吗， 会有什么问题？</span><a href="#q-ye-wu-chai-fen-de-yue-xi-yue-hao-ma-hui-you-shi-me-wen-ti" class="header-anchor">#</a></h2><p>A:<br>维护成本会很大，并且数据库改造等都需要跟上，有时候要考虑工期进度、以及必要性等。</p><h1><span id="4-fu-wu-hua-jia-gou">4、服务化架构</span><a href="#4-fu-wu-hua-jia-gou" class="header-anchor">#</a></h1><h2><span id="shi-me-shi-fu-wu-hua">什么是服务化？</span><a href="#shi-me-shi-fu-wu-hua" class="header-anchor">#</a></h2><p>Service-Oriented Architecture  SOA架构</p><h2><span id="mian-xiang-fu-wu-de-jia-gou">面向服务的架构</span><a href="#mian-xiang-fu-wu-de-jia-gou" class="header-anchor">#</a></h2><p>可以理解为将原本的 controller- service- dao 这个过程再做拆分， 抽出公共的数据或者业务提供服务，  提供给其他服务使用。</p><p>从mvc上理解时，可以是将dao层独立成一个服务， 其他服务不再需要自己重复写dao代码，而是直接调数据获取接口即可。 这样数据获取的逻辑只要改单个服务即可，不需要多个服务同时修改。</p><p>代价就是服务间存在大量依赖关系，需要引入服务治理能力。<br><a href="https://www.zhihu.com/question/42061683?sort=created">如何通俗易懂地解释什么是SOA</a></p><hr><h2><span id="q-ji-qun-he-fen-bu-shi-de-qu-bie-shi-shi-me">Q:  集群和分布式的区别是什么？</span><a href="#q-ji-qun-he-fen-bu-shi-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>集群是把多台服务器集中在一起， 目的是实现同一个业务。<br>分布式是把不同的业务分布在不同的地方， 目的是实现不同的业务。</p><p>分布式中的每个节点都可以构成一个集群<br>但是集群却不一定是分布式的。</p><hr><h2><span id="q-wei-fu-wu-he-fen-bu-shi-de-qu-bie-shi-shi-me">Q: 微服务和分布式的区别是什么？</span><a href="#q-wei-fu-wu-he-fen-bu-shi-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>微服务是“架构设计”方式，分布式是“系统部署”方式，两者概念不同</p><p>微服务是指很小的服务，可以小到只完成一个功能，这个服务可以单独部署运行，不同服务之间通过rpc调用。</p><p>分布式是指服务部署在不同的机器上，一个服务可以提供一个或多个功能，服务之间也是通过rpc来交互或者是webservice来交互的。</p><p>两者的关系是，系统应用部署在“超过一台”服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署<br>生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p><p>简答来说</p><ul><li>微服务——拆出多种业务，不管几台机器</li><li>集群——1种业务，拆到多台机器</li><li>分布式—— x种业务，拆到1台以上，且业务之间有关联。  分布式不一定是微服务，集群也不一定是分布式， 但是分布式一定满足集群，因为机器数量肯定大于1。</li></ul><hr><h2><span id="q-apig-wang-guan-jie-ru-ceng-de-zuo-yong-shi-shi-me">Q:  APIG网关接入层的作用是什么？</span><a href="#q-apig-wang-guan-jie-ru-ceng-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h2><p>A:</p><ul><li>当业务拆分复杂时， 可通过APIG网关确定转发逻辑， 不用维护webServer的公共逻辑。</li><li>灰度发布（配置白名单或者正则，将部分用户请求导入到灰度环境）</li><li>流控</li><li>安全防护</li></ul><p>避免webServer做过多的安全修复和改造，通过网关保证外部输入安全。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS双向认证核心原理</title>
      <link href="/2022/08/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yi-chuang-ye-qian-de-zi-zhi-shen-qing-zheng-shu-qian-fa">一、创业前的资质申请——证书签发</a></li><li><a href="#er-jiu-ji-jin-shen-de-gu-ke-zheng-shu-yan-zheng">二、究极谨慎的顾客——证书验证</a></li><li><a href="#san-chao-ji-er-yin-mi-de-jiao-yi">三、超级而隐秘的交易</a></li><li><a href="#si-qi-ta-guan-jian-wen-ti">四、其他关键问题</a><ul><li><a href="#q-wei-shi-me-bu-shi-yong-fei-dui-cheng-mi-yao-jia-mi-chuan-shu-shu-ju-er-yao-yong-dui-cheng-mi-yao-zhe-yang-rao-yi-da-quan">Q: 为什么不使用非对称密钥加密 传输数据， 而要用对称密钥这样绕一大圈？</a></li><li><a href="#q-wei-shi-me-shu-ju-kai-shi-chuan-shu-zhi-hou-bu-xu-yao-zai-zuo-yan-qian-nan-dao-zhe-zhong-jian-de-shu-ju-jiu-bu-hui-zai-bei-ren-cuan-gai-huo-zhe-ti-huan-ma">Q: 为什么数据开始传输之后不需要再做验签， 难道者中间的数据就不会再被人篡改或者替换吗？</a></li><li><a href="#q-ca-gen-zheng-shu-ke-neng-bei-zao-jia-ma">Q: CA根证书可能被造假吗？</a></li><li><a href="#q-hei-ke-ba-zhe-ge-fu-wu-duan-fan-hui-de-zheng-shu-bao-cun-xia-lai-ran-hou-xia-ci-bie-ren-fang-wen-hei-ke-de-diao-yu-wang-zhan-shi-hei-ke-ba-zhe-ge-zheng-shu-yuan-feng-bu-dong-fa-hui-qu-hui-tong-guo-yan-zheng-ma">Q: 黑客把这个服务端返回的证书， 保存下来，然后下次别人访问黑客的钓鱼网站时， 黑客把这个证书原封不动发回去，会通过验证吗？</a></li></ul></li><li><a href="#wu-zong-jie-he-wan-zheng-da-tu">五、总结和完整大图</a></li></ul><!-- tocstop --></div> <p>[toc]<br>讲解HTTPS认证原理的文章非常多，也算是做web开发的基础知识了。但是这类文章看过去都有一个特点——知识点超级多，很乱。</p><p>证书、签名、公钥、私钥、哈希、CA证书、网站证书、对称非对称加解密……一堆概念夹杂在一起，导致很多人对这块只能说个所以然，却无法做到完全理解。</p><p>这里我就用 从签发证书到数据加密交互，按流程完整解释， 并在其中穿插图片和问题，来完整解释这个原理。</p><hr><h1><span id="yi-chuang-ye-qian-de-zi-zhi-shen-qing-zheng-shu-qian-fa">一、创业前的资质申请——证书签发</span><a href="#yi-chuang-ye-qian-de-zi-zhi-shen-qing-zheng-shu-qian-fa" class="header-anchor">#</a></h1><p>某天，我做了一个网站， 如果直接开放给所有人访问，那么就属于无证经营，  每个访问我网站的人，都会收到浏览器如下的警告。<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/46ac05606fa54e179c3792c53703420d.png" alt="在这里插入图片描述"><br>为了解决这个问题， 我需要去工商局也就是证书颁发机构CA（ Certificate Authority），去获取一个证书，来证明我这个网站是安全的。</p><p>CA机构要求我提供身份证 、 店铺信息等一系列申请信息，整合成一个server.req的文件， 提交给他。<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/986d2b75a7d54935a8f27af8f64e6ea3.png" alt="在这里插入图片描述"></p><p>CA机构会有专门的人进行审查，确认我的资质、合法性。审查通过后，他们就开始了证书签发工作。</p><ol><li><p>首先， 他们觉得我的网站信息太长了，不好用来做检查或者对比，于是用一个 哈希算法（可以是sha256），将其变成一个固定长度的字符串， 这个字符串被他们叫做 <strong>摘要（Digest）</strong>。</p></li><li><p>接着，他们请出了CA机构中的最高领导，将这个摘要加上领导名字 重新在纸上写了一遍，然而写出来时却是一串看不懂的线条。 这是领导独有的写法，除了他自己，任何人都无法模仿。而且普通人也根本看不懂。<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/756f291db9d3454386e666dd4a36560e.png" alt="在这里插入图片描述"></p><p>这个领导的名字叫做 <strong>CA私钥</strong>。<br>而这个看似瞎写的过程， 叫做<strong>私钥签名</strong>，即对摘要重写并暗含了自己的名字，只是一般人根本看不懂罢了。</p></li><li><p>接着他们把我的网站信息、CA签名 打包成了一个证书，颁发给我，叫我好好保管， 如果有顾客问我，我就可以把这个证书拿出来给他们看。</p></li></ol><p>我疑惑地问道： “你这个签名写得乱七八糟，谁也看不懂啊，顾客咋确认我这个是合法的证书？”<br>CA证书的机构笑了笑，说：“你只管提供就好了，顾客们自有办法”。</p><p>最终整个颁发的过程如下所示：<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/c390b12d434440c7a30d9445f881e486.png" alt="在这里插入图片描述"></p><h1><span id="er-jiu-ji-jin-shen-de-gu-ke-zheng-shu-yan-zheng">二、究极谨慎的顾客——证书验证</span><a href="#er-jiu-ji-jin-shen-de-gu-ke-zheng-shu-yan-zheng" class="header-anchor">#</a></h1><p>那天，我游荡在街头，无意发现一个我很感兴趣的店，我进入了店内，却发现这家店是新开的。</p><p>如果我不确认这家店的合法性，那么很有可能进入一家黑店，被宰或者被犯罪都有可能。</p><p>此刻我必须确认这个店家的证书是CA机构签发的，还是他自己造假的证书。</p><p>而我正好认识一位和CA私钥一起出生长大的兄弟 CA公钥（公私钥都是同时生成的），  虽然无法模仿领导的笔迹，但是能够勉强看懂。</p><p>CA公钥确认了签名是CA私钥所写，而且能够正确解读出签名中的摘要信息。<br>他还将其与经营证书上所有文字生成的新摘要进行比对， 发现确实一致，因此他认定这是合法的证书。</p><p>上面这个过程，就叫做<strong>验签</strong>， 如下所示<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/fd3a71f471c24ea18fa6377c3c493ee2.png" alt="在这里插入图片描述"><br>可是，一般能解读出签名是CA私钥所写就够了，  为什么还要比对一下摘要信息呢？</p><p>因为签名公钥只能识别出这个字是私钥所写，但是私钥曾经为别人写过很多的签名。<br>万一造假者把签名换成了其他正规店铺里抄来的签名，那怎么办？ 所以肯定得确认下这个签名的内容是不是和证书上所写的店铺是同一家。</p><p>上面的过程是<strong>单向认证</strong>，即客户端验证服务端。</p><p>如果商家担心碰到居心不良的顾客， 那么同样可以让顾客提供 类似签发过程的证书，以证明自己也是可信的顾客，  这就是<strong>双向认证。</strong></p><h1><span id="san-chao-ji-er-yin-mi-de-jiao-yi">三、超级而隐秘的交易</span><a href="#san-chao-ji-er-yin-mi-de-jiao-yi" class="header-anchor">#</a></h1><p>上面的店家和顾客，通过证书验证，确认了各自的身份。接着便决定互相进行快递交易。<br>但因为路上不安全，经常有强盗或者小偷出没，如何保证快递不被盗取很重要。</p><p>顾客打算把钱（通信数据）放在一个密码箱里， 然后设置好密码，再快递过去。<br>这个密码叫做<strong>会话密钥</strong>，任何人拿到密码都能打开密码箱，所以也叫<strong>对称密钥</strong></p><p>但是店家该怎么知道这个密码呢？</p><p>如果顾客直接把密码箱的密码快递过去， 密码在路上被小偷看到了， 那后面发出去的钱岂不是就能被小偷解开并拿到了？<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/cef207794c864ca8b74e2570ad0d39f6.png" alt="在这里插入图片描述"></p><p>这时候顾客想起来，当时拿到的商家经营证书里，  携带了一个叫 公钥的东西，  通过这个东西， 可以把 密码箱密码  变成另一串看不懂的数字， 只有商家自己能够解读这个数字。</p><p>于是顾客用公钥生成了一个 加密后的密码， 并成功送到了店家手中。</p><p><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/2b3bfbe9877e4ba88a8d90e0b3288578.png" alt="在这里插入图片描述"></p><p>店家拿到后， 使用自己的私钥成功解读出了这个密码。<br>接着店家和顾客就 都把密码箱设置成密码，进行快递， 除了店家和顾客， 其他人都无法知道这个密码是多少，  劫匪们也就无从下手了。<br><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/d5067c736c374aa98af50804e60ce213.png" alt="在这里插入图片描述"></p><h1><span id="si-qi-ta-guan-jian-wen-ti">四、其他关键问题</span><a href="#si-qi-ta-guan-jian-wen-ti" class="header-anchor">#</a></h1><p>上面过程中，还有几个关键问题，这里提出，可以先自己思考，再看答案：</p><hr><h2><span id="q-wei-shi-me-bu-shi-yong-fei-dui-cheng-mi-yao-jia-mi-chuan-shu-shu-ju-er-yao-yong-dui-cheng-mi-yao-zhe-yang-rao-yi-da-quan">Q: 为什么不使用非对称密钥加密 传输数据， 而要用对称密钥这样绕一大圈？</span><a href="#q-wei-shi-me-bu-shi-yong-fei-dui-cheng-mi-yao-jia-mi-chuan-shu-shu-ju-er-yao-yong-dui-cheng-mi-yao-zhe-yang-rao-yi-da-quan" class="header-anchor">#</a></h2><p>A:<br>对称算法的加解密性能比非对称算法快很多， 所以非对称只用于会话密钥的传输即可， 只需要一次。</p><hr><h2><span id="q-wei-shi-me-shu-ju-kai-shi-chuan-shu-zhi-hou-bu-xu-yao-zai-zuo-yan-qian-nan-dao-zhe-zhong-jian-de-shu-ju-jiu-bu-hui-zai-bei-ren-cuan-gai-huo-zhe-ti-huan-ma">Q:  为什么数据开始传输之后不需要再做验签， 难道者中间的数据就不会再被人篡改或者替换吗？</span><a href="#q-wei-shi-me-shu-ju-kai-shi-chuan-shu-zhi-hou-bu-xu-yao-zai-zuo-yan-qian-nan-dao-zhe-zhong-jian-de-shu-ju-jiu-bu-hui-zai-bei-ren-cuan-gai-huo-zhe-ti-huan-ma" class="header-anchor">#</a></h2><p>A:<br>不会，有3个原因保证：</p><ol><li>会话密钥是会话级别， 动态生成的，只有这一次连接才会用到。因此以前废弃的会话密钥不用担心被人拿去利用。</li><li>建立连接并传递会话密钥之前，已经通过验签确认过对方身份是可信的。</li><li>没有任何第三方知道会话密钥是什么。因此第三方攻击人无法用正确的会话密钥加密数据，即无法做到伪造会话密钥来欺骗接收者的目的。</li></ol><hr><h2><span id="q-ca-gen-zheng-shu-ke-neng-bei-zao-jia-ma">Q:  CA根证书可能被造假吗？</span><a href="#q-ca-gen-zheng-shu-ke-neng-bei-zao-jia-ma" class="header-anchor">#</a></h2><p>例如黑客修改了用户机器中的CA证书，导致CA的公钥被替换了，   后面访问了黑客所在的网址时，就会验签成功。</p><p>A:<br>如果真的能修改的话，那么是可行的。<br>但是操作系统基本会内置著名CA的公钥，除非黑客已经能直接触碰你的操作系统底层了，否则基本办不到。</p><hr><h2><span id="q-hei-ke-ba-zhe-ge-fu-wu-duan-fan-hui-de-zheng-shu-bao-cun-xia-lai-ran-hou-xia-ci-bie-ren-fang-wen-hei-ke-de-diao-yu-wang-zhan-shi-hei-ke-ba-zhe-ge-zheng-shu-yuan-feng-bu-dong-fa-hui-qu-hui-tong-guo-yan-zheng-ma">Q:  黑客把这个服务端返回的证书， 保存下来，然后下次别人访问黑客的钓鱼网站时， 黑客把这个证书原封不动发回去，会通过验证吗？</span><a href="#q-hei-ke-ba-zhe-ge-fu-wu-duan-fan-hui-de-zheng-shu-bao-cun-xia-lai-ran-hou-xia-ci-bie-ren-fang-wen-hei-ke-de-diao-yu-wang-zhan-shi-hei-ke-ba-zhe-ge-zheng-shu-yuan-feng-bu-dong-fa-hui-qu-hui-tong-guo-yan-zheng-ma" class="header-anchor">#</a></h2><p>A：<br>客户端会验证成功，<br>但是客户端做公钥时<br>于是对数据进行对称+非对称加密<br>重点来了<br>钓鱼网站接收到的数据，他没法用，他没有正规网站的私钥！ 因为客户端用的是正规网站签发的公钥才可以。<br>黑客做中间人两边相互拦截，把假的签发过的公钥+证书发给客户端<br>客户端验签过程就会发现端倪， 发现他这个证书不对劲， 不是自己这边持有的CA机构正常签发出来证书。</p><hr><h1><span id="wu-zong-jie-he-wan-zheng-da-tu">五、总结和完整大图</span><a href="#wu-zong-jie-he-wan-zheng-da-tu" class="header-anchor">#</a></h1><p>上文的顾客就是客户端（也可以是浏览器），    店家就是服务端（网站）， 工商局就是可信CA机构（或者某域内自己设置的颁发机构也行）。</p><p>而一些要点总结如下：</p><ul><li>CA私钥用于签名， CA公钥用于验签</li><li>要先生成摘要，再签名。目的是为了验签后确认来源是所签的服务端。</li><li>服务端公钥用于加密，  服务端私钥用于解密。</li><li>传输数据使用对称密钥进行加密和解密。</li></ul><p><img src="/images/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/913d97b11e50460681e99eae9f0e272d.jpg" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发知识,网络安全，HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-0818</title>
      <link href="/2022/08/18/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-18/"/>
      <url>/2022/08/18/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-18/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p><a href="https://leetcode.cn/problems/sort-array-by-increasing-frequency/">1636. 按照频率将数组升序排序 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-18/1660838816939.png" alt="1660838816939"></p><p>先统计个数，然后按照个数进行排序</p><p>注意：</p><p>对于int[]，不可以直接进行Arrays.sort(nums, (a,b)-&gt;a-b);</p><p>要么先转成Integer[]</p><p>要么用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(nums).boxed().sorted((a,b)-&gt;</span><br><span class="line">                (counts[a] - counts[b) ).mapToInt(Integer::intValue).toArray()</span><br></pre></td></tr></table></figure><p>来实现，先stream然后boxed最后还要mapToInt才能toArray</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] frequencySort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            counts[num + <span class="number">100</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int[]数组不可以直接自定义排序</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums, (a,b)-&gt;a-b);</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums).boxed().sorted((a,b)-&gt;</span><br><span class="line">                counts[a+<span class="number">100</span>] != counts[b+<span class="number">100</span>] ? (counts[a+<span class="number">100</span>] - counts[b+<span class="number">100</span>]) : (b-a)).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/submissions/">剑指 Offer 30. 包含min函数的栈 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-18/1660838926999.png" alt="1660838926999"></p><p>维护2个数组即可，stack数组和min数组（毕竟往栈底看过去的最小值一定是确定的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20001</span>];</span><br><span class="line">    <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20001</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        min[index] = Math.min(x, index-<span class="number">1</span>&gt;=<span class="number">0</span> ? min[index-<span class="number">1</span>] : Integer.MAX_VALUE);</span><br><span class="line">        stack[index++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        min[index-<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换 - 力扣（LeetCode）</a></p><p><img src="/images/2022-08-18/1660838978323.png" alt="1660838978323"></p><p>时间很紧，先是相当了bfs并用记忆化处理，每次出队硬币个数最少的，类似于走迷宫了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">    </span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        Set&lt;Integer&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        vis.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.peek()[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">am</span> <span class="operator">=</span> queue.poll()[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (am == amount) &#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newAmount</span> <span class="operator">=</span> am + coin;</span><br><span class="line">                <span class="keyword">if</span> (newAmount &gt; amount) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (vis.contains(newAmount)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vis.add(newAmount);</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;count+<span class="number">1</span>, newAmount&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022-08-18/1660839037340.png" alt="1660839037340"></p><p>性能太差了</p><p>看了答案想起来这个完全可以动态规划</p><p>因为amount的范围是0~10<sup>4而非10</sup>9，完全可以把amount作为一个dp状态处理， 且coin的数量也只有12个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[amount+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amount;a++) &#123;</span><br><span class="line">            dp[(<span class="type">int</span>)a] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a - coin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[(<span class="type">int</span>)a] = Math.min(dp[(<span class="type">int</span>)a], dp[(<span class="type">int</span>)a-coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : (<span class="type">int</span>)dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022-08-18/1660839089263.png" alt="1660839089263"></p><p>性能一下子就上去了</p><p>再做一下优化，根据数据范围，去除long和int的强转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amount;a++) &#123;</span><br><span class="line">            dp[a] = <span class="number">10001</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; coin) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[a] = Math.min(dp[a], dp[a-coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">10001</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022-08-18/1660839698405.png" alt="1660839698405"></p><p>提升到11ms了</p><p>另外有个很奇怪的，下面这个的性能始终慢2ms，我感觉明明过滤了很多不必要的coins循环才对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCoin</span> <span class="operator">=</span> coins[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; coins.length;i++) &#123;</span><br><span class="line">            minCoin= Math.min(minCoin, coins[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amount;a++) &#123;</span><br><span class="line">            dp[a] = <span class="number">10001</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; minCoin) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastCoinSum</span> <span class="operator">=</span> a-coin;</span><br><span class="line">                <span class="keyword">if</span> (lastCoinSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[a] = Math.min(dp[a], dp[lastCoinSum] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">10001</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022-08-18/1660839823484.png" alt="1660839823484"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-JVM常用参数</title>
      <link href="/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-JVM%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
      <url>/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-JVM%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-client-he-server-de-dui-bi">Q：-client和-server的对比</a></li><li><a href="#q-yong-yu-pei-zhi-java-chu-shi-dui-nei-cun-de-shi">Q：用于配置java初始堆内存的是（）</a><ul><li><a href="#q-yong-yu-pei-zhi-java-dui-de-zui-da-zhi-de-shi">Q：用于配置java堆的最大值的是（）</a></li></ul></li><li><a href="#q-ru-guo-bu-she-zhi-xms-he-xmx-de-da-xiao-fen-bie-mo-ren-shi-duo-shao">Q：如果不设置，-Xms和-Xmx的大小分别默认是多少？</a></li><li><a href="#q-yong-yu-pei-zhi-xin-sheng-dai-nei-cun-da-xiao-de-zui-da-zhi-shi">Q：用于配置新生代内存大小的最大值是：（）</a><ul><li><a href="#q-ru-he-gen-ju-shang-mian-de-can-shu-ji-suan-lao-nian-dai-nei-cun-da-xiao">Q： 如何根据上面的参数计算老年代内存大小？</a></li></ul></li><li><a href="#q-yong-yu-pei-zhi-xian-cheng-zhan-nei-cun-de-shi-ti-dai-de-huan-you-na-ge-can-shu">Q： 用于配置线程栈内存的是（）？ 替代的还有哪个参数？</a></li><li><a href="#q-ke-yong-yu-guan-bi-zhen-dui-lei-dui-xiang-de-gc-gong-neng-de-shi">Q：可用于关闭针对类对象的gc功能的是（）</a></li><li><a href="#q-ke-yong-yu-jian-shao-gc-de-cheng-xu-ting-dun-shi-jian-de-shi">Q: 可用于减少gc的程序停顿时间的是（）</a></li><li><a href="#q-yong-yu-shu-chu-gc-xiang-guan-ri-zhi-de-shi">Q: 用于输出gc相关日志的是（）</a></li><li><a href="#q-verbose-yi-ban-shi-yong-yu-shi-me-de">Q：-verbose 一般是用于什么的？</a></li><li><a href="#q-xx-permsize-he-xx-maxpermsize-she-zhi-de-shi-shi-me-nei-cun">Q: -XX:PermSize和-XX:MaxPermSize设置的是什么内存？</a></li><li><a href="#q-xx-metaspacesize-he-xx-maxmetaspacesize-you-shi-shi-me-nei-cun">Q：-XX:MetaspaceSize和-XX:MaxMetaspaceSize又是什么内存？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h2><span id="q-client-he-server-de-dui-bi">Q：-client和-server的对比</span><a href="#q-client-he-server-de-dui-bi" class="header-anchor">#</a></h2><p>（）启动较快<br>（）性能和内存管理效率高(注意启动快和性能好不是一回事）<br>桌面应用一般使用（）， 服务器一般使用（）<br>A：<br>（-clien）启动较快<br>（-server）性能和内存管理效率高<br>桌面应用一般使用（-clien）， 服务器一般使用（-server）</p><hr><p>有4个跟内存相关的参数<br>-Xmn -Xms -Xmx -Xss</p><hr><h2><span id="q-yong-yu-pei-zhi-java-chu-shi-dui-nei-cun-de-shi">Q：用于配置java初始堆内存的是（）</span><a href="#q-yong-yu-pei-zhi-java-chu-shi-dui-nei-cun-de-shi" class="header-anchor">#</a></h2><p>A：<br>-Xms。<br>-X、memory、size ，内存大小</p><hr><h3><span id="q-yong-yu-pei-zhi-java-dui-de-zui-da-zhi-de-shi">Q：用于配置java堆的最大值的是（）</span><a href="#q-yong-yu-pei-zhi-java-dui-de-zui-da-zhi-de-shi" class="header-anchor">#</a></h3><p>A:<br>-Xmx。<br>-X、memory、max<br>最大内存<br><img src="2583965d5747d12e17b63fad1a4480868801656b.png" alt="2583965d5747d12e17b63fad1a4480868801656b"></p><hr><h2><span id="q-ru-guo-bu-she-zhi-xms-he-xmx-de-da-xiao-fen-bie-mo-ren-shi-duo-shao">Q：如果不设置，-Xms和-Xmx的大小分别默认是多少？</span><a href="#q-ru-guo-bu-she-zhi-xms-he-xmx-de-da-xiao-fen-bie-mo-ren-shi-duo-shao" class="header-anchor">#</a></h2><p>A：<br>不设置的话，二者相等，默认是 物理内存/64（小于1G）</p><hr><h2><span id="q-yong-yu-pei-zhi-xin-sheng-dai-nei-cun-da-xiao-de-zui-da-zhi-shi">Q：用于配置新生代内存大小的最大值是：（）</span><a href="#q-yong-yu-pei-zhi-xin-sheng-dai-nei-cun-da-xiao-de-zui-da-zhi-shi" class="header-anchor">#</a></h2><p>你问我什么是新生代内存？<br>就是下面这个，1个E区加2个S区的这个内存大小</p><p>A：<br>-Xmn。<br>-X、memory、new<br>相类似的还有-XX:NewSize 和 -XX:MaxNewSize。</p><hr><h3><span id="q-ru-he-gen-ju-shang-mian-de-can-shu-ji-suan-lao-nian-dai-nei-cun-da-xiao">Q： 如何根据上面的参数计算老年代内存大小？</span><a href="#q-ru-he-gen-ju-shang-mian-de-can-shu-ji-suan-lao-nian-dai-nei-cun-da-xiao" class="header-anchor">#</a></h3><p>A：<br>Xmx的值（堆最大值）- Xmn的值（新生代内存）</p><hr><h2><span id="q-yong-yu-pei-zhi-xian-cheng-zhan-nei-cun-de-shi-ti-dai-de-huan-you-na-ge-can-shu">Q： 用于配置线程栈内存的是（）？ 替代的还有哪个参数？</span><a href="#q-yong-yu-pei-zhi-xian-cheng-zhan-nei-cun-de-shi-ti-dai-de-huan-you-na-ge-can-shu" class="header-anchor">#</a></h2><p>A：<br>-Xss。 另一个是-XX:ThreadStackSize<br>-Xss指 -X stack size</p><hr><p>有下面3个和gc相关的参数<br>-Xnoclassgc -Xincgc -Xloggc:file<br>回答以下问题：</p><h2><span id="q-ke-yong-yu-guan-bi-zhen-dui-lei-dui-xiang-de-gc-gong-neng-de-shi">Q：可用于关闭针对类对象的gc功能的是（）</span><a href="#q-ke-yong-yu-guan-bi-zhen-dui-lei-dui-xiang-de-gc-gong-neng-de-shi" class="header-anchor">#</a></h2><p>可用于关闭针对类对象的gc功能的是（-Xnoclassgc）</p><h2><span id="q-ke-yong-yu-jian-shao-gc-de-cheng-xu-ting-dun-shi-jian-de-shi">Q: 可用于减少gc的程序停顿时间的是（）</span><a href="#q-ke-yong-yu-jian-shao-gc-de-cheng-xu-ting-dun-shi-jian-de-shi" class="header-anchor">#</a></h2><p>可用于减少gc的程序停顿时间的是（-Xincgc）</p><h2><span id="q-yong-yu-shu-chu-gc-xiang-guan-ri-zhi-de-shi">Q: 用于输出gc相关日志的是（）</span><a href="#q-yong-yu-shu-chu-gc-xiang-guan-ri-zhi-de-shi" class="header-anchor">#</a></h2><p>用于输出gc相关日志的是（-Xloggc:file）</p><hr><h2><span id="q-verbose-yi-ban-shi-yong-yu-shi-me-de">Q：-verbose 一般是用于什么的？</span><a href="#q-verbose-yi-ban-shi-yong-yu-shi-me-de" class="header-anchor">#</a></h2><p>A：<br>查询gc问题。</p><p>-verbose:class 输出jvm载入类的相关信息，当jvm报告说找不到类或者类冲突时可此进行诊断。<br>-verbose:gc 输出每次GC的相关情况，后面会有更详细的介绍。<br>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息。</p><hr><h2><span id="q-xx-permsize-he-xx-maxpermsize-she-zhi-de-shi-shi-me-nei-cun">Q: -XX:PermSize和-XX:MaxPermSize设置的是什么内存？</span><a href="#q-xx-permsize-he-xx-maxpermsize-she-zhi-de-shi-shi-me-nei-cun" class="header-anchor">#</a></h2><p>A：<br>方法区的内存。就是最开始那个图里的这个</p><p>通过配置-XX:PermSize以及-XX:MaxPermSize来控制这块内存的大小，jvm在启动的时候会根据-XX:PermSize初始化分配一块连续的内存块，这样的话，如果-XX:PermSize设置过大，可能会很浪费。而Max如果设置小了，可能会omm。</p><hr><h2><span id="q-xx-metaspacesize-he-xx-maxmetaspacesize-you-shi-shi-me-nei-cun">Q：-XX:MetaspaceSize和-XX:MaxMetaspaceSize又是什么内存？</span><a href="#q-xx-metaspacesize-he-xx-maxmetaspacesize-you-shi-shi-me-nei-cun" class="header-anchor">#</a></h2><p>A：<br>元数据区内存。 java8引入的，用于替代上面的perm区。<br>无论-XX:MetaspaceSize和-XX:MaxMetaspaceSize两个参数如何设置，随着类加载越来越多不断扩容调整，直到MetaspaceSize(如果没有配置就是默认20.8m)触发FGC，上限是-XX:MaxMetaspaceSize，默认是几乎无穷大</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java新版本特性</title>
      <link href="/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
      <url>/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#java8-te-xing">java8特性</a><ul><li><a href="#1-lambda-biao-da-shi-ba-han-shu-zuo-wei-yi-ge-fang-fa-de-can-shu">1. lambda表达式。把函数作为一个方法的参数</a></li><li><a href="#2-stream-api">2. Stream api</a></li><li><a href="#3-xin-zeng-liao-jie-kou-de-mo-ren-fang-fa-zhi-chi-default-shi-xian-liao">3.新增了接口的默认方法，支持default实现了</a></li><li><a href="#4-xin-zeng-optional-lei-jie-jue-kong-zhi-zhen-pan-duan-wen-ti">4.新增Optional 类，解决空指针判断问题</a></li><li><a href="#5-xin-zeng-base64-bian-ma-ku">5.新增Base64编码库</a></li></ul></li><li><a href="#java11-xin-te-xing">JAVA11新特性</a><ul><li><a href="#1-zhi-chi-ju-bu-bian-liang-lei-xing-tui-duan">1. 支持局部变量类型推断</a></li><li><a href="#2-zi-fu-chuan-api-zeng-qiang">2. 字符串api增强</a></li><li><a href="#3-stream-zeng-qiang">3. stream增强</a></li><li><a href="#4-optional-zeng-qiang">4. Optional增强</a></li><li><a href="#5-zheng-shi-yin-ru-http-client-api">5. 正式引入HTTP Client API</a></li><li><a href="#6-zhi-chi-jshell-lei-si-py-shell">6.支持jshell，类似py shell</a></li><li><a href="#7-mo-ren-shi-yong-g1-shou-ji-qi-qie-jvm-he-la-ji-shou-ji-you-guan-de-can-shu-she-zhi-jin-xing-liao-hen-duo-diao-zheng">7.默认使用G1收集器，且jvm和垃圾收集有关的参数设置进行了很多调整</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><blockquote></blockquote><hr><h1><span id="java8-te-xing">java8特性</span><a href="#java8-te-xing" class="header-anchor">#</a></h1><h2><span id="1-lambda-biao-da-shi-ba-han-shu-zuo-wei-yi-ge-fang-fa-de-can-shu">1. lambda表达式。把函数作为一个方法的参数</span><a href="#1-lambda-biao-da-shi-ba-han-shu-zuo-wei-yi-ge-fang-fa-de-can-shu" class="header-anchor">#</a></h2><ul><li>也叫闭包</li><li>相对应的，还多了函数式接口，二者可以配合使用</li></ul><h2><span id="2-stream-api">2. Stream api</span><a href="#2-stream-api" class="header-anchor">#</a></h2><ul><li>提供一种对Java集合运算和表达的高阶抽象，引入map、reduce等方法。</li><li>map方法中还支持 类名::方法名的调用方式，来单独调用方法<br>把map(a-&gt;a.getX())简写成了map(A::getX)</li></ul><h2><span id="3-xin-zeng-liao-jie-kou-de-mo-ren-fang-fa-zhi-chi-default-shi-xian-liao">3.新增了接口的默认方法，支持default实现了</span><a href="#3-xin-zeng-liao-jie-kou-de-mo-ren-fang-fa-zhi-chi-default-shi-xian-liao" class="header-anchor">#</a></h2><h2><span id="4-xin-zeng-optional-lei-jie-jue-kong-zhi-zhen-pan-duan-wen-ti">4.新增Optional 类，解决空指针判断问题</span><a href="#4-xin-zeng-optional-lei-jie-jue-kong-zhi-zhen-pan-duan-wen-ti" class="header-anchor">#</a></h2><h2><span id="5-xin-zeng-base64-bian-ma-ku">5.新增Base64编码库</span><a href="#5-xin-zeng-base64-bian-ma-ku" class="header-anchor">#</a></h2><hr><h1><span id="java11-xin-te-xing">JAVA11新特性</span><a href="#java11-xin-te-xing" class="header-anchor">#</a></h1><h2><span id="1-zhi-chi-ju-bu-bian-liang-lei-xing-tui-duan">1. 支持局部变量类型推断</span><a href="#1-zhi-chi-ju-bu-bian-liang-lei-xing-tui-duan" class="header-anchor">#</a></h2><p>可以写var这种变量声明了，编译器能自动识别，可加快部分情况下的编程速度。<br>var a = 1;<br>var s = “abcd”;</p><p>但是会加重编译器负担。</p><h2><span id="2-zi-fu-chuan-api-zeng-qiang">2. 字符串api增强</span><a href="#2-zi-fu-chuan-api-zeng-qiang" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;\t \n\r &quot;</span>;</span><br><span class="line">        <span class="comment">//判断字符串是否是空白字符</span></span><br><span class="line">        System.out.println(str1.isBlank());</span><br><span class="line">        System.out.println(<span class="string">&quot;*****===========&quot;</span>);</span><br><span class="line">        str1 = <span class="string">&quot;\t abc \r \n  &quot;</span>;</span><br><span class="line">        <span class="comment">//去除字符串首尾中的空白，包括英文和其它所有语言的空白字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">strip</span> <span class="operator">=</span> str1.strip();</span><br><span class="line">        <span class="comment">//去除字符串首部的空白，包括汉字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stripLeading</span> <span class="operator">=</span> strip.stripLeading();</span><br><span class="line">        <span class="comment">//去除字符串尾部的空白，包括汉字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stripTrailing</span> <span class="operator">=</span> strip.stripTrailing();</span><br><span class="line">        System.out.println(strip+<span class="string">&quot;&lt;====&gt;&quot;</span>+strip.length());</span><br><span class="line"></span><br><span class="line">        str1 = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">        str1.repeat(<span class="number">3</span>);<span class="comment">//把str1 重复三次，输出   javajavajava</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//去除字符串首尾中的空白，只能去除码值小于32的(如果是中文全角的空白是去除不了的)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trim</span> <span class="operator">=</span> str1.trim();</span><br><span class="line">        System.out.println(trim+<span class="string">&quot;&lt;====&gt;&quot;</span>+trim.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-stream-zeng-qiang">3. stream增强</span><a href="#3-stream-zeng-qiang" class="header-anchor">#</a></h2><ul><li>支持Stream.ofNullable(null)生成一个值的流</li><li>支持while循环，符合一个条件就take结束或者开始计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第一个开始计算，当 n &lt; 3 时就截止</span></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).takeWhile(n -&gt; n &lt; <span class="number">3</span>) .collect(Collectors.toList()); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始不计算，当n&lt;3不成立时开始计算</span></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).dropWhile(n -&gt; n &lt; <span class="number">3</span>) .collect(Collectors.toList()); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h2><span id="4-optional-zeng-qiang">4. Optional增强</span><a href="#4-optional-zeng-qiang" class="header-anchor">#</a></h2><p>支持orElseThrow等语法。</p><h2><span id="5-zheng-shi-yin-ru-http-client-api">5. 正式引入HTTP Client API</span><a href="#5-zheng-shi-yin-ru-http-client-api" class="header-anchor">#</a></h2><p>和Apache 的 HttpClient的区别？<br><img src="/images/java%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/8d27930b8e75caf9a2a4c131ad4d6380131d2630.png" alt="8d27930b8e75caf9a2a4c131ad4d6380131d2630"></p><h2><span id="6-zhi-chi-jshell-lei-si-py-shell">6.支持jshell，类似py shell</span><a href="#6-zhi-chi-jshell-lei-si-py-shell" class="header-anchor">#</a></h2><p>可以节省验证demo的时间<br><img src="/images/java%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/83c6d5568870f9f8ac73fe489efa93832ab7d598.png" alt="83c6d5568870f9f8ac73fe489efa93832ab7d598"></p><h2><span id="7-mo-ren-shi-yong-g1-shou-ji-qi-qie-jvm-he-la-ji-shou-ji-you-guan-de-can-shu-she-zhi-jin-xing-liao-hen-duo-diao-zheng">7.默认使用G1收集器，且jvm和垃圾收集有关的参数设置进行了很多调整</span><a href="#7-mo-ren-shi-yong-g1-shou-ji-qi-qie-jvm-he-la-ji-shou-ji-you-guan-de-can-shu-she-zhi-jin-xing-liao-hen-duo-diao-zheng" class="header-anchor">#</a></h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-JDBC应用和原理</title>
      <link href="/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-JDBC-API/"/>
      <url>/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-JDBC-API/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#connection-setautocommit-boolean">Connection.setAutoCommit(boolean)</a><ul><li><a href="#q-setautocommit-mo-ren-shi-true-huan-shi-false">Q： setAutoCommit默认是true还是false</a></li><li><a href="#q-setautocommit-false-hou-ru-guo-chu-liao-cuo-que-mei-you-zai-catch-zhong-jin-xing-connection-de-rollback-cao-zuo-hui-fa-sheng-shi-me">Q： setAutoCommit(false)后，如果出了错却没有在catch中进行Connection的rollBack操作，会发生什么？</a></li></ul></li><li><a href="#fetchsize">fetchSize</a><ul><li><a href="#fetchsize-shi-she-ding-jdbc-de-statement-du-qu-shu-ju-de-shi-hou-mei-ci-cong-shu-ju-ku-zhong-qu-chu-de-ji-lu-tiao-shu">fetchSize 是设定JDBC的Statement读取数据的时候每次从数据库中取出的记录条数</a></li><li><a href="#q-oracle-he-mysql-zhong-de-fetchsize-you-shi-me-qu-bie">Q： Oracle和Mysql中的fetchSize有什么区别？</a></li></ul></li><li><a href="#preparedstatement">PreparedStatement</a><ul><li><a href="#q-shi-yong-preparedstatement-xiang-bi-statement-de-hao-chu">Q：使用PreparedStatement相比Statement的好处？</a></li><li><a href="#q-preparestatement-shi-statement-jie-kou-de-shi-xian-ma">Q：prepareStatement是statement接口的实现吗？</a></li></ul></li><li><a href="#callablestatement">CallableStatement</a></li><li><a href="#connection-pool">Connection Pool</a></li><li><a href="#resultset">ResultSet</a><ul><li><a href="#q-connection-statement-resultset-de-guan-bi-shun-xu-shi">Q:Connection、statement、ResultSet的关闭顺序是？</a></li></ul></li><li><a href="#xiang-guan-yuan-li">相关原理</a><ul><li><a href="#q-jdbc-de-spi-ji-zhi-you-liao-jie-ma">Q: JDBC 的spi机制有了解吗？</a></li><li><a href="#q-jdbc-driver-shi-yong-shi-me-classloader-jia-zai-de-he-xian-cheng-shang-xia-wen-you-you-shi-me-guan-xi">Q: jdbc driver是用什么classloader加载的？  和线程上下文又有什么关系？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="connection-setautocommit-boolean">Connection.setAutoCommit(boolean)</span><a href="#connection-setautocommit-boolean" class="header-anchor">#</a></h1><p>用于事务提交。<br>setAutoCommit（true），  则执行的所有sql执行都会作为单个事务直接提交并运行<br>setAutoCommit（false）， 则必须等调用conn.commit(）才会提交运行</p><h2><span id="q-setautocommit-mo-ren-shi-true-huan-shi-false">Q： setAutoCommit默认是true还是false</span><a href="#q-setautocommit-mo-ren-shi-true-huan-shi-false" class="header-anchor">#</a></h2><p>A： 默认是true。</p><p>Q： setAutoCommit（true）的缺点是什么？<br>A： 如果一次性执行多个sql语句， 中间sql出错时，就会造成脏数据。</p><h2><span id="q-setautocommit-false-hou-ru-guo-chu-liao-cuo-que-mei-you-zai-catch-zhong-jin-xing-connection-de-rollback-cao-zuo-hui-fa-sheng-shi-me">Q： setAutoCommit(false)后，如果出了错却没有在catch中进行Connection的rollBack操作，会发生什么？</span><a href="#q-setautocommit-false-hou-ru-guo-chu-liao-cuo-que-mei-you-zai-catch-zhong-jin-xing-connection-de-rollback-cao-zuo-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2><p>A;  操作的表就会被锁住，造成数据库死锁</p><h1><span id="fetchsize">fetchSize</span><a href="#fetchsize" class="header-anchor">#</a></h1><h2><span id="fetchsize-shi-she-ding-jdbc-de-statement-du-qu-shu-ju-de-shi-hou-mei-ci-cong-shu-ju-ku-zhong-qu-chu-de-ji-lu-tiao-shu">fetchSize 是设定JDBC的Statement读取数据的时候每次从数据库中取出的记录条数</span><a href="#fetchsize-shi-she-ding-jdbc-de-statement-du-qu-shu-ju-de-shi-hou-mei-ci-cong-shu-ju-ku-zhong-qu-chu-de-ji-lu-tiao-shu" class="header-anchor">#</a></h2><ul><li>fetchSize越 <em><strong>大</strong></em>， 客户端内存占用越 <em><strong>大</strong></em>，读取数据库次数越 <em><strong>少</strong></em>，速度越 <em><strong>快</strong></em>。</li></ul><h2><span id="q-oracle-he-mysql-zhong-de-fetchsize-you-shi-me-qu-bie">Q： Oracle和Mysql中的fetchSize有什么区别？</span><a href="#q-oracle-he-mysql-zhong-de-fetchsize-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A： Oracle会每次网络传输fetchSize条数据到客户端， MYSQL则会一次性全部传送到客户端，因此Mysql中的fetchSize是一种模拟游标。</p><h1><span id="preparedstatement">PreparedStatement</span><a href="#preparedstatement" class="header-anchor">#</a></h1><h2><span id="q-shi-yong-preparedstatement-xiang-bi-statement-de-hao-chu">Q：使用PreparedStatement相比Statement的好处？</span><a href="#q-shi-yong-preparedstatement-xiang-bi-statement-de-hao-chu" class="header-anchor">#</a></h2><p>A：</p><ol><li>PreparedStatement是预编译的，比Statement速度快，执行效率高，因此即使sql中不带参数也最好使用PreparedStatement</li><li>代码的可读性和可维护性更好(相比于sql拼接）</li><li>PreparedStatement可以防止SQL注入攻击，而Statement却不能</li></ol><hr><h2><span id="q-preparestatement-shi-statement-jie-kou-de-shi-xian-ma">Q：prepareStatement是statement接口的实现吗？</span><a href="#q-preparestatement-shi-statement-jie-kou-de-shi-xian-ma" class="header-anchor">#</a></h2><p>A：<br>prepareStatement不是实现，而是继承的接口<br><img src="/images/java-JDBC-API/0a20a5f49a20cca0aa7b8e2b3bf04a98ad855e40.png" alt="0a20a5f49a20cca0aa7b8e2b3bf04a98ad855e40"></p><h1><span id="callablestatement">CallableStatement</span><a href="#callablestatement" class="header-anchor">#</a></h1><ul><li>CallableStatement继承自PreparedStatement</li><li>CallableStatement接口添加了 <em><strong>调用存储过程</strong></em> 核函数以及处理输出参数(INOUT)的方法。</li><li>即存储过程就用CallableStatement</li></ul><h1><span id="connection-pool">Connection Pool</span><a href="#connection-pool" class="header-anchor">#</a></h1><p>连接池优点：</p><ol><li>减少连接创建次数</li><li>更快的系统整体响应速度</li><li>统一连接管理，减少失误性的连接未关闭。</li></ol><h1><span id="resultset">ResultSet</span><a href="#resultset" class="header-anchor">#</a></h1><p>作用： 缓存数据结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn. createStatement (<span class="type">int</span> resultSetType, <span class="type">int</span> resultSetConcurrency)</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sqlStr)</span><br></pre></td></tr></table></figure><p>滚动，就是指调用.next()或者.previous()或者移动到对应行<br><br><br>resultSetType 是设置 ResultSet 对象的类型可滚动，或者是不可滚动。取值如下（见单词知意）：</p><ul><li>ResultSet.TYPE_FORWARD_ONLY 只能向前滚动</li><li>ResultSet.TYPE_SCROLL_INSENSITIVE, 支持前后滚动，对修改不敏感</li><li>ResultSet.TYPE_SCROLL_SENSITIVE   支持前后滚动，对修改敏感</li></ul><br>  resultSetConcurency 是设置 ResultSet 对象能够修改的，取值如下：<ul><li>ResultSet.CONCUR_READ_ONLY 设置为只读类型的参数。</li><li>ResultSet.CONCUR_UPDATABLE 设置为可修改类型的参数。</li></ul><hr><h2><span id="q-connection-statement-resultset-de-guan-bi-shun-xu-shi">Q:Connection、statement、ResultSet的关闭顺序是？</span><a href="#q-connection-statement-resultset-de-guan-bi-shun-xu-shi" class="header-anchor">#</a></h2><p>A：<br>先ResultSet、再Statement、最后再connection。<br>因为这种操作很麻烦，最好使用jdbc连接池，或者try-with-resource</p><hr><h1><span id="xiang-guan-yuan-li">相关原理</span><a href="#xiang-guan-yuan-li" class="header-anchor">#</a></h1><h2><span id="q-jdbc-de-spi-ji-zhi-you-liao-jie-ma">Q: JDBC 的spi机制有了解吗？</span><a href="#q-jdbc-de-spi-ji-zhi-you-liao-jie-ma" class="header-anchor">#</a></h2><p>A：<br>SPI机制（Service Provider Interface)其实源自服务提供者框架（Service Provider Framework，参考【EffectiveJava】page6)，是一种将服务接口与服务实现分离以达到解耦、大大提升了程序可扩展性的机制。引入服务提供者就是引入了spi接口的实现者，通过本地的注册发现获取到具体的实现类，轻松可插拔</p><p>关键在于serviceLoader去加载某路径下相关的driver包，获取出一个列表。</p><ol><li>通过SPI方式，读取 META-INF/services 下文件中的类名，使用TCCL加载；</li><li>通过System.getProperty(“jdbc.drivers”)获取设置，然后通过系统类加载器加载。<br><img src="/images/java-JDBC-API/00f3c667eed44817134e87e4bb8ec08084a89177.png" alt="00f3c667eed44817134e87e4bb8ec08084a89177"><br><img src="/images/java-JDBC-API/dd2a60f8ad344663f1502b1604b1db5519659a73.png" alt="dd2a60f8ad344663f1502b1604b1db5519659a73"><br>后面根据url去查找匹配的driver，每个deriver都有一个match方法</li></ol><p><a href="https://blog.csdn.net/lemon89/article/details/79189475?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242.1">深入理解java SPI机制</a></p><hr><h2><span id="q-jdbc-driver-shi-yong-shi-me-classloader-jia-zai-de-he-xian-cheng-shang-xia-wen-you-you-shi-me-guan-xi">Q: jdbc driver是用什么classloader加载的？  和线程上下文又有什么关系？</span><a href="#q-jdbc-driver-shi-yong-shi-me-classloader-jia-zai-de-he-xian-cheng-shang-xia-wen-you-you-shi-me-guan-xi" class="header-anchor">#</a></h2><p>A:</p><ul><li><p>Class.forName(DriverName, false, loader)代码所在的类在java.util.ServiceLoader类中，而ServiceLoader.class又加载在BootrapLoader中，因此传给 forName 的 loader 必然不能是BootrapLoader，复习双亲委派加载机制请看：java类加载器不完整分析 。这时候只能使用TCCL了，也就是说把自己加载不了的类加载到TCCL中（通过Thread.currentThread()获取，简直作弊啊！）。上面那篇文章末尾也讲到了TCCL默认使用当前执行的是代码所在应用的系统类加载器AppClassLoader。</p></li><li><p>ContextClassLoader默认存放了AppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。</p></li><li><p>我（JDK）提供了一种帮你（第三方实现者）加载服务（如数据库驱动、日志库）的便捷方式，只要你遵循约定（把类名写在/META-INF里），那当我启动时我会去扫描所有jar包里符合约定的类名，再调用forName加载，但我的ClassLoader是没法加载的，那就把它加载到当前执行线程的TCCL里，后续你想怎么操作（驱动实现类的static代码块）就是你的事了。<br><a href="https://blog.csdn.net/yangcheng33/article/details/52631940">真正理解线程上下文类加载器（多案例分析)</a></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-JNI应用</title>
      <link href="/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-JNI%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-JNI%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shi-me-shi-jni">什么是JNI？</a></li><li><a href="#jni-ying-yong-bu-zou">JNI应用步骤</a></li><li><a href="#jni-de-di-ceng-yuan-li">JNI的底层原理</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="shi-me-shi-jni">什么是JNI？</span><a href="#shi-me-shi-jni" class="header-anchor">#</a></h1><p>JNI即Java Native Interface(Java本地接口)<br>是一个协议，主要作用为：实现Java调用c/c<ins>代码（类库）,或者C/C</ins>调用Java代码</p><hr><h1><span id="jni-ying-yong-bu-zou">JNI应用步骤</span><a href="#jni-ying-yong-bu-zou" class="header-anchor">#</a></h1><ol><li>首先定义java类</li></ol><ul><li>类里需要有一个native关键字的方法</li><li>静态代码块加载一个C++生成的dll</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JNI.java文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNI</span>&#123;</span><br><span class="line">   <span class="comment">//创建一个native接口方法，此方法在C++代码中实现</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">//静态代码块，加载由C++代码生成的.dll动态链接文件（.dll相当于Java中的jar包吧...）</span></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       System.loadLibrary(<span class="string">&quot;JNIdll&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用javac 编译JNI.java生成字节码文件JNI.class<br><img src="/images/java-JNI%E5%BA%94%E7%94%A8/2e3b00fcc7db910ee0cc332308f69b08448d0333.png" alt="2e3b00fcc7db910ee0cc332308f69b08448d0333"></p></li><li><p>使用javah 编译JNI.class， 将class文件转成头文件<br><img src="/images/java-JNI%E5%BA%94%E7%94%A8/c5a38ef4c9ca5f2aaf60ee8a01699958fe0f0ece.png" alt="c5a38ef4c9ca5f2aaf60ee8a01699958fe0f0ece"><br>头文件中包含了call方法的声明<br><img src="/images/java-JNI%E5%BA%94%E7%94%A8/ef461a898064377ae54e50e2c75daac5ad35b3a3.png" alt="ef461a898064377ae54e50e2c75daac5ad35b3a3"></p></li><li><p>编写cpp文件，实现头文件中的call方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JNIdll.cpp文件</span></span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;jni.h&gt;</span><br><span class="line">#include <span class="string">&quot;JNI.h&quot;</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL <span class="title function_">Java_JNI_call</span></span><br><span class="line">  <span class="params">(JNIEnv *, jobject)</span>&#123;</span><br><span class="line">      <span class="comment">//实现代码</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">777</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>将java目录下的include目录下的两个文件jni.h和jni_md.h（jni_md.h在include目录下的win32目录中）拷贝到vc的include目录下, 好让C++环境支持jni</p></li><li><p>用C/C++编译命令编译cpp和h文件，生成dll动态链接库<br><img src="/images/java-JNI%E5%BA%94%E7%94%A8/7da23cd5f25cc82ce66c07e3ee06f7e09717a5f9.png" alt="7da23cd5f25cc82ce66c07e3ee06f7e09717a5f9"></p></li></ol><hr><h1><span id="jni-de-di-ceng-yuan-li">JNI的底层原理</span><a href="#jni-de-di-ceng-yuan-li" class="header-anchor">#</a></h1><ol><li><p>jvm调用native方法时， 其方法指针nativeFunc默认先指向resolveNativeMethod方法</p></li><li><p>resolveNativeMethod方法中， 是一段通用的实现代码<br>首先，判断这个方法如果是静态方法，首先确保所属的class已经初始化，否则会报错<br><img src="/images/java-JNI%E5%BA%94%E7%94%A8/c1b4d05e0a5342c8159fbc8187caf6c2fb514775.png" alt="c1b4d05e0a5342c8159fbc8187caf6c2fb514775"></p></li><li><p>接着先在内部本地方法表中查询。<br>内部本地方法表是一个集合，这个集合里包含了java语言和虚拟机本身用到的所有native方法<br>根据类描述符的hash值从集合中寻找对应的方法<br>如果找到了，就修改nativeFunc的指针，指向对应方法</p></li><li><p>如果内部本地方法表里没找到， 才会通过System.loadLibrary加载的so，虚拟机会将所有的so存入一个表中<br>gDvm.nativeLibs是一个HashTable，其中存的是动态链接库的信息。其中的数据是通过System.loadLibrary添加进去的。</p></li></ol><p>① 检查是否已经加载过该so，如果是还需要判断加载so的classLoader是否相同，不同的话也会报错，<br>②如果没有加载过，则使用dlopen打开so，然后创建一个ShareLib加入到gDvm.nativeLibs哈希表中。<br>③如果so中有JNI_OnLoad方法，则执行该方法。我们可以在该方法中做一些初始化工作，还可以手动建立java类中的native方法和so中的native方法的对应关系。</p><p><a href="https://www.jianshu.com/p/0b7976fbf81b">【源码解读】JNI的实现原理</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK基础工具应用</title>
      <link href="/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-jian-cha-nei-cun-xie-lu-de-gong-ju-you">Q：检查内存泄露的工具有？</a></li><li><a href="#q-mou-jin-cheng-cpu-shi-yong-lu-yi-zhi-zhan-man-yong-shi-me-gong-ju-ke-yi-pai-cha">Q：某进程CPU使用率一直占满，用什么工具可以排查？</a></li></ul><ul><li><a href="#ge-gong-ju-xiang-xi-jie-shao">各工具详细介绍</a><ul><li><a href="#jstack">jstack</a></li><li><a href="#jstat">jstat</a></li><li><a href="#jmap">jmap</a><ul><li><a href="#q-yong-jmap-jian-cha-nei-cun-xie-lou-shi-li">Q： 用jmap检查内存泄漏实例</a></li></ul></li><li><a href="#jhat">jhat</a></li><li><a href="#jdb">jdb</a></li><li><a href="#jcmd">jcmd</a></li><li><a href="#jps">jps</a></li><li><a href="#jinfo">jinfo</a></li><li><a href="#javap">javap</a></li><li><a href="#javac">javac</a></li></ul></li><li><a href="#idea-debug-gong-neng">IDEA-DEBUG功能</a><ul><li><a href="#q-idea-de-debug-zhong-ke-yi-evaluate-xiu-gai-jin-cheng-xing-wei-shi-tong-guo-shi-me-xiu-gai-de">Q: idea的debug中可以evaluate修改进程行为，是通过什么修改的？</a></li><li><a href="#q-shi-xian-liao-asm-kuang-jia-jiu-hui-zi-dong-zhi-chi-xiu-gai-ma">Q: 实现了ASM框架，就会自动支持修改吗？</a></li><li><a href="#q-zen-me-cai-neng-rang-jvm-neng-gou-diao-yong-wo-men-ti-gong-de-lei-zhuan-huan-qi-ni">Q: 怎么才能让 JVM 能够调用我们提供的类转换器呢</a></li><li><a href="#q-na-ni-jiang-yi-xia-wo-yao-zi-ji-shi-xian-yi-ge-ke-xiu-gai-dai-ma-de-agent-de-hua-gai-zen-me-zuo">Q: 那你讲一下我要自己实现一个可修改代码的agent的话该怎么做？</a></li></ul></li><li><a href="#jdk-xing-neng-jian-kong-he-diao-you-gong-ju">JDK性能监控和调优工具</a><ul><li><a href="#q-a-li-de-arthas-shang-ye-hua-de-jprofiler-ta-men-neng-jian-kong-de-yuan-li-shi-shi-me">Q: 阿里的Arthas、   商业化的jprofiler 他们能监控的原理是什么？</a></li></ul></li><li><a href="#jdk-ke-shi-hua-gong-ju">JDK可视化工具</a><ul><li><a href="#jconsole">jconsole</a></li><li><a href="#jvisualvm">jvisualvm</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><p>以一问一答的形式学习java工具</p><h2><span id="q-jian-cha-nei-cun-xie-lu-de-gong-ju-you">Q：检查内存泄露的工具有？</span><a href="#q-jian-cha-nei-cun-xie-lu-de-gong-ju-you" class="header-anchor">#</a></h2><p>A： jmap生成dump转储文件，jhat可视化查看。</p><hr><h2><span id="q-mou-jin-cheng-cpu-shi-yong-lu-yi-zhi-zhan-man-yong-shi-me-gong-ju-ke-yi-pai-cha">Q：某进程CPU使用率一直占满，用什么工具可以排查？</span><a href="#q-mou-jin-cheng-cpu-shi-yong-lu-yi-zhi-zhan-man-yong-shi-me-gong-ju-ke-yi-pai-cha" class="header-anchor">#</a></h2><p>A：<br>top -Hp pid找到最占CPU的线程<br>然后jstack来查找那个线程此时所处的堆栈，确定问题发生位置。</p><hr><h1><span id="ge-gong-ju-xiang-xi-jie-shao">各工具详细介绍</span><a href="#ge-gong-ju-xiang-xi-jie-shao" class="header-anchor">#</a></h1><h2><span id="jstack">jstack</span><a href="#jstack" class="header-anchor">#</a></h2><p>全称： JVM Stack Trance<br>作用： 查看某个java进程的堆栈情况， 可用于确认死锁、IO等待、死循环等问题。<br>命令用法：</p><ul><li><p>jstack pid</p></li><li><p>查看死锁例子如下图，找到wait的lock和已被锁的lock</p></li><li><p>查看等待IO例子：</p></li></ul><h2><span id="jstat">jstat</span><a href="#jstat" class="header-anchor">#</a></h2><p>全称：<br>作用：<br>查看进程中内存使用情况，但只能给出一些简单统计数据</p><ul><li><p>统计加载了多少类以及占用空间 jstat -class pid</p></li><li><p>统计编译了多少文件 jstat -compiler 10</p></li></ul><hr><p>Q： jstat -gcutil {pid} 2000 可以每隔2秒，对pid进程打印内存使用统计信息。<br>gcutil的输出如下<br><img src="/images/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/bf7e8bc9d6c5e91598baa006685e943e60df272e.png" alt="bf7e8bc9d6c5e91598baa006685e943e60df272e"><br>里面哪个百分比如果长期处于99%-100%会有OMM风险？（OutOfMemoryError)<br>A：<br>如果E和O即新生代、老年代内存区一直都处于满的状态，则很有可能会引发OMM风险。就像下面这个。<br><img src="/images/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/5d59d85bd0c23c151b5985f4aa98f0df64717b1e.png" alt="5d59d85bd0c23c151b5985f4aa98f0df64717b1e"></p><hr><h2><span id="jmap">jmap</span><a href="#jmap" class="header-anchor">#</a></h2><p>全称： JVM Memory Map<br>作用：生成进程的内存堆快照<br>当需要看一下进程里是什么东西占用了过多内存时， 可以用jmap打印一下堆快照。<br>命令用法：</p><ul><li><p>打印堆快照： jmap -dump:file=./dumpfile.dump 进程pid</p></li><li><p>查看特定类所占用的情况： jmap -histo:live 进程pid | grep 类名</p></li></ul><hr><h3><span id="q-yong-jmap-jian-cha-nei-cun-xie-lou-shi-li">Q： 用jmap检查内存泄漏实例</span><a href="#q-yong-jmap-jian-cha-nei-cun-xie-lou-shi-li" class="header-anchor">#</a></h3><p>我分了3次，每个1h调用jmap查看进程的内存实例，查看该时刻各对象数量<br>第一次查看情况如下：<br><img src="/images/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/424ece2d981a6aa09227e85b59c4e40e62bc3879.png" alt="424ece2d981a6aa09227e85b59c4e40e62bc3879"><br>第二次隔了2各小时，查看情况如下：</p><p><img src="/images/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/648c5a30bede19cb2c9848dde177167b9cee2dda.png" alt="648c5a30bede19cb2c9848dde177167b9cee2dda"><br>请问哪个对象可能有内存泄漏风险？<br>A：<br>ObjectA可能有泄露， 因为他的对象数量增加最快，说明对象一直在增加且很多无法进行gc释放。</p><h2><span id="jhat">jhat</span><a href="#jhat" class="header-anchor">#</a></h2><p>全称： JVM Heap Analysis Tool<br>和jmap配合， 可以解析jmap生成的堆快照， 支持生成1个web进程供我们分析和查看。<br>命令用法：</p><ul><li>jhat -J-Xmx515M dumpfile.dump<br>此时就会启动1个webServer，然后我们去访问就行了<br><img src="0361a76d6700b236053c852d2dc02a08dfaa9db8.png" alt="0361a76d6700b236053c852d2dc02a08dfaa9db8"></li></ul><h2><span id="jdb">jdb</span><a href="#jdb" class="header-anchor">#</a></h2><p>全称：Java Debugger<br>作用：用来对core文件和正在运行的Java进程进行实时地调试，类似于c++里的gdb<br>常见用法：</p><ul><li><p>启动进程并调试: jdb -classpath . Test</p></li><li><p>至二级调试某进程: jdb -attach 8000 -sourcepath /Users/wefit/Development/study/java/jtest/src/</p></li></ul><h2><span id="jcmd">jcmd</span><a href="#jcmd" class="header-anchor">#</a></h2><p>作用：多功能的工具，可以用它来导出堆、查看Java进程、导出线程信息、执行GC、还可以进行采样分析，可以理解为1个性能调优时用的工具。<br>常见命令：</p><ul><li><p>查看 当前机器上所有的 jvm 进程信息: jcmd -l</p></li><li><p>查看指定进程的性能统计信息: jcmd pid PerfCounter.print</p></li><li><p>列出当前运行的 java 进程可以执行的操作: jcmd PID help</p></li><li><p>查看线程堆栈信息: jcmd PID Thread.print</p></li><li><p>查看堆内存信息： jcmd PID GC.heap_dump FILE_NAME</p></li></ul><h2><span id="jps">jps</span><a href="#jps" class="header-anchor">#</a></h2><p>简单记法： JVM process status<br>全名：Java Virtual Machine Process Status Tool<br>作用： 显示?当前系统用户?的?所有?Java进程情况及其进程号<br>常用命令：</p><ul><li><p>查看进程jvm参数： jps -v</p></li><li><p>输出程序main class的完整package名或程序的jar文件完整路径名： jps -l</p></li><li><p>输出传递给main方法的参数: jps -m</p></li></ul><h2><span id="jinfo">jinfo</span><a href="#jinfo" class="header-anchor">#</a></h2><p>jvm infomation<br>作用：和jps功能类似， 但是支持根据指定pis查看指定进程</p><ul><li><p>可以查看JVM参数、系统参数、调整jvm参数</p></li><li><p>但不支持查看java程序的内存使用情况</p></li></ul><h2><span id="javap">javap</span><a href="#javap" class="header-anchor">#</a></h2><p>把java字节码文件反汇编为Java源码文件。</p><h2><span id="javac">javac</span><a href="#javac" class="header-anchor">#</a></h2><p>javac是java编译工具<br>javac的执行过程：<br><img src="/images/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/8c24abf8a5ff633bad6222ad66eac944c715ed91.png" alt="8c24abf8a5ff633bad6222ad66eac944c715ed91"></p><h1><span id="idea-debug-gong-neng">IDEA-DEBUG功能</span><a href="#idea-debug-gong-neng" class="header-anchor">#</a></h1><p>idea的debug功能是怎么实现的？ 为什么可以通过Evaluate 进行条件判断的？按以下问题逐个解答<br>完整详解见<a href="https://blog.csdn.net/zhipengfang/article/details/117174718">IDEA的debug功能，背后的原理是怎样的？</a></p><hr><h2><span id="q-idea-de-debug-zhong-ke-yi-evaluate-xiu-gai-jin-cheng-xing-wei-shi-tong-guo-shi-me-xiu-gai-de">Q: idea的debug中可以evaluate修改进程行为，是通过什么修改的？</span><a href="#q-idea-de-debug-zhong-ke-yi-evaluate-xiu-gai-jin-cheng-xing-wei-shi-tong-guo-shi-me-xiu-gai-de" class="header-anchor">#</a></h2><p>A:<br>ASM框架——动态修改类、方法，甚至可以重新定义类，连 CGLib 底层都是用 ASM 实现的。 访问者模式。需要实现visitMethod()/visitAnnotation()</p><hr><h2><span id="q-shi-xian-liao-asm-kuang-jia-jiu-hui-zi-dong-zhi-chi-xiu-gai-ma">Q: 实现了ASM框架，就会自动支持修改吗？</span><a href="#q-shi-xian-liao-asm-kuang-jia-jiu-hui-zi-dong-zhi-chi-xiu-gai-ma" class="header-anchor">#</a></h2><p>A:<br>不会自动支持， 需要使用 instrument 的类修改功能，我们需要实现它的 ClassFileTransformer 接口定义一个类文件转换器。它唯一的一个 transform() 方法会在类文件被加载时调用，在 transform 方法里，我们可以对传入的二进制字节码进行改写或替换，生成新的字节码数组后返回，JVM 会使用 transform 方法返回的字节码数据进行类的加载。</p><hr><h2><span id="q-zen-me-cai-neng-rang-jvm-neng-gou-diao-yong-wo-men-ti-gong-de-lei-zhuan-huan-qi-ni">Q: 怎么才能让 JVM 能够调用我们提供的类转换器呢</span><a href="#q-zen-me-cai-neng-rang-jvm-neng-gou-diao-yong-wo-men-ti-gong-de-lei-zhuan-huan-qi-ni" class="header-anchor">#</a></h2><p>A:</p><ul><li>JVM TI 通过事件机制，通过接口注册各种事件勾子，在 JVM 事件触发时同时触发预定义的勾子，以实现对各个 JVM 事件的感知和反应。</li><li>Agent 是 JVM TI 实现的一种方式</li><li>Java 的调试体系 jdpa 组成，从高到低分别为 jdi-&gt;jdwp-&gt;jvmti，我们通过 JDI 接口发送调试指令，而 jdwp 就相当于一个通道，帮我们翻译 JDI 指令到 JVM TI，最底层的 JVM TI 最终实现对 JVM 的操作。</li><li>debug时要添加参数 -agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:3333，而 -agentlib 选项就指定了我们要加载的 Java Agent，jdwp 是 agent 的名字</li></ul><hr><h2><span id="q-na-ni-jiang-yi-xia-wo-yao-zi-ji-shi-xian-yi-ge-ke-xiu-gai-dai-ma-de-agent-de-hua-gai-zen-me-zuo">Q: 那你讲一下我要自己实现一个可修改代码的agent的话该怎么做？</span><a href="#q-na-ni-jiang-yi-xia-wo-yao-zi-ji-shi-xian-yi-ge-ke-xiu-gai-dai-ma-de-agent-de-hua-gai-zen-me-zuo" class="header-anchor">#</a></h2><p>A:</p><ol><li>实现一个Agent，实现入口类agentmain(String args, Instrumentation inst)<br>在main里给inst添加转化方法addTransformer(自定义Transformer())<br>再对需要的类进行转化inst.retransformClasses(TransformTarget.class)。</li><li>实现自定义Transformer， 里面需要实现一个ClassVisitor 访问者模式，有类似visitMethod的方法实现</li><li>使用Attacher 将agent动态加载到目标jvm上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VirtualMachine</span> <span class="variable">vm</span> <span class="operator">=</span> VirtualMachine.attach(<span class="string">&quot;34242&quot;</span>); <span class="comment">// 目标 JVM pid</span></span><br><span class="line">        vm.loadAgent(<span class="string">&quot;/path/to/agent.jar&quot;</span>)</span><br></pre></td></tr></table></figure><h1><span id="jdk-xing-neng-jian-kong-he-diao-you-gong-ju">JDK性能监控和调优工具</span><a href="#jdk-xing-neng-jian-kong-he-diao-you-gong-ju" class="header-anchor">#</a></h1><p>有阿里的Arthas、   商业化的jprofiler<br>能进行CPU分析、方法耗时分析、GC活动分析、实时堆内容分析、 采样时间内的方法火焰图等</p><h2><span id="q-a-li-de-arthas-shang-ye-hua-de-jprofiler-ta-men-neng-jian-kong-de-yuan-li-shi-shi-me">Q: 阿里的Arthas、   商业化的jprofiler 他们能监控的原理是什么？</span><a href="#q-a-li-de-arthas-shang-ye-hua-de-jprofiler-ta-men-neng-jian-kong-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h2><ul><li>开发者可以在main函数执行之后再启动自己的Instrument应用，入口是agentmain函数。arthas就是通过这个实现的。利用-javaagent参数进行instrument的初始化，可以通过这个入口修改class<br>之后就可以通过addTransformer，retransformClasses，redefineClasses等方式对字节码进行增强和热替换了。</li><li>修改字节码也需要一套框架，不然自己重写太蛮烦了。ASM是一个Java字节码操作框架，用来动态生成class或者增强class，cglib的底层就是它，arthas也是通过它实现对class的增强的。</li><li>Arthas增强功能的核心是Enhancer和AdviceWeaver这两个类，对方法进行Aop织入，达到watch，trace等效果。</li><li>还要提供一个启动端口连接的功能。JVMTI（JVM Tool Interface）是Java虚拟机所提供的native接口，提供了可用于debug和profiler的能力，是实现调试器和其他运行态分析工具的基础，Instrument就是对它的封装。<br>通过JDI接口进行交互调试，attach端口建立连接。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/115127052">Arthas运行原理</a></p><h1><span id="jdk-ke-shi-hua-gong-ju">JDK可视化工具</span><a href="#jdk-ke-shi-hua-gong-ju" class="header-anchor">#</a></h1><h2><span id="jconsole">jconsole</span><a href="#jconsole" class="header-anchor">#</a></h2><p>可监控jvm，即可监控本地jvm也可监控远程jvm，管理应用程序，可以检查死锁等诸多问题。</p><p><img src="/images/JDK%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/c2787e54e2a977602128d12af1e5c03d556d42b4.png" alt="c2787e54e2a977602128d12af1e5c03d556d42b4"></p><h2><span id="jvisualvm">jvisualvm</span><a href="#jvisualvm" class="header-anchor">#</a></h2><ul><li><p>jvisualvm可以监控远程服务器的运行状态</p></li><li><p>可以在java程序运行起来后再运行， 通过某些协议连接到java进程中。</p></li><li><p>运行时， 可以不需要配置配置环境、虚拟机参数等。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-Socket应用</title>
      <link href="/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-Socket%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-Socket%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fu-wu-duan">服务端</a><ul><li><a href="#fu-wu-duan-kai-qi-guo-cheng">服务端开启过程</a></li><li><a href="#q-server-duan-ru-he-you-xiao-pan-duan-client-xiao-xi-chuan-shu-wan-bi">Q：server端如何有效判断client消息传输完毕？</a></li><li><a href="#q-ru-he-bi-mian-shang-mian-yong-while-xun-huan-chu-li-yi-ge-qing-qiu-chu-li-shi-yong-shi-jiao-jiu-ying-xiang-liao-qi-ta-qing-qiu-de-chu-li">Q：如何避免上面用while循环处理一个请求处理时用时较久，影响了其他请求的处理?</a></li><li><a href="#serversocket-xuan-xiang">ServerSocket选项</a></li></ul></li><li><a href="#ke-hu-duan">客户端</a><ul><li><a href="#q-ke-hu-duan-jin-xing-shu-chu-liu-shu-chu-shi-ru-guo-zhi-xing-liao-outputstream-close-hou-huan-xu-yao-zhi-xing-socket-close-ma">Q: 客户端进行输出流输出时，如果执行了outputStream.close()后， 还需要执行socket.close()吗？</a></li></ul></li><li><a href="#udp">UDP</a><ul><li><a href="#q-ru-guo-yao-zuo-udp-tong-xin-na-me-yao-yong-shi-me-socket">Q：如果要做UDP通信， 那么要用什么socket？</a></li><li><a href="#q-datagramsocket-he-java-zhong-pu-tong-serversocket-huo-zhe-socket-ke-hu-duan-de-qu-bie">Q: DatagramSocket和java中普通ServerSocket或者 Socket客户端的区别？</a></li><li><a href="#q-multicastsocket-shi-shi-me">Q： MulticastSocket是什么？</a></li><li><a href="#q-shang-mian-de-socketa-hui-fa-song-gei-zi-ji-ma">Q: 上面的socketA会发送给自己吗？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="fu-wu-duan">服务端</span><a href="#fu-wu-duan" class="header-anchor">#</a></h1><h2><span id="fu-wu-duan-kai-qi-guo-cheng">服务端开启过程</span><a href="#fu-wu-duan-kai-qi-guo-cheng" class="header-anchor">#</a></h2><p>用accept开启一个Socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br></pre></td></tr></table></figure><p>调用后会进入阻塞。</p><ul><li>用socket.getInputStream()， 得到一个socket输入流， 进行read时，就是从客户端那边读取发来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="keyword">while</span>(len = inputStream.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//注意指定编码格式，发送方和接收方需要统一</span></span><br><span class="line">sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果server端要返回数据，就再从socket对象里get输出流，往输出流写东西，就会传到客户端那边了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OuputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOuputStream();</span><br><span class="line">outputStream.write(<span class="string">&quot;hahah, this is response&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>))</span><br></pre></td></tr></table></figure><hr><h2><span id="q-server-duan-ru-he-you-xiao-pan-duan-client-xiao-xi-chuan-shu-wan-bi">Q：server端如何有效判断client消息传输完毕？</span><a href="#q-server-duan-ru-he-you-xiao-pan-duan-client-xiao-xi-chuan-shu-wan-bi" class="header-anchor">#</a></h2><p>A：</p><ul><li>客户端不再发送时，那边会调用socket.shutdownOutput(),  对方的read()方法就会返回-1.<br>*建议使用长度+类型+数据的协议传输方式， 这样服务端可以明确直到自己这一次这要读多少字节以及是什么样的消息， 减少做消息结束判断导致的异常问题。</li></ul><hr><h2><span id="q-ru-he-bi-mian-shang-mian-yong-while-xun-huan-chu-li-yi-ge-qing-qiu-chu-li-shi-yong-shi-jiao-jiu-ying-xiang-liao-qi-ta-qing-qiu-de-chu-li">Q：如何避免上面用while循环处理一个请求处理时用时较久，影响了其他请求的处理?</span><a href="#q-ru-he-bi-mian-shang-mian-yong-while-xun-huan-chu-li-yi-ge-qing-qiu-chu-li-shi-yong-shi-jiao-jiu-ying-xiang-liao-qi-ta-qing-qiu-de-chu-li" class="header-anchor">#</a></h2><p>A:<br>每当accept 返回1个socket之后， 把这个socket放进一个线程中，交给线程池去处理。</p><hr><h2><span id="serversocket-xuan-xiang">ServerSocket选项</span><a href="#serversocket-xuan-xiang" class="header-anchor">#</a></h2><ol><li>SO_TIMEOUT  accept的超时时间</li><li>SO_REUSEADDR   是否支持复用端口<br>即另一个serverSocket还没有close的时候， 新的serverSocket能否重用那个端口。</li><li>SO_RCVBUF 缓冲区大小<br>收到到特定缓存的大小才会从inputStream中返回。</li></ol><ul><li>设置方式：serverScoket.setSoXXX(…)</li></ul><hr><h1><span id="ke-hu-duan">客户端</span><a href="#ke-hu-duan" class="header-anchor">#</a></h1><h2><span id="q-ke-hu-duan-jin-xing-shu-chu-liu-shu-chu-shi-ru-guo-zhi-xing-liao-outputstream-close-hou-huan-xu-yao-zhi-xing-socket-close-ma">Q: 客户端进行输出流输出时，如果执行了outputStream.close()后， 还需要执行socket.close()吗？</span><a href="#q-ke-hu-duan-jin-xing-shu-chu-liu-shu-chu-shi-ru-guo-zhi-xing-liao-outputstream-close-hou-huan-xu-yao-zhi-xing-socket-close-ma" class="header-anchor">#</a></h2><p>A：<br>不需要。对于同一个socket， 如果关闭了输出流比如pw.close()， 则与该输出流关联的socket也会关闭， 所以一般不需要关闭输出流。  当关闭socket的时候， 输出流也会同时关闭。<br>因此如果执行了以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从socket中拿到inputStream和outputStream</span></span><br><span class="line">...</span><br><span class="line">outputStream.close()</span><br><span class="line">inputStream.read();</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><p>这时候inputStream.read()的就会报错， 因为socket已经被关闭了。</p><h1><span id="udp">UDP</span><a href="#udp" class="header-anchor">#</a></h1><h2><span id="q-ru-guo-yao-zuo-udp-tong-xin-na-me-yao-yong-shi-me-socket">Q：如果要做UDP通信， 那么要用什么socket？</span><a href="#q-ru-guo-yao-zuo-udp-tong-xin-na-me-yao-yong-shi-me-socket" class="header-anchor">#</a></h2><p>A: DatagramSocket</p><hr><h2><span id="q-datagramsocket-he-java-zhong-pu-tong-serversocket-huo-zhe-socket-ke-hu-duan-de-qu-bie">Q: DatagramSocket和java中普通ServerSocket或者 Socket客户端的区别？</span><a href="#q-datagramsocket-he-java-zhong-pu-tong-serversocket-huo-zhe-socket-ke-hu-duan-de-qu-bie" class="header-anchor">#</a></h2><p>A:</p><ul><li>TCP的socket建立时， 需要先指定对端口的op和端口， 并用输出流去输出数据</li><li>而java中的UDP客户端建立时， 不需要在socket里指定ip和端口， 而是将ip+端口放在datagramPacket包里去指定。(所以一个socket可以用来发送好几份不同目的组的UDP包）</li><li>另一个区别是， tcp两边用流来传输数据， 而UDP用datagramPacket来传递数据</li></ul><hr><h2><span id="q-multicastsocket-shi-shi-me">Q： MulticastSocket是什么？</span><a href="#q-multicastsocket-shi-shi-me" class="header-anchor">#</a></h2><p>A：<br>多点广播的socket实现， 也是用DatagramPacket来传输数据。<br>类似于一个客户端可以把数据包发给号借给目的端。<br>multicastSocket.joinGroup(多播ip)<br>则这个socket会加入到这个多播组中。<br>举例：</p><blockquote><blockquote><p>假设环境中有4个MulticastSocket,  分别为socketA、socketB、socketC、socketD。<br>socketA、socketB、socketC都通过joinGroup方法，加入到了224.0.0.1这个多播组中<br>那么当socketA发送了某个DatagramPacket时，会只发送给B和C， 不会发送给D。</p></blockquote></blockquote><hr><h2><span id="q-shang-mian-de-socketa-hui-fa-song-gei-zi-ji-ma">Q: 上面的socketA会发送给自己吗？</span><a href="#q-shang-mian-de-socketa-hui-fa-song-gei-zi-ji-ma" class="header-anchor">#</a></h2><p>A:<br>默认会的。</p><p>发送给自己的话， 那就是设置了环回。<br>如果执行过 multicastSocket.setLoopbackMode(true)，那就是禁止环回机制。<br>注意：默认是开启的。</p><hr><p>参考资料：<br><a href="https://blog.csdn.net/a78270528/article/details/80318571%EF%BC%88%E8%BF%99%E7%AF%87%E5%86%99%E5%BE%97%E5%BE%88%E6%A3%92%EF%BC%89">https://blog.csdn.net/a78270528/article/details/80318571（这篇写得很棒）</a><br><a href="https://blog.csdn.net/woshisap/article/details/6597413">https://blog.csdn.net/woshisap/article/details/6597413</a><br><a href="https://blog.csdn.net/weixin_44618862/article/details/98480120">https://blog.csdn.net/weixin_44618862/article/details/98480120</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全管理器应用</title>
      <link href="/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#java-an-quan-lei-ku-chang-jian-wen-ti">Java安全类库常见问题</a><ul><li><a href="#q-you-ji-chong-fang-shi-ke-yi-qi-dong-an-quan-guan-li-qi">Q：有几种方式可以启动安全管理器？</a></li><li><a href="#q-ru-guo-wo-bu-she-zhi-an-quan-guan-li-qi-zhi-jie-pao-system-getproperty-hui-bao-quan-xian-cuo-wu-ma">Q：如果我不设置安全管理器，直接跑System.getProperty，会报权限错误吗？</a></li><li><a href="#q-yin-shi-qi-dong-zhong-ru-guo-zhi-pei-liao-djava-security-manager-dan-mei-you-pei-djava-security-policy-na-me-shang-mian-de-wen-jian-yi-ji-xi-tong-pei-zhi-shi-du-yun-xu-du-huan-shi-du-bu-yun-xu-du">Q: 隐式启动中，如果只配了-Djava.security.manager ，但没有配-Djava.security.policy， 那么上面的文件以及系统配置是都允许读，还是都不允许读？</a></li><li><a href="#q-ru-guo-wo-zhi-qian-you-yin-shi-qi-dong-ci-shi-new-liao-yi-ge-xin-de-securitymanager-fang-jin-qu-ci-shi-shi-fou-huan-you-gai-shu-xing-de-read-quan-xian">Q：如果我之前有隐式启动，此时new了一个新的SecurityManager放进去，此时是否还有该属性的read权限？</a></li><li><a href="#chang-jian-de-java-an-quan-quan-xian">常见的java 安全权限</a></li><li><a href="#q-xiang-xi-jiang-jiang-an-quan-guan-li-qi-de-ying-yong-chang-jing">Q： 详细讲讲安全管理器的应用场景？</a></li><li><a href="#q-shang-mian-zhe-ge-li-zi-zhong-ru-guo-e-yi-diao-yong-zhe-zi-ji-zai-an-quan-guan-li-qi-zhong-zeng-jia-zhe-chong-quan-xian-de-chu-li-zen-me-ban">Q： 上面这个例子中， 如果恶意调用者自己在安全管理器中增加这种权限的处理怎么办？</a></li><li><a href="#q-jia-she-mou-fu-wu-shi-xian-liao-yi-ge-zi-ding-yi-classloader-zhi-chi-cong-wang-luo-huo-qu-xin-ren-ke-hu-chuan-lai-de-jar-bao-bing-zai-zi-ji-de-fu-wu-zhong-zhi-xing-na-me-ying-gai-ru-he-fang-zhi-jia-zai-bu-ke-xin-de-jar-bao-ni">Q： 假设某服务实现了一个自定义classLoader， 支持从网络获取信任客户传来的jar包并在自己的服务中执行， 那么应该如何防止加载不可信的jar包呢？</a></li><li><a href="#q-bu-jia-yan-zhi-de-ha-xi-kou-ling-ha-xi-you-shi-me-que-xian">Q：不加盐值的哈希口令哈希有什么缺陷？</a></li><li><a href="#q-dui-kou-ling-zuo-ha-xi-jia-yan-zhi-shi-you-shi-me-yao-qiu">Q：对口令做哈希加盐值时有什么要求？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="java-an-quan-lei-ku-chang-jian-wen-ti">Java安全类库常见问题</span><a href="#java-an-quan-lei-ku-chang-jian-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-you-ji-chong-fang-shi-ke-yi-qi-dong-an-quan-guan-li-qi">Q：有几种方式可以启动安全管理器？</span><a href="#q-you-ji-chong-fang-shi-ke-yi-qi-dong-an-quan-guan-li-qi" class="header-anchor">#</a></h2><p>A：两种方式<br>隐式启动： 启动命令里加-Djava.security.manager， 即可开启安全管理器。<br>显示启动： 代码里自己new一个SecurityManager或者继承一个新子类， 然后用System.setSecurityManager(xxxSecurityManager)来设置</p><hr><p>看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityManagerTest</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;    </span><br><span class="line">    System.out.println(System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="q-ru-guo-wo-bu-she-zhi-an-quan-guan-li-qi-zhi-jie-pao-system-getproperty-hui-bao-quan-xian-cuo-wu-ma">Q：如果我不设置安全管理器，直接跑System.getProperty，会报权限错误吗？</span><a href="#q-ru-guo-wo-bu-she-zhi-an-quan-guan-li-qi-zhi-jie-pao-system-getproperty-hui-bao-quan-xian-cuo-wu-ma" class="header-anchor">#</a></h2><p>A：<br>不会报错误。 如果隐式和显示启动都没做，那么System里的SecurityManager就是null，那么就不会进行检查。<br>可以看下System.getProperty里的源码：<br><img src="/images/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E5%BA%94%E7%94%A8/492830d481c84ff56c99dec832d0939d6616b824.png" alt="492830d481c84ff56c99dec832d0939d6616b824"></p><hr><h2><span id="q-yin-shi-qi-dong-zhong-ru-guo-zhi-pei-liao-djava-security-manager-dan-mei-you-pei-djava-security-policy-na-me-shang-mian-de-wen-jian-yi-ji-xi-tong-pei-zhi-shi-du-yun-xu-du-huan-shi-du-bu-yun-xu-du">Q: 隐式启动中，如果只配了-Djava.security.manager ，但没有配-Djava.security.policy， 那么上面的文件以及系统配置是都允许读，还是都不允许读？</span><a href="#q-yin-shi-qi-dong-zhong-ru-guo-zhi-pei-liao-djava-security-manager-dan-mei-you-pei-djava-security-policy-na-me-shang-mian-de-wen-jian-yi-ji-xi-tong-pei-zhi-shi-du-yun-xu-du-huan-shi-du-bu-yun-xu-du" class="header-anchor">#</a></h2><p>A：<br>都不允许读。 即开启后，不在policy允许范围内的，都默认不允许读。</p><hr><ul><li><p>如果要允许读文件以及读file.encoding那个系统配置， 需要加上-Djava.security.policy=xxx.policy ， 指明policy文件。</p></li><li><p>文件里大概长这样<br><img src="/images/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E5%BA%94%E7%94%A8/9fe292ac9397f17154eb131f2b7ac65ae6bbfa7a.png" alt="9fe292ac9397f17154eb131f2b7ac65ae6bbfa7a"><br>注意policy是拼在-Djava.security.manager的后面<br><img src="/images/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E5%BA%94%E7%94%A8/5ef1de92e4ef3956fc00c8830f82479b77213629.png" alt="5ef1de92e4ef3956fc00c8830f82479b77213629"></p></li></ul><hr><p>显示启动，就是自己new一个SecurityManager，并set进去。</p><h2><span id="q-ru-guo-wo-zhi-qian-you-yin-shi-qi-dong-ci-shi-new-liao-yi-ge-xin-de-securitymanager-fang-jin-qu-ci-shi-shi-fou-huan-you-gai-shu-xing-de-read-quan-xian">Q：如果我之前有隐式启动，此时new了一个新的SecurityManager放进去，此时是否还有该属性的read权限？</span><a href="#q-ru-guo-wo-zhi-qian-you-yin-shi-qi-dong-ci-shi-new-liao-yi-ge-xin-de-securitymanager-fang-jin-qu-ci-shi-shi-fou-huan-you-gai-shu-xing-de-read-quan-xian" class="header-anchor">#</a></h2><p><img src="/images/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E5%BA%94%E7%94%A8/eb6b0119d97e6e30fd93f610fde5a8e5dc4ecd6b.png" alt="eb6b0119d97e6e30fd93f610fde5a8e5dc4ecd6b"></p><p>A：没有了，之前由启动参数配进去的安全管理器已经被你覆盖掉了</p><p>对于隐式启动和显示启动， 都是默认没有任何可用权限！</p><p>都是白名单机制， 无黑名单机制。</p><hr><h2><span id="chang-jian-de-java-an-quan-quan-xian">常见的java 安全权限</span><a href="#chang-jian-de-java-an-quan-quan-xian" class="header-anchor">#</a></h2><p>都是能从名字就知道什么作用的，瞄一眼有个印象就行，大概知道java里这些功能可能都会有权限。</p><ul><li><p>java.security.AllPermission 所有权限的集合</p></li><li><p>java.util.PropertyPermission 系统/环境属性权限<br>就是System.getProperty(<a href="http://xxx.xxx.xxx">xxx.xxx.xxx</a>)的权限</p></li><li><p>java.lang.RuntimePermission 运行时权限<br>这个安卓用的很多，</p></li><li><p>java.net.SocketPermission Socket权限</p></li><li><p>java.io.FilePermission 文件权限,包括读写,删除,执行</p></li><li><p>java.io.SerializablePermission 序列化权限</p></li><li><p>java.lang.reflect.ReflectPermission 反射权限</p></li><li><p>java.security.UnresolvedPermission 未解析的权限</p></li><li><p>java.net.NetPermission 网络权限</p></li><li><p>java.awt.AWTPermission AWT权限</p></li><li><p>java.sql.SQLPermission 数据库sql权限</p></li><li><p>java.security.SecurityPermission 安全控制方面的权限</p></li><li><p>java.util.logging.LoggingPermission 日志控制权限</p></li><li><p>javax.net.ssl.SSLPermission 安全连接权限</p></li><li><p>javax.security.auth.AuthPermission 认证权限</p></li><li><p>javax.sound.sampled.AudioPermission 音频系统资源的访问权限</p></li></ul><hr><p>关于上面的permission权限，有一个重要的应用，就是在ClassLoader中。<br>如果JVM开启了SecurityManager，  ClasserLoader就会在加载类的时候调用Policy.getPermissions来获取代码权限集， 并将代码来源和权限集封装到保护域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">protect PermissionCollection <span class="title function_">getPermissions</span><span class="params">(CodeSource cs)</span> &#123;</span><br><span class="line"><span class="type">PermissionCollection</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="built_in">super</span>.getPermissions(cs);</span><br><span class="line"><span class="comment">// 添加权限</span></span><br><span class="line">pc.add(<span class="keyword">new</span> <span class="title class_">XXXPersion</span>());</span><br><span class="line"><span class="keyword">return</span> pc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="q-xiang-xi-jiang-jiang-an-quan-guan-li-qi-de-ying-yong-chang-jing">Q： 详细讲讲安全管理器的应用场景？</span><a href="#q-xiang-xi-jiang-jiang-an-quan-guan-li-qi-de-ying-yong-chang-jing" class="header-anchor">#</a></h2><p>A：</p><ul><li>如果你是某个平台开发者，提供了某个SDK给其他人使用， 这里面涉及了某个文件读取或者文件写入操作。<br>但是你只希望他用这个sdk去操作平台下特定目录的文件，而不是去动其他的位置（比如根目录之类的）<br>于是你就可以给sdk代码封装上一层权限， 在这个代码块中只能读特定目录（就像上面的filePermission）</li><li>或者你通过的公开类中有个高危方法deleteXXX， 你希望拥有管理员权限的人才能调用，其他人不能调用， 于是可以在高危方法中加一层权限， 下面的例子来自安全编码规范， removeEncryt就是高危方法， 调用前会检查一下是否具有这个自定义的权限类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveHash</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">check(<span class="string">&quot;removeKeyPerssion&quot;</span>);</span><br><span class="line">ht.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String dire)</span> &#123;</span><br><span class="line"><span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (sm!=<span class="literal">null</span>) &#123;</span><br><span class="line">sm.checkSecurityAccess(dire)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="q-shang-mian-zhe-ge-li-zi-zhong-ru-guo-e-yi-diao-yong-zhe-zi-ji-zai-an-quan-guan-li-qi-zhong-zeng-jia-zhe-chong-quan-xian-de-chu-li-zen-me-ban">Q： 上面这个例子中， 如果恶意调用者自己在安全管理器中增加这种权限的处理怎么办？</span><a href="#q-shang-mian-zhe-ge-li-zi-zhong-ru-guo-e-yi-diao-yong-zhe-zi-ji-zai-an-quan-guan-li-qi-zhong-zeng-jia-zhe-chong-quan-xian-de-chu-li-zen-me-ban" class="header-anchor">#</a></h2><p>A： setSecurityManager方法API也是需要权限的。 作为客户端程序一般没有权限去设置SDK的安全管理器。 java默认的policy配置文件也没有放开这个权限。需要支持在policy里setSecurityManager才行。</p><hr><h2><span id="q-jia-she-mou-fu-wu-shi-xian-liao-yi-ge-zi-ding-yi-classloader-zhi-chi-cong-wang-luo-huo-qu-xin-ren-ke-hu-chuan-lai-de-jar-bao-bing-zai-zi-ji-de-fu-wu-zhong-zhi-xing-na-me-ying-gai-ru-he-fang-zhi-jia-zai-bu-ke-xin-de-jar-bao-ni">Q： 假设某服务实现了一个自定义classLoader， 支持从网络获取信任客户传来的jar包并在自己的服务中执行， 那么应该如何防止加载不可信的jar包呢？</span><a href="#q-jia-she-mou-fu-wu-shi-xian-liao-yi-ge-zi-ding-yi-classloader-zhi-chi-cong-wang-luo-huo-qu-xin-ren-ke-hu-chuan-lai-de-jar-bao-bing-zai-zi-ji-de-fu-wu-zhong-zhi-xing-na-me-ying-gai-ru-he-fang-zhi-jia-zai-bu-ke-xin-de-jar-bao-ni" class="header-anchor">#</a></h2><p>A：</p><ol><li>取出jar包中的证书资源</li><li>获取服务自身的密钥</li><li>校验证书是否是这些密钥的受信任签名（即我要识别你的这个证书是不是从我这里签发出去的）</li></ol><blockquote><blockquote><p>注意，不要使用URLClassLoaer和java.util.jar里的自动签名校验机制，他只是检查jar包中的签名和公钥是否匹配，这仅仅是完整性校验， 这2者是可以被全部替换的</p></blockquote></blockquote><hr><h2><span id="q-bu-jia-yan-zhi-de-ha-xi-kou-ling-ha-xi-you-shi-me-que-xian">Q：不加盐值的哈希口令哈希有什么缺陷？</span><a href="#q-bu-jia-yan-zhi-de-ha-xi-kou-ling-ha-xi-you-shi-me-que-xian" class="header-anchor">#</a></h2><p>A：</p><p>生日判定，可以快速找到一个口令</p><p>可以利用事先计算好的哈希列表几秒钟破解。</p><hr><h2><span id="q-dui-kou-ling-zuo-ha-xi-jia-yan-zhi-shi-you-shi-me-yao-qiu">Q：对口令做哈希加盐值时有什么要求？</span><a href="#q-dui-kou-ling-zuo-ha-xi-jia-yan-zhi-shi-you-shi-me-yao-qiu" class="header-anchor">#</a></h2><p>A:</p><p>盐值至少应该包含8字节而且必须是由安全随机数产生。( 例如如果问你，sha256+4字节盐值，那肯定就是错误的！）</p><p>应使用强哈希函数，推荐使用SHA-256或者更加安全的哈希函数。</p><p>迭代次数默认推荐10000次，对于性能有特殊要求（比如嵌入式系统）的产品低可迭代1000次。</p><p>对于单向哈希时，其输出长度应该不小于256比特</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-NIO</title>
      <link href="/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/15/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-nio-he-biao-zhun-io-you-shi-me-qu-bie">Q： NIO和标准IO有什么区别？</a></li></ul><ul><li><a href="#javanio-he-xin-3-zu-jian">JavaNIO核心3组件：</a><ul><li><a href="#1-channels-tong-dao">1. Channels 通道</a><ul><li><a href="#q-tong-dao-channel-dui-xiang-neng-tong-shi-zuo-du-xie-cao-zuo-ma">Q： 通道Channel对象能同时做读写操作吗？</a></li><li><a href="#q-tong-dao-zhi-chi-yi-bu-du-xie-ma">Q： 通道支持异步读写吗</a></li><li><a href="#q-tong-dao-de-du-xie-shi-fou-bi-xu-yao-yi-lai-huan-chong-qu-buffer">Q： 通道的读写是否必须要依赖缓冲区buffer？</a></li><li><a href="#q-you-na-ji-chong-chang-yong-de-nio-channel">Q: 有哪几种常用的NIO Channel</a></li><li><a href="#q-filechannal-wei-shi-me-bu-zhi-chi-fei-zu-sai">Q: fileChannal为什么不支持非阻塞？</a></li></ul></li><li><a href="#2-buffer-huan-chong-qu">2. Buffer缓冲区</a><ul><li><a href="#buffer-te-dian-xiang-jie">buffer特点详解</a></li><li><a href="#q-buffer-diao-yong-flip-fang-fa-cong-xie-mo-shi-qie-huan-dao-du-mo-shi-shi-position-hui-bian-cheng-duo-shao">Q： buffer调用flip()方法从写模式切换到读模式时，position会变成多少？</a></li><li><a href="#q-buffer-yong-you-1-ge-limit-shu-xing-zhi-dao-shi-zuo-shi-me-de-ma">Q: buffer拥有1个limit属性。知道是做什么的吗？</a></li><li><a href="#q-dang-buffer-cong-xie-mo-shi-qie-huan-dao-du-mo-shi-shi-limit-wei-duo-shao">Q： 当buffer从写模式切换到读模式时，limit为多少？</a></li><li><a href="#q-xiang-buf-huan-chong-qu-xie-shu-ju-de-fang-shi-you-na-xie">Q： 向buf缓冲区写数据的方式有哪些？</a></li><li><a href="#q-shou-dong-xiu-gai-dang-qian-huan-chong-qu-de-postion-de-fang-fa-you-na-xie">Q: 手动修改当前缓冲区的postion的方法有哪些?</a></li><li><a href="#q-1-ge-channel-guan-dao-zhi-chi-duo-ge-buffer-ma">Q：1个channel管道支持多个buffer吗？</a></li><li><a href="#q-buffer-de-warp-slice-duplicate-fen-bie-shi-zuo-shi-me-de">Q: Buffer的Warp、slice、duplicate分别是做什么的？</a></li></ul></li><li><a href="#selector">Selector</a><ul><li><a href="#q-zai-nio-zhong-selector-de-hao-chu-shi-shi-me">Q： 在NIO中Selector的好处是什么？</a></li><li><a href="#q-selector-zhi-chi-zhu-ce-na-chong-lei-xing-de-tong-dao">Q： Selector支持注册哪种类型的通道？</a></li><li><a href="#q-selector-zhu-ce-shi-zhi-chi-jian-ting-na-ji-chong-shi-jian-dui-ying-de-chang-liang-shi-shi-me-a-zui-bu-xi-huan-ji-yi-zhe-chong-dong-xi-liao">Q： Selector注册时，支持监听哪几种事件，对应的常量是什么？（啊最不喜欢记忆这种东西了…）</a></li><li><a href="#q-selector-wei-hu-de-selectionkey-ji-he-gong-you-na-ji-chong">Q： Selector维护的SelectionKey集合共有哪几种？</a></li><li><a href="#q-zhu-ce-zhi-hou-ru-he-shi-yong-selector-dui-zhun-bei-jiu-xu-de-tong-dao-zuo-chu-li">Q:注册之后， 如何使用selector对准备就绪的通道做处理：</a></li><li><a href="#q-select-fang-fa-qi-shi-shi-zu-sai-fang-fa-ji-diao-yong-shi-hui-jin-ru-deng-dai-zhi-dao-ba-suo-you-tong-dao-du-lun-xun-wan-bi-ru-guo-xi-wang-ti-qian-jie-shu-select-you-na-xie-fang-fa">Q：select()方法其实是阻塞方法，即调用时会进入等待，直到把所有通道都轮询完毕。如果希望提前结束select()，有哪些方法？</a></li><li><a href="#q-zhi-qian-shuo-nio-shi-fei-zu-sai-io-dan-wei-shi-me-shang-mian-que-shuo-select-fang-fa-shi-zu-sai-de">Q:之前说NIO是非阻塞IO，但为什么上面却说select()方法是阻塞的？</a></li></ul></li></ul></li><li><a href="#nio-jin-jie">NIO进阶</a><ul><li><a href="#q-duo-xian-cheng-du-xie-tong-yi-wen-jian-shi-ru-he-jia-suo-bao-zheng-xian-cheng-an-quan">Q： 多线程读写同一文件时，如何加锁保证线程安全？</a></li><li><a href="#q-ru-guo-xu-yao-du-1-ge-te-da-wen-jian-ke-yi-shi-yong-shi-me-huan-chong-qu">Q： 如果需要读1个特大文件，可以使用什么缓冲区？</a></li><li><a href="#q-nio-zhong-bytebuffer-gai-ru-he-gen-ju-zheng-que-de-bian-ma-zhuan-wei-dui-ying-de-charbuffer">Q：NIO中ByteBuffer， 该如何根据正确的编码，转为对应的CharBuffer</a></li><li><a href="#q-nio-bei-hou-de-shi-xian-yuan-li-shi-shi-me">Q: NIO背后的实现原理是什么？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h2><span id="q-nio-he-biao-zhun-io-you-shi-me-qu-bie">Q： NIO和标准IO有什么区别？</span><a href="#q-nio-he-biao-zhun-io-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A：</p><p>标准IO， 基于字节流和字符流进行操作，阻塞IO。<br>NIO基于通道channel和缓冲区Buffer进行操作，支持非阻塞IO，提供选择器</p><hr><h1><span id="javanio-he-xin-3-zu-jian">JavaNIO核心3组件：</span><a href="#javanio-he-xin-3-zu-jian" class="header-anchor">#</a></h1><h2><span id="1-channels-tong-dao">1. Channels 通道</span><a href="#1-channels-tong-dao" class="header-anchor">#</a></h2><h3><span id="q-tong-dao-channel-dui-xiang-neng-tong-shi-zuo-du-xie-cao-zuo-ma">Q： 通道Channel对象能同时做读写操作吗？</span><a href="#q-tong-dao-channel-dui-xiang-neng-tong-shi-zuo-du-xie-cao-zuo-ma" class="header-anchor">#</a></h3><p>还是说需要像标准IO那样，需要同时创建input和output对象才能做读写操作？</p><p>A：<br>通道Channel是双向的， 既可以从channel中读数据，也可以写数据。<br>可以看到既能调用read也能调用write，且需要依赖缓冲区buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>).toPath());</span><br><span class="line">   <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    fileChannel.read(buf);</span><br><span class="line">    fileChannel.write(buf);</span><br></pre></td></tr></table></figure><ul><li>注意上图上，fileChannel.read(buf)是将a.txt里的数据读到buf， 即a.txt-&gt;buf</li><li>fileChannel.write(buf)是将buf里的数据写入到a.txt中， 即buf-&gt;a.txt，不要搞反啦！</li><li>通道和缓冲区的关系如下图：<br><img src="/images/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/5cc26d4b5a39246b56d13836560f8f46b428f838.png" alt="5cc26d4b5a39246b56d13836560f8f46b428f838"></li></ul><hr><h3><span id="q-tong-dao-zhi-chi-yi-bu-du-xie-ma">Q： 通道支持异步读写吗</span><a href="#q-tong-dao-zhi-chi-yi-bu-du-xie-ma" class="header-anchor">#</a></h3><p>A: 支持。</p><hr><h3><span id="q-tong-dao-de-du-xie-shi-fou-bi-xu-yao-yi-lai-huan-chong-qu-buffer">Q： 通道的读写是否必须要依赖缓冲区buffer？</span><a href="#q-tong-dao-de-du-xie-shi-fou-bi-xu-yao-yi-lai-huan-chong-qu-buffer" class="header-anchor">#</a></h3><p>A： 一般都是依赖buffer的。 但也支持2个管道之间的传输，即管道之间直接读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;b.txt&quot;</span>&#125;;</span><br><span class="line">FileChannel in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(arr[<span class="number">0</span>]).getChannel();</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">out</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(arr[<span class="number">1</span>]).getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将a.txt中的数据直接写进b.txt中，相当于文件拷贝</span></span><br><span class="line">in.transferTo(<span class="number">0</span>, in.size(), out);</span><br></pre></td></tr></table></figure><hr><h3><span id="q-you-na-ji-chong-chang-yong-de-nio-channel">Q: 有哪几种常用的NIO Channel</span><a href="#q-you-na-ji-chong-chang-yong-de-nio-channel" class="header-anchor">#</a></h3><p>A:</p><ul><li>FileChannel<br>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。<br>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下<br>创建方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span>    <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:/aa.txt&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span>    <span class="variable">fileChannel</span> <span class="operator">=</span> file.getChannel();</span><br></pre></td></tr></table></figure><ul><li>SocketChannel<br>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。<br>支持非阻塞模式socketChannel.configureBlocking(false)。<br>可以通过以下2种方式创建SocketChannel：<br>打开一个SocketChannel并连接到互联网上的某台服务器。<br>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel<br>创建方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.1.100&quot;</span>,<span class="number">80</span>));</span><br></pre></td></tr></table></figure><ul><li>ServerSocketChannel<br>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。<br>SocketChannel和ServerSocketChannel的区别： 前者用于客户端，后者用于服务端<br>创建方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">if</span>(socketChannle != <span class="literal">null</span>)</span><br><span class="line">        doSomething...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="q-filechannal-wei-shi-me-bu-zhi-chi-fei-zu-sai">Q: fileChannal为什么不支持非阻塞？</span><a href="#q-filechannal-wei-shi-me-bu-zhi-chi-fei-zu-sai" class="header-anchor">#</a></h3><p>A：</p><ul><li>UNIX不支持文件的非阻塞I / O,请参见 Non-blocking I/O with regular files.由于Java应该(至少尝试)在所有平台上提供相同的行为,所以FileChannel不会实现SelectableChannel.</li><li>阻塞与非阻塞发生在进程与进程之间的通信，一般文件的读写操作只会发生在进程内部，不存在外部进程的传输。<br>即使存在进程间的传输，文件依旧需要通过网络通信，把内容转成数据流传输，这点的传输和Socket通信是相同的，所以没必要再造一个API出来</li></ul><h2><span id="2-buffer-huan-chong-qu">2. Buffer缓冲区</span><a href="#2-buffer-huan-chong-qu" class="header-anchor">#</a></h2><h3><span id="buffer-te-dian-xiang-jie">buffer特点详解</span><a href="#buffer-te-dian-xiang-jie" class="header-anchor">#</a></h3><ul><li>我们真正要把数据拿到或者要写数据， 实际上都是通过buffer进行操作的。<br>文件 &lt;-&gt; buffer &lt;-&gt; 数据</li><li>buffer是1个即可读也可写的缓冲区，拥有读写2种模式。</li><li>buffer的capacity属性限定了每个buffer的最大容量,下面的1024就是capacity。<br>ByteBuffer buf = ByteBuffer.allocate(1024);</li><li>buffer拥有1个position属性，表示当前的读写位置。</li><li>往buffer中写数据时，position就会增加。</li><li>position最大值为capacity-1</li><li>把fileChannel对应文件里的数据 写入到buffer，叫做写模式</li><li>写之后，调用flip，让buffer的postion置0，此时相当于准备读取buffer里的数据（即调用buffer.get()拿数据）<br>（这个模式的叫法个人也觉得不太好，很容易绕，你可以就记忆成： flip就是从写模式转成读模式！）</li></ul><hr><h3><span id="q-buffer-diao-yong-flip-fang-fa-cong-xie-mo-shi-qie-huan-dao-du-mo-shi-shi-position-hui-bian-cheng-duo-shao">Q： buffer调用flip()方法从写模式切换到读模式时，position会变成多少？</span><a href="#q-buffer-diao-yong-flip-fang-fa-cong-xie-mo-shi-qie-huan-dao-du-mo-shi-shi-position-hui-bian-cheng-duo-shao" class="header-anchor">#</a></h3><p>A： 变为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 数据读到buf中,并返回数量，每次最多读1024个</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> fileChannel.read(buf);</span><br><span class="line">    <span class="comment">// 输出byteRead的数量，最多为1024</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position=&quot;</span> + buf.position()+<span class="string">&quot;, byteRead=&quot;</span> + byteRead);</span><br><span class="line">    </span><br><span class="line">    buf.flip();</span><br><span class="line">    <span class="comment">// 切换到读模式了，输出0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position=&quot;</span> + buf.position());</span><br></pre></td></tr></table></figure><hr><h3><span id="q-buffer-yong-you-1-ge-limit-shu-xing-zhi-dao-shi-zuo-shi-me-de-ma">Q: buffer拥有1个limit属性。知道是做什么的吗？</span><a href="#q-buffer-yong-you-1-ge-limit-shu-xing-zhi-dao-shi-zuo-shi-me-de-ma" class="header-anchor">#</a></h3><p>A:<br>写模式下，buffer的limit就是buffer的capacity，即最大容量</p><hr><h3><span id="q-dang-buffer-cong-xie-mo-shi-qie-huan-dao-du-mo-shi-shi-limit-wei-duo-shao">Q： 当buffer从写模式切换到读模式时，limit为多少？</span><a href="#q-dang-buffer-cong-xie-mo-shi-qie-huan-dao-du-mo-shi-shi-limit-wei-duo-shao" class="header-anchor">#</a></h3><p>A： 每次切换前都要调用flip()，切换后，limit为写模式中的position。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> fileChannel.read(buf);</span><br><span class="line">      <span class="comment">// 输出1024</span></span><br><span class="line">      System.out.println(<span class="string">&quot;limit=&quot;</span> + buf.limit() + <span class="string">&quot;,postion=&quot;</span> + buf.position());</span><br><span class="line">      System.out.println(<span class="string">&quot;切换到读模式&quot;</span>);</span><br><span class="line">      buf.flip();</span><br><span class="line">      <span class="comment">// 输出byteRead数量</span></span><br><span class="line">      System.out.println(<span class="string">&quot;limit=&quot;</span> + buf.limit());</span><br></pre></td></tr></table></figure><p>结果如下<br><img src="/images/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/7faf1b8a996ad366bd46621cbb6207c4afa1a375.png" alt="7faf1b8a996ad366bd46621cbb6207c4afa1a375"></p><hr><h3><span id="q-xiang-buf-huan-chong-qu-xie-shu-ju-de-fang-shi-you-na-xie">Q： 向buf缓冲区写数据的方式有哪些？</span><a href="#q-xiang-buf-huan-chong-qu-xie-shu-ju-de-fang-shi-you-na-xie" class="header-anchor">#</a></h3><p>A：</p><ul><li>int byteRead = fileChannel.read(buf);<br>从通道中读数据到buf中， 即相当于向buf缓冲区中写数据。</li><li>buf.putChar(‘a’);<br>手动向buf中写入字符a， postion加1。</li></ul><hr><h3><span id="q-shou-dong-xiu-gai-dang-qian-huan-chong-qu-de-postion-de-fang-fa-you-na-xie">Q: 手动修改当前缓冲区的postion的方法有哪些?</span><a href="#q-shou-dong-xiu-gai-dang-qian-huan-chong-qu-de-postion-de-fang-fa-you-na-xie" class="header-anchor">#</a></h3><p>A:<br>rewind() 将postion设置为0<br>mark() 可以标记1个特定的位置， 相当于打标记， 在一顿操作后，可通过reset()回到之前mark()的位置（就像你需要mark我的这几篇博文一样！）</p><hr><h3><span id="q-1-ge-channel-guan-dao-zhi-chi-duo-ge-buffer-ma">Q：1个channel管道支持多个buffer吗？</span><a href="#q-1-ge-channel-guan-dao-zhi-chi-duo-ge-buffer-ma" class="header-anchor">#</a></h3><p>A： 支持。 通道的write和read方法都支持传入1个buffer数组，会按照顺序做读写操作。<br><img src="/images/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/27b39bd04044d506452c7404849d4ecee57fc3eb.png" alt="27b39bd04044d506452c7404849d4ecee57fc3eb"></p><hr><p>Q: 讲一下buffer的种类<br>A:<br>Buffer的种类：<br><img src="/images/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/a881a6f6fe6a8395391678a5982d6620de0193b7.png" alt="a881a6f6fe6a8395391678a5982d6620de0193b7"></p><p>大部分都是java基础类型产生的buffer，  除了mappedByteBuffer比较特别。</p><hr><h3><span id="q-buffer-de-warp-slice-duplicate-fen-bie-shi-zuo-shi-me-de">Q: Buffer的Warp、slice、duplicate分别是做什么的？</span><a href="#q-buffer-de-warp-slice-duplicate-fen-bie-shi-zuo-shi-me-de" class="header-anchor">#</a></h3><p>A:</p><ul><li><p>warp:<br>根据一个byte[]来生成一个固定的ByteBuffer时，使用ByteBuffer.wrap()非法的合适。他会直接基于byte[]数组生成一个新的buffer，值也保持一致。</p></li><li><p>slice：<br>得到切片后的数组。</p></li><li><p>duplicate：<br>调用duplicate方法返回的Buffer对象就是复制了一份原始缓冲区，复制了position、limit、capacity这些属性</p></li></ul><blockquote><blockquote><p>注意！！！！！！<br>以上warp\slice\duplicte生成的缓冲区get和put所操作的数组还是与原始缓冲区一样的<br>所以对复制后的缓冲区进行修改也会修改原始的缓冲区，反之亦然<br>因此duplicte、slice一般是用于操作一下poistion\limit等处理，但是原内容不会去变他，否则就会引起原缓冲器的修改。</p></blockquote></blockquote><h2><span id="selector">Selector</span><a href="#selector" class="header-anchor">#</a></h2><p>selector可用来在线程中关联多个通道，并进行事件监听。<br><img src="/images/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/ec184550662e4d8604d9538a21bab5ea0c04bf2c.png" alt="ec184550662e4d8604d9538a21bab5ea0c04bf2c"></p><hr><h3><span id="q-zai-nio-zhong-selector-de-hao-chu-shi-shi-me">Q： 在NIO中Selector的好处是什么？</span><a href="#q-zai-nio-zhong-selector-de-hao-chu-shi-shi-me" class="header-anchor">#</a></h3><p>A：</p><p>可以用更少的线程来管理各个通道。<br>减少线程上下文切换的资源开销。</p><hr><h3><span id="q-selector-zhi-chi-zhu-ce-na-chong-lei-xing-de-tong-dao">Q： Selector支持注册哪种类型的通道？</span><a href="#q-selector-zhi-chi-zhu-ce-na-chong-lei-xing-de-tong-dao" class="header-anchor">#</a></h3><p>A：<br>支持非阻塞的通道。<br>通道要在注册前调用 channel.configureBlocking(false) 设置为非阻塞。<br>例如FileChannel就没办法注册，他注定是阻塞的。<br>而socketChannel就可以支持非阻塞。</p><hr><h3><span id="q-selector-zhu-ce-shi-zhi-chi-jian-ting-na-ji-chong-shi-jian-dui-ying-de-chang-liang-shi-shi-me-a-zui-bu-xi-huan-ji-yi-zhe-chong-dong-xi-liao">Q： Selector注册时，支持监听哪几种事件，对应的常量是什么？（啊最不喜欢记忆这种东西了…）</span><a href="#q-selector-zhu-ce-shi-zhi-chi-jian-ting-na-ji-chong-shi-jian-dui-ying-de-chang-liang-shi-shi-me-a-zui-bu-xi-huan-ji-yi-zhe-chong-dong-xi-liao" class="header-anchor">#</a></h3><p>A：<br>共有4种可监听事件</p><ul><li>Connect 成功连接到1个服务器，对应常量SelectionKey.OP_CONNECT</li><li>Accept 准备好接收新进入的连接， 对应常量SelectionKey.OP_ACCEPT</li><li>Read, 有数据可读，对应常量SelectionKey.OP_READ</li><li>Write 接收到往里写的数据， 对应常量SelectionKey.OP_WRITE<br>如果希望对该通道监听多种事件，可以用&quot;|&quot;位或操作符把常量连接起来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">interestingSet</span> <span class="operator">=</span> Selectionkey.OP_READ | Selectionkey.OP_WRITE;</span><br><span class="line"><span class="type">Selectionkey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector,interestingSet)</span><br></pre></td></tr></table></figure><p>SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系</p><hr><h3><span id="q-selector-wei-hu-de-selectionkey-ji-he-gong-you-na-ji-chong">Q： Selector维护的SelectionKey集合共有哪几种？</span><a href="#q-selector-wei-hu-de-selectionkey-ji-he-gong-you-na-ji-chong" class="header-anchor">#</a></h3><p>A：<br>共有三种。</p><ol><li><p>已注册的所有键的集合(Registered key set)<br>所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过keys()方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。</p></li><li><p>已选择的键的集合(Selected key set)<br>已注册的键的集合的子集。这个集合的每个成员都是相关的通道被选择器(在前一个选择操作中)判断为已经准备好的，并且包含于键的interest集合中的操作。这个集合通过selectedKeys()方法返回(并有可能是空的)。<br>不要将已选择的键的集合与ready集合弄混了。这是一个键的集合，每个键都关联一个已经准备好至少一种操作的通道。每个键都有一个内嵌的ready集合，指示了所关联的通道已经准备好的操作。键可以直接从这个集合中移除，但不能添加。试图向已选择的键的集合中添加元素将抛出java.lang.UnsupportedOperationException。</p></li><li><p>已取消的键的集合(Cancelled key set)<br>已注册的键的集合的子集，这个集合包含了cancel()方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。</p></li></ol><hr><h3><span id="q-zhu-ce-zhi-hou-ru-he-shi-yong-selector-dui-zhun-bei-jiu-xu-de-tong-dao-zuo-chu-li">Q:注册之后， 如何使用selector对准备就绪的通道做处理：</span><a href="#q-zhu-ce-zhi-hou-ru-he-shi-yong-selector-dui-zhun-bei-jiu-xu-de-tong-dao-zuo-chu-li" class="header-anchor">#</a></h3><p>A：</p><ol><li>调用select()方法获取已就绪的通道，返回的int值表示有多少通道已经就绪</li><li>从selector中获取selectedkeys</li><li>遍历selectedkeys</li><li>查看各SelectionKey中 是否有事件就绪了。</li><li>如果有事件就绪，从key中获取对应对应管道。做对应处理</li><li>类似如下，一般都会启1个线程来run这个selector监听的处理</li></ol><hr><h3><span id="q-select-fang-fa-qi-shi-shi-zu-sai-fang-fa-ji-diao-yong-shi-hui-jin-ru-deng-dai-zhi-dao-ba-suo-you-tong-dao-du-lun-xun-wan-bi-ru-guo-xi-wang-ti-qian-jie-shu-select-you-na-xie-fang-fa">Q：select()方法其实是阻塞方法，即调用时会进入等待，直到把所有通道都轮询完毕。如果希望提前结束select()，有哪些方法？</span><a href="#q-select-fang-fa-qi-shi-shi-zu-sai-fang-fa-ji-diao-yong-shi-hui-jin-ru-deng-dai-zhi-dao-ba-suo-you-tong-dao-du-lun-xun-wan-bi-ru-guo-xi-wang-ti-qian-jie-shu-select-you-na-xie-fang-fa" class="header-anchor">#</a></h3><p>A：<br>有2个办法：<br>wakeup()， 调用后，select（）方法立刻返回。<br>close()， 直接关闭selector。</p><hr><h3><span id="q-zhi-qian-shuo-nio-shi-fei-zu-sai-io-dan-wei-shi-me-shang-mian-que-shuo-select-fang-fa-shi-zu-sai-de">Q:之前说NIO是非阻塞IO，但为什么上面却说select()方法是阻塞的？</span><a href="#q-zhi-qian-shuo-nio-shi-fei-zu-sai-io-dan-wei-shi-me-shang-mian-que-shuo-select-fang-fa-shi-zu-sai-de" class="header-anchor">#</a></h3><p>A:<br>其实NIO的非阻塞，指的是IO不阻塞，即我们不会卡在read()处，我们会用selector去查询就绪状态，如果状态ok就。<br>而查询操作是需要时间，因此select()必须要把所有通道都检查一遍才能告诉结果，因此select这个查询操作是阻塞的。</p><hr><h1><span id="nio-jin-jie">NIO进阶</span><a href="#nio-jin-jie" class="header-anchor">#</a></h1><h2><span id="q-duo-xian-cheng-du-xie-tong-yi-wen-jian-shi-ru-he-jia-suo-bao-zheng-xian-cheng-an-quan">Q： 多线程读写同一文件时，如何加锁保证线程安全？</span><a href="#q-duo-xian-cheng-du-xie-tong-yi-wen-jian-shi-ru-he-jia-suo-bao-zheng-xian-cheng-an-quan" class="header-anchor">#</a></h2><p>A：<br>使用FileChannel的加锁功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(target, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span>  <span class="variable">channel</span> <span class="operator">=</span> randFile.getChannel();</span><br><span class="line"><span class="comment">// pos和siz决定加锁区域， shared指定是否是共享锁</span></span><br><span class="line"><span class="type">FileLock</span> <span class="variable">fileLock</span> <span class="operator">=</span> channel.lock(pos , size , shared);</span><br><span class="line"><span class="keyword">if</span> (fileLock!=<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">do</span>();</span><br><span class="line">   <span class="comment">// 这里简化了，实际上应该用try-catch</span></span><br><span class="line">fileLock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="q-ru-guo-xu-yao-du-1-ge-te-da-wen-jian-ke-yi-shi-yong-shi-me-huan-chong-qu">Q： 如果需要读1个特大文件，可以使用什么缓冲区？</span><a href="#q-ru-guo-xu-yao-du-1-ge-te-da-wen-jian-ke-yi-shi-yong-shi-me-huan-chong-qu" class="header-anchor">#</a></h2><p>A：<br>使用MappedByteBuffer。<br>这个缓冲区可以把大文件理解成1个byte数组来访问（但实际上并没有加载这么大的byte数组，实际内容放在内存+虚存中）。<br>主要通过FileChannel.map（模式，起始位置，区域）来生成1个MappedByteBuffer。<br>然后可以用put和get去处理对应位置的byte。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0x8FFFFFF</span>;<span class="comment">//一个byte占1B，所以共向文件中存128M的数据</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;src/c.txt&quot;</span>),</span><br><span class="line">StandardOpenOption.READ, StandardOpenOption.WRITE);) &#123;</span><br><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">mapBuffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, length);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">mapBuffer.put((<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length/<span class="number">2</span>;i&lt;length/<span class="number">2</span>+<span class="number">4</span>;i++) &#123;</span><br><span class="line"><span class="comment">//像数组一样访问</span></span><br><span class="line">System.out.println(mapBuffer.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapMode的三种模式：</p><ul><li>MapMode.READ_ONLY（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException。</li><li>MapMode.READ_WRITE（读/写）： 对得到的缓冲区的更改会写入文件，需要调用fore()方法</li><li>MapMode.PRIVATE（专用）： 可读可写,但是修改的内容不会写入文件,只是buffer自身的改变。</li></ul><hr><h2><span id="q-nio-zhong-bytebuffer-gai-ru-he-gen-ju-zheng-que-de-bian-ma-zhuan-wei-dui-ying-de-charbuffer">Q：NIO中ByteBuffer， 该如何根据正确的编码，转为对应的CharBuffer</span><a href="#q-nio-zhong-bytebuffer-gai-ru-he-gen-ju-zheng-que-de-bian-ma-zhuan-wei-dui-ying-de-charbuffer" class="header-anchor">#</a></h2><p>A：<br>利用Charset的decode功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> charset.decode(byteBuffer);</span><br><span class="line">如果是CharBuffer转ByteBuffer， 就用charset.encode。</span><br></pre></td></tr></table></figure><hr><h2><span id="q-nio-bei-hou-de-shi-xian-yuan-li-shi-shi-me">Q: NIO背后的实现原理是什么？</span><a href="#q-nio-bei-hou-de-shi-xian-yuan-li-shi-shi-me" class="header-anchor">#</a></h2><p>A: 使用了linux的epoll机制<br>NIO和epoll的对应关系见<a href="https://blog.csdn.net/xing317521/article/details/105054661/">浅谈NIO和Epoll的实现原理</a><br>epoll原理见<a href="http://doc.minidown.cn/ejxpkz/">epoll原理</a></p><hr><p><img src="/images/java-NIO%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/398cc1e5fdaa0abf90cd8e577fd826ade07c3ecf.png" alt="398cc1e5fdaa0abf90cd8e577fd826ade07c3ecf"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java高级应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原神旅游日记</title>
      <link href="/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p><img src="/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" alt="1660493655011"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO基础</title>
      <link href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java-IO%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java-IO%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wen-jian-api">文件API</a><ul><li><a href="#q-file-lei-ke-yi-yong-lai-zuo-mu-lu-cao-zuo-ma">Q: File类可以用来做目录操作吗？</a></li><li><a href="#q-zhi-jie-diao-yong-file-delete-ke-yi-shan-chu-mu-lu-ma">Q：直接调用file.delete()可以删除目录吗？</a></li><li><a href="#q-you-na-xie-fang-fa-pan-duan-gei-ding-lu-jing-xia-wen-jian-shi-fou-cun-zai">Q： 有哪些方法判断给定路径下文件是否存在？</a></li></ul></li><li><a href="#zi-jie-shu-ru-liu-inputstream">字节输入流InputStream</a><ul><li><a href="#shuo-yi-xia-yi-xia-zhe-xie-te-dian-dui-ying-na-xie-inputstream-lei">说一下以下这些特点对应哪些InputStream类</a></li><li><a href="#q-filterinputstream-shi-shi-me">Q： FilterInputStream是什么？</a></li></ul></li><li><a href="#zi-jie-shu-chu-liu-outputstream">字节输出流OutputStream</a><ul><li><a href="#q-outputstream-bao-han-na-xie-shi-xian">Q: OutputStream包含哪些实现？</a></li><li><a href="#q-new-fileoutputstream-name-true-zhe-ge-gou-zao-li-de-true-can-shu-shi-zuo-shi-me-yong-de">Q：new FileOutputStream(name, true)，这个构造里的true参数是做什么用的？</a></li><li><a href="#q-bufferoutputstream-xiang-guan-gai-nian-qi-shi-shi-kao-huan-chong-qu-shi-fou-xu-yao-shua-xin-zhi-lei-de-wen-ti">Q：BufferOutputStream相关概念（其实是考缓冲区是否需要刷新之类的问题）</a></li></ul></li><li><a href="#reader-he-writer">Reader和Writer</a><ul><li><a href="#q-reader-writer-he-inputstream-outputstream-de-qu-bie">Q: Reader/Writer和InputStream/OutputStream的区别？</a></li><li><a href="#ru-he-she-zhi-she-zhi-bian-ma">如何设置设置编码：</a></li></ul></li><li><a href="#xu-lie-hua-wen-ti">序列化问题</a><ul><li><a href="#q-java-de-xu-lie-hua-yi-ban-shi-zuo-shi-me-de">Q: java的序列化一般是做什么的？</a></li><li><a href="#q-dui-mou-dui-xiang-jin-xing-xu-lie-hua-shi-ru-he-rang-li-mian-mou-ge-min-gan-cheng-yuan-bu-bei-xu-lie-hua">Q： 对某对象进行序列化时， 如何让里面某个敏感成员不被序列化？</a></li><li><a href="#q-externalizable-he-serializable-na-ge-kuai-yuan-yin-shi-shi-me">Q： Externalizable和Serializable哪个快？ 原因是什么？</a></li><li><a href="#q-externalizable-xu-yao-chan-sheng-xu-lie-hua-id-ma">Q： Externalizable需要产生序列化ID吗？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="wen-jian-api">文件API</span><a href="#wen-jian-api" class="header-anchor">#</a></h1><h2><span id="q-file-lei-ke-yi-yong-lai-zuo-mu-lu-cao-zuo-ma">Q: File类可以用来做目录操作吗？</span><a href="#q-file-lei-ke-yi-yong-lai-zuo-mu-lu-cao-zuo-ma" class="header-anchor">#</a></h2><p>A：<br>可以。<br>File对象本身可以是目录。<br>调用file.mkdirs()即可创建目录。</p><hr><h2><span id="q-zhi-jie-diao-yong-file-delete-ke-yi-shan-chu-mu-lu-ma">Q：直接调用file.delete()可以删除目录吗？</span><a href="#q-zhi-jie-diao-yong-file-delete-ke-yi-shan-chu-mu-lu-ma" class="header-anchor">#</a></h2><p>A：<br>如果是文件或者空目录，可以直接删除。<br>但如果目录中有文件或者子目录，则必须递归删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">    String[] children = dir.list();</span><br><span class="line">　　　　　　　<span class="comment">//递归删除目录中的子目录下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;children.length; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> deleteDir(<span class="keyword">new</span> <span class="title class_">File</span>(dir, children[i]));</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 目录此时为空，可以删除</span></span><br><span class="line">   <span class="keyword">return</span> dir.delete();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="q-you-na-xie-fang-fa-pan-duan-gei-ding-lu-jing-xia-wen-jian-shi-fou-cun-zai">Q： 有哪些方法判断给定路径下文件是否存在？</span><a href="#q-you-na-xie-fang-fa-pan-duan-gei-ding-lu-jing-xia-wen-jian-shi-fou-cun-zai" class="header-anchor">#</a></h2><p>A：</p><ol><li>File类的exists方法： ? file.exist(string)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">testFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(testFilePath);</span><br><span class="line"><span class="keyword">if</span>(!testFile .exists()) &#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>File类的静态exist方法, File.exist(Path path)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> Paths.get(testFilePath);</span><br><span class="line"><span class="keyword">if</span> (Files.exists(filePath) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>注意静态方法和非静态方法的区别</p><h1><span id="zi-jie-shu-ru-liu-inputstream">字节输入流InputStream</span><a href="#zi-jie-shu-ru-liu-inputstream" class="header-anchor">#</a></h1><h2><span id="shuo-yi-xia-yi-xia-zhe-xie-te-dian-dui-ying-na-xie-inputstream-lei">说一下以下这些特点对应哪些InputStream类</span><a href="#shuo-yi-xia-yi-xia-zhe-xie-te-dian-dui-ying-na-xie-inputstream-lei" class="header-anchor">#</a></h2><ul><li>字节数组char[] 作为输入源的InputStream类是————ByteArrayInputStream</li><li>用文件作为输入源的InputStream类是？————FileInputStream</li><li>用字符串作为输入源的是？————StringBufferInputStream</li><li>用于多线程之间管道通信的输入源是————PipeInputStream ?</li></ul><hr><h2><span id="q-filterinputstream-shi-shi-me">Q： FilterInputStream是什么？</span><a href="#q-filterinputstream-shi-shi-me" class="header-anchor">#</a></h2><p>A： 用于装饰上面这些输入流的，可以叠加，每装饰一层就相当于增加了1个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInputStream</span>(InputStream)</span><br></pre></td></tr></table></figure><p>–<br>以下这些特点分别对应哪些FilterInputStream？</p><ul><li>装饰后，不仅可读字符串，还可读取例如int、long等java基本类型的是————DataInputStream<br>DataInputStream里面会支持readInt、readLong等方法。</li><li>装饰后，支持分批缓冲读取读取的是————BufferedInputStream<br>创建BufferedInputStream时，我们会通过它的构造函数指定某个输入流为参数。BufferedInputStream会将该输入流数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从输入流中读取下一部分的数据。</li><li>其他：<br>PushbackInputStream： 具有1个能回退上一个字节的缓冲区<br>ObjectInputStream ： 一般用于反序列化读入<br>LineNumberInputStream： 可跟踪输入流中的行号</li></ul><hr><h1><span id="zi-jie-shu-chu-liu-outputstream">字节输出流OutputStream</span><a href="#zi-jie-shu-chu-liu-outputstream" class="header-anchor">#</a></h1><h2><span id="q-outputstream-bao-han-na-xie-shi-xian">Q: OutputStream包含哪些实现？</span><a href="#q-outputstream-bao-han-na-xie-shi-xian" class="header-anchor">#</a></h2><p>ByteArrayOutputStream ?输出到缓冲区?<br>FileOutputStream ? 写到文件<br>PipedOutputStream ?写入管道<br>FilterOutputStream ?</p><p>而FilterOutputStream 包含</p><ul><li>DataOutputStream ?（可以out.writexxx各种类型的数据，writeDouble， writeUTF， ?reader也一样，可以读想要的数据类型）、</li><li>PringtStream （输出到文件用这个， 该类.println(str)即可写入文件）</li><li>BufferOutputString</li></ul><hr><p>FileOutputStream相关</p><h2><span id="q-new-fileoutputstream-name-true-zhe-ge-gou-zao-li-de-true-can-shu-shi-zuo-shi-me-yong-de">Q：new FileOutputStream(name, true)，这个构造里的true参数是做什么用的？</span><a href="#q-new-fileoutputstream-name-true-zhe-ge-gou-zao-li-de-true-can-shu-shi-zuo-shi-me-yong-de" class="header-anchor">#</a></h2><p>A：<br>是否支持在文件末追加的意思。<br><img src="/images/Java-IO%E5%9F%BA%E7%A1%80/1618921889243064567.png" alt="image.png"></p><p>默认是false，指的是覆盖整个文本。<br>如果设置成true，会在要写入的文件后面追加本次写入的内容。</p><hr><h2><span id="q-bufferoutputstream-xiang-guan-gai-nian-qi-shi-shi-kao-huan-chong-qu-shi-fou-xu-yao-shua-xin-zhi-lei-de-wen-ti">Q：BufferOutputStream相关概念（其实是考缓冲区是否需要刷新之类的问题）</span><a href="#q-bufferoutputstream-xiang-guan-gai-nian-qi-shi-shi-kao-huan-chong-qu-shi-fou-xu-yao-shua-xin-zhi-lei-de-wen-ti" class="header-anchor">#</a></h2><ul><li>BufferOutputStream里的flush()方法是做什么的？</li><li>BufferOutputStream调用close后，会触发flush()来刷新缓冲区吗？</li><li>BufferOutputStream调用close可能会丢数据吗？</li><li>BufferOutputStream多次调用close会报错吗？</li></ul><p>A：</p><ul><li><p>flush把缓冲区里的数据写入文件，并刷新缓冲区<br><img src="/images/Java-IO%E5%9F%BA%E7%A1%80/1618921900764052010.png" alt="image.png"></p></li><li><p>close关闭此输出流并释放与此相关联的任何系统资源， 会调用flush，除了flushBuffer，还会调用父类的flush。</p></li><li><p>不会丢数据，因为上面这条原因。</p></li><li><p>多次调用不会报错。<br>*?<br><img src="/images/Java-IO%E5%9F%BA%E7%A1%80/1618921909192091711.png" alt="image.png"></p></li></ul><h1><span id="reader-he-writer">Reader和Writer</span><a href="#reader-he-writer" class="header-anchor">#</a></h1><h2><span id="q-reader-writer-he-inputstream-outputstream-de-qu-bie">Q: Reader/Writer和InputStream/OutputStream的区别？</span><a href="#q-reader-writer-he-inputstream-outputstream-de-qu-bie" class="header-anchor">#</a></h2><p>A：</p><ul><li>InputStream是表示 <em><strong>字节输入流</strong></em> 的所有类的超类<br>Reader是用于读取 <em><strong>字符流</strong></em> 的抽象类<br>InputStream提供的是字节流的读取，而非文本读取，这是和Reader类的根本区别。<br>即用Reader读取出来的是char数组或者String ，使用InputStream读取出来的是byte数组。</li><li>Reader/Writer提供兼容Unicode、面向字符的IO功能，为了国际化</li></ul><hr><ul><li>用reader读取标准输入：<br>BufferedReader bufr = new BufferedReader(new InputStreamReader(<a href="http://System.in">System.in</a>));</li><li>用Writer进行标准输出：<br>BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</li></ul><hr><h2><span id="ru-he-she-zhi-she-zhi-bian-ma">如何设置设置编码：</span><a href="#ru-he-she-zhi-she-zhi-bian-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file), <span class="string">&quot;UTF-8&quot;</span>); ?</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr); ?</span><br></pre></td></tr></table></figure><h1><span id="xu-lie-hua-wen-ti">序列化问题</span><a href="#xu-lie-hua-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-java-de-xu-lie-hua-yi-ban-shi-zuo-shi-me-de">Q: java的序列化一般是做什么的？</span><a href="#q-java-de-xu-lie-hua-yi-ban-shi-zuo-shi-me-de" class="header-anchor">#</a></h2><p>A:</p><ol><li>永久的保存对象数据(将对象数据保存在文件当中,或者是磁盘中</li><li>通过序列化操作将对象数据在网络上进行传输(由于网络传输是以字节流的方式对数据进行传输的.因此序列化的目的是将对象数据转换成字节流的形式)</li><li>将对象数据在进程之间进行传递(Activity之间传递对象数据时,需要在当前的Activity中对对象数据进行序列化操作.在另一个Activity中需要进行反序列化操作讲数据取出)</li><li>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长（即每个对象都在JVM中）但在现实应用中，就可能要停止JVM运行，但有要保存某些指定的对象，并在将来重新读取被保存的对象。这是Java对象序列化就能够实现该功能。（可选择入数据库、或文件的形式保存）</li><li>序列化对象的时候只是针对变量进行序列化,不针对方法进行序列化.</li><li>在Intent之间,基本的数据类型直接进行相关传递即可,但是一旦数据类型比较复杂的时候,就需要进行序列化操作了.</li></ol><hr><h2><span id="q-dui-mou-dui-xiang-jin-xing-xu-lie-hua-shi-ru-he-rang-li-mian-mou-ge-min-gan-cheng-yuan-bu-bei-xu-lie-hua">Q： 对某对象进行序列化时， 如何让里面某个敏感成员不被序列化？</span><a href="#q-dui-mou-dui-xiang-jin-xing-xu-lie-hua-shi-ru-he-rang-li-mian-mou-ge-min-gan-cheng-yuan-bu-bei-xu-lie-hua" class="header-anchor">#</a></h2><p>A:?</p><ul><li>方法一：可使用transient关键字处理那个敏感成员</li><li>方法二：可以通过覆盖Serializable接口的writeObject和readObject来实现序列化， ?但是方法签名必须是private void writeObject(ObjetOutputStream stream) throw IOException;</li><li>方法三： 实现Externalizable接口，可自定义实现writeExternal以及readExternal方法</li></ul><hr><h2><span id="q-externalizable-he-serializable-na-ge-kuai-yuan-yin-shi-shi-me">Q： Externalizable和Serializable哪个快？ 原因是什么？</span><a href="#q-externalizable-he-serializable-na-ge-kuai-yuan-yin-shi-shi-me" class="header-anchor">#</a></h2><p>A： Externalizable更快。<br>原因：</p><ul><li><p>Java序列化写入不仅是完整的类名，也包含整个类的定义，包含所有被引用的类。<br>类定义可以是相当大的，也许构成了性能和效率的问题，当然这是编写一个单一的对象。如果您正在编写了大量相同的类的对象，这时类定义的开销通常不是一个大问题。另一件事情是，如果你的对象有一类的引用（如元数据对象），那么Java序列化将写入整个类的定义，不只是类的名称，因此，使用Java序列化写出元数据（meta-data）是非常昂贵的</p></li><li><p>通过实现Externalizable接口，这是可能优化Java序列化的。实现此接口，避免写出整个类定义，只是类名被写入</p></li></ul><hr><h2><span id="q-externalizable-xu-yao-chan-sheng-xu-lie-hua-id-ma">Q： Externalizable需要产生序列化ID吗？</span><a href="#q-externalizable-xu-yao-chan-sheng-xu-lie-hua-id-ma" class="header-anchor">#</a></h2><p>A： 采用Externalizable无需产生序列化ID（serialVersionUID）~而Serializable接口则需要</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程基础</title>
      <link href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#thread-lei-ji-chu">Thread类基础</a><ul><li><a href="#q-thread-de-deprecated-guo-qi-fang-fa-shi-na-3-ge-zuo-yong-shi-sha">Q： Thread的deprecated过期方法是哪3个？作用是啥</a></li><li><a href="#q-fei-qi-stop-de-yuan-yin-shi-sha">Q： 废弃stop的原因是啥？</a></li><li><a href="#q-stop-de-ti-dai-fang-fa-shi-shi-me">Q： stop的替代方法是什么？</a></li><li><a href="#q-suspend-resume-de-fei-qi-yuan-yin-shi-shi-me">Q： suspend/resume的废弃原因是什么？</a></li><li><a href="#q-shang-ti-de-suspend-he-resume-ke-yi-zen-me-ti-huan-lai-jie-jue-si-suo-wen-ti">Q： 上题的suspend和resume可以怎么替换，来解决死锁问题？</a></li><li><a href="#q-xia-mian-zhe-li-zi-wei-shi-me-hui-yun-xing-yi-chang-pao-chu-illegalmonitorstateexception-cuo-wu">Q： 下面这例子为什么会运行异常，抛出IllegalMonitorStateException错误？</a></li><li><a href="#q-wei-shi-me-wait-bi-xu-chi-you-suo-de-shi-hou-cai-neng-diao-yong">Q: 为什么wait必须持有锁的时候才能调用？</a></li><li><a href="#q-thread-sleep-he-object-wait-de-qu-bie">Q： Thread.sleep()和Object.wait()的区别</a></li><li><a href="#q-ru-guo-you-3-ge-xian-cheng-tong-shi-qiang-zhan-liao-zhe-ge-suo-qie-du-zai-wait-wo-xi-wang-zhi-notify-huan-xing-mou-ge-xian-cheng-zen-me-ban">Q: 如果有3个线程同时抢占了这个锁且都在wait，我希望只notify唤醒某个线程，怎么办？</a></li><li><a href="#q-locksupport-xiang-bi-notify-wait-you-shi-me-you-dian">Q: LockSupport相比notify/wait有什么优点？</a></li><li><a href="#q-runnable-jie-kou-he-callable-de-qu-bie">Q：Runnable接口和Callable的区别。</a></li><li><a href="#q-thread-alive-biao-shi-xian-cheng-dang-qian-shi-fou-chu-yu-huo-yue-ke-yong-zhuang-tai-thread-start-hou-shi-fou-alive-yi-ding-fan-hui-true">Q：thread.alive()表示线程当前是否处于活跃/可用状态。thread.start()后，是否alive()一定返回true？</a></li><li><a href="#q-xian-cheng-a-ru-xia-ba-xian-cheng-a-zuo-wei-gou-zao-can-shu-chuan-gei-xian-cheng-b-ci-shi-dui-b-xian-cheng-da-yin-this-isalive-hui-xian-shi-shi-me">Q: 线程A如下，把线程A作为构造参数，传给线程B，此时对B线程打印this.isAlive会显示什么？：</a></li><li><a href="#q-ba-futuretask-fang-jin-thread-zhong-bing-start-hou-hui-zheng-chang-zhi-xing-callable-li-de-nei-rong-ma">Q：把FutureTask放进Thread中，并start后，会正常执行callable里的内容吗？</a></li></ul></li><li><a href="#synchronized-guan-jian-zi">synchronized关键字</a><ul><li><a href="#q-diao-yong-xia-mian-de-f-shi-hui-chu-xian-si-suo-ma">Q： 调用下面的f()时，会出现死锁吗？</a></li><li><a href="#q-2-ge-xian-cheng-tong-shi-diao-yong-f1-he-f2-hui-chan-sheng-tong-bu-ma">Q:2个线程同时调用f1和f2会产生同步吗？</a></li></ul></li><li><a href="#qi-ta-de-tong-bu-gong-ju">其他的同步工具</a><ul><li><a href="#countdownlatch">CountDownLatch</a><ul><li><a href="#q-countdownlatch-de-nei-bu-ji-shu-zhi-neng-bei-chong-zhi-ma">Q： countDownLatch的内部计数值能被重置吗？</a></li></ul></li><li><a href="#futuretask">FutureTask</a><ul><li><a href="#q-diao-yong-futruetask-get-shi-zhe-ge-shi-zu-sai-fang-fa-ma-ru-guo-shi-zu-sai-shi-me-shi-hou-hui-jie-shu">Q：调用futrueTask.get()时，这个是阻塞方法吗？如果是阻塞，什么时候会结束？</a></li></ul></li><li><a href="#semaphore">Semaphore</a><ul><li><a href="#xin-hao-liang-gai-nian">信号量概念</a></li><li><a href="#q-xin-hao-liang-zhong-gong-ping-mo-shi-he-fei-gong-ping-mo-shi-de-qu-bie-xia-mian-she-cheng-true-jiu-shi-gong-ping-mo-shi">Q： 信号量中，公平模式和非公平模式的区别？下面设成true就是公平模式</a></li></ul></li><li><a href="#cyclicbarrier-zha-lan">CyclicBarrier （栅栏）</a></li><li><a href="#exchanger-jiao-huan-zha-lan">Exchanger （交换栅栏）</a></li><li><a href="#yuan-zi-lei-atomicxxx">原子类AtomicXXX</a><ul><li><a href="#q-xia-mian-shu-chu-shi-me-kao-cha-getandadd-de-yong-fa">Q：下面输出什么？（考察getAndAdd的用法）</a></li><li><a href="#q-atomicreference-he-atomicinteger-de-qu-bie">Q：AtomicReference和AtomicInteger的区别？</a></li><li><a href="#java-zhong-yi-shi-xian-de-quan-bu-yuan-zi-lei">java中已实现的全部原子类：</a></li></ul></li></ul></li><li><a href="#xian-cheng-chi">线程池</a><ul><li><a href="#q-threadpoolexecutor-xian-cheng-chi-gou-zao-can-shu-zhong-corepoolsize-he-maximumpoolsize-you-shi-me-qu-bie">Q: ThreadPoolExecutor线程池构造参数中，corePoolSize和maximumPoolSize有什么区别？</a></li><li><a href="#q-xian-cheng-chi-de-keepalive-can-shu-shi-gan-ma-de">Q： 线程池的keepalive参数是干嘛的？</a></li><li><a href="#q-he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">Q: 核心线程可以被回收吗？（线程池没有被回收的情况下）</a></li><li><a href="#q-na-zhe-ge-xian-cheng-shu-she-zhi-duo-shao-ni-shi-zen-me-kao-lu-de-ni">Q: 那这个线程数设置多少，你是怎么考虑的呢？</a></li><li><a href="#q-xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">Q： 线程池有哪三种队列策略？</a></li><li><a href="#q-xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">Q： 线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</a></li><li><a href="#q-xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">Q: 线程池为什么需要阻塞队列？</a></li><li><a href="#q-you-yi-xia-wu-chong-executor-ti-gong-de-xian-cheng-chi-zhu-yi-ji-yi-yi-xia-ta-men-de-yong-tu-jiu-neng-li-jie-nei-bu-de-yuan-li-liao">Q：有以下五种Executor提供的线程池，注意记忆一下他们的用途，就能理解内部的原理了。</a></li><li><a href="#q-submit-he-execute-de-qu-bie-shi-shi-me">Q： submit和execute的区别是什么？</a></li><li><a href="#q-xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">Q：线程池中， shutdown、 shutdownNow、awaitTermination的区别？</a></li></ul></li><li><a href="#thread-zhuang-tai-zhuan-huan">Thread状态转换</a><ul><li><a href="#q-xian-cheng-de-6-chong-zhuang-tai-shi">Q： 线程的6种状态是：</a></li><li><a href="#q-java-xian-cheng-shi-me-shi-hou-hui-jin-ru-zu-sai-ke-neng-an-duo-xuan-ti-kao">Q： java线程什么时候会进入阻塞（可能按多选题考）：</a></li></ul></li><li><a href="#volatile">Volatile</a><ul><li><a href="#q-bu-yong-volatile-xiu-shi-cheng-yuan-bian-liang-shi-wei-shi-me-qi-ta-xian-cheng-hui-wu-fa-li-ji-kan-dao-gai-bian">Q： 不用volatile修饰成员变量时， 为什么其他线程会无法立即看到改变？</a></li><li><a href="#q-yong-liao-volatile-shi-bu-shi-jiu-ke-yi-bu-yong-jia-suo-la">Q： 用了volatile是不是就可以不用加锁啦？</a></li><li><a href="#q-zhan-shi-yi-duan-java-bing-fa-bian-cheng-shi-zhan-shu-li-de-yi-ge-jing-dian-li-zi-wei-shi-me-xia-mian-zhe-ge-li-zi-ke-neng-hui-si-xun-huan-huo-zhe-shu-chu-0">Q:展示一段《Java并发编程实战》书里的一个经典例子，为什么下面这个例子可能会死循环，或者输出0？</a></li><li><a href="#q-volatile-bian-liang-ru-guo-ding-yi-de-tai-duo-hui-fa-sheng-shi-me">Q: volatile变量如果定义的太多会发生什么？</a></li></ul></li><li><a href="#xian-cheng-qun-zu">线程群组</a><ul><li><a href="#q-zai-xian-cheng-a-zhong-chuang-jian-xian-cheng-b-ta-men-shu-yu-tong-yi-ge-xian-cheng-zu-ma">Q：在线程A中创建线程B， 他们属于同一个线程组吗</a></li><li><a href="#q-na-wo-gai-cheng-gou-zao-guan-xi-shang-de-fu-zi-guan-xi-xia-mian-shu-chu-shi-me">Q： 那我改成构造关系上的父子关系，下面输出什么？</a></li><li><a href="#q-ru-guo-wo-rang-zi-ji-zuo-set-bu-zhuo-qi-de-cao-zuo-ni-na-xia-mian-zhe-ge-shu-chu-shi-me">Q：如果我让自己做set捕捉器的操作呢？那下面这个输出什么？</a></li><li><a href="#xiu-gai-yi-xia-zhi-qian-de-zong-jie-yi-xia-xian-cheng-de-shi-ji-yi-chang-pao-chu-pan-duan-luo-ji">修改一下之前的总结一下线程的实际异常抛出判断逻辑：</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="thread-lei-ji-chu">Thread类基础</span><a href="#thread-lei-ji-chu" class="header-anchor">#</a></h1><h2><span id="q-thread-de-deprecated-guo-qi-fang-fa-shi-na-3-ge-zuo-yong-shi-sha">Q： Thread的deprecated过期方法是哪3个？作用是啥</span><a href="#q-thread-de-deprecated-guo-qi-fang-fa-shi-na-3-ge-zuo-yong-shi-sha" class="header-anchor">#</a></h2><p>A：</p><ul><li>stop()， 终止线程的执行。</li><li>suspend()， 暂停线程执行。</li><li>resume()， 恢复线程执行。</li></ul><hr><h2><span id="q-fei-qi-stop-de-yuan-yin-shi-sha">Q： 废弃stop的原因是啥？</span><a href="#q-fei-qi-stop-de-yuan-yin-shi-sha" class="header-anchor">#</a></h2><p>A：<br>调用stop时，会直接终止线程并释放线程上已锁定的锁，线程内部无法感知，<em><strong>并且不会做线程内的catch操作</strong></em>！<br>即线程内部不会处理stop后的烂摊子。如果其他线程等在等着上面的锁去取数据， 那么拿到的可能是1个半成品。<br>变成题目的话应该是下面这样，问会输出什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        <span class="comment">// thread.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//处理烂摊子,清理资源</span></span><br><span class="line">            System.out.println(<span class="string">&quot;clear resource!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是输出 start和run，但是不会输出clear resource</p><hr><h2><span id="q-stop-de-ti-dai-fang-fa-shi-shi-me">Q： stop的替代方法是什么？</span><a href="#q-stop-de-ti-dai-fang-fa-shi-shi-me" class="header-anchor">#</a></h2><p>A： interrupt()。<br>调用thread.interrupt()终止时，  不会直接释放锁，可通过调用interrupt()或者捕捉sleep产生的中断异常，来判断是否被终止，并处理烂摊子。<br>上题把thread.stop()改成thread.interrupt()，在Thread.sleep()过程中就会抛出interrupException（注意，InterrupExcetpion是sleep抛出的）<br>因此就会输出clear resource。<br>如果没有做sleep操作， 可以用isInterrupted()来判断自己这个线程是否被终止了，来做清理。<br>另外注意一下interrupt和isInterrupted的区别：<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147310174077755.png" alt="image.png"></p><hr><h2><span id="q-suspend-resume-de-fei-qi-yuan-yin-shi-shi-me">Q： suspend/resume的废弃原因是什么？</span><a href="#q-suspend-resume-de-fei-qi-yuan-yin-shi-shi-me" class="header-anchor">#</a></h2><p>A： ：调用suspend不会释放锁。<br>如果线程A暂停后，他的resume是由线程B来调用的，但是线程B又依赖A里的某个锁，那么就死锁了。<br>例如下面这个例子，就要知道会引发死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程试图占用lockObject锁资源&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">            <span class="comment">// 用Test.lockObject做一些事</span></span><br><span class="line">            System.out.println(<span class="string">&quot;做一些事&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复&quot;</span>);</span><br><span class="line">        thread.resume();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;占用Test.lockObject&quot;</span>);</span><br><span class="line">                suspend();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread释放TestlockObject锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案输出<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147342840021209.png" alt="image.png"></p><p>MyThread内部暂停后，外部的main因为没法拿到锁，所以无法执行后面的resume操作。</p><hr><h2><span id="q-shang-ti-de-suspend-he-resume-ke-yi-zen-me-ti-huan-lai-jie-jue-si-suo-wen-ti">Q： 上题的suspend和resume可以怎么替换，来解决死锁问题？</span><a href="#q-shang-ti-de-suspend-he-resume-ke-yi-zen-me-ti-huan-lai-jie-jue-si-suo-wen-ti" class="header-anchor">#</a></h2><p>A： 可以用wait和noitfy来处理（不过尽量不要这样设计，一般都是用run内部带1个while循环的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//拿来做临时锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程试图占用lockObject锁资源&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">            <span class="comment">// 用Test.lockObject做一些事</span></span><br><span class="line">            System.out.println(<span class="string">&quot;做一些事&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">            Test.lockObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;占用Test.lockObject&quot;</span>);</span><br><span class="line">                Test.lockObject.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread释放TestlockObject锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如此执行，结果正常：<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147354886034832.png" alt="image.png"></p><hr><h2><span id="q-xia-mian-zhe-li-zi-wei-shi-me-hui-yun-xing-yi-chang-pao-chu-illegalmonitorstateexception-cuo-wu">Q： 下面这例子为什么会运行异常，抛出IllegalMonitorStateException错误？</span><a href="#q-xia-mian-zhe-li-zi-wei-shi-me-hui-yun-xing-yi-chang-pao-chu-illegalmonitorstateexception-cuo-wu" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： notify和wait的使用前提是必须持有这个对象的锁， 即main代码块 需要先持有thread对象的锁，才能使用notify去唤醒（wait同理）。<br>改成下面就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">    thread.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2><span id="q-wei-shi-me-wait-bi-xu-chi-you-suo-de-shi-hou-cai-neng-diao-yong">Q: 为什么wait必须持有锁的时候才能调用？</span><a href="#q-wei-shi-me-wait-bi-xu-chi-you-suo-de-shi-hou-cai-neng-diao-yong" class="header-anchor">#</a></h2><p>A:<br>因为wait和notify是组合使用的。</p><ul><li>一般是到了一定条件例如缺少资源、缺乏某个前置动作时，才会进入wait。</li><li>这时候生产资源的那个线程生产了新资源后，就会调用notify方法，告诉另一个线程，我做好了，你可以动身了。</li><li>但如果我们不先加同步块， 就可能导致 wait之前的判断条件有问题，即先判断缺资源， 然后切到另一个线程 做了资源生产并notify， 这时候再wait已经没有意义了, 永远收不到notify。  ”即如果不在同步块中，则wait的判断条件或者wait时机可能是有问题的！“<br><a href="https://www.cnblogs.com/set-cookie/p/8686218.html">为什么WAIT必须在同步块中</a></li></ul><hr><h2><span id="q-thread-sleep-he-object-wait-de-qu-bie">Q： Thread.sleep()和Object.wait()的区别</span><a href="#q-thread-sleep-he-object-wait-de-qu-bie" class="header-anchor">#</a></h2><p>A：<br>sleep不会释放对象锁， 而wait会释放对象锁。</p><hr><h2><span id="q-ru-guo-you-3-ge-xian-cheng-tong-shi-qiang-zhan-liao-zhe-ge-suo-qie-du-zai-wait-wo-xi-wang-zhi-notify-huan-xing-mou-ge-xian-cheng-zen-me-ban">Q: 如果有3个线程同时抢占了这个锁且都在wait，我希望只notify唤醒某个线程，怎么办？</span><a href="#q-ru-guo-you-3-ge-xian-cheng-tong-shi-qiang-zhan-liao-zhe-ge-suo-qie-du-zai-wait-wo-xi-wang-zhi-notify-huan-xing-mou-ge-xian-cheng-zen-me-ban" class="header-anchor">#</a></h2><p>A:</p><ol><li>使用LockSupport,  可以unPark指定的线程。<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/0904c96f81872d9d57deb7cc7cf5e9afb0601039.png" alt="0904c96f81872d9d57deb7cc7cf5e9afb0601039"></li><li>使用Lock + Condition 实现唤醒指定的部分线程。即锁是同一个，但是可以针对锁生成的特定condition做唤醒<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/799b48eaf23750316d096f97237b0cca42e2332f.png" alt="799b48eaf23750316d096f97237b0cca42e2332f"><br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/3ad4a174c3b5b160dc51501502f57c2fe62cdcb5.png" alt="3ad4a174c3b5b160dc51501502f57c2fe62cdcb5"></li></ol><hr><h2><span id="q-locksupport-xiang-bi-notify-wait-you-shi-me-you-dian">Q: LockSupport相比notify/wait有什么优点？</span><a href="#q-locksupport-xiang-bi-notify-wait-you-shi-me-you-dian" class="header-anchor">#</a></h2><p>A:</p><ol><li>LockSupport不需要在同步代码块里 。所以线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦。</li><li>unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序。</li></ol><hr><h2><span id="q-runnable-jie-kou-he-callable-de-qu-bie">Q：Runnable接口和Callable的区别。</span><a href="#q-runnable-jie-kou-he-callable-de-qu-bie" class="header-anchor">#</a></h2><p>A： Callable可以和Futrue配合，并且启动线程时用的时call，能够拿到线程结束后的返回值，call方法还能抛出异常。</p><hr><h2><span id="q-thread-alive-biao-shi-xian-cheng-dang-qian-shi-fou-chu-yu-huo-yue-ke-yong-zhuang-tai-thread-start-hou-shi-fou-alive-yi-ding-fan-hui-true">Q：thread.alive()表示线程当前是否处于活跃/可用状态。thread.start()后，是否alive()一定返回true？</span><a href="#q-thread-alive-biao-shi-xian-cheng-dang-qian-shi-fou-chu-yu-huo-yue-ke-yong-zhuang-tai-thread-start-hou-shi-fou-alive-yi-ding-fan-hui-true" class="header-anchor">#</a></h2><p>活跃状态： 线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestThread</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Begin == &quot;</span> + tt.isAlive());</span><br><span class="line">        tt.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;end == &quot;</span> + tt.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>不一定，有可能在打印时，线程已经运行结束了，或者start后，还未真正启动起来（就是还没进入到run中）</p><hr><h2><span id="q-xian-cheng-a-ru-xia-ba-xian-cheng-a-zuo-wei-gou-zao-can-shu-chuan-gei-xian-cheng-b-ci-shi-dui-b-xian-cheng-da-yin-this-isalive-hui-xian-shi-shi-me">Q: 线程A如下，把线程A作为构造参数，传给线程B，此时对B线程打印this.isAlive会显示什么？：</span><a href="#q-xian-cheng-a-ru-xia-ba-xian-cheng-a-zuo-wei-gou-zao-can-shu-chuan-gei-xian-cheng-b-ci-shi-dui-b-xian-cheng-da-yin-this-isalive-hui-xian-shi-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this.isAlive()=&quot;</span> + <span class="built_in">this</span>.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(a);</span><br><span class="line">b.start()</span><br></pre></td></tr></table></figure><p>A：<br>此时会打印false!<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147372933056462.png" alt="image.png"></p><p>因为把a作为构造参数传入b中， b执行start时， 实际上是在B线程中去调用了 A对象的run方法，而不是启用了A线程。<br>如果改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.start()</span><br></pre></td></tr></table></figure><p>那么就会打印true了</p><hr><h2><span id="q-ba-futuretask-fang-jin-thread-zhong-bing-start-hou-hui-zheng-chang-zhi-xing-callable-li-de-nei-rong-ma">Q：把FutureTask放进Thread中，并start后，会正常执行callable里的内容吗？</span><a href="#q-ba-futuretask-fang-jin-thread-zhong-bing-start-hou-hui-zheng-chang-zhi-xing-callable-li-de-nei-rong-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;call 100&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>能正常打印</p><h1><span id="synchronized-guan-jian-zi">synchronized关键字</span><a href="#synchronized-guan-jian-zi" class="header-anchor">#</a></h1><ul><li>即可作为方法的修饰符，也可以作为代码块的修饰符</li><li>注意修饰方法时，并不是这个方法上有锁， 而是调用该方法时，需要取该方法所在对象上的锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">     synchroized <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即调用这个f()， 并不是说f同一时刻只能进入一次，而是说进入f时，需要取到A上的锁。</p><hr><h2><span id="q-diao-yong-xia-mian-de-f-shi-hui-chu-xian-si-suo-ma">Q： 调用下面的f()时，会出现死锁吗？</span><a href="#q-diao-yong-xia-mian-de-f-shi-hui-chu-xian-si-suo-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">     synchroized <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        t()</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     synchroized <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：不会。<br>1个线程内， 可以重复进入1个对象的synchroized 块。</p><ul><li><p>原理：<br>当线程请求自己的锁时。JVM会记下锁的持有者，并且给这个锁计数为1。<br>如果该线程再次请求自己的锁，则可以再次进入，计数为2.<br>退出时计数-1.<br>直到全部退出时才会释放锁。</p></li><li><p>目的是为了避免死锁。万一 1个对象在sync方法中调用另一个sync方法，如果是非重入的，就可能导致自己把自己锁住了。</p></li></ul><blockquote><blockquote><p>sync和JUC-Lock都是可重入锁，原理类似。</p></blockquote></blockquote><hr><h2><span id="q-2-ge-xian-cheng-tong-shi-diao-yong-f1-he-f2-hui-chan-sheng-tong-bu-ma">Q:2个线程同时调用f1和f2会产生同步吗？</span><a href="#q-2-ge-xian-cheng-tong-shi-diao-yong-f1-he-f2-hui-chan-sheng-tong-bu-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>不会产生同步。二者不是1个锁。<br>f1是类锁，等同于synchronized(A.class)<br>f2是对象锁。</p><h1><span id="qi-ta-de-tong-bu-gong-ju">其他的同步工具</span><a href="#qi-ta-de-tong-bu-gong-ju" class="header-anchor">#</a></h1><h2><span id="countdownlatch">CountDownLatch</span><a href="#countdownlatch" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>2是计数器初始值。<br>然后执行latch.await()时， 就会阻塞，直到其他线程中把这个latch进行latch.countDown()，并且计数器降低至0。</p><ul><li>和join的区别：<br>join阻塞时，是只等待单个线程的完成<br>而CountDownLatch可能是为了等待多个线程</li></ul><hr><h3><span id="q-countdownlatch-de-nei-bu-ji-shu-zhi-neng-bei-chong-zhi-ma">Q： countDownLatch的内部计数值能被重置吗？</span><a href="#q-countdownlatch-de-nei-bu-ji-shu-zhi-neng-bei-chong-zhi-ma" class="header-anchor">#</a></h3><p>A：<br>不能重置了。如果要重新计数必须重新new一个。毕竟他的类名就叫DownLatch</p><h2><span id="futuretask">FutureTask</span><a href="#futuretask" class="header-anchor">#</a></h2><p>可以理解为一个支持有返回值的线程<br>FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(runable);<br>当调用task.get()时，就能能达到线程里的返回值</p><hr><h3><span id="q-diao-yong-futruetask-get-shi-zhe-ge-shi-zu-sai-fang-fa-ma-ru-guo-shi-zu-sai-shi-me-shi-hou-hui-jie-shu">Q：调用futrueTask.get()时，这个是阻塞方法吗？如果是阻塞，什么时候会结束？</span><a href="#q-diao-yong-futruetask-get-shi-zhe-ge-shi-zu-sai-fang-fa-ma-ru-guo-shi-zu-sai-shi-me-shi-hou-hui-jie-shu" class="header-anchor">#</a></h3><p>A：<br>是阻塞方法。</p><ol><li>线程跑完并返回结果</li><li>阻塞时间达到futrueTask.get(xxx)里设定的xxx时间</li><li>线程出现异常InterruptedException或者ExecutionException</li><li>线程被取消，抛出CancellationException</li></ol><h2><span id="semaphore">Semaphore</span><a href="#semaphore" class="header-anchor">#</a></h2><h3><span id="xin-hao-liang-gai-nian">信号量概念</span><a href="#xin-hao-liang-gai-nian" class="header-anchor">#</a></h3><p>就是操作系统里常见的那个概念，java实现，用于各线程间进行资源协调。<br>用Semaphore(permits)构造一个包含permits个资源的信号量<br>然后某线程做了消费动作， 则执行semaphore.acquire()，则会消费一个资源<br>如果某线程做了生产动作，则执行semaphore.release()，则会释放一个资源（即新增一个资源）<br>更详细的信号量方法说明：<br><a href="https://blog.csdn.net/hanchao5272/article/details/79780045">https://blog.csdn.net/hanchao5272/article/details/79780045</a></p><hr><h3><span id="q-xin-hao-liang-zhong-gong-ping-mo-shi-he-fei-gong-ping-mo-shi-de-qu-bie-xia-mian-she-cheng-true-jiu-shi-gong-ping-mo-shi">Q： 信号量中，公平模式和非公平模式的区别？下面设成true就是公平模式</span><a href="#q-xin-hao-liang-zhong-gong-ping-mo-shi-he-fei-gong-ping-mo-shi-de-qu-bie-xia-mian-she-cheng-true-jiu-shi-gong-ping-mo-shi" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new Semaphore(permits,fair):初始化许可证数量和是否公平模式的构造函数</span></span><br><span class="line">semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>A：<br>其实就是使用哪种公平锁还是非公平锁。<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147404856001732.png" alt="image.png"></p><p>Java并发中的NonfairSync（非公平）和fairSync（公平）主要区别为：</p><ul><li>如果当前线程不是锁的占有者,则NonfairSync并不判断是否有等待队列,直接使用compareAndSwap去进行锁的占用,即谁正好抢到，就给谁用！</li><li>如果当前线程不是锁的占有者,则FairSync则会判断当前是否有等待队列,如果有则将自己加到等待队列尾，即严格的先到先得！</li></ul><h2><span id="cyclicbarrier-zha-lan">CyclicBarrier （栅栏）</span><a href="#cyclicbarrier-zha-lan" class="header-anchor">#</a></h2><p>栅栏，一般是在线程中去调用的<br>它的构造需要指定1个线程数量，和栅栏被破坏前要执行的操作<br>每当有1个线程调用barrier.await()，就会进入阻塞，同时barrier里的线程计数-1。<br>当线程计数为0时，  调用栅栏里指定的那个操作后，然后破坏栅栏， 所有被阻塞在await上的线程继续往下走。</p><h2><span id="exchanger-jiao-huan-zha-lan">Exchanger  （交换栅栏）</span><a href="#exchanger-jiao-huan-zha-lan" class="header-anchor">#</a></h2><p>我理解为两方栅栏，用于交换数据。<br>简单说就是一个线程在完成一定的事务后，想与另一个线程交换数据<br>则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据</p><h2><span id="yuan-zi-lei-atomicxxx">原子类AtomicXXX</span><a href="#yuan-zi-lei-atomicxxx" class="header-anchor">#</a></h2><p>就是内部已实现了原子同步机制</p><h3><span id="q-xia-mian-shu-chu-shi-me-kao-cha-getandadd-de-yong-fa">Q：下面输出什么？（考察getAndAdd的用法）</span><a href="#q-xia-mian-shu-chu-shi-me-kao-cha-getandadd-de-yong-fa" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(num.getAndAdd(<span class="number">1</span>));</span><br><span class="line">System.out.println(num.get());</span><br></pre></td></tr></table></figure><p>A：<br>输出1、2<br>顾名思义， getAndAdd(),那么就是先get，再加， 类似于num++。<br>如果是addAndGet()，那么就是++num</p><hr><h3><span id="q-atomicreference-he-atomicinteger-de-qu-bie">Q：AtomicReference和AtomicInteger的区别？</span><a href="#q-atomicreference-he-atomicinteger-de-qu-bie" class="header-anchor">#</a></h3><p>A：<br>AtomicInteger是对整数的封装，而AtomicReference则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。<br>即可能会有多个线程修改atomicReference里包含的引用。</p><ul><li>经典用法：<br>boolean exchanged = atomicStringReference.compareAndSet(initialReference, newReference)<br>就是经典的CAS同步法<br>compreAndSet它会将将引用与预期值（引用）进行比较，如果它们相等，则在AtomicReference对象内设置一个新的引用。类似于一个非负责的自旋锁。</li></ul><hr><ul><li>AtomicReferenceArray是原子数组， 可以进行一些原子的数组操作例如 set(index, value)，</li></ul><hr><h3><span id="java-zhong-yi-shi-xian-de-quan-bu-yuan-zi-lei">java中已实现的全部原子类：</span><a href="#java-zhong-yi-shi-xian-de-quan-bu-yuan-zi-lei" class="header-anchor">#</a></h3><p><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147422534053370.png" alt="image.png"></p><p>注意，没有float，没有short和byte。</p><hr><h1><span id="xian-cheng-chi">线程池</span><a href="#xian-cheng-chi" class="header-anchor">#</a></h1><hr><h2><span id="q-threadpoolexecutor-xian-cheng-chi-gou-zao-can-shu-zhong-corepoolsize-he-maximumpoolsize-you-shi-me-qu-bie">Q: ThreadPoolExecutor线程池构造参数中，corePoolSize和maximumPoolSize有什么区别？</span><a href="#q-threadpoolexecutor-xian-cheng-chi-gou-zao-can-shu-zhong-corepoolsize-he-maximumpoolsize-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A：<br>当提交新线程到池中时</p><ul><li>如果当前线程数 &lt; corePoolSize，则会创建新线程</li><li>如果当前线程数=corePoolSize，则新线程被塞进一个队列中等待。</li><li>如果队列也被塞满了，那么又会开始新建线程来运行任务，避免任务阻塞或者丢弃</li><li>如果队列满了的情况下， 线程总数超过了maxinumPoolSize，那么就抛异常或者阻塞（取决于队列性质）。</li></ul><hr><ul><li>调用prestartCoreThread()可提前开启一个空闲的核心线程</li><li>调用prestartAllCoreThreads()，可提前创建corePoolSize个核心线程。</li></ul><hr><h2><span id="q-xian-cheng-chi-de-keepalive-can-shu-shi-gan-ma-de">Q： 线程池的keepalive参数是干嘛的？</span><a href="#q-xian-cheng-chi-de-keepalive-can-shu-shi-gan-ma-de" class="header-anchor">#</a></h2><p>A：当线程数量在corePoolSize到maxinumPoolSize之间时， 如果有线程已跑完，且空闲时间超过keepalive时，则会被清除（注意只限于corePoolSize到maxinumPoolsize之间的线程）</p><hr><h2><span id="q-he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">Q: 核心线程可以被回收吗？（线程池没有被回收的情况下）</span><a href="#q-he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia" class="header-anchor">#</a></h2><p>A:<br>ThreadPoolExecutor有个allowCoreThreadTimeOut(boolean value)方法，可以设置是否在超期后做回收</p><hr><h2><span id="q-na-zhe-ge-xian-cheng-shu-she-zhi-duo-shao-ni-shi-zen-me-kao-lu-de-ni">Q: 那这个线程数设置多少，你是怎么考虑的呢？</span><a href="#q-na-zhe-ge-xian-cheng-shu-she-zhi-duo-shao-ni-shi-zen-me-kao-lu-de-ni" class="header-anchor">#</a></h2><p>A:<br>io密集型， 可以设置多一点， 因为多一个线程，他可能也没太占cpu，都是在等待IO。<br>如果是计算密集型，则要设置少一点，别把cpu搞满载了。</p><p>有超线程技术的话， 一般可以设置成2倍CPU数量的线程数</p><blockquote><blockquote><p>超线程技术把多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作</p></blockquote></blockquote><hr><h2><span id="q-xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">Q： 线程池有哪三种队列策略？</span><a href="#q-xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue" class="header-anchor">#</a></h2><p>A：</p><ol><li>握手队列<br>相当于不排队的队列。可能造成线程数量无限增长直到超过maxinumPoolSize（相当于corePoolSize没什么用了，只以maxinumPoolSize做上限）</li><li>无界队列<br>队列队长无限，即线程数量达到corePoolSize时，后面的线程只会在队列中等待。（相当于maxinumPoolSize没什么用了）<br>缺陷： 可能造成队列无限增长以至于OOM</li><li>有界队列</li></ol><hr><h2><span id="q-xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">Q： 线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</span><a href="#q-xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue" class="header-anchor">#</a></h2><p>A：</p><ul><li>AbortPolicy 默认策略：直接抛出RejectedExecutionException异常</li><li>DiscardPolicy 丢弃策略： 直接丢了，什么错误也不报</li><li>DiscardOldestPolicy 丢弃队头策略： 即把最先入队的人从队头扔出去，再尝试让该任务进入队尾（队头任务内心：不公平。。。。）</li><li>CallerRunsPolicy 调用者处理策略： 交给调用者所在线程自己去跑任务（即谁调用的submit或者execute，他就自己去跑） <strong>注意这个策略会用的比较多</strong></li><li>也可以用实现自定义新的RejectedExecutionHandler</li></ul><hr><h2><span id="q-xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">Q:  线程池为什么需要阻塞队列？</span><a href="#q-xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie" class="header-anchor">#</a></h2><p>A:<br>线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。避免大量线程获取这个创建锁。</p><hr><h2><span id="q-you-yi-xia-wu-chong-executor-ti-gong-de-xian-cheng-chi-zhu-yi-ji-yi-yi-xia-ta-men-de-yong-tu-jiu-neng-li-jie-nei-bu-de-yuan-li-liao">Q：有以下五种Executor提供的线程池，注意记忆一下他们的用途，就能理解内部的原理了。</span><a href="#q-you-yi-xia-wu-chong-executor-ti-gong-de-xian-cheng-chi-zhu-yi-ji-yi-yi-xia-ta-men-de-yong-tu-jiu-neng-li-jie-nei-bu-de-yuan-li-liao" class="header-anchor">#</a></h2><ul><li><p>newCachedThreadPool： 缓存线程池<br>corePoolSize=0, maxinumPoolSize=+∞，队列长度=0 ，<br>因此线程数量会在corePoolSize到maxinumPoolSize之间一直灵活缓存和变动， 且不存在队列等待的情况，一来任务我就创建，用完了会释放。<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147438780044960.png" alt="image.png"></p></li><li><p>newFixedThreadPool ：定长线程池<br>corePoolSize= maxinumPoolSize=构造参数值， 队列长度=+∞。<br>因此不存在线程不够时扩充的情况</p></li><li><p>newScheduledThreadPool :定时器线程池<br>提交定时任务用的，构造参数里会带定时器的间隔和单位。 其他和FixedThreadPool相同，属于定长线程池。</p></li><li><p>newSingleThreadExecutor : 单线程池<br>corePoolSize=maxinumPoolSize=1， 队列长度=+∞<br>只会跑一个任务， 所以其他的任务都会在队列中等待，因此会严格按照FIFO执行</p></li><li><p>newWorkStealingPool（继承自ForkJoinPool ）： 并行线程池<br>如果你的任务执行时间很长，并且里面的任务运行并行跑的，那么他会把你的线程任务再细分到其他的线程来分治。<br>ForkJoinPool介绍：<a href="https://blog.csdn.net/m0_37542889/article/details/92640903">https://blog.csdn.net/m0_37542889/article/details/92640903</a></p></li></ul><p>A：</p><hr><h2><span id="q-submit-he-execute-de-qu-bie-shi-shi-me">Q： submit和execute的区别是什么？</span><a href="#q-submit-he-execute-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h2><p>A:</p><ul><li>execute只能接收Runnable类型的任务，而submit除了Runnable，还能接收Callable（Callable类型任务支持返回值）</li><li>execute方法返回void，  submit方法返回FutureTask。</li><li>异常方面， submit方法因为返回了futureTask对象，而当进行future.get()时，会把线程中的异常抛出，因此调用者可以方便地处理异常。（如果是execute，只能用内部捕捉或者设置catchHandler）</li></ul><hr><h2><span id="q-xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">Q：线程池中， shutdown、 shutdownNow、awaitTermination的区别？</span><a href="#q-xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie" class="header-anchor">#</a></h2><p>A：</p><ul><li>shutdown: 停止接收新任务，等待所有池中已存在任务完成（ <em><strong>包括等待队列中的线程</strong></em> ）。异步方法，即调用后马上返回。</li><li>shutdownNow: 停止接收新任务，并 <em><strong>停止所有正执行的task</strong></em>，返回还在队列中的task列表 。</li><li>awaitTermination： <em><strong>仅仅是一个判断方法</strong></em>，判断当前线程池任务是否全部结束。一般用在shutdown后面，因为shutdown是异步方法，你需要知道什么时候才真正结束。</li></ul><hr><h1><span id="thread-zhuang-tai-zhuan-huan">Thread状态转换</span><a href="#thread-zhuang-tai-zhuan-huan" class="header-anchor">#</a></h1><h2><span id="q-xian-cheng-de-6-chong-zhuang-tai-shi">Q： 线程的6种状态是：</span><a href="#q-xian-cheng-de-6-chong-zhuang-tai-shi" class="header-anchor">#</a></h2><p>A：</p><ul><li>New： 新建了线程，但是还没调用start</li><li>RUNNABLE： 运行， 就绪状态包括在运行态中</li><li>BLOCKED： 阻塞，一般是因为想拿锁拿不到</li><li>WAITING： 等待，一般是wait或者join之后</li><li>TIMED_WAITING: 定时等待，即固定时间后可返回，一般是调用sleep或者wait(时间)的。</li><li>TERMINATED： 终止状态。</li></ul><hr><p>欣赏一幅好图，能了解调用哪些方法会进入哪些状态。<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147455707018197.png" alt="image.png"></p><p><a href="https://blog.csdn.net/qq_22771739/article/details/82529874">原图链接</a></p><h2><span id="q-java-xian-cheng-shi-me-shi-hou-hui-jin-ru-zu-sai-ke-neng-an-duo-xuan-ti-kao">Q： java线程什么时候会进入阻塞（可能按多选题考）：</span><a href="#q-java-xian-cheng-shi-me-shi-hou-hui-jin-ru-zu-sai-ke-neng-an-duo-xuan-ti-kao" class="header-anchor">#</a></h2><p>A：</p><ul><li>sleep</li><li>wati()挂起，  等待获得别的线程发送的Notify（）消息</li><li>等待IO</li><li>等待锁</li></ul><h1><span id="volatile">Volatile</span><a href="#volatile" class="header-anchor">#</a></h1><p>用volatile修饰成员变量时， 一旦有线程修改了变量，其他线程可立即看到改变。</p><hr><h2><span id="q-bu-yong-volatile-xiu-shi-cheng-yuan-bian-liang-shi-wei-shi-me-qi-ta-xian-cheng-hui-wu-fa-li-ji-kan-dao-gai-bian">Q： 不用volatile修饰成员变量时， 为什么其他线程会无法立即看到改变？</span><a href="#q-bu-yong-volatile-xiu-shi-cheng-yuan-bian-liang-shi-wei-shi-me-qi-ta-xian-cheng-hui-wu-fa-li-ji-kan-dao-gai-bian" class="header-anchor">#</a></h2><p>A：<br>线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。<br>这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值。</p><hr><h2><span id="q-yong-liao-volatile-shi-bu-shi-jiu-ke-yi-bu-yong-jia-suo-la">Q： 用了volatile是不是就可以不用加锁啦？</span><a href="#q-yong-liao-volatile-shi-bu-shi-jiu-ke-yi-bu-yong-jia-suo-la" class="header-anchor">#</a></h2><p>A： 不行。</p><ul><li>锁并不是只保证1个变量的互斥， 有时候是要保证几个成员在连续变化时，让其他线程无法干扰、读取。</li><li>而volatile保证1个变量可变， 保证不了几个变量同时变化时的原子性。</li></ul><hr><h2><span id="q-zhan-shi-yi-duan-java-bing-fa-bian-cheng-shi-zhan-shu-li-de-yi-ge-jing-dian-li-zi-wei-shi-me-xia-mian-zhe-ge-li-zi-ke-neng-hui-si-xun-huan-huo-zhe-shu-chu-0">Q:展示一段《Java并发编程实战》书里的一个经典例子，为什么下面这个例子可能会死循环，或者输出0？</span><a href="#q-zhan-shi-yi-duan-java-bing-fa-bian-cheng-shi-zhan-shu-li-de-yi-ge-jing-dian-li-zi-wei-shi-me-xia-mian-zhe-ge-li-zi-ke-neng-hui-si-xun-huan-huo-zhe-shu-chu-0" class="header-anchor">#</a></h2><p><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147466151081835.png" alt="image.png"></p><p>A:<br>首先理解一下java重排序，可以看一下这篇博文：<br><a href="https://www.cnblogs.com/coshaho/p/8093944.html">https://www.cnblogs.com/coshaho/p/8093944.html</a></p><p>然后分析后面那2个奇怪的情况是怎么发生的。</p><ul><li>永远不输出：<br>经过程序的指令排序，出现了这种情况：</li></ul><ol><li>ReaderThread在while里读取ready值， 此时是false， 于是存入了ReaderThread的寄存器。</li><li>主线程修改ready和number。</li><li>ReaderThread没有感知到ready的修改（对于ReaderThread线程，感知不到相关的指令，来让他更新ready寄存器的值），因此进入死循环。</li></ol><ul><li>输出0<br>经过程序的指令排序，出现了这种情况：<br>1）主线程设置ready为true<br>2）ReaderThread在while里读取ready值，是true，于是退出while循环</li></ul><ol start="3"><li>ReaderThread读取到number值， 此时number还是初始化的值为0，于是输出0</li><li>主线程这时候才修改number=42，此时ReaderThread已经结束了！</li></ol><p>上面这个问题，可以用volatile或者加锁。当你加了锁时， 如果变量被写了，会有指令去更新另一个寄存器的值，因此就可见了。</p><hr><h2><span id="q-volatile-bian-liang-ru-guo-ding-yi-de-tai-duo-hui-fa-sheng-shi-me">Q: volatile变量如果定义的太多会发生什么？</span><a href="#q-volatile-bian-liang-ru-guo-ding-yi-de-tai-duo-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2><p>A:<br>volatile有嗅探机制，如果定义过多，可能会引发总线风暴，导致性能下降。</p><hr><h1><span id="xian-cheng-qun-zu">线程群组</span><a href="#xian-cheng-qun-zu" class="header-anchor">#</a></h1><p>为了方便管理一批线程，我们使用ThreadGroup来表示线程组，通过它对一批线程进行分类管理<br>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gourp, ()-&gt;&#123;..&#125;);</span><br></pre></td></tr></table></figure><p>即thread除了Thread(Runable)这个构造方法外，还有个Thread(ThreadGroup, Runnable)构造方法</p><hr><h2><span id="q-zai-xian-cheng-a-zhong-chuang-jian-xian-cheng-b-ta-men-shu-yu-tong-yi-ge-xian-cheng-zu-ma">Q：在线程A中创建线程B， 他们属于同一个线程组吗</span><a href="#q-zai-xian-cheng-a-zhong-chuang-jian-xian-cheng-b-ta-men-shu-yu-tong-yi-ge-xian-cheng-zu-ma" class="header-anchor">#</a></h2><p>A：<br>是的</p><hr><p>线程组的一大作用是对同一个组线程进行统一的异常捕捉处理，避免每次新建线程时都要重新去setUncaghtExceptionHandler。即线程组自身可以实现一个uncaughtException方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group&quot;</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">System.out.println(thread.getName() + throwable.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程如果抛出异常，且没有在线程内部被捕捉，那么此时线程异常的处理顺序是什么？<br>相信很多人都看过下面这段话，好多讲线程组的博客里都这样写：<br>（1）首先看看当前线程组（ThreadGroup）有没有父类的线程组，如果有，则使用父类的UncaughtException()方法。<br>（2）如果没有，就看线程是不是调用setUncaughtExceptionHandler()方法建立Thread.setUncaughtExceptionHandler实例。如果建立，直接使用它的UncaughtException()方法处理异常。<br>（3）如果上述都不成立就看这个异常是不是ThreadDead实例，如果是，什么都不做，如果不是，输出堆栈追踪信息（printStackTrace）。</p><blockquote><blockquote><blockquote><p>来源：<br><a href="https://blog.csdn.net/qq_43073128/article/details/90597006">https://blog.csdn.net/qq_43073128/article/details/90597006</a><br><a href="https://blog.csdn.net/qq_43073128/article/details/88280469">https://blog.csdn.net/qq_43073128/article/details/88280469</a></p></blockquote></blockquote></blockquote><hr><p>好，别急着记，先看一下下面的题目，问输出什么：<br>Q:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类线程组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GroupFather</span> <span class="keyword">extends</span> <span class="title class_">ThreadGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupFather</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;groupFather=&quot;</span> + throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 子类线程组</span></span><br><span class="line">    <span class="type">GroupFather</span> <span class="variable">groupSon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupFather</span>(<span class="string">&quot;groupSon&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;groupSon=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(groupSon, ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我异常了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>一看（1），那是不是应该输出groupFather?<br>错错错，输出的是groupSon这句话在很多地方能看到，但没有去实践过看过源码的人就会这句话被误导。<br>实际上父线程组不是指类继承关系上的线程组，而是指下面这样的：<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147483889080721.png" alt="image.png"></p><p>即指的是构造关系的有父子关系。<br>如果子类的threadGroup没有去实现uncaughtException方法，那么就会去构造参数里指定的父线程组去调用方法。</p><hr><h2><span id="q-na-wo-gai-cheng-gou-zao-guan-xi-shang-de-fu-zi-guan-xi-xia-mian-shu-chu-shi-me">Q： 那我改成构造关系上的父子关系，下面输出什么？</span><a href="#q-na-wo-gai-cheng-gou-zao-guan-xi-shang-de-fu-zi-guan-xi-xia-mian-shu-chu-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 父线程组</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">groupFather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;groupFather&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;groupFather=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程组,把groupFather作为parent参数</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">groupSon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(groupFather, <span class="string">&quot;groupSon&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;groupSon=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(groupSon, ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我异常了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>答案输出<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147498561059637.png" alt="image.png"></p><p>即只要子线程组有实现过，则会用子线程组里的方法，而不是直接去找的父线程组！</p><hr><h2><span id="q-ru-guo-wo-rang-zi-ji-zuo-set-bu-zhuo-qi-de-cao-zuo-ni-na-xia-mian-zhe-ge-shu-chu-shi-me">Q：如果我让自己做set捕捉器的操作呢？那下面这个输出什么？</span><a href="#q-ru-guo-wo-rang-zi-ji-zuo-set-bu-zhuo-qi-de-cao-zuo-ni-na-xia-mian-zhe-ge-shu-chu-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 父线程组</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建一个线程，在线程组内</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我异常了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己设置setUncaughtExceptionHandler方法</span></span><br><span class="line">    thread1.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no gourp:&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>看之前的结论里，似乎是应该输出线程组的异常？<br>但是结果却输出的是：<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147507452005732.png" alt="image.png"></p><p>也就是说，如果线程对自己特地执行过setUncaughtExceptionHandler，那么有优先对自己设置过的UncaughtExceptionHandler做处理。</p><p>那难道第（2）点这个是错的吗？确实错了，实际上第二点应该指的是全局Thread的默认捕捉器，注意是全局的<br>实际上那段话出自ThreadGroup里uncaughtException的源码：<br><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147517593022275.png" alt="image.png"></p><p>这里就解释了之前的那三点，但是该代码中没考虑线程自身设置了捕捉器</p><hr><h2><span id="xiu-gai-yi-xia-zhi-qian-de-zong-jie-yi-xia-xian-cheng-de-shi-ji-yi-chang-pao-chu-pan-duan-luo-ji">修改一下之前的总结一下线程的实际异常抛出判断逻辑：</span><a href="#xiu-gai-yi-xia-zhi-qian-de-zong-jie-yi-xia-xian-cheng-de-shi-ji-yi-chang-pao-chu-pan-duan-luo-ji" class="header-anchor">#</a></h2><ol><li>如果线程自身有进行过setUncaughtExceptionHandler,则使用自己设置的按个。</li><li>如果没设置过，则看一下没有线程组。并按照以下逻辑判断:<br>如果线程组有覆写过uncaughtException，则用覆写过的uncaughtException<br>如果线程组没有覆写过，则去找父线程组（注意是构造体上的概念）的uncaughtException方法。</li><li>如果线程组以及父类都没覆写过uncaughtException， 则判断是否用Thread.setDefaultUncaughtExceptionHandler(xxx)去设置全局的默认捕捉器，有的话则用全局默认</li><li>如果不是ThreadDeath线程， 则只打印堆栈。</li><li>如果是ThreadDeath线程，那么就什么也不处理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fan-she">反射</a><ul><li><a href="#q-diao-yong-lei-dui-xiang-class-he-forname-lei-ming-de-qu-bie">Q： 调用类对象.class 和 forName(类名)的区别？</a></li><li><a href="#q-yong-instanceof-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q： 用instanceof 可以和父类比较吗，且会返回true吗？</a></li><li><a href="#q-yong-getclass-bing-yong-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q： 用getClass并用== 可以和父类比较吗，且会返回true吗</a></li><li><a href="#q-yong-getclass-bing-yong-equals-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma-xia-mian-zhe-yang">Q： 用getClass并用.equals可以和父类比较吗，且会返回true吗，下面这样：</a></li><li><a href="#q-getdeclaredxxx-you-na-ji-chong">Q： getDeclaredXXX 有哪几种？</a></li><li><a href="#q-getmethods-fan-hui-na-xie-fang-fa-getdeclaredmethods-hui-fan-hui-na-xie-fang-fa">Q：getMethods()返回哪些方法， getDeclaredMethods()会返回哪些方法？</a></li><li><a href="#q-fan-she-na-dao-method-dui-xiang-hou-gai-dui-xiang-getmodifiers-shi-gan-ma-de">Q： 反射拿到Method对象后，  该对象.getModifiers() 是干嘛的？</a></li><li><a href="#q-xia-mian-zhe-yang-dui-yi-ge-wu-mo-ren-gou-zao-de-lei-zhi-xing-newinstance-hui-fa-sheng-shi-me">Q：下面这样对一个无默认构造的类执行newInstance会发生什么？</a><ul><li><a href="#q-ru-he-ti-gao-fan-she-de-xiao-lu">Q：如何提高反射的效率？</a></li></ul></li><li><a href="#q-yong-fan-she-huo-qu-dao-de-method-dui-xiang-shi-fan-hui-yi-ge-method-yin-yong-huan-shi-fan-hui-1-ge-kao-bei-de-method-dui-xiang">Q：用反射获取到的method对象， 是返回一个method引用，还是返回1个拷贝的method对象？</a></li><li><a href="#q-getmethods-hou-zi-ji-zuo-bian-li-huo-qu-fang-fa-he-getmethod-methodname-zhi-jie-huo-qu-fang-fa-wei-shi-me-xing-neng-hui-you-chai-yi">Q:getMethods()后自己做遍历获取方法和getMethod(methodName) 直接获取方法， 为什么性能会有差异？</a></li><li><a href="#q-huo-qu-fang-fa-shi-jvm-nei-bu-qi-shi-you-huan-cun-dan-shi-fan-hui-gei-wai-bu-shi-yi-ran-hui-zuo-kao-bei-na-me-gai-method-de-huan-cun-shi-chi-jiu-cun-zai-de-ma">Q:获取方法时，jvm内部其实有缓存，但是返回给外部时依然会做拷贝。那么该method的缓存是持久存在的吗？</a></li><li><a href="#q-fan-she-shi-xian-cheng-an-quan-de-ma">Q： 反射是线程安全的吗?</a></li><li><a href="#q-fan-she-de-ju-ti-xing-neng-chai-yi-zai-na">Q: 反射的具体性能差异在哪？</a></li><li><a href="#q-wei-shi-me-fan-she-mei-fa-zuo-jit-you-hua-ni">Q: 为什么反射没法做JIT优化呢？</a></li></ul></li><li><a href="#dong-tai-dai-li">动态代理</a><ul><li><a href="#q-jiang-yi-xia-dong-tai-dai-li-de-zuo-yong-yi-ji-ta-he-jing-tai-dai-li-de-qu-bie">Q: 讲一下动态代理的作用 以及他和静态代理的区别</a></li><li><a href="#q-jiang-yi-xia-dong-tai-dai-li-zen-me-yong-de">Q: 讲一下动态代理怎么用的？</a></li><li><a href="#q-java-dong-tai-dai-li-de-di-ceng-shi-xian-yuan-li">Q: java动态代理的底层实现原理？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="fan-she">反射</span><a href="#fan-she" class="header-anchor">#</a></h1><h2><span id="q-diao-yong-lei-dui-xiang-class-he-forname-lei-ming-de-qu-bie">Q： 调用类对象.class 和 forName(类名)的区别？</span><a href="#q-diao-yong-lei-dui-xiang-class-he-forname-lei-ming-de-qu-bie" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;A&gt; classA = A.class;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;A&gt; classA = Class.forName(<span class="string">&quot;A&quot;</span>);</span><br></pre></td></tr></table></figure><p>A： 仅使用.class不能进行第一次静态初始化， forname函数则可以</p><hr><p>例如B是A的基类,下面这段代码如何？<br>假设有父子2个类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2><span id="q-yong-instanceof-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q：  用instanceof 可以和父类比较吗，且会返回true吗？</span><a href="#q-yong-instanceof-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">if</span> (son <span class="keyword">instanceof</span>  Parent) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a instanof B&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： 可以比较，且返回true。</p><hr><h2><span id="q-yong-getclass-bing-yong-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q： 用getClass并用== 可以和父类比较吗，且会返回true吗</span><a href="#q-yong-getclass-bing-yong-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma" class="header-anchor">#</a></h2><p>比如下面这样， 注意A是B的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">if</span> (son.getClass() == Parent.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;son class == Parent.class&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： 不可以，编译就会报错了。和Class&lt;泛型&gt;的 ==号比较有关。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810095068062903.png" alt="image.png"></p><p>因为getClass返回的是&lt;? extends Son&gt;， .class返回的是Class&lt;Parent&gt;</p><hr><h2><span id="q-yong-getclass-bing-yong-equals-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma-xia-mian-zhe-yang">Q： 用getClass并用.equals可以和父类比较吗，且会返回true吗，下面这样：</span><a href="#q-yong-getclass-bing-yong-equals-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma-xia-mian-zhe-yang" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">if</span> (son.getClass().equals(Parent.class))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;son class.equals(Parent.class)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： 可以比较，正常编译， 但是会返回false，即不相等！</p><hr><h2><span id="q-getdeclaredxxx-you-na-ji-chong">Q： getDeclaredXXX 有哪几种？</span><a href="#q-getdeclaredxxx-you-na-ji-chong" class="header-anchor">#</a></h2><p>A： 5种：</p><ul><li>注解Annotation</li><li>内部类Classed</li><li>构造方法Construcotor</li><li>字段Field</li><li>方法Method<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810106986007259.png" alt="image.png"></li></ul><hr><h2><span id="q-getmethods-fan-hui-na-xie-fang-fa-getdeclaredmethods-hui-fan-hui-na-xie-fang-fa">Q：getMethods()返回哪些方法，  getDeclaredMethods()会返回哪些方法？</span><a href="#q-getmethods-fan-hui-na-xie-fang-fa-getdeclaredmethods-hui-fan-hui-na-xie-fang-fa" class="header-anchor">#</a></h2><p>A：<br>getMethods()返回   本类、父类、父接口 的public方法<br>getDeclaredMethods()只 返回本类的 <em><strong>所有</strong></em> 方法</p><p>其他getXXX和getDeclaredXXX的区别同理。</p><hr><p>拿到Filed、Method、Constructor之后咋用</p><ul><li>Method可以invoke（object， args）</li><li>Constructor可以newInstance(Object…)来做构造调用。</li><li>Filed可以用get(object)、set(object)来设置属性值。</li></ul><hr><h2><span id="q-fan-she-na-dao-method-dui-xiang-hou-gai-dui-xiang-getmodifiers-shi-gan-ma-de">Q： 反射拿到Method对象后，  该对象.getModifiers() 是干嘛的？</span><a href="#q-fan-she-na-dao-method-dui-xiang-hou-gai-dui-xiang-getmodifiers-shi-gan-ma-de" class="header-anchor">#</a></h2><p>A： 返回该方法的修饰符，并且是1个整数。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810116021009939.png" alt="image.png"></p><hr><h2><span id="q-xia-mian-zhe-yang-dui-yi-ge-wu-mo-ren-gou-zao-de-lei-zhi-xing-newinstance-hui-fa-sheng-shi-me">Q：下面这样对一个无默认构造的类执行newInstance会发生什么？</span><a href="#q-xia-mian-zhe-yang-dui-yi-ge-wu-mo-ren-gou-zao-de-lei-zhi-xing-newinstance-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huawei.test</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> i )</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;i=&quot;</span> +i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> (A)Class.forName(<span class="string">&quot;com.huawei.test.A&quot;</span>).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;ClassNotFoundException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;InstantiationException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;IllegalAccessException&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>打印InstantiationException初始化错误。<br>因为A没有默认构造器了，所以不可以用newInstance来构造。<br>应该改成这样,通过获取正确的构造器来进行构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> (A)Class.forName(<span class="string">&quot;A&quot;</span>).getConstructor(<span class="type">int</span>.class).newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><hr><h3><span id="q-ru-he-ti-gao-fan-she-de-xiao-lu">Q：如何提高反射的效率？</span><a href="#q-ru-he-ti-gao-fan-she-de-xiao-lu" class="header-anchor">#</a></h3><p>A：</p><ul><li>使用高性能反射包，例如ReflectASM</li><li>缓存反射的对象，避免每次都要重复去字节码中获取。（缓存！缓存！）</li><li>method反射可设置method.setAccessible(true)来关闭安全检查。</li><li>尽量不要getMethods()后再遍历筛选，而直接用getMethod(methodName)来根据方法名获取方法</li><li>利用hotspot虚拟机中的反射优化技术（jit技术）<br>参考资料：<br><a href="https://segmentfault.com/q/1010000003004720">https://segmentfault.com/q/1010000003004720</a><br><a href="https://www.cnblogs.com/coding-night/p/10772631.html">https://www.cnblogs.com/coding-night/p/10772631.html</a></li></ul><hr><hr><h2><span id="q-yong-fan-she-huo-qu-dao-de-method-dui-xiang-shi-fan-hui-yi-ge-method-yin-yong-huan-shi-fan-hui-1-ge-kao-bei-de-method-dui-xiang">Q：用反射获取到的method对象， 是返回一个method引用，还是返回1个拷贝的method对象？</span><a href="#q-yong-fan-she-huo-qu-dao-de-method-dui-xiang-shi-fan-hui-yi-ge-method-yin-yong-huan-shi-fan-hui-1-ge-kao-bei-de-method-dui-xiang" class="header-anchor">#</a></h2><p>A：<br>反射拿method对象时，   会做一次拷贝，而不是直接返回引用，因此最好对频繁使用的同一个method做缓存，而不是每次都去查找。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810152127031226.png" alt="image.png"></p><hr><h2><span id="q-getmethods-hou-zi-ji-zuo-bian-li-huo-qu-fang-fa-he-getmethod-methodname-zhi-jie-huo-qu-fang-fa-wei-shi-me-xing-neng-hui-you-chai-yi">Q:getMethods()后自己做遍历获取方法和getMethod(methodName) 直接获取方法， 为什么性能会有差异？</span><a href="#q-getmethods-hou-zi-ji-zuo-bian-li-huo-qu-fang-fa-he-getmethod-methodname-zhi-jie-huo-qu-fang-fa-wei-shi-me-xing-neng-hui-you-chai-yi" class="header-anchor">#</a></h2><p>A：<br>getMethods() 返回method数组时，每个method都做了一次拷贝。<br>getMethod(methodName)只会返回那个方法的拷贝，  性能的差异就体现在拷贝上。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810160296062066.png" alt="image.png"></p><hr><h2><span id="q-huo-qu-fang-fa-shi-jvm-nei-bu-qi-shi-you-huan-cun-dan-shi-fan-hui-gei-wai-bu-shi-yi-ran-hui-zuo-kao-bei-na-me-gai-method-de-huan-cun-shi-chi-jiu-cun-zai-de-ma">Q:获取方法时，jvm内部其实有缓存，但是返回给外部时依然会做拷贝。那么该method的缓存是持久存在的吗？</span><a href="#q-huo-qu-fang-fa-shi-jvm-nei-bu-qi-shi-you-huan-cun-dan-shi-fan-hui-gei-wai-bu-shi-yi-ran-hui-zuo-kao-bei-na-me-gai-method-de-huan-cun-shi-chi-jiu-cun-zai-de-ma" class="header-anchor">#</a></h2><p>A:<br>不是持久存在的，内存不足时会被回收。<br>源码如下：<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810168569077686.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class.ReflectionData&lt;T&gt; <span class="title function_">reflectionData</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;Class.ReflectionData&lt;T&gt;&gt; reflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">    Class.ReflectionData rd;</span><br><span class="line">    <span class="keyword">return</span> reflectionData != <span class="literal">null</span> &amp;&amp; (rd = (Class.ReflectionData)reflectionData.get()) != <span class="literal">null</span></span><br><span class="line">    &amp;&amp; rd.redefinedCount == classRedefinedCount ? rd : <span class="built_in">this</span>.newReflectionData(reflectionData,     classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810176787057104.png" alt="image.png"></p><p>可以看到这是一个软引用。<br>软引用的定义：<br>内存紧张时可能会被回收，不过也可以通过-XX:SoftRefLRUPolicyMSPerMB参数控制回收的时机，<br>只要发生GC就会将其回收<br>如果reflectionData被回收之后，又执行了反射方法，那只能通过newReflectionData方法重新创建一个这样的对象了</p><hr><h2><span id="q-fan-she-shi-xian-cheng-an-quan-de-ma">Q： 反射是线程安全的吗?</span><a href="#q-fan-she-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h2><p>A:<br>是线程安全的。 获取反射的数据时，通过cas去获取。  cas概念可以见多线程一节。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810186202053338.png" alt="image.png"></p><hr><h2><span id="q-fan-she-de-ju-ti-xing-neng-chai-yi-zai-na">Q: 反射的具体性能差异在哪？</span><a href="#q-fan-she-de-ju-ti-xing-neng-chai-yi-zai-na" class="header-anchor">#</a></h2><p>a普通方法调用<br>b反射方法调用<br>c关闭安全检查的反射方法调用，性能差异如下：<br><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810195773033845.png" alt="image.png"></p><p>b反射方法调用和c关闭安全检查的反射方法调用的性能差异在哪？<br>普通方法调用和关闭安全检查的反射方法调用的性能差异在哪？<br>A:</p><ul><li><p>安全检查的性能消耗在于<br>，SecurityManager.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION); 这项检测需要运行时申请 RuntimePermission(“accessDeclaredMembers”)。<br>所以如果不考虑安全检查， 对反射方法调用invoke时， 应当设置 Method#setAccessible(true)</p></li><li><p>普通方法和反射方法的性能差异在于</p></li></ul><ol><li>Method#invoke 方法会对参数做封装和解封操作</li><li>需要检查方法可见性</li><li>需要校验参数</li><li>反射方法难以内联</li><li>JIT 无法优化</li></ol><h2><span id="q-wei-shi-me-fan-she-mei-fa-zuo-jit-you-hua-ni">Q: 为什么反射没法做JIT优化呢？</span><a href="#q-wei-shi-me-fan-she-mei-fa-zuo-jit-you-hua-ni" class="header-anchor">#</a></h2><p>A:<br>我们都知道 Java 代码是需要编译才能在虚拟机里运行的，但其实 Java 的编译期是一段不确定的操作过程。因为它可能是一个前端编译器（如 Javac）把 *.java 文件编译成 *.class 文件的过程；也可能是程序运行期的即时编译器（JIT 编译器，Just In Time Compiler）把字节码文件编译成机器码的过程；还可能是静态提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成本地机器码的过程。<br>其中即时编译器（JIT）在运行期的优化过程对于程序运行来说更重要，Java虚拟机在编译阶段的代码优化就在这里进行，<br>由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此应该避免在对性能敏感的应用程序中频繁使用Java反射来创建对象</p><h1><span id="dong-tai-dai-li">动态代理</span><a href="#dong-tai-dai-li" class="header-anchor">#</a></h1><hr><h2><span id="q-jiang-yi-xia-dong-tai-dai-li-de-zuo-yong-yi-ji-ta-he-jing-tai-dai-li-de-qu-bie">Q: 讲一下动态代理的作用 以及他和静态代理的区别</span><a href="#q-jiang-yi-xia-dong-tai-dai-li-de-zuo-yong-yi-ji-ta-he-jing-tai-dai-li-de-qu-bie" class="header-anchor">#</a></h2><p>A:</p><ul><li><p>作用</p><p>先弄一个原始接口类Info，里面提供一些接口例如dealInfo()、getInfo()之类的</p><p>然后可以有N个实现了这个接口的各种Info子类。</p><p>我们希望这些Info字类做dealInfo的时候， 都能在调用前后打一下日志。</p><p>但不希望每个子类里强制都添加这个过程。</p><p>所以引入一个代理Proxy， 将Info类放进去代理种执行，无论你放什么info子类进去，调用dealInfo时，都会在调用前后打印日志。</p></li><li><p>和静态代理的区别：</p><p>静态代理也是给代理传1个对象，然后执行方法时，执行代理对象的方法</p><p>但是有个执行问题：</p><p>如果我们的类需要加100个方法，那么我们在代理中也要加100个方法，里面反复写“啊，我要调用代理对象的方法”， 这太蠢了</p><p>所以引入动态代理， 这样代理和所代理类之间实现了解耦， 没有必要每次改实类时，也要改代理的内容，重复加方法之类的。</p><p>动态代理可以直接根据method去调用，并且还能弄一个自己独有的处理。</p></li></ul><hr><h2><span id="q-jiang-yi-xia-dong-tai-dai-li-zen-me-yong-de">Q: 讲一下动态代理怎么用的？</span><a href="#q-jiang-yi-xia-dong-tai-dai-li-zen-me-yong-de" class="header-anchor">#</a></h2><p>A:<br>代理Proxy类必须implements InvocationHandler<br>要有一个代理成员，在构造器中去传参数绑定这个代理成员<br>并实现Object invoke(Object object, Method method, Object[] args)<br>在invoke方法中调用method.invoke(subject, args)<br>然后真正执行时，<br>接口Info = （Info）Proxy.newProxyInstance（代理类对象.getClass().getClassLoader()，实际对象.handler.getInterfaces(), 代理类对象.）<br>那么当我们执行Info类的某些函数时，就是通过代理去执行了。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/d190cf550b2ccb10577825cf86f8d3b2a24b99e2.png" alt="d190cf550b2ccb10577825cf86f8d3b2a24b99e2"></p><hr><h2><span id="q-java-dong-tai-dai-li-de-di-ceng-shi-xian-yuan-li">Q: java动态代理的底层实现原理？</span><a href="#q-java-dong-tai-dai-li-de-di-ceng-shi-xian-yuan-li" class="header-anchor">#</a></h2><p>A:<br>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象<br>在invoke方法中调用了被代理对象的相应方法。<br>通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。<br>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法<br>从而达到代理执行被代理对象的方法。<br>也就是说，动态代理通过中介类实现了具体的代理功能。<br><img src="/images/Java%E5%8F%8D%E5%B0%84/d2cee51a51bbbd8be3c5315d2b39b1c664497474.png" alt="d2cee51a51bbbd8be3c5315d2b39b1c664497474"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第306场周赛-763名-80分钟4题</title>
      <link href="/2022/08/14/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/"/>
      <url>/2022/08/14/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458753851.png" alt="1660458753851"></p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>bfs时，必须要记得在对第一个入队节点做vis[start]=true的操作！否则一定会导致WA！</li><li></li></ol><p><a href="https://leetcode.cn/contest/weekly-contest-306/problems/largest-local-values-in-a-matrix/">矩阵中的局部最大值 - 力扣 (LeetCode) 竞赛</a></p><p>直接硬写即可，就是写8个方向的dirs数组比较累</p><p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458804313.png" alt="1660458804313"></p><hr><p><a href="https://leetcode.cn/contest/weekly-contest-306/problems/node-with-highest-edge-score/">https://leetcode.cn/contest/weekly-contest-306/problems/node-with-highest-edge-score/</a></p><p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458823828.png" alt="1660458823828"></p><p>看起来也很简单， 遍历一次就等得到所有点的积分了，然后再遍历一次得到最大节点（都不用写sort函数，直接遍历求最大值即可）</p><p>比较坑的是相加结果会超int。。。。</p><ul><li><p><code>2 &lt;= n &lt;= 10^5</code></p><p>O(n^2)会超int范围，一定要注意</p><p>Arrays.sort不支持直接long类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">edgeScore</span><span class="params">(<span class="type">int</span>[] edges)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] counts = <span class="keyword">new</span> <span class="title class_">long</span>[edges.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length;i++) &#123;</span><br><span class="line">            counts[edges[i]][<span class="number">0</span>] += i;</span><br><span class="line">            counts[edges[i]][<span class="number">1</span>] = edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(counts, (a,b)-&gt;(a[<span class="number">0</span>] != b[<span class="number">0</span>] ? (b[<span class="number">0</span>] - a[<span class="number">0</span>] &gt; <span class="number">0</span>?<span class="number">1</span>:-<span class="number">1</span>) : (a[<span class="number">1</span>] - b[<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)counts[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><a href="https://leetcode.cn/problems/construct-smallest-number-from-di-string/">6150. 根据模式串构造最小数字 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458978033.png" alt="1660458978033"></p><p>我竟然一时无法冷静，看最多就9位，只想到了dfs，然后写了15分钟。。正确答案肯定不是dfs这么蠢的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">smallestNumber</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; rest = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            Set&lt;Integer&gt; set = Arrays.stream(nums).boxed().collect(Collectors.toSet());</span><br><span class="line">            rest.add(i);</span><br><span class="line">            set.remove(i);</span><br><span class="line">            dfs(pattern, rest, set,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">min</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String p, List&lt;Integer&gt; res, Set&lt;Integer&gt; canSelect,<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == p.length()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> res.stream().map(r -&gt; String.valueOf(r)).collect(Collectors.joining());</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="literal">null</span> || s.compareTo(min) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                min = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> res.get(res.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">sort</span> <span class="operator">=</span> p.charAt(i);</span><br><span class="line">        Set&lt;Integer&gt; copySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(canSelect);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> select : copySet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sort == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (select &lt; now) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (select &gt; now) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            canSelect.remove(select);</span><br><span class="line">            res.add(select);</span><br><span class="line">            dfs(p, res, canSelect, i+<span class="number">1</span>);</span><br><span class="line">            canSelect.add(select);</span><br><span class="line">            res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳做法肯定是一次遍历搞定</p><p>有个规律</p><p>III的时候，就是选取当前最小值，逐步递增</p><p>当DDD的时候， 则应该是从DDD的最右边选当前最小值，逐步往左边递增</p><p>处理完DDD的时候更新最小值</p><p>结果这个处理也很恶心，写死我了</p><p>后来想到每次只判断I这个字母前面所存的数字，后面数字存疑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">smallestNumber</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] results = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i &lt; pattern.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(i) == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            results[ri++] = num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern.charAt(i) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="comment">// 统计D的最右边，然后从右往左处理</span></span><br><span class="line">            <span class="keyword">while</span> (right+<span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(right+<span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">desLen</span> <span class="operator">=</span> right - i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">highNum</span> <span class="operator">=</span> num + desLen;</span><br><span class="line">            <span class="keyword">while</span> (desLen-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                results[ri++] = highNum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下一个注定是之前放的最小的那个</span></span><br><span class="line">            results[ri++] = num;</span><br><span class="line">            <span class="comment">// num要更新</span></span><br><span class="line">            num = num + (right - i + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            i = right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后是III的情况</span></span><br><span class="line">    <span class="keyword">if</span> (results[results.length-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        results[results.length-<span class="number">1</span>] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(results).boxed().map(r-&gt;r.toString()).collect(Collectors.joining());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660462821305.png" alt="1660462821305"></p><hr><p><a href="https://leetcode.cn/problems/count-special-integers/">6151. 统计特殊整数 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660462871513.png" alt="1660462871513"></p><p>排列组合题</p><p>处理0的时候很恶心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] = s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] select = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">canSelectCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">nowCanSelect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;nums[i];j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!select[j]) &#123;</span><br><span class="line">                    nowCanSelect++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                nowCanSelect--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nowCanSelect * getSum(canSelectCount - <span class="number">1</span>, s.length() - i - <span class="number">1</span>);</span><br><span class="line">                result += r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newR</span> <span class="operator">=</span> <span class="number">9</span>*getSum(<span class="number">9</span>, s.length()-i-<span class="number">1</span>);</span><br><span class="line">                result += newR;</span><br><span class="line">            &#125;</span><br><span class="line">            canSelectCount --;</span><br><span class="line">            <span class="keyword">if</span> (select[nums[i]]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            select[nums[i]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            sum *= n;</span><br><span class="line">            count--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂存以下数位DP，后面做一下强化以下</p><p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660462942718.png" alt="1660462942718"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fan-xing-fang-fa">泛型方法</a><ul><li><a href="#san-chong-fan-xing-can-shu-de-tui-duan-fang-shi">三种泛型参数的推断方式：</a></li><li><a href="#q-xia-mian-zhe-duan-dai-ma-na-li-you-wen-ti-shi-tostring-na-li-ma">Q: 下面这段代码哪里有问题？ 是toString()那里吗？</a></li></ul></li><li><a href="#fan-xing-can-shu-he-lei-xing-xiao-chu">泛型参数和类型消除</a><ul><li><a href="#q-fan-xing-can-shu-t-zai-yun-xing-shi-hui-bian-cheng-shi-me">Q： 泛型参数T在运行时，会变成什么？</a></li><li><a href="#q-fan-xing-can-shu-t-ke-yi-ke-yi-shi-yong-instanceof-zuo-bi-jiao-ma">Q: 泛型参数T可以可以使用instanceof做比较吗？</a></li><li><a href="#q-fan-xing-can-shu-t-ke-yi-jin-xing-new-t-huo-zhe-new-t-cao-zuo-ma">Q： 泛型参数T可以进行new T()或者new T[]操作吗？</a></li><li><a href="#q-neng-diao-yong-fan-xing-can-shu-dui-xiang-li-de-fang-fa-ma">Q： 能调用泛型参数对象里的方法吗？</a></li><li><a href="#q-ke-yi-yong-t-zuo-qiang-zhi-zhuan-hua-ma">Q： 可以用T做强制转化吗？</a></li></ul></li><li><a href="#xin-jian-fan-xing-dui-xiang-shi-de-wen-ti">新建泛型对象时的问题</a><ul><li><a href="#q-xia-mian-zhe-ju-hua-sheng-ming-list-dui-xiang-zuo-bian-fu-lei-fan-xing-you-bian-zi-lei-fan-xing-you-wen-ti-ma">Q： 下面这句话（声明list对象，左边父类泛型，右边子类泛型）有问题吗？</a></li><li><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-extends-parent-child-you-shi-me-xian-zhi">Q：这个list对象声明中， <strong>? extends Parent = Child</strong>   有什么限制？</a></li><li><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-super-child-parent-you-shi-me-te-dian">Q：这个list对象声明中，? super Child = Parent 有什么特点？</a></li><li><a href="#q-list-list-new-arraylist-a-zhe-ge-list-you-shi-me-te-dian">Q：List&lt;?&gt; list = new ArrayList<a>();这个list有什么特点？</a></a></li><li><a href="#q-xia-mian-zhe-ge-dai-ma-hui-bao-cuo-ma">Q：下面这个代码会报错吗？</a></li></ul></li><li><a href="#pecs-yuan-ze">PECS原则</a><ul><li><a href="#q-xia-mian-dai-ma-neng-zheng-chang-yun-xing-ma">Q：下面代码能正常运行吗？</a></li><li><a href="#q-ru-guo-shang-wen-yao-zhi-chi-pushlist-ying-gai-zen-me-xiu-gai-pushlist-fang-fa-de-ding-yi">Q： 如果上文要支持pushList，应该怎么修改pushList方法的定义？</a></li><li><a href="#q-ru-guo-yao-zhi-chi-polllist-zen-me-xiu-gai-ding-yi">Q： 如果要支持pollList，怎么修改定义？</a></li><li><a href="#pecs-yuan-ze-chu-zi-effective-java-zhu-yi-zhi-shi-yi-ge-bian-cheng-jian-yi-er-yi">PECS原则出自Effective Java， 注意只是一个编程建议而已！</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="fan-xing-fang-fa">泛型方法</span><a href="#fan-xing-fang-fa" class="header-anchor">#</a></h1><p>一般定义如下，即方法的前面加了个&lt;T&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">f</span><span class="params">(T t)</span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="san-chong-fan-xing-can-shu-de-tui-duan-fang-shi">三种泛型参数的推断方式：</span><a href="#san-chong-fan-xing-can-shu-de-tui-duan-fang-shi" class="header-anchor">#</a></h2><ol><li>直接在f()前面加确定泛型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fTest.&lt;Integer&gt;f(xxx)</span><br></pre></td></tr></table></figure><ol start="2"><li>通过输入参数确定， 下面这个推断为Integer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">fTest.f(number)</span><br></pre></td></tr></table></figure><ol start="3"><li>可通过 <em><strong>返回值</strong></em> 确定</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = fTest.f(xxx);</span><br></pre></td></tr></table></figure><hr><h2><span id="q-xia-mian-zhe-duan-dai-ma-na-li-you-wen-ti-shi-tostring-na-li-ma">Q: 下面这段代码哪里有问题？ 是toString()那里吗？</span><a href="#q-xia-mian-zhe-duan-dai-ma-na-li-you-wen-ti-shi-tostring-na-li-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">  System.out.println(t.toString());  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>test是static方法， 因此无法感知A&lt;T&gt;实例里的T<br>需要改成<br>public static &lt;T&gt; void test(T t)</p><p>toString（）那里没问题，toString就是Object的方法。</p><h1><span id="fan-xing-can-shu-he-lei-xing-xiao-chu">泛型参数和类型消除</span><a href="#fan-xing-can-shu-he-lei-xing-xiao-chu" class="header-anchor">#</a></h1><h2><span id="q-fan-xing-can-shu-t-zai-yun-xing-shi-hui-bian-cheng-shi-me">Q： 泛型参数T在运行时，会变成什么？</span><a href="#q-fan-xing-can-shu-t-zai-yun-xing-shi-hui-bian-cheng-shi-me" class="header-anchor">#</a></h2><p>A： 统一变成Object且不包含任何类型信息。</p><hr><h2><span id="q-fan-xing-can-shu-t-ke-yi-ke-yi-shi-yong-instanceof-zuo-bi-jiao-ma">Q: 泛型参数T可以可以使用instanceof做比较吗？</span><a href="#q-fan-xing-can-shu-t-ke-yi-ke-yi-shi-yong-instanceof-zuo-bi-jiao-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Object arg)</span></span><br><span class="line">   <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">  ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 不能，编译器会报错。</p><hr><h2><span id="q-fan-xing-can-shu-t-ke-yi-jin-xing-new-t-huo-zhe-new-t-cao-zuo-ma">Q： 泛型参数T可以进行new T()或者new T[]操作吗？</span><a href="#q-fan-xing-can-shu-t-ke-yi-jin-xing-new-t-huo-zhe-new-t-cao-zuo-ma" class="header-anchor">#</a></h2><p>A： 不能，编译器会报错。</p><hr><h2><span id="q-neng-diao-yong-fan-xing-can-shu-dui-xiang-li-de-fang-fa-ma">Q： 能调用泛型参数对象里的方法吗？</span><a href="#q-neng-diao-yong-fan-xing-can-shu-dui-xiang-li-de-fang-fa-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T.f();</span><br></pre></td></tr></table></figure><p>A： 只能调用Object的方法。</p><hr><h2><span id="q-ke-yi-yong-t-zuo-qiang-zhi-zhuan-hua-ma">Q： 可以用T做强制转化吗？</span><a href="#q-ke-yi-yong-t-zuo-qiang-zhi-zhuan-hua-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> (T)object;</span><br></pre></td></tr></table></figure><p>A: 能运行， 但不会真正发生转型， 编译时会触发waring警告。</p><h1><span id="xin-jian-fan-xing-dui-xiang-shi-de-wen-ti">新建泛型对象时的问题</span><a href="#xin-jian-fan-xing-dui-xiang-shi-de-wen-ti" class="header-anchor">#</a></h1><p>先假定有2个类， 基类Parent 和子类Child</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>回答以下问题：</p><h2><span id="q-xia-mian-zhe-ju-hua-sheng-ming-list-dui-xiang-zuo-bian-fu-lei-fan-xing-you-bian-zi-lei-fan-xing-you-wen-ti-ma">Q： 下面这句话（声明list对象，左边父类泛型，右边子类泛型）有问题吗？</span><a href="#q-xia-mian-zhe-ju-hua-sheng-ming-list-dui-xiang-zuo-bian-fu-lei-fan-xing-you-bian-zi-lei-fan-xing-you-wen-ti-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Parent&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Child&gt;()</span><br></pre></td></tr></table></figure><p>A：<br>有问题，编译就错误了。 List&lt;Parent&gt;和ArrayList&lt;Child&gt;并不存在父子类的关系</p><hr><h2><span id="q-zhe-ge-list-dui-xiang-sheng-ming-zhong-extends-parent-child-you-shi-me-xian-zhi">Q：这个list对象声明中， <strong>? extends Parent = Child</strong>   有什么限制？</span><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-extends-parent-child-you-shi-me-xian-zhi" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Parent</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Child&gt;();</span><br></pre></td></tr></table></figure><p>A：<br>这个list可以调用A a = list.get()， 但是不能list.add(new Parent())</p><ul><li>原因：<br>list.get()所做的操作是在返回时， 把内部的&lt;? extend Parent&gt; 强转成Parent，  是合理的，任何Parent的子类都可以转成Parent<br>list.add(new Parent()）所做的操作是在输入时，  把外部的A转成内部的&lt;? extend Parent&gt;，  这是不合理的，因为我们不知道这个Parent对象可以转成哪个Parent的子类。</li></ul><hr><h2><span id="q-zhe-ge-list-dui-xiang-sheng-ming-zhong-super-child-parent-you-shi-me-te-dian">Q：这个list对象声明中，? super Child = Parent 有什么特点？</span><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-super-child-parent-you-shi-me-te-dian" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Child&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Parent&gt;();</span><br></pre></td></tr></table></figure><p>下面谁会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Parent</span>())</span><br><span class="line">Parent a= list.get();</span><br><span class="line"><span class="type">Child</span> <span class="variable">b</span> <span class="operator">=</span> list.get()</span><br></pre></td></tr></table></figure><p>A：<br>截图如下：<br><img src="/images/java%E6%B3%9B%E5%9E%8B/1619454364092008017.png" alt="image.png"></p><ul><li>Child c = list.get() 或者Parent p = list.get()所做的操作是在返回时， 把内部的&lt;? super Child&gt; 强转成外部的Parent或者child， 是不合理的，  因为编译器觉得child的父类 <em><strong>不一定</strong></em> 能转成parent或者child，所以禁止了这种行为（ 比如parent的父类是object， 但object不一定就能转成parent或者child）<br>*list.add(new Child())所做的操作是在输入时， 把外部的child或者parent转成内部的&lt;? super Child&gt;， 这是合理的，因为child和parent一定能转成child的父类。</li></ul><hr><h2><span id="q-list-lt-gt-list-new-arraylist-zhe-ge-list-you-shi-me-te-dian">Q：List&lt;?&gt; list = new ArrayList</span><a href="#q-list-lt-gt-list-new-arraylist-zhe-ge-list-you-shi-me-te-dian" class="header-anchor">#</a></h2><p>A：<br>get和add都不行，只能做remove等无返回值无输入A的操作。<br>PS： 注意，不是说不能调用get或add方法， 而是调用get或add时，不能使用A这个对象去操作。<br>即无法做add(A) 或者  A a = get(0)<br>但是可以做add(object)  或者Object o = get(0)<br>因为？可以转为Object， 但是无法转为A。</p><hr><h2><span id="q-xia-mian-zhe-ge-dai-ma-hui-bao-cuo-ma">Q：下面这个代码会报错吗？</span><a href="#q-xia-mian-zhe-ge-dai-ma-hui-bao-cuo-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">fruitList.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>());</span><br><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">appleList.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">fruitList.addAll(appleList);</span><br><span class="line">System.out.println(fruitList);</span><br></pre></td></tr></table></figure><p>A:<br>不会报错。会正常打印结果。<br><img src="/images/java%E6%B3%9B%E5%9E%8B/1619454374478088912.png" alt="image.png"></p><hr><h1><span id="pecs-yuan-ze">PECS原则</span><a href="#pecs-yuan-ze" class="header-anchor">#</a></h1><p>注意PECS原则和上面的区别！<br>上面之前提到的? extend或者? supert， 都是在声明对象的时候用的。<br>而PECS原则是用于泛型对象的方法输入参数！</p><p>假设有一个类定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;T&gt; &#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把输入参数塞给自己，类似于生产操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushList</span><span class="params">(List&lt;T&gt; t)</span> &#123;</span><br><span class="line">        list.addAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把自己的内容塞给输入参数，类似于让输入参数做消费。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pollList</span><span class="params">(List&lt;T&gt; t)</span> &#123;</span><br><span class="line">         t.addAll(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则T就是泛型参数。</p><h2><span id="q-xia-mian-dai-ma-neng-zheng-chang-yun-xing-ma">Q：下面代码能正常运行吗？</span><a href="#q-xia-mian-dai-ma-neng-zheng-chang-yun-xing-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Number&gt; myList = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">myList.pushList(intList);</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">myList.pollList(objectList);</span><br></pre></td></tr></table></figure><p>A:<br>不能正常运行， pushList和pollList都会报错<br>因为编译器检查后，认为  List&lt;Integer&gt;和List&lt;Number&gt;不是一个东西！</p><hr><h2><span id="q-ru-guo-shang-wen-yao-zhi-chi-pushlist-ying-gai-zen-me-xiu-gai-pushlist-fang-fa-de-ding-yi">Q： 如果上文要支持pushList，应该怎么修改pushList方法的定义？</span><a href="#q-ru-guo-shang-wen-yao-zhi-chi-pushlist-ying-gai-zen-me-xiu-gai-pushlist-fang-fa-de-ding-yi" class="header-anchor">#</a></h2><p>A：<br>改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把输入参数塞给自己，类似于生产操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushList</span><span class="params">(List&lt;? extends T&gt; t)</span> &#123;</span><br><span class="line">    list.addAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即编译器认为，List&lt;Integer&gt; 和List&lt;? extend Number&gt;是一个东西，允许!</p><hr><h2><span id="q-ru-guo-yao-zhi-chi-polllist-zen-me-xiu-gai-ding-yi">Q： 如果要支持pollList，怎么修改定义？</span><a href="#q-ru-guo-yao-zhi-chi-polllist-zen-me-xiu-gai-ding-yi" class="header-anchor">#</a></h2><p>A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把自己的内容塞给输入参数，类似于让输入参数做消费。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pollList</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; t)</span> &#123;</span><br><span class="line">    t.addAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是把自己的东西塞给输入参数， 而想要能塞进去，必须保证自己这个T，是输入参数的子类，反过来说，输入参数必须是T的父类，所以用super<br>于是编译器认为，List&lt;Object&gt; 和List&lt;? super Number&gt;是一个东西，允许!</p><hr><h2><span id="pecs-yuan-ze-chu-zi-effective-java-zhu-yi-zhi-shi-yi-ge-bian-cheng-jian-yi-er-yi">PECS原则出自Effective Java， 注意只是一个编程建议而已！</span><a href="#pecs-yuan-ze-chu-zi-effective-java-zhu-yi-zhi-shi-yi-ge-bian-cheng-jian-yi-er-yi" class="header-anchor">#</a></h2><ul><li>如果有一个类A，泛型参数为T</li><li>如果他一般只用于接收输入容器List后，塞入自己内部的T容器， 则类A就叫生产者，   因此输入参数最好定义为&lt;? extend T&gt;最好， 以便能接收任何T子类的容器。</li><li>如果他一般只用于接收输入容器后List， 把自己内部的T元素塞给它， 那么这个类A就叫消费者， 输入参数最好定义为&lt;? super T&gt;\ 最好，  以便自己的T元素能塞给任何T元素的父类容器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java异常机制</title>
      <link href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yi-chang-ti-xi-fen-lei">异常体系分类</a><ul><li><a href="#q-throwable-he-error-de-guan-xi">Q： Throwable 和 Error的关系</a></li><li><a href="#q-error-he-exception-de-guan-xi">Q： Error和Exception的关系</a></li><li><a href="#q-error-ke-yi-bei-catch-bu-zhuo-ma">Q： Error可以被catch捕捉吗？</a></li><li><a href="#yi-chang-ti-xi-huan-ke-yi-fen-wei-zhe-2-lei">异常体系还可以分为这2类:</a></li></ul></li><li><a href="#yi-chang-bu-zhuo-he-fan-hui">异常捕捉和返回</a><ul><li><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1：  finally能通过修改变量，来更新return的变量值吗</a></li><li><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</a></li><li><a href="#q-shi-me-qing-kuang-xia-finally-kuai-li-de-bu-zou-ke-yi-bu-zhi-xing">Q： 什么情况下finally块里的步骤可以不执行？</a></li><li><a href="#q-xian-bu-zhuo-fu-lei-yi-chang-zai-bu-zhuo-zi-lei-yi-chang-hui-fa-sheng-shi-me">Q： 先捕捉父类异常，再捕捉子类异常，会发生什么？</a></li><li><a href="#q-throw-yi-chang-de-shi-hou-zai-finally-zhong-zuo-return-na-me-yi-chang-huan-hui-pao-chu-ma">Q：throw异常的时候，在finally中做return，那么异常还会抛出吗？</a></li></ul></li><li><a href="#shou-jian-yi-chang-xiang-guan-wen-ti">受检异常相关问题</a><ul><li><a href="#q-zi-lei-fu-xie-ji-lei-fang-fa-shi-neng-throws-ji-lei-fang-fa-zhong-bu-cun-zai-de-yi-chang-ma">Q: 子类覆写基类方法时 ， 能throws基类方法中不存在的异常吗？</a></li><li><a href="#q-finally-zhong-diao-yong-mou-zi-yuan-de-close-shi-ye-hui-pao-chu-shou-jian-yi-chang-chu-liao-zai-finally-li-zuo-try-catch-huan-neng-zen-me-zuo">Q: finally中调用某资源的close时，也会抛出受检异常，  除了在finally里做try-catch，还能怎么做？</a></li><li><a href="#q-xian-cheng-pao-chu-yi-chang-de-hua-gai-zen-me-bu-zhuo">Q: 线程抛出异常的话该怎么捕捉？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="yi-chang-ti-xi-fen-lei">异常体系分类</span><a href="#yi-chang-ti-xi-fen-lei" class="header-anchor">#</a></h1><h2><span id="q-throwable-he-error-de-guan-xi">Q：  Throwable 和 Error的关系</span><a href="#q-throwable-he-error-de-guan-xi" class="header-anchor">#</a></h2><p>A： Throwable是Error(错误）的基类，也是Exception的基类<br>1个好图，可看到常见的异常和error<br><img src="/images/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/1616809879000046121.png" alt="image.png"></p><hr><h2><span id="q-error-he-exception-de-guan-xi">Q： Error和Exception的关系</span><a href="#q-error-he-exception-de-guan-xi" class="header-anchor">#</a></h2><p>A：</p><ul><li>Error一般是会直接引起jvm出错的错误，例如Java虚拟机运行错误等，如果出现了当前线程会无法继续运行。</li><li>Excpetion是程序本身可以处理的异常。发生后还能正常运行。</li></ul><hr><h2><span id="q-error-ke-yi-bei-catch-bu-zhuo-ma">Q： Error可以被catch捕捉吗？</span><a href="#q-error-ke-yi-bei-catch-bu-zhuo-ma" class="header-anchor">#</a></h2><p>A： 只要是Throwable和其子类都是可以throw和catch的。 但是不建议捕捉Error。</p><hr><h2><span id="yi-chang-ti-xi-huan-ke-yi-fen-wei-zhe-2-lei">异常体系还可以分为这2类:</span><a href="#yi-chang-ti-xi-huan-ke-yi-fen-wei-zhe-2-lei" class="header-anchor">#</a></h2><ul><li><p>unchecked exception（非检查异常）<br>也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</p></li><li><p>checked exception（检查异常，编译异常）<br>也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p></li></ul><h1><span id="yi-chang-bu-zhuo-he-fan-hui">异常捕捉和返回</span><a href="#yi-chang-bu-zhuo-he-fan-hui" class="header-anchor">#</a></h1><h2><span id="q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1：  finally能通过修改变量，来更新return的变量值吗</span><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      a=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:  不能， f返回1。</p><hr><h2><span id="q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</span><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：返回finally里的，返回2。</p><hr><h2><span id="q-shi-me-qing-kuang-xia-finally-kuai-li-de-bu-zou-ke-yi-bu-zhi-xing">Q： 什么情况下finally块里的步骤可以不执行？</span><a href="#q-shi-me-qing-kuang-xia-finally-kuai-li-de-bu-zou-ke-yi-bu-zhi-xing" class="header-anchor">#</a></h2><p>A： 只有在finally之前调用System.exit(0)退出jvm， 才能让finally不执行。</p><hr><h2><span id="q-xian-bu-zhuo-fu-lei-yi-chang-zai-bu-zhuo-zi-lei-yi-chang-hui-fa-sheng-shi-me">Q： 先捕捉父类异常，再捕捉子类异常，会发生什么？</span><a href="#q-xian-bu-zhuo-fu-lei-yi-chang-zai-bu-zhuo-zi-lei-yi-chang-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;catch Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;catch RuntimeException&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 直接编译就错误了。 catch是会按顺序的且匹配1个就不再往下匹配，编译器因此识别出RuntimeExcpetion永远不会被捕捉到，便提前报错。</p><hr><h2><span id="q-throw-yi-chang-de-shi-hou-zai-finally-zhong-zuo-return-na-me-yi-chang-huan-hui-pao-chu-ma">Q：throw异常的时候，在finally中做return，那么异常还会抛出吗？</span><a href="#q-throw-yi-chang-de-shi-hou-zai-finally-zhong-zuo-return-na-me-yi-chang-huan-hui-pao-chu-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>不会，返回-1.<br>即finaly中做return会中断throw<br>因此永远不要在finally中去做return操作</p><h1><span id="shou-jian-yi-chang-xiang-guan-wen-ti">受检异常相关问题</span><a href="#shou-jian-yi-chang-xiang-guan-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-zi-lei-fu-xie-ji-lei-fang-fa-shi-neng-throws-ji-lei-fang-fa-zhong-bu-cun-zai-de-yi-chang-ma">Q: 子类覆写基类方法时 ， 能throws基类方法中不存在的异常吗？</span><a href="#q-zi-lei-fu-xie-ji-lei-fang-fa-shi-neng-throws-ji-lei-fang-fa-zhong-bu-cun-zai-de-yi-chang-ma" class="header-anchor">#</a></h2><p>像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 不行，直接编译报错。  即子类覆写父类方法时， throws关键字后面跟的异常必须是小于等于父类方法异常的。<br><img src="/images/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/1616809912530040293.png" alt="image.png"></p><hr><h2><span id="q-finally-zhong-diao-yong-mou-zi-yuan-de-close-shi-ye-hui-pao-chu-shou-jian-yi-chang-chu-liao-zai-finally-li-zuo-try-catch-huan-neng-zen-me-zuo">Q: finally中调用某资源的close时，也会抛出受检异常，  除了在finally里做try-catch，还能怎么做？</span><a href="#q-finally-zhong-diao-yong-mou-zi-yuan-de-close-shi-ye-hui-pao-chu-shou-jian-yi-chang-chu-liao-zai-finally-li-zuo-try-catch-huan-neng-zen-me-zuo" class="header-anchor">#</a></h2><p>像下面这样，finally又有catch，就很难看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TryWithResource</span> <span class="variable">tryWithResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TryWithResource</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(tryWithResource.age);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tryWithResource.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>A：如果是JDK1.7，可以用try-with-resource语法。<br>需要资源类实现AutoCloseable接口，  并在try的时候在try括号后面跟上资源的创建，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">TryWithResource</span> <span class="variable">tryWithResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TryWithResource</span>()) &#123;</span><br><span class="line">        System.out.println(tryWithResource.age);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不需要写finally，finally+close会通过编译器给我们自动加上。</p><hr><h2><span id="q-xian-cheng-pao-chu-yi-chang-de-hua-gai-zen-me-bu-zhuo">Q: 线程抛出异常的话该怎么捕捉？</span><a href="#q-xian-cheng-pao-chu-yi-chang-de-hua-gai-zen-me-bu-zhuo" class="header-anchor">#</a></h2><p>A： 实现异常处理接口MyUnchecckedExceptionhandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUnchecckedExceptionhandler</span> <span class="keyword">implements</span> <span class="title class_">UncaughtExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获异常处理方法：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把实现类设置给对应线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUnchecckedExceptionhandler</span>());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>除此之外还有6种方法可以设置，详见<a href="https://blog.csdn.net/pange1991/article/details/82115437">链接</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java容器基础概念和应用</title>
      <link href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#list-xiang-guan-wen-ti">List相关问题</a><ul><li><a href="#q-arrlist-new-arraylist-arrays-aslist-he-arrlist-arrays-aslist-you-shi-me-qu-bie">Q:arrList = new ArrayList&lt;&gt;(Arrays.asList（）)   和  arrList =   Arrays.asList（）有什么区别</a></li><li><a href="#q-na-aslist-zhi-chi-tong-guo-xiu-gai-yuan-shu-zu-lai-xiu-gai-list-nei-rong-ma">Q：那asList()支持通过修改原数组来修改list内容吗？</a></li><li><a href="#q-dang-shu-ru-wei-na-xie-zi-mu-shi-die-dai-shi-hui-bao-cuo">Q： 当输入为哪些字母时，迭代时会报错</a></li><li><a href="#q-arraylist-de-kuo-rong-gong-shi-he-mo-ren-chu-shi-da-xiao-shi-duo-shao">Q： ArrayList的扩容公式和默认初始大小是多少？</a></li><li><a href="#q-vector-de-kuo-rong-gong-shi-shi-duo-shao">Q： Vector的扩容公式是多少？</a></li><li><a href="#q-vector-he-arraylist-de-qu-bie">Q：vector和ArrayList的区别</a></li><li><a href="#q-wei-shi-me-bu-tui-jian-shi-yong-stack">Q：为什么不推荐使用stack</a></li></ul></li><li><a href="#map-xiang-guan-wen-ti">Map相关问题</a><ul><li><a href="#q-jie-da-xia-lie-te-xing-he-na-xie-map-you-guan">Q： 解答下列特性和哪些Map有关</a></li><li><a href="#q-hashcode-xiang-tong-na-me-equals-ken-ding-true-ma">Q： hashCode相同， 那么equals肯定true吗？</a></li><li><a href="#q-equals-wei-true-na-me-hashcode-ken-ding-xiang-tong-ma">Q： equals为true， 那么hashCode肯定相同吗？</a></li><li><a href="#q-2-ge-string-ru-guo-nei-rong-xiang-tong-na-me-hashcode-xiang-tong-ma">Q： 2个String如果内容相同，那么hashCode相同吗？</a></li><li><a href="#hashtable-hashmap-concurrenthashmap-bi-jiao">HashTable、HashMap、ConcurrentHashMap比较：</a></li><li><a href="#q-collections-synchronizedmap-map-he-concurrenthashmap-na-ge-tong-bu-xiao-guo-hao">Q：Collections.synchronizedMap（map）和ConcurrentHashMap,哪个同步效果好？</a></li><li><a href="#q-linkedhashmap-de-accessorder-wen-ti-xia-mian-shu-chu-shi-me">Q:linkedHashMap的accessOrder问题,下面输出什么</a></li><li><a href="#q-hashmap-wei-shi-me-duo-xian-cheng-shi-yong-shi-ke-neng-hui-zao-cheng-si-xun-huan">Q：hashMap为什么多线程使用时可能会造成死循环？</a></li><li><a href="#q-java1-7-he-1-8-zhi-jian-hashmap-zuo-liao-shi-me-gai-jin">Q:java1.7 和1.8 之间， hashMap做了什么改进？</a></li></ul></li><li><a href="#collections">Collections</a></li><li><a href="#te-shu-de-yin-yong-rong-qi">特殊的引用容器</a><ul><li><a href="#q-ru-guo-ra-yin-yong-liao-a-ze-a-bi-bu-ke-neng-bei-hui-shou-ra-shu-yu-shi-me-yin-yong">Q：如果RA引用了A，则A必不可能被回收， RA属于什么引用？</a></li><li><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-zai-nei-cun-bu-zu-shi-hui-qiang-zhi-hui-shou-a-ze-ra-shu-yu-shi-me-yin-yong">Q： 如果只有RA引用了A， 在内存不足时会强制回收A，则RA属于什么引用？</a></li><li><a href="#hexopostrendercodeblock-figure-class-highlight-java-table-tr-td-class-gutter-pre-span-class-line-1-span-br-pre-td-td-class-code-pre-span-class-line-softreference-lt-string-gt-softreference-span-class-keyword-new-span-span-class-title-class-softreference-span-lt-string-gt-str-span-br-pre-td-tr-table-figure-hexopostrendercodeblock"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></a></li><li><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-bu-guan-nei-cun-zu-bu-zu-zhi-yao-la-ji-hui-shou-qi-sao-miao-dao-liao-jiu-hui-zhi-jie-hui-shou-ra-shu-yu">Q： 如果只有RA引用了A， 不管内存足不足，只要垃圾回收器扫描到了，就会直接回收，RA属于：</a></li><li><a href="#q-dang-zhi-you-ra-yin-yong-liao-a-shi-du-hui-zai-xia-yi-ci-la-ji-shou-ji-shi-zhi-jie-hui-shou-qie-chuang-jian-yin-yong-shi-bi-xu-yi-lai-yin-yong-dui-lie-zhe-ge-yin-yong-ra-shu-yu">Q： 当只有RA引用了A时，都会在下一次垃圾收集时直接回收，且创建引用时必须依赖引用队列，这个引用RA属于：</a></li><li><a href="#q-yin-yong-dui-lie-shi-shi-me-zuo-yong-shi-shi-me">Q： 引用队列是什么，作用是什么？</a></li><li><a href="#you-xian-dui-lie">优先队列</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><p>经典java容器结构图：<br><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218412983051246.png" alt="image.png"></p><p>注意哪些属于Collection，哪些属于Map。</p><hr><h1><span id="list-xiang-guan-wen-ti">List相关问题</span><a href="#list-xiang-guan-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-arrlist-new-arraylist-lt-gt-arrays-aslist-he-arrlist-arrays-aslist-you-shi-me-qu-bie">Q:arrList = new ArrayList&lt;&gt;(Arrays.asList（）)   和  arrList =   Arrays.asList（）有什么区别</span><a href="#q-arrlist-new-arraylist-lt-gt-arrays-aslist-he-arrlist-arrays-aslist-you-shi-me-qu-bie" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arrList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">List&lt;Integer&gt; arrList2 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">arrList1.add(<span class="number">4</span>);</span><br><span class="line">arrList2.add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>A:执行arrList2.add(4)时会报错。<br>因为 Arrays.asList()只会返回1个固定大小的列表， 其返回的List是AbstractList，无法调用add、remove和clear， 如果调用会直接抛异常。<br>异常名字为UnsupportedOperationException<br>具体原因可以见评论区。</p><hr><h2><span id="q-na-aslist-zhi-chi-tong-guo-xiu-gai-yuan-shu-zu-lai-xiu-gai-list-nei-rong-ma">Q：那asList()支持通过修改原数组来修改list内容吗？</span><a href="#q-na-aslist-zhi-chi-tong-guo-xiu-gai-yuan-shu-zu-lai-xiu-gai-list-nei-rong-ma" class="header-anchor">#</a></h2><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; arrList = Arrays.asList(ss);</span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(arrList);</span><br></pre></td></tr></table></figure><p>上面操作后arrList会报错吗？</p><p>A：<br>不会报错。arrList里的内容变成了{“d”,“b”,“c”}</p><h2><span id="q-dang-shu-ru-wei-na-xie-zi-mu-shi-die-dai-shi-hui-bao-cuo">Q： 当输入为哪些字母时，迭代时会报错</span><a href="#q-dang-shu-ru-wei-na-xie-zi-mu-shi-die-dai-shi-hui-bao-cuo" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (String curStr : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(curStr)) &#123;</span><br><span class="line">            list.remove(curStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>删除A或者B会报错，  但是删除C不会！<br>对于foreach遍历容器，并用remove做删除时，当删除倒数第二个元素时，是不会报错的。<br>因为：</p><hr><h2><span id="q-arraylist-de-kuo-rong-gong-shi-he-mo-ren-chu-shi-da-xiao-shi-duo-shao">Q： ArrayList的扩容公式和默认初始大小是多少？</span><a href="#q-arraylist-de-kuo-rong-gong-shi-he-mo-ren-chu-shi-da-xiao-shi-duo-shao" class="header-anchor">#</a></h2><p>A：<br>扩容容量= 原容量 + (原容量右移1位，即0.5倍)= 1.5倍<br><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218437437040318.png" alt="image.png"></p><p>初始容量为10.<br><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218442905061711.png" alt="image.png"></p><ul><li>注意，初始的数组长度还是0，数组长度和容量不是一个东西。</li></ul><hr><h2><span id="q-vector-de-kuo-rong-gong-shi-shi-duo-shao">Q： Vector的扩容公式是多少？</span><a href="#q-vector-de-kuo-rong-gong-shi-shi-duo-shao" class="header-anchor">#</a></h2><p>A:<br>扩容容量= 原容量 *2<br><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218451056083054.png" alt="image.png"></p><p>初始大小为10<br><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218456618026072.png" alt="image.png"></p><hr><h2><span id="q-vector-he-arraylist-de-qu-bie">Q：vector和ArrayList的区别</span><a href="#q-vector-he-arraylist-de-qu-bie" class="header-anchor">#</a></h2><p>A：<br>vector是线程安全的， 每个方法都加了syn关键字，频繁的加锁可能导致性能降低</p><hr><h2><span id="q-wei-shi-me-bu-tui-jian-shi-yong-stack">Q：为什么不推荐使用stack</span><a href="#q-wei-shi-me-bu-tui-jian-shi-yong-stack" class="header-anchor">#</a></h2><p>A：<br>为什么不推荐使用stack<br><a href="https://www.cnblogs.com/cosmos-wong/p/11845934.html">https://www.cnblogs.com/cosmos-wong/p/11845934.html</a><br>stack 继承自vector ， 但是vector里包含了很多不需要的public方法<br>只是为了实现栈，不用链表来单独实现，而是为了复用简单的方法而迫使它继承 Vector，Stack 和 Vector 本来是毫无关系的。这使得 Stack 在基于数组实现上效率受影响，另外因为继承 Vector 类，Stack 可以复用 Vector 大量方法，这使得 Stack 在设计上不严谨</p><hr><h1><span id="map-xiang-guan-wen-ti">Map相关问题</span><a href="#map-xiang-guan-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-jie-da-xia-lie-te-xing-he-na-xie-map-you-guan">Q： 解答下列特性和哪些Map有关</span><a href="#q-jie-da-xia-lie-te-xing-he-na-xie-map-you-guan" class="header-anchor">#</a></h2><ul><li><p>实现基于散列表，迭代时是不确定随机的顺序的Map为-----------------------------------------HashMap</p></li><li><p>迭代时按照插入顺序进行迭代-----------------------------------------------------LinkedHashMap</p></li><li><p>迭代时按照键值的比较顺序进行迭代-----------------------------------------------------TreeMap</p></li><li><p>基于红黑树的实现-----------------------------------------------------TreeMap</p></li><li><p>线程安全的Map-----------------------------------------------------ConcurrentHashMap</p></li><li><p>键值比较时使用==而不是equal的Map-------------------------------------------------IdentityHashMap</p></li><li><p>可以按区间得到1个子map的Map----------------------sortMap</p></li><li><p>Set也有HashSet、LinkedSet、TreeSet、SortSet等，作用同理。</p></li></ul><hr><h2><span id="q-hashcode-xiang-tong-na-me-equals-ken-ding-true-ma">Q： hashCode相同， 那么equals肯定true吗？</span><a href="#q-hashcode-xiang-tong-na-me-equals-ken-ding-true-ma" class="header-anchor">#</a></h2><p>A： 不一定。</p><h2><span id="q-equals-wei-true-na-me-hashcode-ken-ding-xiang-tong-ma">Q： equals为true， 那么hashCode肯定相同吗？</span><a href="#q-equals-wei-true-na-me-hashcode-ken-ding-xiang-tong-ma" class="header-anchor">#</a></h2><p>A： 对。<br>原因： 参见散列表的原理，明白hashCode的作用后就明白为什么了。<br><br></p><h2><span id="q-2-ge-string-ru-guo-nei-rong-xiang-tong-na-me-hashcode-xiang-tong-ma">Q： 2个String如果内容相同，那么hashCode相同吗？</span><a href="#q-2-ge-string-ru-guo-nei-rong-xiang-tong-na-me-hashcode-xiang-tong-ma" class="header-anchor">#</a></h2><p>A： 对,相同。因为二者equals返回true，所以必定hashCode相同。<br>Q： 如果在插入后，修改某个key的hashCode，可能造成什么问题？<br>A：<br>可能造成内存泄漏。因为map是按计算后的hashCode存放的，而如果在外部修改了某个key的值，可能造成之前塞入的那个哈希所在的地址无法被外部remove(key)，却又无法被gc（因为一直持有），造成内存泄漏。</p><hr><h2><span id="hashtable-hashmap-concurrenthashmap-bi-jiao">HashTable、HashMap、ConcurrentHashMap比较：</span><a href="#hashtable-hashmap-concurrenthashmap-bi-jiao" class="header-anchor">#</a></h2><ul><li>key和value不可以为null的是：----------------------------HashTable</li><li>线程安全的是：---------------------------------HashTable和ConcurrentHashMap<br>他们2个的区别：<br>在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。(具体可参考底层实现原理，总之ConcurrentHashMap最重要的是做了分段)</li></ul><hr><h2><span id="q-collections-synchronizedmap-map-he-concurrenthashmap-na-ge-tong-bu-xiao-guo-hao">Q：Collections.synchronizedMap（map）和ConcurrentHashMap,哪个同步效果好？</span><a href="#q-collections-synchronizedmap-map-he-concurrenthashmap-na-ge-tong-bu-xiao-guo-hao" class="header-anchor">#</a></h2><p>A：</p><blockquote><blockquote><blockquote><p>Collections.synchronizedMap(map)与ConcurrentHashMap主要区别是：Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步<br>而ConcurrentHashMap的实现却更加精细,分端加锁</p></blockquote></blockquote></blockquote><p>其实Colletions.synchronizedMap就是对放进去的map包了一层sync关键字。<br>详见：<br><a href="https://www.cnblogs.com/a198720/articles/4227500.html">https://www.cnblogs.com/a198720/articles/4227500.html</a></p><hr><h2><span id="q-linkedhashmap-de-accessorder-wen-ti-xia-mian-shu-chu-shi-me">Q:linkedHashMap的accessOrder问题,下面输出什么</span><a href="#q-linkedhashmap-de-accessorder-wen-ti-xia-mian-shu-chu-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LinkedHashMap&lt;String, String&gt; accessOrderTrue = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;put后的数据：&quot;</span>+accessOrderTrue);</span><br><span class="line">    accessOrderTrue.get(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    accessOrderTrue.get(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get后的数据&quot;</span>+accessOrderTrue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>省略key值<br>put后的数据： {1=1,2=2,3=3,4=4}<br>get后的数据： {1=1,4=4,2=2,3=3}</p><ul><li>accessOrder为true时， 会把最近访问过的数据放到链表 <em><strong>末尾</strong></em>。</li></ul><hr><h2><span id="q-hashmap-wei-shi-me-duo-xian-cheng-shi-yong-shi-ke-neng-hui-zao-cheng-si-xun-huan">Q：hashMap为什么多线程使用时可能会造成死循环？</span><a href="#q-hashmap-wei-shi-me-duo-xian-cheng-shi-yong-shi-ke-neng-hui-zao-cheng-si-xun-huan" class="header-anchor">#</a></h2><p>A：<br><a href="https://www.jianshu.com/p/1e9cf0ac07f4">https://www.jianshu.com/p/1e9cf0ac07f4</a><br>主要发生在2个线程同时put并进行扩容时， 对同一个对象的链表引用会出现问题。、</p><hr><h2><span id="q-java1-7-he-1-8-zhi-jian-hashmap-zuo-liao-shi-me-gai-jin">Q:java1.7 和1.8 之间， hashMap做了什么改进？</span><a href="#q-java1-7-he-1-8-zhi-jian-hashmap-zuo-liao-shi-me-gai-jin" class="header-anchor">#</a></h2><p>A：<br>1.7的哈希如果冲突严重，则在一个点上形成的链表会越来越长。<br>因此1.8做了改进，如果那个点的链表长度超过TREEIFY_THRESHOLD,则会转为红黑树。</p><h1><span id="collections">Collections</span><a href="#collections" class="header-anchor">#</a></h1><ul><li>Collection是接口， Collections是1个工具类</li><li>排序： Collections.sort(collection ,Comparator&lt;&gt;)</li><li>打乱顺序： Collections.shuffle(collection ,Random)</li><li>填充: Collections.fill(list, 对象) ，  注意是浅拷贝填充， 即填充后使用的是同一个引用。</li><li>返回不可变容器（即无法对容器做修改）： Collections.unmodifiableMap(容器)<br>除此之外可以返回空的不可变集合和仅有单个元素的不可变集合。<br><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218468075036317.png" alt="image.png"></li></ul><hr><p><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218476720061727.png" alt="image.png"></p><h1><span id="te-shu-de-yin-yong-rong-qi">特殊的引用容器</span><a href="#te-shu-de-yin-yong-rong-qi" class="header-anchor">#</a></h1><p>假设有1个对象A， 有1个引用RA指向A</p><h2><span id="q-ru-guo-ra-yin-yong-liao-a-ze-a-bi-bu-ke-neng-bei-hui-shou-ra-shu-yu-shi-me-yin-yong">Q：如果RA引用了A，则A必不可能被回收， RA属于什么引用？</span><a href="#q-ru-guo-ra-yin-yong-liao-a-ze-a-bi-bu-ke-neng-bei-hui-shou-ra-shu-yu-shi-me-yin-yong" class="header-anchor">#</a></h2><p>A:  强引用StrongRefernce，默认的引用操作都是强引用</p><hr><h2><span id="q-ru-guo-zhi-you-ra-yin-yong-liao-a-zai-nei-cun-bu-zu-shi-hui-qiang-zhi-hui-shou-a-ze-ra-shu-yu-shi-me-yin-yong">Q： 如果只有RA引用了A， 在内存不足时会强制回收A，则RA属于什么引用？</span><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-zai-nei-cun-bu-zu-shi-hui-qiang-zhi-hui-shou-a-ze-ra-shu-yu-shi-me-yin-yong" class="header-anchor">#</a></h2><p>A: 软引用SoftReferencem，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><hr><h2><span id="q-ru-guo-zhi-you-ra-yin-yong-liao-a-bu-guan-nei-cun-zu-bu-zu-zhi-yao-la-ji-hui-shou-qi-sao-miao-dao-liao-jiu-hui-zhi-jie-hui-shou-ra-shu-yu">Q： 如果只有RA引用了A， 不管内存足不足，只要垃圾回收器扫描到了，就会直接回收，RA属于：</span><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-bu-guan-nei-cun-zu-bu-zu-zhi-yao-la-ji-hui-shou-qi-sao-miao-dao-liao-jiu-hui-zhi-jie-hui-shou-ra-shu-yu" class="header-anchor">#</a></h2><p>A： 弱引用WeakReference，  注意和垃圾收集器的启动间隔有关，因此短时间内RA还是可用的。<br>和这个引用相关的集合：WeakHashMap</p><hr><h2><span id="q-dang-zhi-you-ra-yin-yong-liao-a-shi-du-hui-zai-xia-yi-ci-la-ji-shou-ji-shi-zhi-jie-hui-shou-qie-chuang-jian-yin-yong-shi-bi-xu-yi-lai-yin-yong-dui-lie-zhe-ge-yin-yong-ra-shu-yu">Q： 当只有RA引用了A时，都会在下一次垃圾收集时直接回收，且创建引用时必须依赖引用队列，这个引用RA属于：</span><a href="#q-dang-zhi-you-ra-yin-yong-liao-a-shi-du-hui-zai-xia-yi-ci-la-ji-shou-ji-shi-zhi-jie-hui-shou-qie-chuang-jian-yin-yong-shi-bi-xu-yi-lai-yin-yong-dui-lie-zhe-ge-yin-yong-ra-shu-yu" class="header-anchor">#</a></h2><p>A： 虚引用（幽灵引用）PhantomReference。<br>和弱引用区别：<br>虚引用创建时必须依赖引用队列，且用途一般是跟踪对象的垃圾回收，让用户在回收时通过虚引用去触发一些清理行为。</p><hr><h2><span id="q-yin-yong-dui-lie-shi-shi-me-zuo-yong-shi-shi-me">Q： 引用队列是什么，作用是什么？</span><a href="#q-yin-yong-dui-lie-shi-shi-me-zuo-yong-shi-shi-me" class="header-anchor">#</a></h2><p>A： 引用队列可以配合软引用、弱引用及幽灵引用使用，当引用的对象将要被JVM回收时，会将其加入到引用队列。<br>应用：通过引用队列可以了解JVM垃圾回收情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 引用队列</span></span><br><span class="line">ReferenceQueue&lt;String&gt; rq = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 幽灵引用</span></span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>), rq);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 永远为null（幽灵引用相当于无引用）</span></span><br><span class="line">System.out.println(pr.get());</span><br></pre></td></tr></table></figure><hr><p><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218485847000930.png" alt="image.png"></p><h2><span id="you-xian-dui-lie">优先队列</span><a href="#you-xian-dui-lie" class="header-anchor">#</a></h2><p><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218491033053213.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类初始化顺序和类加载基础概念</title>
      <link href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#java-lei-de-jia-zai-shun-xu">Java类的加载顺序</a><ul><li><a href="#q-shi-me-shi-hou-hui-jin-xing-jing-tai-bian-liang-de-fu-zhi-he-jing-tai-dai-ma-kuai-de-zhi-xing">Q： 什么时候会进行静态变量的赋值和静态代码块的执行？</a></li><li><a href="#q-chu-shi-hua-mou-ge-zi-lei-shi-ye-hui-dui-fu-lei-zuo-jing-tai-chu-shi-hua-ma-shun-xu-ni">Q：初始化某个子类时，也会对父类做静态初始化吗？顺序呢？</a></li><li><a href="#q-wei-shi-me-fu-lei-de-method-bu-hui-bei-zi-lei-de-method-chong-xie">Q： 为什么父类的method不会被子类的method重写？</a></li><li><a href="#q-wei-shi-me-di-yi-ge-shu-chu-de-shi-e-er-bu-shi-a">Q： 为什么第一个输出的是e而不是a？</a></li><li><a href="#q-mei-you-zai-zi-lei-de-gou-zao-qi-zhong-diao-yong-super-shi-ye-hui-jin-xing-fu-lei-dui-xiang-de-shi-li-hua-ma">Q： 没有在子类的构造器中调用super()时，也会进行父类对象的实例化吗？</a></li><li><a href="#q-gou-zao-fang-fa-cheng-yuan-xian-shi-fu-zhi-fei-jing-tai-dai-ma-kuai-ji-shu-chu-c-he-h-de-na-2-ju-de-shun-xu-shi-shi-me">Q： 构造方法、成员显示赋值、非静态代码块（即输出c和h的那2句）的顺序是什么？</a></li><li><a href="#q-wei-shi-me-animal-shi-li-hua-shi-i-test-zhong-shu-chu-de-shi-i-er-bu-shi-d">Q： 为什么Animal实例化时， i=test()中输出的是i而不是d？</a></li><li><a href="#q-tong-shang-ti-ru-guo-test-fang-fa-du-shi-private-huo-zhe-final-shu-xing-na-me-shang-ti-de-qing-kuang-hui-you-bian-hua-ma">Q： 同上题， 如果test方法都是private或者final属性， 那么上题的情况会有变化吗？？</a></li></ul></li><li><a href="#lei-jia-zai-guo-cheng">类加载过程</a><ul><li><a href="#q-lei-jia-zai-de-3-ge-bi-jing-jie-duan-shi">Q：类加载的3个必经阶段是：</a></li></ul></li><li><a href="#bei-dong-yin-yong-zhong-he-lei-jing-tai-chu-shi-hua-de-guan-xi">被动引用中和类静态初始化的关系</a><ul><li><a href="#q-new-mou-ge-lei-de-shu-zu-shi-hui-yin-fa-lei-chu-shi-hua-ma">Q：new某个类的数组时，会引发类初始化吗？</a></li><li><a href="#q-yin-yong-lei-de-final-jing-tai-zi-duan-hui-yin-fa-lei-chu-shi-hua-ma">Q：引用类的final静态字段，会引发类初始化吗？</a></li><li><a href="#q-zi-lei-yin-yong-liao-fu-lei-de-jing-tai-cheng-yuan-ci-shi-zi-lei-hui-zuo-lei-chu-shi-hua-ma">Q：子类引用了父类的静态成员，此时子类会做类初始化嘛？</a></li></ul></li><li><a href="#lei-jia-zai-qi">类加载器</a><ul><li><a href="#shuang-qin-wei-pai">双亲委派</a></li><li><a href="#q-java-zhong-shi-fou-lei-he-jie-kou-de-bao-ming-he-ming-zi-xiang-tong-na-me-jiu-yi-ding-shi-tong-yi-ge-lei-huo-zhe-jie-kou">Q：java中， 是否类和接口的包名和名字相同， 那么就一定是同一个类或者接口？</a></li><li><a href="#q-jiang-yi-xia-classloader-yuan-li-yi-ji-ying-yong-chang-jing">Q: 讲一下ClassLoader原理， 以及应用场景</a></li><li><a href="#q-ru-guo-zai-ni-xiang-mu-zhong-jian-yi-ge-java-lang-string-de-lei-na-xi-tong-zhong-yong-de-string-lei-shi-ni-ding-yi-de-string-lei-huan-shi-yuan-sheng-api-zhong-de-string-lei">Q:如果在你项目中建一个java.lang.String的类，那系统中用的String类是你定义的String类，还是原生api中的String类？</a></li><li><a href="#q-wei-shi-me-yao-yong-shuang-qin-wei-tuo-you-shi-me-hao-chu">Q ： 为什么要用双亲委托，有什么好处？</a></li><li><a href="#q-na-wo-ru-guo-zhen-de-you-xu-qiu-bu-xiang-yong-shuang-qin-de-ji-zhi-ni">Q: 那我如果真的有需求， 不想用双亲的机制呢？</a></li><li><a href="#q-shu-zu-lei-shi-zen-me-zuo-jia-zai-de">Q: 数组类是怎么做加载的？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><p>很多时候提到类加载，大家总是没法马上回忆起顺序，这篇文章会用一个例子为你把类加载的诸多问题一次性澄清。</p><h1><span id="java-lei-de-jia-zai-shun-xu">Java类的加载顺序</span><a href="#java-lei-de-jia-zai-shun-xu" class="header-anchor">#</a></h1><p>引用1个网上的经典例子，并做稍许改动，以便大家更好地理解。<br>原例子引用自：<a href="https://blog.csdn.net/zfx2013/article/details/89453482">https://blog.csdn.net/zfx2013/article/details/89453482</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> j ?= method();</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     Animal()&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">     &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> j ?= method();</span><br><span class="line"></span><br><span class="line">     Dog()&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">          System.out.println();</span><br><span class="line">          <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行这段main程序，会输出什么？<br>答案是<br>eafjicbhig<br>icbhig</p><p>为了方便大家一个个细节去理解， 我换一种方式去提问。</p><h2><span id="q-shi-me-shi-hou-hui-jin-xing-jing-tai-bian-liang-de-fu-zhi-he-jing-tai-dai-ma-kuai-de-zhi-xing">Q： 什么时候会进行静态变量的赋值和静态代码块的执行？</span><a href="#q-shi-me-shi-hou-hui-jin-xing-jing-tai-bian-liang-de-fu-zhi-he-jing-tai-dai-ma-kuai-de-zhi-xing" class="header-anchor">#</a></h2><p>A：?</p><ul><li>第一次创建某个类或者某个类的子类的实例</li><li>访问类的静态变量、调用类的静态方法</li><li>使用反射方法forName</li><li>调用主类的main方法(本例子的第一次静态初始化其实属于这个情况，调用了Dog的main方法）<br>注： 类初始化只会进行一次， 上面任何一种情况触发后，之后都不会再引起类初始化操作。</li></ul><hr><h2><span id="q-chu-shi-hua-mou-ge-zi-lei-shi-ye-hui-dui-fu-lei-zuo-jing-tai-chu-shi-hua-ma-shun-xu-ni">Q：初始化某个子类时，也会对父类做静态初始化吗？顺序呢？</span><a href="#q-chu-shi-hua-mou-ge-zi-lei-shi-ye-hui-dui-fu-lei-zuo-jing-tai-chu-shi-hua-ma-shun-xu-ni" class="header-anchor">#</a></h2><p>A：如果父类之前没有被静态初始化过，那就会进行， 且顺序是先父类再子类。 后面的非静态成员初始化也是如此。<br>所以会先输出eafj。</p><hr><h2><span id="q-wei-shi-me-fu-lei-de-method-bu-hui-bei-zi-lei-de-method-chong-xie">Q： 为什么父类的method不会被子类的method重写？</span><a href="#q-wei-shi-me-fu-lei-de-method-bu-hui-bei-zi-lei-de-method-chong-xie" class="header-anchor">#</a></h2><p>A： 静态方法是类方法，不会被子类重写。毕竟类方法调用时，是必定带上类名的。</p><hr><h2><span id="q-wei-shi-me-di-yi-ge-shu-chu-de-shi-e-er-bu-shi-a">Q： 为什么第一个输出的是e而不是a？</span><a href="#q-wei-shi-me-di-yi-ge-shu-chu-de-shi-e-er-bu-shi-a" class="header-anchor">#</a></h2><p>A： 因为类变量的显示赋值代码和静态代码块代码按照从上到下的顺序执行。<br>Animal的静态初始化过程中，method的调用在static代码块之前，所以先输出e再输出a。<br>而Dog的静态初始化过程中，method的调用在static代码块之后，因此先输出f，再输出j</p><hr><h2><span id="q-mei-you-zai-zi-lei-de-gou-zao-qi-zhong-diao-yong-super-shi-ye-hui-jin-xing-fu-lei-dui-xiang-de-shi-li-hua-ma">Q： 没有在子类的构造器中调用super()时，也会进行父类对象的实例化吗？</span><a href="#q-mei-you-zai-zi-lei-de-gou-zao-qi-zhong-diao-yong-super-shi-ye-hui-jin-xing-fu-lei-dui-xiang-de-shi-li-hua-ma" class="header-anchor">#</a></h2><p>A： 会的。会自动调用父类的默认构造器。 ?super()主要是用于需要调用父类的特殊构造器的情况。<br>因此会先进行Animal的对象实例化，再进行Dog的对象实例化</p><hr><h2><span id="q-gou-zao-fang-fa-cheng-yuan-xian-shi-fu-zhi-fei-jing-tai-dai-ma-kuai-ji-shu-chu-c-he-h-de-na-2-ju-de-shun-xu-shi-shi-me">Q： 构造方法、成员显示赋值、非静态代码块（即输出c和h的那2句）的顺序是什么？</span><a href="#q-gou-zao-fang-fa-cheng-yuan-xian-shi-fu-zhi-fei-jing-tai-dai-ma-kuai-ji-shu-chu-c-he-h-de-na-2-ju-de-shun-xu-shi-shi-me" class="header-anchor">#</a></h2><p>A：?</p><ol><li>成员显示赋值、非静态代码块（按定义顺序）</li><li>构造方法<br>因此Animal的实例化过程输出icb（如果对输出i有疑问，见下面一题）<br>接着进行Dog的实例化，输出hig</li></ol><hr><h2><span id="q-wei-shi-me-animal-shi-li-hua-shi-i-test-zhong-shu-chu-de-shi-i-er-bu-shi-d">Q： 为什么Animal实例化时， i=test()中输出的是i而不是d？</span><a href="#q-wei-shi-me-animal-shi-li-hua-shi-i-test-zhong-shu-chu-de-shi-i-er-bu-shi-d" class="header-anchor">#</a></h2><p>A:因为你真正创建的是Dog子类，Dog子类中的test()方法由于签名和父类test方法一致，因此test方法被重写了。?<br>此时即使在父类中调用，也还是用使用子类Dog的方法。除非你new的是Animal。</p><hr><h2><span id="q-tong-shang-ti-ru-guo-test-fang-fa-du-shi-private-huo-zhe-final-shu-xing-na-me-shang-ti-de-qing-kuang-hui-you-bian-hua-ma">Q： 同上题， 如果test方法都是private或者final属性， 那么上题的情况会有变化吗？？</span><a href="#q-tong-shang-ti-ru-guo-test-fang-fa-du-shi-private-huo-zhe-final-shu-xing-na-me-shang-ti-de-qing-kuang-hui-you-bian-hua-ma" class="header-anchor">#</a></h2><p>A: ?<br>因为private和final方法是不能被子类重写的。<br>所以Animal实例化时，i=test输出d。</p><hr><p>总结一下顺序：</p><ol><li>父类静态变量显式赋值、父类静态代码块（按定义顺序）</li><li>子类静态变量显式赋值、子类静态代码块（按定义顺序）</li><li>父类非静态变量显式赋值（父类实例成员变量）、父类非静态代码块（按定义顺序）</li><li>父类构造函数</li><li>子类非静态变量（子类实例成员变量）、子类非静态代码块（按定义顺序）</li><li>子类构造函数。</li></ol><h1><span id="lei-jia-zai-guo-cheng">类加载过程</span><a href="#lei-jia-zai-guo-cheng" class="header-anchor">#</a></h1><h2><span id="q-lei-jia-zai-de-3-ge-bi-jing-jie-duan-shi">Q：类加载的3个必经阶段是：</span><a href="#q-lei-jia-zai-de-3-ge-bi-jing-jie-duan-shi" class="header-anchor">#</a></h2><p>A：</p><ol><li>加载（类加载器读取二进制字节流，生成java类对象）</li><li>链接（验证，分配静态域初始零值）</li><li>初始化（前面的题目讲的其实就是初始化时的顺序）<br>更详细的如下：<br><img src="/images/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image(142).png" alt="image.png"></li></ol><h1><span id="bei-dong-yin-yong-zhong-he-lei-jing-tai-chu-shi-hua-de-guan-xi">被动引用中和类静态初始化的关系</span><a href="#bei-dong-yin-yong-zhong-he-lei-jing-tai-chu-shi-hua-de-guan-xi" class="header-anchor">#</a></h1><h2><span id="q-new-mou-ge-lei-de-shu-zu-shi-hui-yin-fa-lei-chu-shi-hua-ma">Q：new某个类的数组时，会引发类初始化吗？</span><a href="#q-new-mou-ge-lei-de-shu-zu-shi-hui-yin-fa-lei-chu-shi-hua-ma" class="header-anchor">#</a></h2><p>像下面输出什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">static</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ?</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          A[] as = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">5</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：?<br>new数组时，不会引发类初始化。<br>什么都不输出。</p><hr><h2><span id="q-yin-yong-lei-de-final-jing-tai-zi-duan-hui-yin-fa-lei-chu-shi-hua-ma">Q：引用类的final静态字段，会引发类初始化吗？</span><a href="#q-yin-yong-lei-de-final-jing-tai-zi-duan-hui-yin-fa-lei-chu-shi-hua-ma" class="header-anchor">#</a></h2><p>像下面输出什么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">static</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;A.a=&quot;</span> + A.a);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A： 不会引发。<br>不会输出initA。 去掉final就会引发了。<br>（注意这里必须是基本类型常量， 如果是引用类型产量，则会引发类初始化）</p><hr><h2><span id="q-zi-lei-yin-yong-liao-fu-lei-de-jing-tai-cheng-yuan-ci-shi-zi-lei-hui-zuo-lei-chu-shi-hua-ma">Q：子类引用了父类的静态成员，此时子类会做类初始化嘛？</span><a href="#q-zi-lei-yin-yong-liao-fu-lei-de-jing-tai-cheng-yuan-ci-shi-zi-lei-hui-zuo-lei-chu-shi-hua-ma" class="header-anchor">#</a></h2><p>如下会输出什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">static</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">static</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initB&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;B.a=&quot;</span> + B.a);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：?<br>子类不会初始化。<br>打印initA,却不会打印initB。</p><h1><span id="lei-jia-zai-qi">类加载器</span><a href="#lei-jia-zai-qi" class="header-anchor">#</a></h1><h2><span id="shuang-qin-wei-pai">双亲委派</span><a href="#shuang-qin-wei-pai" class="header-anchor">#</a></h2><hr><p>类加载时的双亲委派模型，不知道能怎么出题。。。反正就记得优先去父类加载器中看类是否能加载。<br>就贴个图吧<br><img src="/images/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image(143).png" alt="image.png"></p><hr><p>注意，上面的图有问题。<br>Bootsrap不是ClassLoader的子类，他是C++编写的。<br>而ExtClassLoader和AppClassLoader都是继承自ClassLoader的</p><h2><span id="q-java-zhong-shi-fou-lei-he-jie-kou-de-bao-ming-he-ming-zi-xiang-tong-na-me-jiu-yi-ding-shi-tong-yi-ge-lei-huo-zhe-jie-kou">Q：java中， 是否类和接口的包名和名字相同， 那么就一定是同一个类或者接口？</span><a href="#q-java-zhong-shi-fou-lei-he-jie-kou-de-bao-ming-he-ming-zi-xiang-tong-na-me-jiu-yi-ding-shi-tong-yi-ge-lei-huo-zhe-jie-kou" class="header-anchor">#</a></h2><p>A：<br>错误。<br>1个jvm中， 类和接口的唯一性由 <em><strong>二进制名称以及它的定义类加载器</strong></em> 共同决定。<br>因此2个不同的加载器加载出来相同的类或接口时， 实际上是不同的。</p><hr><h2><span id="q-jiang-yi-xia-classloader-yuan-li-yi-ji-ying-yong-chang-jing">Q: 讲一下ClassLoader原理， 以及应用场景</span><a href="#q-jiang-yi-xia-classloader-yuan-li-yi-ji-ying-yong-chang-jing" class="header-anchor">#</a></h2><p>loaderClass  双亲加载实现（这里会体现先去父亲找，再自己）<br>findClass  如何根据名字，生成1个class（内部需要借助defineClass）<br>defineClass  通过这个方法生成1个class类</p><p>例如需要根据类目，从某个远端网络加载获取这个类， 而且获取过来的时候还是加密的，需要在findClass里对byte数组做解密并加载。</p><p><a href="https://blog.csdn.net/zzti_erlie/article/details/82757435">https://blog.csdn.net/zzti_erlie/article/details/82757435</a></p><hr><h2><span id="q-ru-guo-zai-ni-xiang-mu-zhong-jian-yi-ge-java-lang-string-de-lei-na-xi-tong-zhong-yong-de-string-lei-shi-ni-ding-yi-de-string-lei-huan-shi-yuan-sheng-api-zhong-de-string-lei">Q:如果在你项目中建一个java.lang.String的类，那系统中用的String类是你定义的String类，还是原生api中的String类？</span><a href="#q-ru-guo-zai-ni-xiang-mu-zhong-jian-yi-ge-java-lang-string-de-lei-na-xi-tong-zhong-yong-de-string-lei-shi-ni-ding-yi-de-string-lei-huan-shi-yuan-sheng-api-zhong-de-string-lei" class="header-anchor">#</a></h2><p>A:<br>用的原生api中的string， 因为双亲委派机制。</p><hr><h2><span id="q-wei-shi-me-yao-yong-shuang-qin-wei-tuo-you-shi-me-hao-chu">Q ： 为什么要用双亲委托，有什么好处？</span><a href="#q-wei-shi-me-yao-yong-shuang-qin-wei-tuo-you-shi-me-hao-chu" class="header-anchor">#</a></h2><p>A:</p><ul><li>对于任意一个类，都需要由加载它的&quot;类加载器和这个类本身&quot;来一同确立其在Java虚拟机中的唯一性。那么双亲委派可以保证顺序加载的特性。</li><li>核心类的安全。Object类如果不使用双亲委派原则的话，那么A创建的Object对象就可能和B创建的Object是不一样的。不使用双亲委派原则无法保证一些java核心类库的唯一性</li><li>例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</li></ul><hr><h2><span id="q-na-wo-ru-guo-zhen-de-you-xu-qiu-bu-xiang-yong-shuang-qin-de-ji-zhi-ni">Q: 那我如果真的有需求， 不想用双亲的机制呢？</span><a href="#q-na-wo-ru-guo-zhen-de-you-xu-qiu-bu-xiang-yong-shuang-qin-de-ji-zhi-ni" class="header-anchor">#</a></h2><p>A:<br>按照上 面说的， 自己重写类加载的loaderClass就行了， 不走双亲机制的那块代码。</p><hr><h2><span id="q-shu-zu-lei-shi-zen-me-zuo-jia-zai-de">Q: 数组类是怎么做加载的？</span><a href="#q-shu-zu-lei-shi-zen-me-zuo-jia-zai-de" class="header-anchor">#</a></h2><p>A:<br>数组类是由AppClassLoader加载的。<br>数组类打印className时，前面会有个[Lxx类<br>二维数组就是[[Lxxx类<br>数组类的父类型是Object</p><p>注意此时加载的是数组类，而数组类里面的对象是不会做自动加载的<br>因此xx类的静态代码并不会被直接调用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和接口基本概念</title>
      <link href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#xiu-shi-fu">修饰符</a><ul><li><a href="#q-ge-xiu-shi-fu-suo-dai-biao-de-ke-jian-xing">Q： 各修饰符所代表的可见性？</a></li><li><a href="#q-wai-bu-lei-ke-yi-yong-private-huo-zhe-protect-xiu-shi-ma">Q： 外部类可以用private或者protect修饰吗？</a></li><li><a href="#jie-shi-yi-xia-final-de-zuo-yong">解释以下final的作用</a><ul><li><a href="#q-final-cheng-yuan">Q： final 成员？</a></li><li><a href="#q-final-can-shu">Q： final 参数？</a></li><li><a href="#q-final-fang-fa">Q： final方法</a></li><li><a href="#q-final-lei">Q： final类</a></li></ul></li><li><a href="#q-final-ju-bu-bian-liang-ke-yi-zuo-wei-fei-final-de-can-shu-chuan-ru-ma-hui-bian-yi-bao-cuo-ma">Q:final局部变量可以作为非final的参数传入吗？会编译报错吗？</a></li></ul></li><li><a href="#lei">类</a><ul><li><a href="#q-chong-zai-he-chong-xie-de-qu-bie">Q： 重载和重写的区别？</a></li><li><a href="#q-ru-guo-zi-lei-chong-xie-liao-fu-lei-zhong-de-fang-fa-na-me-zi-lei-zhong-huan-neng-diao-yong-fu-lei-zhong-de-tong-ming-fang-fa-ma">Q: 如果子类重写了父类中的方法， 那么子类中还能调用父类中的同名方法吗？</a></li><li><a href="#q-zen-yang-neng-bi-mian-zi-lei-zai-chong-xie-fu-lei-de-fang-fa-bu-xiao-xin-nong-cheng-liao-chong-zai">Q: 怎样能避免子类在重写父类的方法，不小心弄成了重载？</a></li><li><a href="#q-fu-lei-de-cheng-yuan-bian-liang-neng-bei-chong-xie-fu-gai-ma">Q：父类的成员变量能被重写/覆盖嘛？</a></li><li><a href="#q-nei-bu-lei-shi-sha-nei-bu-lei-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q：内部类是啥，内部类能访问外部类的成员吗？</a></li><li><a href="#q-a-zhong-you-1-ge-nei-bu-lei-c-a-de-zi-lei-b-zhong-ye-you-1-ge-nei-bu-lei-c-b-zhong-de-c-hui-fu-gai-a-zhong-de-c-ma">Q： A中有1个内部类C， A的子类B中也有1个内部类C， B中的C会覆盖A中的C吗？</a></li><li><a href="#q-ke-yi-zai-nei-bu-lei-zhong-ding-yi-jing-tai-cheng-yuan-ma">Q：可以在内部类中定义静态成员吗？</a></li><li><a href="#q-ni-ming-lei-shi-sha-ni-ming-lei-neng-fang-wen-wai-mian-de-bian-liang-huo-zhe-dui-xiang-ma">Q： 匿名类是啥， 匿名类能访问外面的变量或者对象吗？</a></li><li><a href="#q-qian-tao-lei-shi-sha-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q: 嵌套类是啥，能访问外部类的成员吗？</a></li></ul></li><li><a href="#jie-kou">接口</a><ul><li><a href="#q-jie-kou-zhong-ru-guo-yao-ding-yi-cheng-yuan-bian-liang-na-cheng-yuan-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中如果要定义成员变量，那成员的默认修饰符是什么？</a></li><li><a href="#q-jie-kou-zhong-ge-fang-fa-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中各方法的默认修饰符是什么？</a></li><li><a href="#q-jie-kou-zhong-ke-yi-ding-yi-shi-xian-ju-ti-fang-fa-ma">Q： 接口中可以定义实现具体方法嘛？</a></li></ul></li><li><a href="#mei-ju">枚举</a><ul><li><a href="#q-enum-ke-yi-bei-ji-cheng-ma">Q： enum可以被继承吗？</a></li><li><a href="#q-switch-enum-shi-xu-yao-jia-default-ma">Q： switch(enum)时需要加default吗？</a></li><li><a href="#q-enum-ji-lei-li-shi-xian-liao-values-fang-fa-ma">Q： Enum基类里实现了values()方法吗？</a></li></ul></li><li><a href="#jing-tai-fen-pai-he-dong-tai-fen-pai">静态分派和动态分派</a><ul><li><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派？</a></li><li><a href="#q-she-ji-ru-xia-ge-chong-bu-tong-shu-ju-lei-xing-de-jing-tai-fen-pai-ru-he-ying-dui">Q： 涉及如下各种不同数据类型的静态分派如何应对？</a></li><li><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派：</a></li><li><a href="#q-jing-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai-dong-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai">Q：静态分派属于单分派还是多分派？动态分派属于单分派还是多分派？</a></li><li><a href="#q-lei-fang-fa-zai-class-wen-jian-zhong-shi-shi-me-yang-de-shi-fu-hao-yin-yong-huan-shi-zhi-jie-yin-yong">Q：类方法在class文件中是什么样的? 是符号引用还是直接引用？</a></li><li><a href="#q-shi-me-shi-hou-fang-fa-de-fu-hao-yin-yong-hui-zhuan-wei-shi-ji-fang-fa-qu-zhong-de-zhi-jie-yin-yong">Q：什么时候方法的符号引用会转为实际方法区中的直接引用？</a></li><li><a href="#q-dong-tai-fen-pai-ji-duo-tai-xu-ni-ji-li-shi-zen-me-que-ding-diao-yong-na-ge-fang-fa-de">Q：动态分派(即多态）， 虚拟机里是怎么确定调用哪个方法的？</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="xiu-shi-fu">修饰符</span><a href="#xiu-shi-fu" class="header-anchor">#</a></h1><h2><span id="q-ge-xiu-shi-fu-suo-dai-biao-de-ke-jian-xing">Q： 各修饰符所代表的可见性？</span><a href="#q-ge-xiu-shi-fu-suo-dai-biao-de-ke-jian-xing" class="header-anchor">#</a></h2><p>public: 可被所有使用<br>protect： 只能被自己和子类使用，或者同一个包路径<br>private： 只能自己使用，儿子都不行<br>不加修饰符即default权限： 包访问权限，和他在同一包内的类都可以访问他，包外的则都不能访问</p><hr><h2><span id="q-wai-bu-lei-ke-yi-yong-private-huo-zhe-protect-xiu-shi-ma">Q： 外部类可以用private或者protect修饰吗？</span><a href="#q-wai-bu-lei-ke-yi-yong-private-huo-zhe-protect-xiu-shi-ma" class="header-anchor">#</a></h2><p>A： 不能，只能用public或者包访问权限。 内部类可以。</p><hr><h2><span id="jie-shi-yi-xia-final-de-zuo-yong">解释以下final的作用</span><a href="#jie-shi-yi-xia-final-de-zuo-yong" class="header-anchor">#</a></h2><h3><span id="q-final-cheng-yuan">Q： final 成员？</span><a href="#q-final-cheng-yuan" class="header-anchor">#</a></h3><p>A： 如果是基本类型，则指值不能被改变。 如果是对象，指对象的引用不可改变，但是引用处的内容可改变。</p><hr><p>编译器会要求final成员必须初始化或者构造器里赋值，且后续不能再主动赋值。</p><h3><span id="q-final-can-shu">Q： final 参数？</span><a href="#q-final-can-shu" class="header-anchor">#</a></h3><p>A： 参数不可变，只能读不能修改，同上</p><hr><h3><span id="q-final-fang-fa">Q： final方法</span><a href="#q-final-fang-fa" class="header-anchor">#</a></h3><p>A： 方法不能被子类重写。</p><hr><h3><span id="q-final-lei">Q： final类</span><a href="#q-final-lei" class="header-anchor">#</a></h3><p>A： 该类不能被继承。</p><hr><h2><span id="q-final-ju-bu-bian-liang-ke-yi-zuo-wei-fei-final-de-can-shu-chuan-ru-ma-hui-bian-yi-bao-cuo-ma">Q:final局部变量可以作为非final的参数传入吗？会编译报错吗？</span><a href="#q-final-ju-bu-bian-liang-ke-yi-zuo-wei-fei-final-de-can-shu-chuan-ru-ma-hui-bian-yi-bao-cuo-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">changeA(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeA</span><span class="params">(A a)</span> &#123;</span><br><span class="line"><span class="comment">// change A...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>可以作为非final的参数传入，不会编译报错。</p><hr><h1><span id="lei">类</span><a href="#lei" class="header-anchor">#</a></h1><h2><span id="q-chong-zai-he-chong-xie-de-qu-bie">Q： 重载和重写的区别？</span><a href="#q-chong-zai-he-chong-xie-de-qu-bie" class="header-anchor">#</a></h2><p>A：<br>重载是方法名相同，参数不同。<br>重写是方法参数等都一致的情况下重写父类的方法。</p><hr><h2><span id="q-ru-guo-zi-lei-chong-xie-liao-fu-lei-zhong-de-fang-fa-na-me-zi-lei-zhong-huan-neng-diao-yong-fu-lei-zhong-de-tong-ming-fang-fa-ma">Q: 如果子类重写了父类中的方法， 那么子类中还能调用父类中的同名方法吗？</span><a href="#q-ru-guo-zi-lei-chong-xie-liao-fu-lei-zhong-de-fang-fa-na-me-zi-lei-zhong-huan-neng-diao-yong-fu-lei-zhong-de-tong-ming-fang-fa-ma" class="header-anchor">#</a></h2><p>A: 可以，super.xxx即可（C++中不可以调用父类中的同名重载方法)。</p><hr><h2><span id="q-zen-yang-neng-bi-mian-zi-lei-zai-chong-xie-fu-lei-de-fang-fa-bu-xiao-xin-nong-cheng-liao-chong-zai">Q: 怎样能避免子类在重写父类的方法，不小心弄成了重载？</span><a href="#q-zen-yang-neng-bi-mian-zi-lei-zai-chong-xie-fu-lei-de-fang-fa-bu-xiao-xin-nong-cheng-liao-chong-zai" class="header-anchor">#</a></h2><p>（即你想重写父类的f(int), 却不小心写成了f(int，int)，导致调用f(int)时还是调用了父类的f ，怎么能避免这种失误？）<br>A: 加个@Override关键字即可，原文解释：<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/69e4b13dbfbb57476c7f29e7a5b00ee24db66776.png" alt="69e4b13dbfbb57476c7f29e7a5b00ee24db66776"></p><hr><h2><span id="q-fu-lei-de-cheng-yuan-bian-liang-neng-bei-chong-xie-fu-gai-ma">Q：父类的成员变量能被重写/覆盖嘛？</span><a href="#q-fu-lei-de-cheng-yuan-bian-liang-neng-bei-chong-xie-fu-gai-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main&#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">   System.out.println(a.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>输出A。<br>注意成员变量不具有多态性，因此你定义的是A，赋值的是B， 那么输出的依旧是A里的成员。<br>如果是被重写的方法的话，那会用B里的方法。</p><hr><h2><span id="q-nei-bu-lei-shi-sha-nei-bu-lei-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q：内部类是啥，内部类能访问外部类的成员吗？</span><a href="#q-nei-bu-lei-shi-sha-nei-bu-lei-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma" class="header-anchor">#</a></h2><p>A：<br>内部类概念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B就是A的内部类,B能访问A的所有成员</p><hr><h2><span id="q-a-zhong-you-1-ge-nei-bu-lei-c-a-de-zi-lei-b-zhong-ye-you-1-ge-nei-bu-lei-c-b-zhong-de-c-hui-fu-gai-a-zhong-de-c-ma">Q： A中有1个内部类C， A的子类B中也有1个内部类C， B中的C会覆盖A中的C吗？</span><a href="#q-a-zhong-you-1-ge-nei-bu-lei-c-a-de-zi-lei-b-zhong-ye-you-1-ge-nei-bu-lei-c-b-zhong-de-c-hui-fu-gai-a-zhong-de-c-ma" class="header-anchor">#</a></h2><p>A： 不会， 因为使用时是通过B.C或者A.C去调用的，存在命名空间的关系。</p><hr><h2><span id="q-ke-yi-zai-nei-bu-lei-zhong-ding-yi-jing-tai-cheng-yuan-ma">Q：可以在内部类中定义静态成员吗？</span><a href="#q-ke-yi-zai-nei-bu-lei-zhong-ding-yi-jing-tai-cheng-yuan-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>不可以。 除非在class B前面加static变为静态类</p><hr><h2><span id="q-ni-ming-lei-shi-sha-ni-ming-lei-neng-fang-wen-wai-mian-de-bian-liang-huo-zhe-dui-xiang-ma">Q： 匿名类是啥， 匿名类能访问外面的变量或者对象吗？</span><a href="#q-ni-ming-lei-shi-sha-ni-ming-lei-neng-fang-wen-wai-mian-de-bian-liang-huo-zhe-dui-xiang-ma" class="header-anchor">#</a></h2><p>A： 匿名类概念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>(构造参数)&#123;</span><br><span class="line">   &#123;构造器内容&#125;</span><br><span class="line">   类定义 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类如果要用外面的对象， 外面的对象必须要定义为final。</p><hr><h2><span id="q-qian-tao-lei-shi-sha-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q: 嵌套类是啥，能访问外部类的成员吗？</span><a href="#q-qian-tao-lei-shi-sha-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma" class="header-anchor">#</a></h2><p>A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> sa;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B只能访问A中的静态成员sa, 而不能访问a。</p><h1><span id="jie-kou">接口</span><a href="#jie-kou" class="header-anchor">#</a></h1><p>类是单继承，接口可以多继承</p><hr><h2><span id="q-jie-kou-zhong-ru-guo-yao-ding-yi-cheng-yuan-bian-liang-na-cheng-yuan-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中如果要定义成员变量，那成员的默认修饰符是什么？</span><a href="#q-jie-kou-zhong-ru-guo-yao-ding-yi-cheng-yuan-bian-liang-na-cheng-yuan-de-mo-ren-xiu-shi-fu-shi-shi-me" class="header-anchor">#</a></h2><p>A： public static final</p><hr><h2><span id="q-jie-kou-zhong-ge-fang-fa-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中各方法的默认修饰符是什么？</span><a href="#q-jie-kou-zhong-ge-fang-fa-de-mo-ren-xiu-shi-fu-shi-shi-me" class="header-anchor">#</a></h2><p>A： public abstract</p><hr><h2><span id="q-jie-kou-zhong-ke-yi-ding-yi-shi-xian-ju-ti-fang-fa-ma">Q： 接口中可以定义实现具体方法嘛？</span><a href="#q-jie-kou-zhong-ke-yi-ding-yi-shi-xian-ju-ti-fang-fa-ma" class="header-anchor">#</a></h2><p>A：<br>java8以上版本可以。<br>引入了default关键字，在接口中用default关键字修饰接口，就可以在接口中去实现这个接口了。</p><hr><h1><span id="mei-ju">枚举</span><a href="#mei-ju" class="header-anchor">#</a></h1><h2><span id="q-enum-ke-yi-bei-ji-cheng-ma">Q： enum可以被继承吗？</span><a href="#q-enum-ke-yi-bei-ji-cheng-ma" class="header-anchor">#</a></h2><p>像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> extend B&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： 不可以。enum标识符本身被编译器处理过，自身就继承自Enum类，而java不支持多重继承。但支持实现接口<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6ae62ac7072c2bf308db83b832dafce68ed2d5cf.png" alt="6ae62ac7072c2bf308db83b832dafce68ed2d5cf"></p><hr><h2><span id="q-switch-enum-shi-xu-yao-jia-default-ma">Q： switch(enum)时需要加default吗？</span><a href="#q-switch-enum-shi-xu-yao-jia-default-ma" class="header-anchor">#</a></h2><p>A： 可以不需要。</p><hr><h2><span id="q-enum-ji-lei-li-shi-xian-liao-values-fang-fa-ma">Q： Enum基类里实现了values()方法吗？</span><a href="#q-enum-ji-lei-li-shi-xian-liao-values-fang-fa-ma" class="header-anchor">#</a></h2><p>A： 没有实现， values方法是编译器加的。因此从List<enum>里取出的对象，是不能调用values（）的。<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3f7ff65142341ef0771067edc7698616e0ce6154.png" alt="3f7ff65142341ef0771067edc7698616e0ce6154"></enum></p><hr><p>Q：enum里的枚举的默认修饰符默认是？<br>A：static final</p><hr><h1><span id="jing-tai-fen-pai-he-dong-tai-fen-pai">静态分派和动态分派</span><a href="#jing-tai-fen-pai-he-dong-tai-fen-pai" class="header-anchor">#</a></h1><h2><span id="q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派？</span><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();          <span class="comment">//静态分派</span></span><br><span class="line">       print(father);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Father father)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;this is father&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Son son)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;this is son&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>A:<br>输出this is father。 属于静态分派。<br>静态分派概念： 编译器就能确定调用哪个方法。<br>这里2个print属于重载方法，通过输入参数的定义类型即立刻确定调用哪个<br>静态分派取决于静态类型</p><p>静态类型概念： 编译期写在java文件里能马上看到的类型<br>例如 A a = Factory.create(args);<br>那么左边的A就是静态类型， 而右边的类型取决于运行期，是不确定的。</p><hr><h2><span id="q-she-ji-ru-xia-ge-chong-bu-tong-shu-ju-lei-xing-de-jing-tai-fen-pai-ru-he-ying-dui">Q： 涉及如下各种不同数据类型的静态分派如何应对？</span><a href="#q-she-ji-ru-xia-ge-chong-bu-tong-shu-ju-lei-xing-de-jing-tai-fen-pai-ru-he-ying-dui" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overload</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">char</span> arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Object arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 测试代码</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出什么？<br>A：<br>输出 hello char<br>因为‘a’是一个char类型数据（即静态类型是char），所以会选择参数类型为char的重载方法。<br>若注释掉sayHello(char arg)方法，那么会输出 hello int<br>因为‘a’除了可代表字符串，还可代表数字97。因此当没有最合适的sayHello(char arg)方式进行重载时，会选择第二合适（第二优先级）的方法重载，即sayHello(int arg)</p><p>总结：当没有最合适的方法进行重载时，会选优先级第二高的的方法进行重载，如此类推。<br>优先级顺序为：char&gt;int&gt;long&gt;float&gt;double&gt;Character（自动装箱）&gt;Serializable（接口，从下往上）&gt;Object（父类1，父类2，从下往上）&gt;…<br>其中…为变长参数，将其视为一个数组元素。变长参数的重载优先级最低。<br>因为 char 转型到 byte 或 short 的过程是不安全的，所以不会选择参数类型为byte 或 short的方法进行重载，故优先级列表里也没有。</p><p><strong>上面可以看到，重载时选择方法的优先级顺序是基本类型-&gt;高精度类型-&gt;包装类-&gt;接口（从下往上）-&gt;父类（从下往上）-&gt;可变参数</strong></p><hr><h2><span id="q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派：</span><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();       </span><br><span class="line">     father.name();    </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>A：<br>输出son，属于动态分派。运行的时候根据所指向的具体对象才确定调用哪个方法</p><hr><h2><span id="q-jing-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai-dong-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai">Q：静态分派属于单分派还是多分派？动态分派属于单分派还是多分派？</span><a href="#q-jing-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai-dong-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai" class="header-anchor">#</a></h2><p>A：<br>静态分派是多分派。<br>动态分派是单分派。<br>多分派概念: 分派时即要考虑调用者的类型，也要考虑参数类型。<br>而单分派只考虑调用者的类型。</p><p>动态分派原理：</p><hr><h2><span id="q-lei-fang-fa-zai-class-wen-jian-zhong-shi-shi-me-yang-de-shi-fu-hao-yin-yong-huan-shi-zhi-jie-yin-yong">Q：类方法在class文件中是什么样的? 是符号引用还是直接引用？</span><a href="#q-lei-fang-fa-zai-class-wen-jian-zhong-shi-shi-me-yang-de-shi-fu-hao-yin-yong-huan-shi-zhi-jie-yin-yong" class="header-anchor">#</a></h2><p>A：<br>class文件中， 所定义的方法 都只是符号引用，即只是个符号，知道方法名字， 但是不知道方法的实际指令运行地址<br>符号引用如下，不过我这展示的时class_info即类的符号引用， 实际上还会有method_info即方法的引用：<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ce8d672af3d63cb9a8b56a2325651bea772d8970.png" alt="ce8d672af3d63cb9a8b56a2325651bea772d8970"></p><p>然后方法在class文件中时这样存放的， 先是一个method_count数量，接着再存储方法。<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/03f7962c02a331c88824602f1052a7f866ae687f.png" alt="03f7962c02a331c88824602f1052a7f866ae687f"></p><p>此时是不知道方法的指令地址的。 除非从符号引用转为直接引用。</p><hr><h2><span id="q-shi-me-shi-hou-fang-fa-de-fu-hao-yin-yong-hui-zhuan-wei-shi-ji-fang-fa-qu-zhong-de-zhi-jie-yin-yong">Q：什么时候方法的符号引用会转为实际方法区中的直接引用？</span><a href="#q-shi-me-shi-hou-fang-fa-de-fu-hao-yin-yong-hui-zhuan-wei-shi-ji-fang-fa-qu-zhong-de-zhi-jie-yin-yong" class="header-anchor">#</a></h2><p>A：<br>类加载的解析阶段会把满足「编译期可知，运行期不可变」的方法的符号引用替换为指向方法区的直接引用，不会延迟到运行时再去完成。</p><ul><li>构造</li><li>私有</li><li>静态<br>final修饰<br>上面这4类方法在类加载时都会被识别出来，并转成 指向方法区的直接引用（即能知道了指令地址了，而不是字节码的符号）</li></ul><hr><h2><span id="q-dong-tai-fen-pai-ji-duo-tai-xu-ni-ji-li-shi-zen-me-que-ding-diao-yong-na-ge-fang-fa-de">Q：动态分派(即多态）， 虚拟机里是怎么确定调用哪个方法的？</span><a href="#q-dong-tai-fen-pai-ji-duo-tai-xu-ni-ji-li-shi-zen-me-que-ding-diao-yong-na-ge-fang-fa-de" class="header-anchor">#</a></h2><p>如下， 他怎么确定调用的是Son实现的do， 还是father实现的do？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">f.<span class="keyword">do</span>(a);</span><br></pre></td></tr></table></figure><p>A：<br>首先，通过静态分派， 他知道一定选用的是f(int a) 这个方法，但是他不知道选用哪个类的do(int a)方法。<br><a href="http://xn--f-376av22dj41a1vi.do">而你执行f.do</a>(a)时， 操作数栈上会存放一个对象引用</p><p><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/4b25d6e4706cecfa8651680fb19d2603db8113e0.png" alt="4b25d6e4706cecfa8651680fb19d2603db8113e0"></p><p>那么执行f方法的虚拟机指令就会通过这个对象引用，找到他的实际类型的class<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ee1b41d71b7c0e897c34fa86deb79fb9a242cad8.png" alt="ee1b41d71b7c0e897c34fa86deb79fb9a242cad8"></p><p>他会在这个实际类中查找是否有实现这个方法，具体看class文件中有没有这个方法的定义<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1dc65dc0cda6cf91e650f456d2351518465e6ebb.png" alt="1dc65dc0cda6cf91e650f456d2351518465e6ebb"></p><p>如果没有找到，他就去父类找，父类的关系class文件中就可以知道<br><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/95427daaed60924141c46d48a56efb4f66c97691.png" alt="95427daaed60924141c46d48a56efb4f66c97691"></p><p>如果父类没有，就接着往上找，直到找到实现了的。</p><p><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/0cd5d2504cda48e554facaded21ffbf82b8af33a.png" alt="0cd5d2504cda48e554facaded21ffbf82b8af33a"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java流程控制语句</title>
      <link href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#q-break-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: break后面加一个label标签是做什么的？像下面这样：</a></li><li><a href="#q-continue-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: continue后面加一个label标签是做什么的？像下面这样：</a></li><li><a href="#q-switch-de-default-xian-jing-1-yi-xia-shu-chu-shi-me">Q: switch的default陷阱1，以下输出什么</a></li><li><a href="#q-case-hou-mian-ke-yi-gen-bian-liang-ma">Q:case后面可以跟变量吗？</a></li><li><a href="#q-switch-de-default-xian-jing-2-yi-xia-shu-chu-shi-me">Q: switch的default陷阱2，以下输出什么</a></li><li><a href="#q-switch-neng-shi-bie-na-xie-lei-xing">Q: switch(） 能识别哪些类型？</a></li><li><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1： finally能通过修改变量，来更新return的变量值吗</a></li><li><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</a></li><li><a href="#q-for-each-he-for-index-na-ge-kuai-jiu-shi-for-num-nums-he-for-int-i-0-i-n-i">Q： for-each和for-index 哪个快？（就是for(num:nums)和for(int i=0;i&lt;n;i++)）</a></li><li><a href="#q-shi-me-shi-hou-mei-fa-yong-for-each-dai-ti-for-index">Q： 什么时候没法用for-each代替for-index？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h2><span id="q-break-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: break后面加一个label标签是做什么的？像下面这样：</span><a href="#q-break-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABC：</span><br><span class="line"><span class="keyword">while</span>(t++&lt;<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">break</span> ABC;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: break+label标签 是用于从内部退出多层循环的， 上面的例子就是直接从for内部直接退出到while的外面了。</p><hr><h2><span id="q-continue-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: continue后面加一个label标签是做什么的？像下面这样：</span><a href="#q-continue-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABC：</span><br><span class="line"><span class="keyword">while</span>(t++&lt;<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">continue</span> ABC;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 直接contine到ABC的后面，即用于contine到最外层循环， 即走到while(t++&lt;5)那边继续走</p><hr><h2><span id="q-switch-de-default-xian-jing-1-yi-xia-shu-chu-shi-me">Q: switch的default陷阱1，以下输出什么</span><a href="#q-switch-de-default-xian-jing-1-yi-xia-shu-chu-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： 输出&quot;0 1&quot;， default都是最后再匹配的。</p><hr><h2><span id="q-case-hou-mian-ke-yi-gen-bian-liang-ma">Q:case后面可以跟变量吗？</span><a href="#q-case-hou-mian-ke-yi-gen-bian-liang-ma" class="header-anchor">#</a></h2><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> a:</span><br><span class="line"><span class="keyword">case</span> b:</span><br></pre></td></tr></table></figure><p>这样子<br>A：<br>不可以，case后面只能跟常量。</p><hr><h2><span id="q-switch-de-default-xian-jing-2-yi-xia-shu-chu-shi-me">Q: switch的default陷阱2，以下输出什么</span><a href="#q-switch-de-default-xian-jing-2-yi-xia-shu-chu-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A： 输出&quot;default 0 1&quot;， 匹配到default之后，如果没有break还是会一直往下走。</p><hr><h2><span id="q-switch-neng-shi-bie-na-xie-lei-xing">Q: switch(） 能识别哪些类型？</span><a href="#q-switch-neng-shi-bie-na-xie-lei-xing" class="header-anchor">#</a></h2><p>A：<br>JDK1.0-1.4 数据类型接受 byte short int char<br>JDK1.5 ? ? ? 数据类型接受 byte short int char enum(枚举)<br>JDK1.7 ? ? ? 数据类型接受?byte short int char enum(枚举)，String 六种类型<br>PS： 上面提到的基本类型的包装类型也是支持的。</p><hr><h2><span id="q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1： finally能通过修改变量，来更新return的变量值吗</span><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      a=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 不能， f返回1。<br>（PS：注意下如果是a引用的话，不能改变返回的a的引用， 但是可以改变a的引用里的属性）<br>原理见：流程控制语句知识点里的java原理</p><hr><h2><span id="q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</span><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：返回finally里的，返回2。</p><hr><h2><span id="q-for-each-he-for-index-na-ge-kuai-jiu-shi-for-num-nums-he-for-int-i-0-i-lt-n-i">Q： for-each和for-index 哪个快？（就是for(num:nums)和for(int i=0;i&lt;n;i++)）</span><a href="#q-for-each-he-for-index-na-ge-kuai-jiu-shi-for-num-nums-he-for-int-i-0-i-lt-n-i" class="header-anchor">#</a></h2><p>A： 和场景有关。引用评论区2个小伙伴给的信息：</p><p>若实现了RandomAccess接口，那么使用for-index是优于for-each的吧</p><p>for-each 比 for-index 快，是不是可以这样考虑：<br>for-each 是通过内部的迭代器进行遍历的，类似于索引；<br>for-index 是通过 index 计算偏移量的方式遍历。<br>—— 这样一来：<br>对 ArrayList 这样的连续结构来说，for-each 和 for-index 的效率应该不相上下；<br>而对 LinkedList 这样的链式列表，for-each 的索引优势就体现出来了。</p><hr><h2><span id="q-shi-me-shi-hou-mei-fa-yong-for-each-dai-ti-for-index">Q： 什么时候没法用for-each代替for-index？</span><a href="#q-shi-me-shi-hou-mei-fa-yong-for-each-dai-ti-for-index" class="header-anchor">#</a></h2><p>A: 需要往迭代器中插入元素或者删除元素时。（这会破坏迭代器结构）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础数据类型</title>
      <link href="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shu-ju-lei-xing">数据类型</a><ul><li><a href="#q-java-zhong-shu-ju-lei-xing-da-xiao-hui-he-ping-tai-shi-32-wei-64-wei-xiang-guan-ma">Q：java中数据类型大小会和平台是32位、64位相关吗？</a></li><li><a href="#q-java-zhong-jie-xi-shu-ju-shi-xu-yao-kao-lu-chu-li-qi-de-da-xiao-duan-wen-ti-ma-ji-0x1234-de-12-shi-fang-zai-gao-di-zhi-huan-shi-di-di-zhi">Q：java中解析数据时，需要考虑处理器的大小端问题吗？（即0x1234的12是放在高地址还是低地址）</a></li><li><a href="#q-java-zhong-short-int-long-de-zi-jie-fen-bie-shi-duo-shao">Q：java中short、int 、long的字节分别是多少？</a></li><li><a href="#q-float-double-shi-duo-shao-zi-jie">Q： float、double是多少字节？</a></li><li><a href="#q-java-zhong-byte-char-shi-duo-shao-zi-jie-c-zhong-char-shi-duo-shao-zi-jie">Q: java中byte、char是多少字节？C++中char是多少字节？</a></li><li><a href="#q-java-zhong-boolean-lei-xing-de-da-xiao">Q： java中boolean类型的大小？</a></li><li><a href="#q-bu-ke-bian-lei-xing-you-na-ji-chong">Q： 不可变类型有哪几种？</a></li><li><a href="#q-lei-li-de-cheng-yuan-ru-guo-shi-ji-ben-shu-ju-lei-xing-na-me-hui-zi-dong-chu-shi-hua-ma-chu-shi-hua-cheng-shi-me">Q：类里的成员如果是基本数据类型， 那么会自动初始化吗？初始化成什么？</a></li><li><a href="#q-java-zhong-ju-bu-bian-liang-mei-chu-shi-hua-hui-bao-cuo-ma">Q： java中局部变量没初始化，会报错吗？</a></li><li><a href="#q-bu-er-lei-xing-ke-yi-qiang-zhi-zhuan-hua-cheng-qi-ta-lei-xing-ma">Q： 布尔类型可以强制转化成其他类型吗？</a></li><li><a href="#q-shi-me-shi-hou-bu-neng-yin-shi-zhuan-hua">Q： 什么时候不能隐式转化？</a></li><li><a href="#q-8-chong-yuan-shi-shu-ju-lei-xing-de-lei-xing-you-xian-ji-pai-xu-shi">Q: 8种原始数据类型的类型优先级排序是？</a></li><li><a href="#q-xia-mian-na-ge-shi-cuo-wu-de">Q:下面哪个是错误的？</a></li><li><a href="#q-float-f-1-1-you-cuo-ma">Q：float f = 1.1;有错吗？</a></li><li><a href="#q-bu-er-lei-xing-ke-yi-zuo-jia-jian-cheng-chu-ma">Q： 布尔类型可以做加减乘除吗？</a></li><li><a href="#q-zheng-xing-bao-zhuang-lei-xing-de-bi-jiao-xia-mian-shu-chu-sha">Q：整型包装类型的比较，下面输出啥？</a></li><li><a href="#q-java-zhong-na-2-ge-lei-ke-yi-zhi-chi-ren-yi-jing-du-de-zheng-shu-he-ren-yi-jing-du-de-fu-dian-shu">Q： java中哪2个类可以支持任意精度的整数 和任意精度的浮点数?</a></li><li><a href="#q-java-de-shu-zu-yi-ding-xu-yao-wo-men-shou-dong-chu-shi-hua-ma">Q: java的数组一定需要我们手动初始化吗？</a></li><li><a href="#q-java-zhi-chi-c-li-de-yun-suan-fu-chong-zai-ma">Q：java支持C++里的运算符重载吗？</a></li><li><a href="#q-if-a-b-ke-yi-ma">Q： if(a=b) 可以吗？</a></li><li><a href="#q-fu-dian-shu-xiang-deng-de-bi-jiao-fang-shi">Q： 浮点数相等的比较方式</a></li><li><a href="#q-shang-mian-zhe-xian-xiang-de-yuan-yin-ni-liao-jie-ma-cong-fu-dian-shu-de-yuan-li-jiang-yi-xia-shi-shi">Q： 上面这现象的原因，你了解吗，从浮点数的原理讲一下试试</a></li><li><a href="#q-xia-mian-de-shu-zu-sheng-ming-na-ji-ge-shi-dui-de">Q:下面的数组声明哪几个是对的？</a></li></ul></li><li><a href="#zi-fu-chuan">字符串</a><ul><li><a href="#q-stringbuffer-he-stringbuilder-de-qu-bie">Q： StringBuffer和StringBuilder的区别：</a></li><li><a href="#q-string-s-123-456-789-dui-yu-zhe-chong-jing-tai-de-pin-jie-yong-stringbuffer-qu-pin-jie-bi-yong-string-qu-pin-jie-yao-kuai-dui-ma">Q：String s = “123”+“456”+“789”;对于这种静态的拼接，用StringBuffer去拼接比用String去拼接要快，对吗？</a></li><li><a href="#q-xia-mian-9-chong-zi-fu-chuan-pin-jie-xiang-deng-de-bi-jiao-shu-chu-shi-me-jie-guo-wei-shi-me">Q：下面9种字符串拼接相等的比较，输出什么结果？为什么？</a></li></ul></li><li><a href="#ke-bian-can-shu">可变参数</a><ul><li><a href="#q-fang-fa-chong-zai-shi-ru-he-xuan-ze-ke-bian-can-shu-he-gu-ding-can-shu-xiang-xia-mian-shu-chu-sha">Q： 方法重载时，如何选择可变参数和固定参数？像下面输出啥：</a></li><li><a href="#can-kao-zi-liao">参考资料：</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="shu-ju-lei-xing">数据类型</span><a href="#shu-ju-lei-xing" class="header-anchor">#</a></h1><h2><span id="q-java-zhong-shu-ju-lei-xing-da-xiao-hui-he-ping-tai-shi-32-wei-64-wei-xiang-guan-ma">Q：java中数据类型大小会和平台是32位、64位相关吗？</span><a href="#q-java-zhong-shu-ju-lei-xing-da-xiao-hui-he-ping-tai-shi-32-wei-64-wei-xiang-guan-ma" class="header-anchor">#</a></h2><p>A：不相关，虚拟机原因平台兼容</p><hr><h2><span id="q-java-zhong-jie-xi-shu-ju-shi-xu-yao-kao-lu-chu-li-qi-de-da-xiao-duan-wen-ti-ma-ji-0x1234-de-12-shi-fang-zai-gao-di-zhi-huan-shi-di-di-zhi">Q：java中解析数据时，需要考虑处理器的大小端问题吗？（即0x1234的12是放在高地址还是低地址）</span><a href="#q-java-zhong-jie-xi-shu-ju-shi-xu-yao-kao-lu-chu-li-qi-de-da-xiao-duan-wen-ti-ma-ji-0x1234-de-12-shi-fang-zai-gao-di-zhi-huan-shi-di-di-zhi" class="header-anchor">#</a></h2><p>A：不需要。java由于虚拟机的关系,屏蔽了大小端问题,需要知道的话可用 ByteOrder.nativeOrder() 查询。在操作ByteBuffer中，也可以使用 ByteBuffer.order() 进行设置：。</p><hr><h2><span id="q-java-zhong-short-int-long-de-zi-jie-fen-bie-shi-duo-shao">Q：java中short、int 、long的字节分别是多少？</span><a href="#q-java-zhong-short-int-long-de-zi-jie-fen-bie-shi-duo-shao" class="header-anchor">#</a></h2><p>A：2、4、8</p><hr><h2><span id="q-float-double-shi-duo-shao-zi-jie">Q： float、double是多少字节？</span><a href="#q-float-double-shi-duo-shao-zi-jie" class="header-anchor">#</a></h2><p>A：4、8</p><hr><h2><span id="q-java-zhong-byte-char-shi-duo-shao-zi-jie-c-zhong-char-shi-duo-shao-zi-jie">Q: java中byte、char是多少字节？C++中char是多少字节？</span><a href="#q-java-zhong-byte-char-shi-duo-shao-zi-jie-c-zhong-char-shi-duo-shao-zi-jie" class="header-anchor">#</a></h2><p>A : java中是1和2， C++中char是1</p><hr><h2><span id="q-java-zhong-boolean-lei-xing-de-da-xiao">Q： java中boolean类型的大小？</span><a href="#q-java-zhong-boolean-lei-xing-de-da-xiao" class="header-anchor">#</a></h2><p>A： bool类型无空间大小（来自java编程思想）<br>根据http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html官方文档的描述：</p><p>boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.</p><p>布尔类型：布尔数据类型只有两个可能的值：真和假。使用此数据类型为跟踪真/假条件的简单标记。这种数据类型就表示这一点信息，但是它的“大小”并不是精确定义的。</p><p>贴一下书中关于布尔数据类型的描述：<br><img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1613726452952078147.png" alt="img"></p><hr><h2><span id="q-bu-ke-bian-lei-xing-you-na-ji-chong">Q： 不可变类型有哪几种？</span><a href="#q-bu-ke-bian-lei-xing-you-na-ji-chong" class="header-anchor">#</a></h2><p>A： short、int、long、float、double、byte、char、boolean的?包装类型， 以及String，这9种属于不可变类型。（这只是部分，还有其他的不可变类）</p><p>不可变类型概念：里面的值的内容变了，对应的内存地址也会变化。</p><hr><h2><span id="q-lei-li-de-cheng-yuan-ru-guo-shi-ji-ben-shu-ju-lei-xing-na-me-hui-zi-dong-chu-shi-hua-ma-chu-shi-hua-cheng-shi-me">Q：类里的成员如果是基本数据类型， 那么会自动初始化吗？初始化成什么？</span><a href="#q-lei-li-de-cheng-yuan-ru-guo-shi-ji-ben-shu-ju-lei-xing-na-me-hui-zi-dong-chu-shi-hua-ma-chu-shi-hua-cheng-shi-me" class="header-anchor">#</a></h2><p>A： 会， 初始化为0或者false。</p><hr><h2><span id="q-java-zhong-ju-bu-bian-liang-mei-chu-shi-hua-hui-bao-cuo-ma">Q： java中局部变量没初始化，会报错吗？</span><a href="#q-java-zhong-ju-bu-bian-liang-mei-chu-shi-hua-hui-bao-cuo-ma" class="header-anchor">#</a></h2><p>A： 会</p><hr><h2><span id="q-bu-er-lei-xing-ke-yi-qiang-zhi-zhuan-hua-cheng-qi-ta-lei-xing-ma">Q： 布尔类型可以强制转化成其他类型吗？</span><a href="#q-bu-er-lei-xing-ke-yi-qiang-zhi-zhuan-hua-cheng-qi-ta-lei-xing-ma" class="header-anchor">#</a></h2><p>A ： 不能。 boolean b = 1或者boolean b = “true” 是不可以的</p><hr><h2><span id="q-shi-me-shi-hou-bu-neng-yin-shi-zhuan-hua">Q： 什么时候不能隐式转化？</span><a href="#q-shi-me-shi-hou-bu-neng-yin-shi-zhuan-hua" class="header-anchor">#</a></h2><p>A： 如果会丢失精度，则不能隐式转化，比如long转int或者double转long这种。 编译器会强制我们使用强制转化</p><hr><h2><span id="q-8-chong-yuan-shi-shu-ju-lei-xing-de-lei-xing-you-xian-ji-pai-xu-shi">Q: 8种原始数据类型的类型优先级排序是？</span><a href="#q-8-chong-yuan-shi-shu-ju-lei-xing-de-lei-xing-you-xian-ji-pai-xu-shi" class="header-anchor">#</a></h2><p>A：<br>（byte/short/char)&lt;int&lt;long&lt;float&lt;double<br>即隐式转换都是从低往高转。</p><hr><h2><span id="q-xia-mian-na-ge-shi-cuo-wu-de">Q:下面哪个是错误的？</span><a href="#q-xia-mian-na-ge-shi-cuo-wu-de" class="header-anchor">#</a></h2><p><img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1613726121049038816.png" alt="img"><br>A：<br>B选项是错误的。<br>因为2个byte类型变量相加的时候，会自动转换成int类型，右边的int类型赋值给short类型便会报错。（好冷的知识）</p><hr><h2><span id="q-float-f-1-1-you-cuo-ma">Q：float f = 1.1;有错吗？</span><a href="#q-float-f-1-1-you-cuo-ma" class="header-anchor">#</a></h2><p>A：<br>float浮点后面要加f。加f就代表是float类型，否则就是double类型浮点。</p><p>float f = 1.1f;<br>double d1 = 1.1;</p><hr><h2><span id="q-bu-er-lei-xing-ke-yi-zuo-jia-jian-cheng-chu-ma">Q： 布尔类型可以做加减乘除吗？</span><a href="#q-bu-er-lei-xing-ke-yi-zuo-jia-jian-cheng-chu-ma" class="header-anchor">#</a></h2><p>A ： 不能</p><p>Q： Integer N = 0; int n = N; 这时候会发生什么？<br>A： 自动拆包</p><hr><h2><span id="q-zheng-xing-bao-zhuang-lei-xing-de-bi-jiao-xia-mian-shu-chu-sha">Q：整型包装类型的比较，下面输出啥？</span><a href="#q-zheng-xing-bao-zhuang-lei-xing-de-bi-jiao-xia-mian-shu-chu-sha" class="header-anchor">#</a></h2><p>Integer num1 = 128,num2 = 128;<br>System.out.println(num1==num2);</p><p>A：<br>输出false。<br>值的范围在-128~127的时候Integer可以直接用==比较大小，但是超出这个范围时，==就不管用了，要用equals。<br>大致原因是在那个范围，Integer的对象会直接用缓存对象，所以地址都相同。<br>不在那个范围，Integer对象会新生成1个对象，所以地址不同。</p><p>另一个注意点： “==” 对于对象来说，比较的是地址。</p><hr><h2><span id="q-java-zhong-na-2-ge-lei-ke-yi-zhi-chi-ren-yi-jing-du-de-zheng-shu-he-ren-yi-jing-du-de-fu-dian-shu">Q： java中哪2个类可以支持任意精度的整数 和任意精度的浮点数?</span><a href="#q-java-zhong-na-2-ge-lei-ke-yi-zhi-chi-ren-yi-jing-du-de-zheng-shu-he-ren-yi-jing-du-de-fu-dian-shu" class="header-anchor">#</a></h2><p>A: BigInteger和BigDecimal</p><p>这2个也属于不可变类。</p><hr><h2><span id="q-java-de-shu-zu-yi-ding-xu-yao-wo-men-shou-dong-chu-shi-hua-ma">Q: java的数组一定需要我们手动初始化吗？</span><a href="#q-java-de-shu-zu-yi-ding-xu-yao-wo-men-shou-dong-chu-shi-hua-ma" class="header-anchor">#</a></h2><p>A： 不需要，数组元素会自动初始化为null或者0或者false。</p><hr><h2><span id="q-java-zhi-chi-c-li-de-yun-suan-fu-chong-zai-ma">Q：java支持C++里的运算符重载吗？</span><a href="#q-java-zhi-chi-c-li-de-yun-suan-fu-chong-zai-ma" class="header-anchor">#</a></h2><p>A： 不支持</p><hr><h2><span id="q-if-a-b-ke-yi-ma">Q： if(a=b) 可以吗？</span><a href="#q-if-a-b-ke-yi-ma" class="header-anchor">#</a></h2><p>A： 不行，不能在条件表达式中放入赋值操作。除非a和b都是boolean类型。</p><hr><h2><span id="q-fu-dian-shu-xiang-deng-de-bi-jiao-fang-shi">Q： 浮点数相等的比较方式</span><a href="#q-fu-dian-shu-xiang-deng-de-bi-jiao-fang-shi" class="header-anchor">#</a></h2><p>A：<br>相等的话要像下面这样</p><p>if(Math.abs(a-b))&lt;1E-6F)</p><p>如果用浮点的a==b或者a!=b做while循环退出判断，可能会导致死循环</p><hr><h2><span id="q-shang-mian-zhe-xian-xiang-de-yuan-yin-ni-liao-jie-ma-cong-fu-dian-shu-de-yuan-li-jiang-yi-xia-shi-shi">Q： 上面这现象的原因，你了解吗，从浮点数的原理讲一下试试</span><a href="#q-shang-mian-zhe-xian-xiang-de-yuan-yin-ni-liao-jie-ma-cong-fu-dian-shu-de-yuan-li-jiang-yi-xia-shi-shi" class="header-anchor">#</a></h2><p>A:<br><img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3744d5b86b6e1010d046ea4b423e635c5bdc330f.png" alt="3744d5b86b6e1010d046ea4b423e635c5bdc330f"></p><ul><li>1.1用二进制表示为：1.000110…xxxx…(后面表示省略)<br>0.1 = 02(-1)+0<em>2(-2)+02(-3)+1</em>2(-4)+…</li><li>而double类型表示小数部分只有52位，当向后计算 52位后基数还不为0，那后面的部分只能舍弃，从这里可以看出float、double并不能准确表示每一位小数，对于有的小数只能无限趋向它。</li><li>在计算机 中加减成除运算实际上最后都要在计算机中转换成二进制的加运算，由此，当计算机运行System.out.println(2.00-1.10);<br>时会拿他们在计算机内存中的二进制表示计算，而1.10的二进制表示本身就不准确，所以会出现0.8999999999999999的结果。</li></ul><hr><h2><span id="q-xia-mian-de-shu-zu-sheng-ming-na-ji-ge-shi-dui-de">Q:下面的数组声明哪几个是对的？</span><a href="#q-xia-mian-de-shu-zu-sheng-ming-na-ji-ge-shi-dui-de" class="header-anchor">#</a></h2><p>A. char[] chr1 = new char[]{‘A’,‘B’,‘C’};<br>B. char[] chr2 = new char[3]{‘A’,‘B’,‘C’};<br>C. char[][] chr3 = new char[][10];<br>D. char[][] chr4 = new char[10][];<br>E. char[] chr5 = new char[3];</p><p>A：<br>ADE是对的。</p><h1><span id="zi-fu-chuan">字符串</span><a href="#zi-fu-chuan" class="header-anchor">#</a></h1><hr><h2><span id="q-stringbuffer-he-stringbuilder-de-qu-bie">Q： StringBuffer和StringBuilder的区别：</span><a href="#q-stringbuffer-he-stringbuilder-de-qu-bie" class="header-anchor">#</a></h2><p>A：<br>StringBuffer是线程安全的，但是慢<br>StringBuilder是线程不安全的（即可以多个线程同时读取他的内容），但是快。</p><hr><h2><span id="q-string-s-123-456-789-dui-yu-zhe-chong-jing-tai-de-pin-jie-yong-stringbuffer-qu-pin-jie-bi-yong-string-qu-pin-jie-yao-kuai-dui-ma">Q：String s = “123”+“456”+“789”;对于这种静态的拼接，用StringBuffer去拼接比用String去拼接要快，对吗？</span><a href="#q-string-s-123-456-789-dui-yu-zhe-chong-jing-tai-de-pin-jie-yong-stringbuffer-qu-pin-jie-bi-yong-string-qu-pin-jie-yao-kuai-dui-ma" class="header-anchor">#</a></h2><p>A：<br>错，反编译代码后，我们发现代码是<br>String s = “123456789”;<br>因为对于静态字符串的连接操作，Java在编译时会进行彻底的优化，将多个连接操作的字符串在编译时合成一个单独的长字符串。<br>因此要注意StringBuffer/Builder的适用场合： for循环中大量拼接字符串。<br>如果是静态的编译器就能感知到的拼接，不要盲目地去使用StirngBuffer/Builder<br>PS：</p><p>如果是字符串变量相加，会优化成StringBuilder做append<br>如果是常量字符串相加， 则会直接拼接<br>具体可以查看这篇博文，里面有展示这2 种情况的字节码。<br><a href="https://blog.csdn.net/weixin_34405557/article/details/89630362?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/weixin_34405557/article/details/89630362?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><hr><h2><span id="q-xia-mian-9-chong-zi-fu-chuan-pin-jie-xiang-deng-de-bi-jiao-shu-chu-shi-me-jie-guo-wei-shi-me">Q：下面9种字符串拼接相等的比较，输出什么结果？为什么？</span><a href="#q-xia-mian-9-chong-zi-fu-chuan-pin-jie-xiang-deng-de-bi-jiao-shu-chu-shi-me-jie-guo-wei-shi-me" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;Hel&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s5.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;H&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;ello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> s7 + s8;</span><br><span class="line"> </span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s4);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s6);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s9);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><p>A：<br>println(s1 == s2)输出 true<br>println(s1 == s3)输出 true<br>println(s1 == s4)输出 false<br>println(s4 == s5)输出 false<br>println(s1 == s6)输出 true<br>println(s1 == s9)输出 false</p><p>字符串的==操作比较的是引用地址。<br>如果是直接写死在代码里的常量字符串，则地址是固定的，都在常量池中。<br>写死的常量字符串拼接，依旧会作为常量放入常量池中。（常量池就是指，程序编译的时候，就已经知道了这个字符串）<br>如果是String类型的，则引用地址是堆中的string对象地址，而非常量池中地址。（因为程序编译的时候，string里的内容不一定是确定的，因此不可能会放到常量池中）<br>因此涉及string拼接的，都是和原先常量不等。s7和s8已经属于string对象，所以二者不属于常量拼接。<br>intern会试图把字符串放入常量池。</p><p>具体原因可见<br><a href="https://www.cnblogs.com/syp172654682/p/8082625.html">https://www.cnblogs.com/syp172654682/p/8082625.html</a></p><p>关于常量池，更多可以见：<br>原始数据类型强化学习之常量池</p><h1><span id="ke-bian-can-shu">可变参数</span><a href="#ke-bian-can-shu" class="header-anchor">#</a></h1><hr><h2><span id="q-fang-fa-chong-zai-shi-ru-he-xuan-ze-ke-bian-can-shu-he-gu-ding-can-shu-xiang-xia-mian-shu-chu-sha">Q： 方法重载时，如何选择可变参数和固定参数？像下面输出啥：</span><a href="#q-fang-fa-chong-zai-shi-ru-he-xuan-ze-ke-bian-can-shu-he-gu-ding-can-shu-xiang-xia-mian-shu-chu-sha" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> ...a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可变参数方法：&quot;</span>+Arrays.toString(a));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;固定长度 参数方法：&quot;</span>+a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：<br>输出固定长度参数方法。<br>原则:<br>如果重载方法中，固定参数方法能满足，优先用固定参数方法，不满足时再去选择可变参数方法。</p><hr><p><img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/662027daa06620610256ebc9a89705952ca01b0e.png" alt="662027daa06620610256ebc9a89705952ca01b0e"></p><h2><span id="can-kao-zi-liao">参考资料：</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h2><p><a href="https://www.cnblogs.com/syp172654682/p/8082625.html">https://www.cnblogs.com/syp172654682/p/8082625.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
          <category> java初级语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程高级应用和原理分析</title>
      <link href="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#executor-xian-cheng-chi-ying-yong-xiang-jie">Executor线程池应用详解</a><ul><li><a href="#corepoolsize-he-maximumpoolsize-can-shu-you-shi-me-qu-bie">corePoolSize和maximumPoolSize参数有什么区别？</a></li><li><a href="#keepalive-can-shu-shi-gan-ma-de">keepalive参数是干嘛的？</a></li><li><a href="#he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">核心线程可以被回收吗？（线程池没有被回收的情况下）</a></li><li><a href="#he-xin-xian-cheng-shu-she-zhi-duo-shao-zen-me-kao-lu">核心线程数设置多少，怎么考虑？</a></li><li><a href="#xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">线程池有哪三种队列策略？</a></li><li><a href="#xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</a></li><li><a href="#xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">线程池为什么需要阻塞队列？</a></li><li><a href="#wu-chong-chang-jian-de-executor-zi-dai-xian-cheng-chi">五种常见的Executor自带线程池</a><ul><li><a href="#newcachedthreadpool-huan-cun-xian-cheng-chi">newCachedThreadPool： 缓存线程池</a></li><li><a href="#newfixedthreadpool-ding-chang-xian-cheng-chi">newFixedThreadPool ：定长线程池</a></li><li><a href="#newscheduledthreadpool-ding-shi-qi-xian-cheng-chi">newScheduledThreadPool :定时器线程池</a></li><li><a href="#newsinglethreadexecutor-dan-xian-cheng-chi">newSingleThreadExecutor : 单线程池</a></li><li><a href="#newworkstealingpool-ji-cheng-zi-forkjoinpool-gong-zuo-mi-qu-xian-cheng-chi">newWorkStealingPool（继承自ForkJoinPool ）： 工作密取线程池</a></li></ul></li><li><a href="#submit-he-execute-fang-fa-qu-bie-shi-shi-me">submit和execute方法区别是什么？</a><ul><li><a href="#xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">线程池中， shutdown、 shutdownNow、awaitTermination的区别？</a></li></ul></li></ul></li><li><a href="#forkjoin-xian-cheng-chi">ForkJoin线程池</a><ul><li><a href="#forkjoin-he-xin-gai-nian">forkJoin核心概念</a></li><li><a href="#forkjoin-zhong-ge-ge-xian-cheng-shi-ru-he-huo-qu-na-xie-xiao-ren-wu-de-ni">forkJoin中各个线程是如何获取那些小任务的呢？</a></li><li><a href="#fork-shi-ju-ti-fa-sheng-liao-shi-me">fork时具体发生了什么？</a></li><li><a href="#join-shi-shi-me-han-yi-shi-me-shi-hou-zuo-de">join是什么含义？什么时候做的？</a></li><li><a href="#join-zhe-ge-zu-sai-guo-cheng-shi-zen-me-zuo-de-ru-guo-ba-xian-cheng-gua-qi-na-zhe-ge-xian-cheng-qi-bu-shi-wu-fa-gong-zuo-liao">join这个阻塞过程是怎么做的？如果把线程挂起，那这个线程岂不是无法工作了？</a></li><li><a href="#forkjoin-cun-fang-ren-wu-de-shi-hou-zen-me-bao-zheng-bu-hui-chu-xian-bing-fa-wen-ti-bi-ru-tong-shi-wang-dui-wei-cha-ru-de-hua">forkJoin存放任务的时候，怎么保证不会出现并发问题？比如同时往队尾插入的话</a></li><li><a href="#forkjoin-ying-yong-zai-na">forkJoin应用在哪？</a></li></ul></li><li><a href="#theadlocal-he-xin-yuan-li">TheadLocal核心原理</a><ul><li><a href="#threadlocal-de-chang-jian-shi-yong-chang-jing">ThreadLocal的常见使用场景？</a></li><li><a href="#threadlocal-he-synchronized-guan-jian-zi-de-qu-bie">ThreadLocal和Synchronized关键字的区别？</a></li><li><a href="#theadlocal-zai-mei-ge-xian-cheng-zhong-shi-yi-shi-me-xing-shi-cun-chu-de-yuan-li-shi-shi-me">TheadLocal在每个线程中是以什么形式存储的？ 原理是什么</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="executor-xian-cheng-chi-ying-yong-xiang-jie">Executor线程池应用详解</span><a href="#executor-xian-cheng-chi-ying-yong-xiang-jie" class="header-anchor">#</a></h1><h2><span id="corepoolsize-he-maximumpoolsize-can-shu-you-shi-me-qu-bie">corePoolSize和maximumPoolSize参数有什么区别？</span><a href="#corepoolsize-he-maximumpoolsize-can-shu-you-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A：<br>当提交新线程到池中时</p><ul><li>如果当前线程数 &lt; corePoolSize，则会创建新线程</li><li>如果当前线程数=corePoolSize，则新线程被塞进一个队列中等待。</li><li>如果队列也被塞满了，那么又会开始新建线程来运行任务，避免任务阻塞或者丢弃</li><li>如果队列满了的情况下， 线程总数超过了maxinumPoolSize，那么就抛异常或者阻塞（取决于队列性质）。</li></ul><hr><ul><li>调用prestartCoreThread()可提前开启一个空闲的核心线程</li><li>调用prestartAllCoreThreads()，可提前创建corePoolSize个核心线程。</li></ul><hr><h2><span id="keepalive-can-shu-shi-gan-ma-de">keepalive参数是干嘛的？</span><a href="#keepalive-can-shu-shi-gan-ma-de" class="header-anchor">#</a></h2><p>A：当线程数量在corePoolSize到maxinumPoolSize之间时， 如果有线程已跑完，且空闲时间超过keepalive时，则会被清除（注意只限于corePoolSize到maxinumPoolsize之间的线程）</p><hr><h2><span id="he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">核心线程可以被回收吗？（线程池没有被回收的情况下）</span><a href="#he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia" class="header-anchor">#</a></h2><p>A:<br>ThreadPoolExecutor有个allowCoreThreadTimeOut(boolean value)方法，可以设置是否在超期后做回收</p><hr><h2><span id="he-xin-xian-cheng-shu-she-zhi-duo-shao-zen-me-kao-lu">核心线程数设置多少，怎么考虑？</span><a href="#he-xin-xian-cheng-shu-she-zhi-duo-shao-zen-me-kao-lu" class="header-anchor">#</a></h2><p>A:<br>io密集型， 可以设置多一点， 因为多一个线程，他可能也没太占cpu，都是在等待IO。<br>如果是计算密集型，则要设置少一点，别把cpu搞满载了。</p><p>有超线程技术的话， 一般可以设置成2倍CPU数量的线程数</p><blockquote><blockquote><p>超线程技术把多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作</p></blockquote></blockquote><hr><h2><span id="xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">线程池有哪三种队列策略？</span><a href="#xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue" class="header-anchor">#</a></h2><p>A：</p><ol><li>握手队列<br>相当于不排队的队列。可能造成线程数量无限增长直到超过maxinumPoolSize（相当于corePoolSize没什么用了，只以maxinumPoolSize做上限）</li><li>无界队列<br>队列队长无限，即线程数量达到corePoolSize时，后面的线程只会在队列中等待。（相当于maxinumPoolSize没什么用了）<br>缺陷： 可能造成队列无限增长以至于OOM</li><li>有界队列</li></ol><hr><h2><span id="xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</span><a href="#xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue" class="header-anchor">#</a></h2><p>A：</p><ul><li>AbortPolicy 默认策略：直接抛出RejectedExecutionException异常</li><li>DiscardPolicy 丢弃策略： 直接丢了，什么错误也不报</li><li>DiscardOldestPolicy 丢弃队头策略： 即把最先入队的人从队头扔出去，再尝试让该任务进入队尾（队头任务内心：不公平。。。。）</li><li>CallerRunsPolicy 调用者处理策略： 交给调用者所在线程自己去跑任务（即谁调用的submit或者execute，他就自己去跑） <strong>注意这个策略会用的比较多</strong></li><li>也可以用实现自定义新的RejectedExecutionHandler</li></ul><hr><h2><span id="xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">线程池为什么需要阻塞队列？</span><a href="#xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie" class="header-anchor">#</a></h2><p>A:<br>线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。避免大量线程获取这个创建锁。</p><hr><h2><span id="wu-chong-chang-jian-de-executor-zi-dai-xian-cheng-chi">五种常见的Executor自带线程池</span><a href="#wu-chong-chang-jian-de-executor-zi-dai-xian-cheng-chi" class="header-anchor">#</a></h2><p>有以下五种Executor提供的线程池，注意记忆一下他们的用途，就能理解内部的原理了。</p><ul><li><h3><span id="newcachedthreadpool-huan-cun-xian-cheng-chi">newCachedThreadPool： 缓存线程池</span><a href="#newcachedthreadpool-huan-cun-xian-cheng-chi" class="header-anchor">#</a></h3><p>corePoolSize=0, maxinumPoolSize=+∞，队列长度=0 ，<br>因此线程数量会在corePoolSize到maxinumPoolSize之间一直灵活缓存和变动， 且不存在队列等待的情况，一来任务我就创建，用完了会释放。<br><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1619147438780044960.png" alt="image.png"></p></li><li><h3><span id="newfixedthreadpool-ding-chang-xian-cheng-chi">newFixedThreadPool ：定长线程池</span><a href="#newfixedthreadpool-ding-chang-xian-cheng-chi" class="header-anchor">#</a></h3><p>corePoolSize= maxinumPoolSize=构造参数值， 队列长度=+∞。<br>因此不存在线程不够时扩充的情况</p></li><li><h3><span id="newscheduledthreadpool-ding-shi-qi-xian-cheng-chi">newScheduledThreadPool :定时器线程池</span><a href="#newscheduledthreadpool-ding-shi-qi-xian-cheng-chi" class="header-anchor">#</a></h3><p>提交定时任务用的，构造参数里会带定时器的间隔和单位。 其他和FixedThreadPool相同，属于定长线程池。</p></li><li><h3><span id="newsinglethreadexecutor-dan-xian-cheng-chi">newSingleThreadExecutor : 单线程池</span><a href="#newsinglethreadexecutor-dan-xian-cheng-chi" class="header-anchor">#</a></h3><p>corePoolSize=maxinumPoolSize=1， 队列长度=+∞<br>只会跑一个任务， 所以其他的任务都会在队列中等待，因此会严格按照FIFO执行</p></li><li><h3><span id="newworkstealingpool-ji-cheng-zi-forkjoinpool-gong-zuo-mi-qu-xian-cheng-chi">newWorkStealingPool（继承自ForkJoinPool ）： 工作密取线程池</span><a href="#newworkstealingpool-ji-cheng-zi-forkjoinpool-gong-zuo-mi-qu-xian-cheng-chi" class="header-anchor">#</a></h3></li></ul><p>如果你的任务执行时间很长，并且里面的任务运行并行跑的，那么他会把你的线程任务再细分到其他的线程来分治。这种特点在于可以在任务队列的两头取任务</p><hr><h2><span id="submit-he-execute-fang-fa-qu-bie-shi-shi-me">submit和execute方法区别是什么？</span><a href="#submit-he-execute-fang-fa-qu-bie-shi-shi-me" class="header-anchor">#</a></h2><p>A:</p><ul><li>execute只能接收Runnable类型的任务，而submit除了Runnable，还能接收Callable（Callable类型任务支持返回值）</li><li>execute方法返回void，  submit方法返回FutureTask。</li><li>异常方面， submit方法因为返回了futureTask对象，而当进行future.get()时，会把线程中的异常抛出，因此调用者可以方便地处理异常。（如果是execute，只能用内部捕捉或者设置catchHandler）</li></ul><hr><h3><span id="xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">线程池中， shutdown、 shutdownNow、awaitTermination的区别？</span><a href="#xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie" class="header-anchor">#</a></h3><p>A：</p><ul><li>shutdown: 停止接收新任务，等待所有池中已存在任务完成（ <em><strong>包括等待队列中的线程</strong></em> ）。异步方法，即调用后马上返回。</li><li>shutdownNow: 停止接收新任务，并 <em><strong>停止所有正执行的task</strong></em>，返回还在队列中的task列表 。</li><li>awaitTermination： <em><strong>仅仅是一个判断方法</strong></em>，判断当前线程池任务是否全部结束。一般用在shutdown后面，因为shutdown是异步方法，你需要知道什么时候才真正结束。</li></ul><h1><span id="forkjoin-xian-cheng-chi">ForkJoin线程池</span><a href="#forkjoin-xian-cheng-chi" class="header-anchor">#</a></h1><h2><span id="forkjoin-he-xin-gai-nian">forkJoin核心概念</span><a href="#forkjoin-he-xin-gai-nian" class="header-anchor">#</a></h2><p>ForkJoin线程池在常规的java书籍里还是提到比较少的，毕竟是java8引入的产物。</p><p>首先这里简单解释一下forkJoin的运作原理， 本质上有点像归并计算。</p><ol><li>他会将提交大任务按照一定规则拆解（fork）成多个小任务</li><li>当任务小到一定程度时，就会执行计算</li><li>执行完成时会和其他的小任务进行合并（join）， 逐步将所有小结果合成一个大结果。<br><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361412728070823-1660063481962.png" alt="image.png"></li></ol><p>可以看这个forkJoinTask的实现伪代码，即如果想使用forkJoin并发执行任务，需要自己把任务继承RecursiveTask，作为forkJoin池的submit对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;任务参数&gt; &#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReckonTask</span><span class="params">(任务参数)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> File <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(根据任务参数判断任务是否足够小) &#123;</span><br><span class="line">        计算，返回</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       拆分成子任务<span class="number">1</span>和子任务<span class="number">2</span> </span><br><span class="line">        任务<span class="number">1.</span>fork();</span><br><span class="line">        任务<span class="number">2.</span>fork();</span><br><span class="line">        结果<span class="number">1</span> = 任务<span class="number">1.</span>join();</span><br><span class="line">        结果<span class="number">2</span> = 任务<span class="number">2.</span>join();</span><br><span class="line">        返回结果<span class="number">1</span>+结果<span class="number">2</span>；</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实际上整个forkjoin的细节非常多，这里我通过给自己提好几个问题，来逐步理解forkJoin的原理，</p><hr><h2><span id="forkjoin-zhong-ge-ge-xian-cheng-shi-ru-he-huo-qu-na-xie-xiao-ren-wu-de-ni">forkJoin中各个线程是如何获取那些小任务的呢？</span><a href="#forkjoin-zhong-ge-ge-xian-cheng-shi-ru-he-huo-qu-na-xie-xiao-ren-wu-de-ni" class="header-anchor">#</a></h2><p>A:<br>他是通过工作密取的方式获取。（java并发那本书里提到过工作密取workSteal，原来是用在这了）</p><ul><li>假设我们给forkJoin设置3个工作线程，那么就会有3个工作队列， 注意，这个队列是双端队列。</li><li>每当执行任务时，如果不满足小任务的条件，他会fork出2个子任务，并push进自己的工作队列中。</li><li>每个工作线程不断取自己队头的任务执行。</li><li>关键点：如果自己队列里没有数据，则会从其他队列的队尾取数据。</li></ul><hr><h2><span id="fork-shi-ju-ti-fa-sheng-liao-shi-me">fork时具体发生了什么？</span><a href="#fork-shi-ju-ti-fa-sheng-liao-shi-me" class="header-anchor">#</a></h2><p>A:<br>是一个异步的操作， 就是向当前线程队列中添加这个fork出来任务，能放进去的话就返回，不会等待。<br>注意，默认fork出的任务是先默认给自己的。 当自己做不完时，才可能被别人取走！<br><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361429766064686-1660063481975.png" alt="image.png"></p><hr><h2><span id="join-shi-shi-me-han-yi-shi-me-shi-hou-zuo-de">join是什么含义？什么时候做的？</span><a href="#join-shi-shi-me-han-yi-shi-me-shi-hou-zuo-de" class="header-anchor">#</a></h2><p>A:<br>见实现forkJoin任务接口时的代码：<br><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361436926002588-1660063481980.png" alt="image.png"></p><p>可以看到时每次fork完之后， 通过join，来获取子task的结果，获取到之后，再合并计算，返回结果。</p><hr><h2><span id="join-zhe-ge-zu-sai-guo-cheng-shi-zen-me-zuo-de-ru-guo-ba-xian-cheng-gua-qi-na-zhe-ge-xian-cheng-qi-bu-shi-wu-fa-gong-zuo-liao">join这个阻塞过程是怎么做的？如果把线程挂起，那这个线程岂不是无法工作了？</span><a href="#join-zhe-ge-zu-sai-guo-cheng-shi-zen-me-zuo-de-ru-guo-ba-xian-cheng-gua-qi-na-zhe-ge-xian-cheng-qi-bu-shi-wu-fa-gong-zuo-liao" class="header-anchor">#</a></h2><p>A:</p><p>首先，之前fork时，新的子任务已经被放入队列了。<br>每个子任务都有一个任务状态。<br>当调用该子任务的join时， 会循环判断他的状态</p><p>如果这个子任务状态未完成， 则从自身队列或其他人的队列中取出新的任务执行，因此进入了下一层的exec()操作。<br>如果发现子任务状态更新为了完成（这个更新动作可能是自己线程完成的，也可能是别的线程完成的，反正这个任务的状态实现了同步和可见）， 则将结果返回给上层。<br>因此join的本质是一个递归的过程， 任务没完成的话，他就取其他任务继续递归往下执行。</p><p>更详细的可以看这个链接<a href="https://www.cnblogs.com/yougewe/p/14943418.html">fork+join过程详细解读</a></p><hr><h2><span id="forkjoin-cun-fang-ren-wu-de-shi-hou-zen-me-bao-zheng-bu-hui-chu-xian-bing-fa-wen-ti-bi-ru-tong-shi-wang-dui-wei-cha-ru-de-hua">forkJoin存放任务的时候，怎么保证不会出现并发问题？比如同时往队尾插入的话</span><a href="#forkjoin-cun-fang-ren-wu-de-shi-hou-zen-me-bao-zheng-bu-hui-chu-xian-bing-fa-wen-ti-bi-ru-tong-shi-wang-dui-wei-cha-ru-de-hua" class="header-anchor">#</a></h2><p>A:</p><ul><li>n个工作线程是通过数组存放的（即有一个工作线程数组）</li><li>sun.misc.Unsafe操作类直接基于操作系统控制层在硬件层面上进行原子操作，它是ForkJoinPool高效性能的一大保证，类似的编程思路还体现在java.util.concurrent包中相当规模的类功能实现中。<br><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361445964033773-1660063481982.png" alt="image.png"></li></ul><hr><h2><span id="forkjoin-ying-yong-zai-na">forkJoin应用在哪？</span><a href="#forkjoin-ying-yong-zai-na" class="header-anchor">#</a></h2><p>A:<br>java8 stream的parallel并发功能就是基于forkJoin做的， parallelStream实现的forkJoin拆解任务和执行任务的接口， 默认用机器所有CPU数量的forkJoin线程池。<br>如果需要限制线程数量，可以用<br>new forkJoin(线程数).submit(()-&gt;(list.stream().parallel().map()…)); 即可</p><p>关于java8和forkJoin究竟是如何配合的，可以看这个链接：<br><a href="https://www.cnblogs.com/Dorae/p/7779246.html">源码级别学习java8并行流执行原理</a><br><a href="https://www.cnblogs.com/Dorae/p/7779246.html">https://www.cnblogs.com/Dorae/p/7779246.html</a></p><h1><span id="theadlocal-he-xin-yuan-li">TheadLocal核心原理</span><a href="#theadlocal-he-xin-yuan-li" class="header-anchor">#</a></h1><hr><h2><span id="threadlocal-de-chang-jian-shi-yong-chang-jing">ThreadLocal的常见使用场景？</span><a href="#threadlocal-de-chang-jian-shi-yong-chang-jing" class="header-anchor">#</a></h2><p>每个线程中需要维护1个不同的副本， 但这个副本可能是某一个时刻一起塞入每个线程的， 只不过之后该副本的变化 不再受其他线程的影响。</p><p>常见场景有连接器管理模块connectorManager， 每个线程持有的connect变量是单独使用的，不会互相影响或者需要加锁。原因就是将其作为副本放入每个线程，当线程启动连接或者关闭时，不影响其他线程里的getConnect方法。</p><hr><h2><span id="threadlocal-he-synchronized-guan-jian-zi-de-qu-bie">ThreadLocal和Synchronized关键字的区别？</span><a href="#threadlocal-he-synchronized-guan-jian-zi-de-qu-bie" class="header-anchor">#</a></h2><p>A：<br>Synchronized是用时间的消耗，来换取数据同步以及互不冲突<br>ThreadLocal则是用空间的消耗，来换取数据之间互不冲突（不涉及同步）</p><hr><h2><span id="theadlocal-zai-mei-ge-xian-cheng-zhong-shi-yi-shi-me-xing-shi-cun-chu-de-yuan-li-shi-shi-me">TheadLocal在每个线程中是以什么形式存储的？ 原理是什么</span><a href="#theadlocal-zai-mei-ge-xian-cheng-zhong-shi-yi-shi-me-xing-shi-cun-chu-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h2><p>这篇文章讲解ThreadLocal源码讲解的蛮好的：<br><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html">Java并发编程：深入剖析</a></p><p>看完后用我自己的话总结一下就是：</p><ol><li><p>在某个线程中调用 某threadlocal.set(value)时， 其实就是在该线程中新建了1个threalocalMap， 然后把threadLocal作为键，value作为值，放进本线程的threalocalMap中。</p></li><li><p>当在线程中调用threadlocal.get()的时候，就是从线程的threadLocalMap中获取这个threadLocal对应的值<br>如果get不到，则可以通过自定义initValue方法生成一个threadLocal的默认值</p></li></ol><p>见如下图所示：<br><img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/20210718230858556.png" alt="在这里插入图片描述"></p><hr><p>下面这个代码会报什么错？（例子改编自上面链接的文章）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">         </span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(stringLocal.get());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">stringLocal.set(<span class="string">&quot;thread0&quot;</span>)</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Thread1中，会报空指针， 因为调用get之前没有做过set， 此时做get会报错。<br>一种方式改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    stringLocal.set(<span class="string">&quot;thread1&quot;</span>)</span><br><span class="line">        System.out.println(stringLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种是给stringLocal设置默认值，这种一般用于能直接根据线程推导出初始值的情况：<br>ThreadLocal<string> stringLocal = new ThreadLocal<string>(){;<br>protected String initialValue() {<br>return xxx;<br>};<br>};</string></string></p><p>正确set之后， 答案就会返回thread0和thread1， 且后续怎么set，两边都不会互相影响各自的threadLocal，<strong>虽然看起来是都用的是同一个Test里的成员。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第305场周赛-264名-22分钟4题</title>
      <link href="/2022/08/07/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/"/>
      <url>/2022/08/07/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841108569.png" alt="1659841108569"></p> <div class="toc"><!-- toc --><ul><li><a href="#ben-qi-zong-jie">本期总结：</a></li></ul><!-- tocstop --></div> <h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>bfs时，必须要记得在对第一个入队节点做vis[start]=true的操作！否则一定会导致WA！</li><li></li></ol><p><a href="https://leetcode.cn/contest/weekly-contest-305/problems/number-of-arithmetic-triplets/">算术三元组的数目 - 力扣 (LeetCode) 竞赛</a></p><p>直接3个for循环搞定</p><hr><p><a href="https://leetcode.cn/contest/weekly-contest-305/problems/reachable-nodes-with-restrictions/">受限条件下可到达节点的数目 - 力扣 (LeetCode) 竞赛</a></p><p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841166952.png" alt="1659841166952"></p><p>这么简单的bfs题竟然错了一次（用bfs是因为节点数量很多有10^5个）</p><p>因为bfs时忘了对第一个入队节点做vis[起点] = true;的操作， 直接导致错失前200</p><p>另外这题甚至不应该思考， 直接开写才对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt;[] edgToNextNodeLists(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] list = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            list[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edg : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> edg[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> edg[<span class="number">1</span>];</span><br><span class="line">            list[s].add(e);</span><br><span class="line">            list[e].add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachableNodes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span>[] restricted)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] nextNodes = edgToNextNodeLists(n, edges);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        Set&lt;Integer&gt; resSet = Arrays.stream(restricted).boxed().collect(Collectors.toSet());</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nextNode : nextNodes[node]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[nextNode] || resSet.contains(nextNode)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(nextNode);</span><br><span class="line">                vis[nextNode] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/contest/weekly-contest-305/problems/check-if-there-is-a-valid-partition-for-the-array/">检查数组是否存在有效划分 - 力扣 (LeetCode) 竞赛</a></p><p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841394607.png" alt="1659841394607"></p><p>可检查范围最多就3个，如果[4,5,6]如果符合，那我只要检查4前面那个数字是否有符合的划分，划分可以传递，因此直接动态规划即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == num) &#123;</span><br><span class="line">            dp[i] |= (i-<span class="number">2</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">2</span>] : <span class="literal">true</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == num &amp;&amp; nums[i-<span class="number">2</span>] == num) &#123;</span><br><span class="line">            dp[i] |= (i-<span class="number">3</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">3</span>] : <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == num-<span class="number">1</span> &amp;&amp; nums[i-<span class="number">2</span>] == num-<span class="number">2</span>) &#123;</span><br><span class="line">            dp[i] |= (i-<span class="number">3</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">3</span>] : <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/contest/weekly-contest-305/problems/longest-ideal-subsequence/">最长理想子序列 - 力扣 (LeetCode) 竞赛</a></p><p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841530495.png" alt="1659841530495"></p><p>显然是动态规划，   在[a-z]中找到符合k差值的字母， 根据字母已记录的最长子序列长度，进行+1即可。</p><p>最开始想歪了，想成了k是位置距离了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIdealString</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lastc</span> <span class="operator">=</span> c-k;lastc &lt;= c+k;lastc++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastc &lt; <span class="number">0</span> || lastc &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, dp[lastc] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[c] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第85场双周赛-1322-3题</title>
      <link href="/2022/08/06/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/"/>
      <url>/2022/08/06/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659806489275.png" alt="1659806489275"></p> <div class="toc"><!-- toc --><ul><li><a href="#ben-qi-zong-jie">本期总结：</a></li></ul><!-- tocstop --></div> <p>只记录一下对我而言比较有意义的题目</p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li><p>遇到类似坐标  <code>j - i == nums[j] - nums[i]</code>的题目，记得直接转移公式以期望得到一个f(x)从而建立基于f(x)做key的hashmap， 不要想着什么从左往右+多少减多少这种绕来绕去的思路。</p></li><li><p>数字num要拆成任意个比Target小的任意数字，且还要拆后的最小值尽可能大，那肯定不是直接基于target去做减法，而是让数字尽可能平均， 切分数量*target正好比num大的话，那么num/切分数量肯定满足比target小</p></li></ol><p><a href="https://leetcode.cn/contest/biweekly-contest-84/problems/merge-similar-items/">合并相似的物品 - 力扣 (LeetCode) 竞赛</a></p><p>hashmap直接用即可</p><hr><p><a href="https://leetcode.cn/contest/biweekly-contest-84/problems/count-number-of-bad-pairs/">统计坏数对的数目 - 力扣 (LeetCode) 竞赛</a></p><p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659806990621.png" alt="1659806990621"></p><p>好数概念： <code>i &lt; j</code> 且 <code>j - i == nums[j] - nums[i]</code>， 求好数的个数</p><p>明明对做法有印象但就是理不清楚，每次做每次都头晕</p><p>主要没法用很简洁的语言表达和解释这个做法</p><p>即使我刚做完，我现在也没法很好地描述，为什么是每次put这个nums[i] - i</p><p>啊，等等？公式推导？</p><p><code>i &lt; j</code> 且 <code>j - i == nums[j] - nums[i]</code></p><p>那不就是</p><p>nums[j] - j == nums[i] - i</p><p>即</p><p>f[j] ==  f[i]</p><p>f[x] = nums[x] - x</p><p><strong>根本和什么动态规划无关，就是一个数学公式推导啊。。。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countBadPairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">needNum</span> <span class="operator">=</span> nums[i] - i;</span><br><span class="line">        result += map.getOrDefault(needNum, <span class="number">0L</span>);</span><br><span class="line">        map.put(needNum, map.getOrDefault(needNum, <span class="number">0L</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)nums.length * (nums.length-<span class="number">1</span>) /<span class="number">2</span> - result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/contest/biweekly-contest-84/problems/task-scheduler-ii/">任务调度器 II - 力扣 (LeetCode) 竞赛</a></p><p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659807018323.png" alt="1659807018323"></p><p>这个还好，每次完成任务后，存一下下一次任务开始时至少的时间即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">taskSchedulerII</span><span class="params">(<span class="type">int</span>[] tasks, <span class="type">int</span> space)</span> &#123;</span><br><span class="line">        <span class="comment">// 存的是下一次任务的至少开始时间</span></span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">task</span> <span class="operator">=</span> tasks[i];</span><br><span class="line">            <span class="type">long</span> <span class="variable">canStartTime</span> <span class="operator">=</span> map.getOrDefault(task, Long.MIN_VALUE);</span><br><span class="line">            <span class="keyword">if</span> (nowTime &lt; canStartTime) &#123;</span><br><span class="line">                nowTime = canStartTime;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(task, nowTime + space + <span class="number">1</span>);</span><br><span class="line">            nowTime++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nowTime - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode.cn/contest/biweekly-contest-84/problems/minimum-replacements-to-sort-the-array/">将数组排序的最少替换次数 - 力扣 (LeetCode) 竞赛</a></p><p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659807076595.png" alt="1659807076595"></p><p>首先我很快想到必须是从右往左去遍历和替换，</p><p>如果当前比右边的都要小，则尽可能不拆</p><p>如果当前比右边的最小值要大， 则必须拆，拆的时候要保证最小值尽可能大</p><p>这题就演变成了</p><p>数字x要拆成k个比t小的任意数字，且最小值尽可能小（y)</p><p>我固执己见以为是一直按t去减，最后剩余的数字求个平均，就能保证最小值尽可能小了</p><p>却没考虑剩余数字可能因为我错误的选择了t导致特别小</p><p>实际上应该是拆分后的数字尽可能平均</p><p>以100 22为例</p><p>5个22正好比100大（4个22比100小）</p><p>那么100/5得到的均值肯定比22小</p><p>公式上即满足</p><p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659807407709.png" alt="1659807407709"></p><p>简单点的话就是  k&gt;=x/y的最小整数，即向上取整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumReplacement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>  <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; last) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// k=【num[i] / last】向上取整</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i] / last;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % last != <span class="number">0</span>) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                last = nums[i] / k;</span><br><span class="line">                result += k-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二阶段心理成长感悟</title>
      <link href="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/"/>
      <url>/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me">思考追求工作高绩效的价值是什么</a></li></ul><!-- tocstop --></div> <h1><span id="si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me">思考追求工作高绩效的价值是什么</span><a href="#si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me" class="header-anchor">#</a></h1><p>我是觉得在某个大公司做工作，就是有意义的吗？</p><p>做的项目影响的人数越多，我就越有价值吗？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第304场周赛-897-4题（心态重要）</title>
      <link href="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/"/>
      <url>/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659277621782.png" alt="1659277621782"></p> <div class="toc"><!-- toc --><ul><li><a href="#ben-qi-zong-jie">本期总结：</a></li></ul><!-- tocstop --></div> <p>只记录一下对我而言比较有意义的题目</p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>永远保持冷静，不要激动，下次可以录屏，记录自己的心态和过程</li><li>图里有环的判断并不是走回自己，而是走到了重复走过的点</li></ol><p><a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">6132. 使数组中所有元素都等于零 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278338228.png" alt="1659278338228"></p><p>这题花了七分钟，不应该。</p><p>题目没看懂</p><p>**选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 **最小的 <strong>非零</strong> 元素</p><p>又要求最少操作数，那么只能是每次选nums中的最小即可,这里想复杂了，以为是选某个区间范围内的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(nums);</span><br><span class="line">        <span class="keyword">if</span> (min == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] -= min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            min = Math.min(nums[i], min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/">6133. 分组的最大数量 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278765664.png" alt="1659278765664"></p><p>脑筋急转弯啊这是</p><p>跟grades根本没关系</p><p>直接排序后，每次取1个、2个、3个即可</p><p>拿就是看这样增加到什么时候为止结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGroups</span><span class="params">(<span class="type">int</span>[] grades)</span> &#123;</span><br><span class="line">        <span class="comment">//Arrays.sort(grades);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> grades.length;</span><br><span class="line">        <span class="keyword">while</span> (len - (k+<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = len - (k+<span class="number">1</span>);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/">6134. 找到离给定两个节点最近的节点 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278866526.png" alt="1659278866526"></p><p>这题思路其实也容易想：</p><p>先从node1一直往下遍历，直到遇到尽头或者环，记录每个点的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dis[node1] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> edges[node1];</span><br><span class="line"><span class="keyword">while</span> (node != -<span class="number">1</span> &amp;&amp; dis[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">    dis[node] = d++;</span><br><span class="line">    node = edges[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后node2也一直往下走，遇到node1走过的点（通过dis是否为-1判断）则计算最小值和要选择的点。同时也要判断环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="number">0</span>;</span><br><span class="line">node = node2;</span><br><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[edges.length];</span><br><span class="line"><span class="keyword">while</span> (node!=-<span class="number">1</span> &amp;&amp; !vis[node]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[node] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.max(d, dis[node]) &lt; result) &#123;</span><br><span class="line">            result = Math.max(d, dis[node]);</span><br><span class="line">            select = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d++;</span><br><span class="line">    vis[node] = <span class="literal">true</span>;</span><br><span class="line">    node = edges[node];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是自己提前想漏了很多点</p><p>遗漏点1：环的判断并不是走回自己啊，而是走到了重复走过的点！</p><p>遗漏点2：要注意节点距离相同的情况，要选节点编号最小！</p><p>遗漏点3：冷静冷静，不要妄自生气，你及时没进200，也拿到了每日3题的积分了！</p><p>这种easy题做了40分钟还错了2次很不应该！</p><p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279307738.png" alt="1659279307738"></p><p><a href="https://leetcode.cn/problems/longest-cycle-in-a-graph/">6135. 图中的最长环 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279326269.png" alt="1659279326269"></p><p>大放水，欸，知道每个点不需要重复走， 这个思路就能处理了</p><p>但是要注意  ”碰到自己走过的点即成环了“ 和”碰到别人走过的点，不用再走“是有区别的，不能一起判断</p><p>所以我用了一个root来判断</p><p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279449222.png" alt="1659279449222"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22年8月刷题日记（0730-0817）</title>
      <link href="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88%EF%BC%880730-0817%EF%BC%89/"/>
      <url>/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88%EF%BC%880730-0817%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="22-nian-8-yue-shua-ti-ri-ji-0730-0817">22年8月刷题日记（0730-0817）</span><a href="#22-nian-8-yue-shua-ti-ri-ji-0730-0817" class="header-anchor">#</a></h1><p>[toc]</p> <div class="toc"><!-- toc --><ul><li><a href="#2022-07-30">2022-07-30</a></li><li><a href="#2022-07-29">2022-07-29</a></li><li><a href="#2022-08-01">2022-08-01</a></li><li><a href="#2022-08-03">2022-08-03</a></li><li><a href="#2022-08-04">2022-08-04</a></li><li><a href="#2022-08-05">2022-08-05</a></li><li><a href="#2022-08-07">2022-08-07</a></li><li><a href="#2022-08-08">2022-08-08</a></li><li><a href="#2022-08-09">2022-08-09</a></li><li><a href="#2022-08-10">2022-08-10</a></li><li><a href="#2022-08-11">2022-08-11</a></li><li><a href="#2022-08-12">2022-08-12</a></li><li><a href="#2022-08-13">2022-08-13</a></li><li><a href="#2022-08-15">2022-08-15</a></li><li><a href="#2022-08-16">2022-08-16</a></li><li><a href="#2022-08-17">2022-08-17</a></li></ul><!-- tocstop --></div> <hr><h1><span id="2022-07-30">2022-07-30</span><a href="#2022-07-30" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列 - 力扣（LeetCode）</a></p><p>简单，题意理解了就好， 排列组合的数学应用</p><p><a href="https://leetcode.cn/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串 - 力扣（LeetCode）</a></p><p>简单，推导出贪心规律，从左到右只要符合平衡，就一定可以从更大的平衡串中拆掉</p><p><a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数 - 力扣（LeetCode）</a></p><p>“111011011”这种二进制字符串如何快速转int整数？</p><p>可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(&quot;111011011&quot;, 2) </span><br></pre></td></tr></table></figure><p>2指代二进制</p><h1><span id="2022-07-29">2022-07-29</span><a href="#2022-07-29" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/valid-square/">593. 有效的正方形 - 力扣（LeetCode）</a></p><p><strong>如何用4个点判断是否是一个正方形？</strong></p><ul><li><p>方法1： 设置顺时针点为1-&gt;2-&gt;3-&gt;4，然后根据边长相同、22边平行、勾股定理3者判断是否为正方形。</p><p>1-&gt;2-&gt;3-&gt;4点的判定先根据横坐标最小，再根据纵坐标最小。</p></li><li><p>方法二：正方形的任意3个点都是等边直角三角形，判断4次即可，注意额外加一个三角形中边的判断</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validSquare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c, <span class="type">int</span>[] d)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calc(a, b, c) &amp;&amp; calc(a, b, d) &amp;&amp; calc(a, c, d) &amp;&amp; calc(b, c, d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/furthest-building-you-can-reach/">1642. 可以到达的最远建筑 - 力扣（LeetCode）</a></p><p>简单贪心题。</p><p>注意PriorityQueue默认小顶堆</p><p><a href="https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/">1285. 找到连续区间的开始和结束数字 - 力扣（LeetCode）</a></p><ul><li><p>row_number() over() 指每一行在整个表分区中的序号</p></li><li><p>over()是窗口函数，不会做汇聚动作，因此行数不会发生变化。只会给出每一行所处分区的某个特定值（例如各分区的和 sum over(PARTITION  by xxx)）</p></li><li><p>id - <strong>row_number() over()</strong> diff   外层套一个group by diff可以用来求解连续区间的问题</p></li></ul><hr><h1><span id="2022-08-01">2022-08-01</span><a href="#2022-08-01" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合 - 力扣（LeetCode）</a></p><ul><li>dfs全排列搜索问题且要求不能重复，关键语句就是”预处理排序。选的时候前一位相同，则必须是连续选的情况，不可以前面的相同数字还没选，却选了自己“</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == nums[i] &amp;&amp; lastIndex != i-<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list.remove(int) 就是按索引移除。  list.remove(object)是针对非int对象的</li></ul><p><a href="https://leetcode.cn/problems/largest-plus-sign/">764. 最大加号标志 - 力扣（LeetCode）</a></p><ul><li><p>写了4个2重循环好麻烦，就是提前预处理好每个点的上下左右到最近0的距离即可</p></li><li><p>for (int y = 0, dis=0; y &lt; n;y++)    此时int等同于声明了dis，外层不可再声明dis了</p></li></ul><hr><h1><span id="2022-08-03">2022-08-03</span><a href="#2022-08-03" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">2265. 统计值等于子树平均值的节点数 - 力扣（LeetCode）</a></p><p>直接后序遍历即可</p><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p><p>翻转问题还是写一个reverse的简单方法会比较快，用stringBuilder不一定快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distribute-candies/">575. 分糖果 - 力扣（LeetCode）</a></p><p>集合应用，没啥好说的</p><h1><span id="2022-08-04">2022-08-04</span><a href="#2022-08-04" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/">1403. 非递增顺序的最小子序列 - 力扣（LeetCode）</a></p><p>排序即可</p><p><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计 - 力扣（LeetCode）</a></p><p>将出点和入点放入数组中，出点位置+seats， 入点位置-seats即可</p><p><a href="https://leetcode.cn/problems/print-foobar-alternately/">1115. 交替打印 FooBar - 力扣（LeetCode）</a></p><p>第一次做多线程的题目，还蛮有意思的</p><p>要求交替打印n次foo和bat</p><p>其实可以用资源的角度来理解</p><p>即需要打印foo时，说明生产了一个foo令牌，才可以打印</p><p>如果要打印bar，则要求有bar令牌才可以。</p><p>那么就很容易想到用2个阻塞队列或者2个信号量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; fooSync = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; barSync = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fooSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fooSync.take();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            barSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            barSync.take();</span><br><span class="line">            printBar.run();</span><br><span class="line">            fooSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以用一个boolean布尔值来表示此时打印foo还是打印bar，然后利用等待-唤醒机制。</p><p>如果用java自带语法，可以是wait和notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">2</span>*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                 printFoo.run();</span><br><span class="line">                 count--;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                count--;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用JUC，则用Condition即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-08-05">2022-08-05</span><a href="#2022-08-05" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/shortest-way-to-form-string/">1055. 形成字符串的最短路径 - 力扣（LeetCode）</a></p><p>2个字符串长度最多1000，双指针即可，没啥难的</p><p><a href="https://leetcode.cn/problems/cyJERH/">剑指 Offer II 092. 翻转字符 - 力扣（LeetCode）</a></p><p>提前预处理往左看的1的个数和往右看的0的个数</p><p>然后再遍历一次，每次把左边翻0，右边翻1，因为预处理过了所以可以马上得到答案</p><p>但是这个做法比较消耗2个O(n)的空间</p><p>用动态规划可以节省很多空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFlipsMonoIncr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// dp0代表位置为i时变成000..00所需翻转的数量</span></span><br><span class="line">    <span class="comment">// dp1代表位置为i时变成0001111所需翻转的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>, dp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last0</span> <span class="operator">=</span> dp0;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last1</span> <span class="operator">=</span> dp1;</span><br><span class="line">        dp0 = last0 + (c==<span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        dp1 = (c==<span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>) + Math.min(last0, last1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp0, dp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-palindrome/">409. 最长回文串 - 力扣（LeetCode）</a></p><p>就是数量统计题而已</p><hr><h1><span id="2022-08-07">2022-08-07</span><a href="#2022-08-07" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/exclusive-time-of-functions/submissions/">636. 函数的独占时间 - 力扣（LeetCode）</a></p><p>栈的应用题，start和end等同于左括号和右括号</p><p>注意用int[]数组来简化新类的定义操作，注意每次end出栈后，要把这段程序占用的总时间加到栈顶</p><hr><h1><span id="2022-08-08">2022-08-08</span><a href="#2022-08-08" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/path-with-maximum-gold/">1219. 黄金矿工 - 力扣（LeetCode）</a></p><p>提示dfs最大深度为25，则认为可以直接做带vis访问标记的dfs且不需要做记忆化结果。</p><p>另外dfs时也不要忘记对初始点的vis处理</p><p><a href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/submissions/">1365. 有多少小于当前数字的数字 - 力扣（LeetCode）</a></p><p>虽然是简单题，数量级别只有500，但还是考虑写了一下最快性能，直接按值做键处理，就能知道比每个值小的数量了，然后再分别设置。</p><p><a href="https://leetcode.cn/problems/special-binary-string/">761. 特殊的二进制序列 - 力扣（LeetCode）</a></p><p>这题没做出来，直接看答案了</p><p>0和1的数量相等  +  任意前缀1数量大于0，  类似于括号匹配</p><p>要我们调整括号对使得字典序尽可能大</p><p>这样就很容易想到递归了，即最外层括号可以不管， 然后只对内层做处理， 内层找到每一个括号对，然后按字典序排序。</p><ul><li><p>字符串list快速拼接：list.stream().collect(Collectors.joining());</p></li><li><p>s.subString(a,b)中b是开区间</p></li></ul><h1><span id="2022-08-09">2022-08-09</span><a href="#2022-08-09" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/">1413. 逐步求和得到正数的最小值 - 力扣（LeetCode）</a></p><p>遍历求和，求中间sum距离1的最大差值即可</p><p><a href="https://leetcode.cn/problems/linked-list-in-binary-tree/">1367. 二叉树中的列表 - 力扣（LeetCode）</a></p><p>O(二叉树节点*链表节点)的复杂度符合要求</p><p>遍历每个点为起点，然后往下搜索判断能否找到即可，还是挺有意思的递归应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        nodes.add(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, List&lt;Integer&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkToDown(node, nodes, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(node.left, nodes)  ||   dfs(node.right, nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">checkToDown</span><span class="params">(TreeNode node, List&lt;Integer&gt; nodes, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nodes.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val != nodes.get(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> checkToDown(node.left, nodes, index+<span class="number">1</span>) || checkToDown(node.right, nodes, index+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/7WHec2/">剑指 Offer II 077. 链表排序 - 力扣（LeetCode）</a></p><p>要求在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序</p><p>那所有排序方法里，只有递归排序可以实现了</p><p>而且得是从下往上递归</p><p>先11合并，再22合并，再44合并。</p><p>链表归并排序处理的几个坑：</p><ol><li>头节点可能变更的话，最好提前创建一个dummy头节点，这样dummy头节点.next就是新节点了</li><li>注意记录下一个排序序列的起始节点，用于确认是否第二个序列到末尾结束了。</li><li>还要记录上次排序序列的末尾节点， 用于排序后更新  上次末尾节点.next</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">listLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            listLen++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要总是改变头节点的情况下，最好定义一个空头节点用来更新头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">emptyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        emptyHead.next = head;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; listLen) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> emptyHead;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> emptyHead.next;</span><br><span class="line">            <span class="keyword">while</span>(head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> head1;</span><br><span class="line">                <span class="comment">// 走过len步，找到第二个比较序列的头部</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; head2 != <span class="literal">null</span>;i++) &#123;</span><br><span class="line">                    head2 = head2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找不到第二个序列头部了，则不用比较直接结束这次排序</span></span><br><span class="line">                <span class="keyword">if</span> (head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找一下下一次排序序列的开始节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">nextSortStartNode</span> <span class="operator">=</span> head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; nextSortStartNode != <span class="literal">null</span>;i++) &#123;</span><br><span class="line">                    nextSortStartNode = nextSortStartNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 合并，并更新新合并序列的末尾节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">newSortHead</span> <span class="operator">=</span> sortBatch(head1, head2, nextSortStartNode);</span><br><span class="line">                <span class="comment">// 更新头节点</span></span><br><span class="line">                preNode.next = newSortHead;</span><br><span class="line">                <span class="comment">// 定位末尾节点</span></span><br><span class="line">                <span class="keyword">while</span>(preNode.next != nextSortStartNode) &#123;</span><br><span class="line">                    preNode = preNode.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                head1 = nextSortStartNode;</span><br><span class="line">            &#125;</span><br><span class="line">            len*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emptyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode <span class="title function_">sortBatch</span><span class="params">(ListNode head1, ListNode head2, ListNode nextNode)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> head3;</span><br><span class="line">        <span class="keyword">while</span>(node1 != head2 || node2 != nextNode) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> node1 != head2 ? node1.val : Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> node2 != nextNode ? node2.val : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">                node3.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node3.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node3 = node3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node3.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> head3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="2022-08-10">2022-08-10</span><a href="#2022-08-10" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">1253. 重构 2 行二进制矩阵 - 力扣（LeetCode）</a></p><p>还是蛮容易推导的一个数组题，先处理掉所有0和2的情况</p><p>再处理1的情况，先把1都分配给上边，上边不够之后再分配给下边，最后检查是否清零即可。</p><p><a href="https://leetcode.cn/problems/path-with-maximum-minimum-value/">1102. 得分最高的路径 - 力扣（LeetCode）</a></p><p>很有意思的搜索题，我想到了bfs，且这个bfs是支持刷新点的bfs。先优先按最大的走</p><p>如果发现当前点被人走过，但是自己是比他优（不能相等），则可以刷新对方自己继续走。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已经有人走过，且自己不能刷新最好记录，则没必要走了，别人已经在走了</span></span><br><span class="line"><span class="keyword">if</span> (gMin[ny][nx] != Integer.MIN_VALUE &amp;&amp; gMin[ny][nx] &gt;= Math.min(grid[ny][nx], lastMin)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">gMin[ny][nx] = Math.min(grid[ny][nx], lastMin);</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ny, nx, gMin[ny][nx]&#125;);</span><br></pre></td></tr></table></figure><p>当然看答案还有dfs+二分， 即确定目标最小值之后， dfs搜索最多10000次。</p><p>复杂度O(10000 * (log2(10^9)))</p><p><a href="https://leetcode.cn/problems/UHnkqh/">剑指 Offer II 024. 反转链表 - 力扣（LeetCode）</a></p><p>用递归做比较有趣</p><hr><h1><span id="2022-08-11">2022-08-11</span><a href="#2022-08-11" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/find-all-the-lonely-nodes/">1469. 寻找所有的独生节点</a></p><p>直接递归判断，简单</p><p><a href="https://leetcode.cn/problems/sparse-array-search-lcci/">面试题 10.05. 稀疏数组搜索 - 力扣（LeetCode）</a></p><p>二分搜索，但我还是遍历了一遍先过滤空字符串了。导致性能是1ms</p><p>但差距不大是因为那些人也要定位后在0上去走，消耗不会差别太大。</p><p><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串 - 力扣（LeetCode）</a></p><p>很简单的滑动窗口</p><ol><li>第一波做出来性能20ms，不是最佳。因为用了Stream去判断是否有重复</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">int</span>[] counts)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(counts).noneMatch(c -&gt; c &gt;= <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>去掉Stream改用简单for循环，性能就到 5 ms 了</p></li><li><p>去掉k&gt;26的判断，提升到4ms</p></li><li><p>避免每次26次判断，用repeatCount值来记录，这样每次最多判断2次，结果还是4ms</p><p><img src="/images/22%E5%B9%B48%E6%9C%88/1660233587305.png" alt="1660233587305"></p></li></ol><p><a href="https://leetcode.cn/problems/reformat-the-string/">1417. 重新格式化字符串</a></p><p>一般那种要你交叉放数字的，都可能有一种改进点是看你能否空间复杂度为O(1)（不包含结果输出空间）</p><p>这就需要原地算法，双指针进行交换</p><hr><h1><span id="2022-08-12">2022-08-12</span><a href="#2022-08-12" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/">1282. 用户分组 - 力扣（LeetCode）</a></p><p>按数量建哈希表，每个数量对应一个列表，列表满了就放入结果中并重置，很简单</p><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数 - 力扣（LeetCode）</a></p><p>只能取左右两边，那么等同于滑动窗口，只不过是反着求中间的滑动窗口最小值</p><p><a href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或 - 力扣（LeetCode）</a></p><p>很有意思，要求 <code>nums[i] XOR nums[j]</code> 的最大运算 结果</p><p>想了半天终于想起来有一个字典树这玩意，一开始觉得麻烦，后来还是写了 ，答案也有这个思路，很棒</p><p>只不过自己得记住，要先在字典树中试图求解最大运算结果，  求解完成后，才能把自己再插入字典树中</p><hr><h1><span id="2022-08-13">2022-08-13</span><a href="#2022-08-13" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/goal-parser-interpretation/">1678. 设计 Goal 解析器 - 力扣（LeetCode）</a></p><p>直接取临时字符串然后判断即可</p><p><a href="https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/">1874. 两个数组的最小乘积和 - 力扣（LeetCode）</a></p><p>直接排序后第一个数组的最大乘第二个数组的最小，依次处理即可，很简单，虽然我不知道怎么证明 <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II - 力扣（LeetCode）</a></p><p>一次就AC了， 想到了动态规划</p><p>每次求出左边的最大值</p><p>然后看一下自己当前位置往左边遍历时，选取那个左边位置作为一块，能否满足要求，能满足要求则就看判断当前最大分割块即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (左边最大值 小于 我当前位置从右往左遍历时的最小值， 说明可以分割)&#123;</span><br><span class="line">    dp[当前位置] = Math.max(dp[左边界-<span class="number">1</span>] + <span class="number">1</span>  , dp[当前位置]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="2022-08-15">2022-08-15</span><a href="#2022-08-15" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列 - 力扣（LeetCode）</a></p><p>循环双端队列，其实关键在于循环队列的定义，双端的话很容易处理的。</p><p>这题肯定是要用数组来做比较有意义</p><p>循环队列数组概念硬记忆：</p><ul><li>front指向已存储的队头元素， rear指向已存储的队尾元素的下一个位置（即空位置）</li></ul><ul><li>队满： (Q.rear+1)%M = Q.front，  即队尾的下一个位置已经有了</li><li>队空： Q.front = Q.rear    即队头存储的是一个空的</li><li>队长： (rear-front+M)%M</li></ul><p><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组 - 力扣（LeetCode）</a></p><p>很简单， 直接计算左边前缀乘积， 计算右边前缀乘积即可</p><p><a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/comments/">1015. 可被 K 整除的最小整数 - 力扣（LeetCode）</a></p><ul><li><p>数字末尾是1的情况下，肯定不能被2和5整除</p></li><li><p>通过公式推导：</p><blockquote><blockquote></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">设n=p*K+q</span><br><span class="line">则n*<span class="number">10</span>+<span class="number">1</span>= <span class="number">10</span>*p*K + q*<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">对两边都取k取余</span><br><span class="line">有(n*<span class="number">10</span>+<span class="number">1</span>)%K=(<span class="number">10</span>*p*K+q*<span class="number">10</span>+<span class="number">1</span>)%K</span><br><span class="line">又因为n%k=q</span><br><span class="line">则右边(<span class="number">10</span>*p*K+q*<span class="number">10</span>+<span class="number">1</span>)%K = (q*<span class="number">10</span>+<span class="number">1</span>)%K = (n%k*<span class="number">10</span> + <span class="number">1</span>) %K</span><br><span class="line">推断出：(n*<span class="number">10</span>+<span class="number">1</span>)%K = ((n%K)*<span class="number">10</span>+<span class="number">1</span>)%K</span><br><span class="line">因此(n*<span class="number">10</span>+<span class="number">1</span>)如果能被k整除，等同于 (n%k)*<span class="number">10</span>+<span class="number">1</span>被k整除</span><br><span class="line">所以只要n做增加时先取余即可</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>不含2和5的质因子的数必定在K之内有解，直接用其mod循环即可，避免了大数之间的除法</p><hr><h1><span id="2022-08-16">2022-08-16</span><a href="#2022-08-16" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/design-an-ordered-stream/">1656. 设计有序流 - 力扣（LeetCode）</a></p><p>用String[]做数组，当前点之前是空，现在要插入，则可以尝试往后遍历直到遇到空</p><p><a href="https://leetcode.cn/problems/percentage-of-letter-in-string/">2278. 字母在字符串中的百分比 - 力扣（LeetCode）</a></p><p>没看懂有啥用</p><p><a href="https://leetcode.cn/problems/power-of-three/">326. 3 的幂 - 力扣（LeetCode）</a></p><p>直接按3取余，不断除3，直到为1说明就是3的幂</p><p>题解有个超简单方法：</p><p>根据数值范围，找到最大的3幂的值 1162261467  ，然后直接看 1162261467  能否被询问的这个值整除即可</p><p>这提示我们如果以后遇到这种需求，可以直接定义一个最大范围值取判断，而不用自己重复去循环计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2022-08-17">2022-08-17</span><a href="#2022-08-17" class="header-anchor">#</a></h1><p><a href="https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/">914. 卡牌分组 - 力扣（LeetCode）</a></p><p>记住gcd公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">x</span> <span class="operator">=</span>= <span class="number">0</span> ? y : gcd(y % x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这题里因为题目必须要求分成每组X个，所以总数必须要能被X整除，这就过滤掉很多了</p><p><a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接 - 力扣（LeetCode）</a></p><p>一个树，加上一个边构成带环的图，问怎么找到应该去掉的那条边，重新变回树</p><p>我最初的思路：每次去掉一个边，然后做bfs看是否重新碰到自己的点，但是要考虑很多判断，很麻烦</p><p>这题最佳是用并查集， 当拼接的时候，如果发现左右两个点属于同一个集合，则一定会出现环</p><p>即是否图中成环的判断可以用这个方式：</p><p><strong>通过边连接2个点的时候，如果2个点属于同一个并查集，则一定存在环</strong></p><p><a href="https://leetcode.cn/problems/minimum-number-of-people-to-teach/">1733. 需要教语言的最少人数 - 力扣（LeetCode）</a></p><p>最开始以为我的思路需要500乘500乘500</p><p>后来发现其实好友关系的总数只有500，即边只有500个</p><p>则遍历次数少了500倍</p><p>那可以直接遍历每种语言，判断能否加</p><p>注意需要提前处理掉那些不需要新学语言的人（即他和他的所有好友都有共同语言）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年8月 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库锁、事务、隔离级别超详细原理</title>
      <link href="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/"/>
      <url>/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zang-du-he-zang-du-guo-cheng-zhong-she-ji-de-suo">脏读和脏读过程中涉及的锁</a><ul><li><a href="#q-tong-shi-zhi-xing-jia-qian-he-kou-qian-cao-zuo-yi-fang-hui-gun-dao-zhi-shu-ju-chu-cuo-de-du-guo-cheng-jiao-shi-me"><strong>Q:同时执行加钱和扣钱操作，一方回滚导致数据出错的读过程叫什么？</strong></a></li><li><a href="#q-zai-bu-xiu-gai-shu-ju-ku-ge-chi-ji-bie-de-qing-kuang-xia-wo-men-ke-yi-ru-he-yong-sql-yu-ju-shou-dong-jie-jue-zhe-ge-zang-du">Q: 在不修改数据库隔离级别的情况下， 我们可以如何用sql语句手动解决这个脏读？</a></li><li><a href="#q-gang-cai-kan-dao-suo-zhu-li-si-zhe-yi-xing-na-me-zhe-ge-jiu-jiao-xing-ji-suo-shi-me-qing-kuang-xia-hui-bian-cheng-suo-zhu-zheng-ge-biao"><strong>Q: 刚才看到”锁住李四这一行“， 那么这个就叫行级锁。什么情况下会变成锁住整个表？</strong></a></li><li><a href="#q-ru-guo-yi-ge-shi-wu-a-shen-qing-liao-xing-suo-suo-zhu-mou-yi-xing-ling-yi-ge-shi-wu-b-shen-qing-liao-biao-suo-na-b-hui-bei-zu-sai-ma"><strong>Q: 如果一个事务A申请了行锁，锁住某一行， 另一个事务B申请了表锁，那B会被阻塞吗？</strong></a></li><li><a href="#pai-ta-suo-gai-nian">排他锁概念</a></li><li><a href="#gong-xiang-suo-gai-nian">共享锁概念</a></li><li><a href="#q-na-me-shi-me-shi-hou-shi-yong-gong-xiang-suo-bi-pai-ta-suo-yao-hao-ni"><strong>Q: 那么什么时候使用共享锁比排他锁要好呢？</strong></a></li><li><a href="#q-na-wo-jia-de-gong-xiang-suo-s-suo-he-pai-ta-suo-x-shi-me-shi-hou-shi-fang-ni-shi-mei-ci-zhi-xing-wan-update-ma-shang-shi-fang-ma"><strong>Q: 那我加的共享锁（S锁）和排他锁（X)什么时候释放呢？是每次执行完update马上释放吗？</strong></a></li><li><a href="#q-liang-jie-duan-suo-xie-yi-ke-yi-bi-mian-si-suo-ma"><strong>Q: 两阶段锁协议可以避免死锁吗？</strong></a></li></ul></li><li><a href="#ge-chi-ji-bie-he-mvcc-yuan-li">隔离级别和MVCC原理</a><ul><li><a href="#q-xian-lai-ge-xiao-wen-ti-ru-ji-bie-mei-you-ren-he-suo-dui-ma"><strong>Q: 先来个小问题，RU级别没有任何锁，对吗？</strong></a></li><li><a href="#q-dang-wo-men-de-shu-ju-ku-bei-she-zhi-cheng-rc-ji-bie-read-commited-shi-ke-yi-jie-jue-zang-du-na-me-bei-hou-shi-zen-me-jie-jue-de-ni"><strong>Q: 当我们的数据库被设置成RC级别（Read commited）时， 可以解决脏读， 那么背后是怎么解决的呢？</strong></a></li><li><a href="#q-mvcc-jiu-jing-shi-zen-me-zuo-de-ni"><strong>Q: MVCC究竟是怎么做的呢？</strong></a></li><li><a href="#q-mvcc-ji-zhi-xia-shi-me-shi-kuai-zhao-du-shi-me-shi-dang-qian-du"><strong>Q: MVCC机制下， 什么是快照读，什么是当前读？</strong></a></li><li><a href="#q-na-me-hui-dao-gang-cai-de-zang-du-wen-ti-mvcc-jiu-jing-shi-zen-me-zai-du-bu-jia-suo-de-qing-kuang-xia-jie-jue-zang-du-de"><strong>Q: 那么回到刚才的脏读问题，  MVCC究竟是怎么在读不加锁的情况下， 解决脏读的？</strong></a></li><li><a href="#q-ru-guo-shi-wu-b-zhong-bu-zuo-yu-e-pan-duan-zhi-chi-zhi-jie-she-zhang-kou-fei-na-shi-bu-shi-hui-dao-zhi-xian-kou-fei-ran-hou-hui-gun-cheng-0-zhe-yang-de-qing-kuang"><strong>Q: 如果事务B中不做余额判断，支持直接赊账+扣费， 那是不是会导致先扣费，然后回滚成0这样的情况？</strong></a></li><li><a href="#q-shang-mian-zhe-ge-guo-cheng-you-shi-me-yin-huan"><strong>Q: 上面这个过程有什么隐患</strong></a></li><li><a href="#q-rr-ke-chong-fu-du-repeat-read-de-ge-chi-ji-bie-you-shi-zen-me-jie-jue-shang-mian-zhe-ge-wen-ti-de"><strong>Q: RR（可重复读，Repeat Read)的隔离级别又是怎么解决上面这个问题的？</strong></a></li><li><a href="#q-na-du-wen-ti-zhong-de-huan-du-you-shi-shi-me"><strong>Q: 那读问题中的幻读又是什么？</strong></a></li><li><a href="#q-rr-ge-chi-ji-bie-zhong-de-mvcc-ji-zhi-ke-yi-jie-jue-shang-mian-de-wen-ti-ma"><strong>Q: RR隔离级别中的MVCC机制可以解决上面的问题吗？</strong></a></li><li><a href="#q-na-ru-guo-xiang-xia-mian-zhe-yang-shi-wu-a-lian-xu-zuo-liang-ci-geng-xin-ni-dan-chun-kao-mvcc-neng-bi-mian-geng-xin-cao-zuo-de-huan-du-me"><strong>Q: 那如果像下面这样， 事务A连续做两次更新呢，单纯靠MVCC能避免更新操作的幻读么？</strong></a></li><li><a href="#q-na-shu-ju-ku-zen-me-chu-li-zhe-chong-2-ci-updete-zhong-jian-zuo-insert-de-huan-du-qing-kuang-ni"><strong>Q: 那数据库怎么处理这种2次updete中间做insert的幻读情况呢？</strong></a></li><li><a href="#q-na-xing-suo-jian-xi-suo-next-key-suo-shi-shi-me-qu-bie"><strong>Q: 那行锁、间隙锁、next-key锁是什么区别？</strong></a></li><li><a href="#q-ru-guo-name-zhe-ge-zi-duan-bu-shi-suo-yin-er-shi-pu-tong-zi-duan-na-jian-xi-suo-hui-zen-me-jia"><strong>Q: 如果name这个字段不是索引，而是普通字段，那间隙锁会怎么加？</strong></a></li><li><a href="#q-na-shi-bu-shi-zhi-yao-name-shi-suo-yin-jiu-bu-hui-gei-zheng-ge-biao-quan-jia-jian-xi-suo-liao"><strong>Q: 那是不是只要name是索引，就不会给整个表全加间隙锁了？</strong></a></li><li><a href="#q-gang-cai-kan-dao-shuo-rr-ke-yi-jie-jue-2-ci-select-zhi-jian-de-huan-du-ye-neng-jie-jue-2-ci-update-zhi-jian-de-huan-du-na-wei-shi-me-hen-duo-zi-liao-li-reng-ran-shuo-rr-bu-neng-jie-jue-huan-du"><strong>Q: 刚才看到说RR可以解决2次select之间的幻读， 也能解决2次update之间的幻读， 那为什么很多资料里，仍然说RR不能解决幻读？</strong></a></li><li><a href="#q-na-chuan-xing-hua-serializable-ge-chi-ji-bie-wei-shi-me-jiu-neng-bi-mian-huan-du-liao"><strong>Q: 那串行化serializable隔离级别，为什么就能避免幻读了？</strong></a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><p>将下面这些数据库的概念单独拿出来时，相信很多人都有了解或者记忆过，但是将这些概念全部串联在一起时，可能就会很混乱。<br>我这里举个例子：</p><ul><li>排他锁、共享锁</li><li>行锁、表锁、意向锁、间隙锁、next-key锁</li><li>悲观锁、乐观锁</li><li>两阶段锁协议</li><li>LCBB锁并发控制协议、MVCC多版本控制协议</li><li>脏读、不可重复读、幻读</li><li>RU\RC\RR\SE隔离级别<br>然后自己问自己一个问题：</li></ul><ol><li>这一堆锁的关联关系究竟是什么？</li><li>各隔离级别究竟是怎么用各种锁+MVCC来解决事务读问题的？</li></ol><hr><h1><span id="zang-du-he-zang-du-guo-cheng-zhong-she-ji-de-suo">脏读和脏读过程中涉及的锁</span><a href="#zang-du-he-zang-du-guo-cheng-zhong-she-ji-de-suo" class="header-anchor">#</a></h1><p>首先，我们完全不考虑数据库引擎、隔离级别设置之类的，就当作你用一个超简陋的儿科级别数据库来存放和更新数据。</p><p>假设你的商城服务正好在<strong>同时执行</strong>如下的2种事情</p><ul><li>张三给穷光蛋李四转账100元。</li><li>李四尝试下单购买100元的衣服</li></ul><p>李四在最开始余额只有0元钱。<br>注意因为是同时执行，在没有做任何保护的情况下，就可能会出现下图这样的情况<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463857433006958-1659020780284.png" alt="image.png"></p><p>可以看到李四明明没有钱，却扣费了，变成了很奇怪的-100元。</p><hr><h2><span id="q-tong-shi-zhi-xing-jia-qian-he-kou-qian-cao-zuo-yi-fang-hui-gun-dao-zhi-shu-ju-chu-cuo-de-du-guo-cheng-jiao-shi-me"><strong>Q:同时执行加钱和扣钱操作，一方回滚导致数据出错的读过程叫什么？</strong></span><a href="#q-tong-shi-zhi-xing-jia-qian-he-kou-qian-cao-zuo-yi-fang-hui-gun-dao-zhi-shu-ju-chu-cuo-de-du-guo-cheng-jiao-shi-me" class="header-anchor">#</a></h2><p>A: 这个过程就叫做<strong>脏读</strong>。  即更新回退的时，另一个事务读到了脏数据，判断失误，导致做了错误的处理。<br><strong>根本原因是2个事务都是先查后扣，却没有提前保护的形式</strong></p><hr><h2><span id="q-zai-bu-xiu-gai-shu-ju-ku-ge-chi-ji-bie-de-qing-kuang-xia-wo-men-ke-yi-ru-he-yong-sql-yu-ju-shou-dong-jie-jue-zhe-ge-zang-du">Q: 在不修改数据库隔离级别的情况下， 我们可以如何用sql语句手动解决这个脏读？</span><a href="#q-zai-bu-xiu-gai-shu-ju-ku-ge-chi-ji-bie-de-qing-kuang-xia-wo-men-ke-yi-ru-he-yong-sql-yu-ju-shou-dong-jie-jue-zhe-ge-zang-du" class="header-anchor">#</a></h2><p>A: 那很显然就是加锁对事务过程做提前保护， 不让B去判断和扣费。<br>sql语句里有个 ”for update“ 语法， 会手动锁住李四那一行，在调用commit后释放<br>具体见下面绿色的标注部分：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463870583057788-1659020780291.png" alt="image.png"></p><hr><h2><span id="q-gang-cai-kan-dao-suo-zhu-li-si-zhe-yi-xing-na-me-zhe-ge-jiu-jiao-xing-ji-suo-shi-me-qing-kuang-xia-hui-bian-cheng-suo-zhu-zheng-ge-biao"><strong>Q: 刚才看到”锁住李四这一行“， 那么这个就叫行级锁。什么情况下会变成锁住整个表？</strong></span><a href="#q-gang-cai-kan-dao-suo-zhu-li-si-zhe-yi-xing-na-me-zhe-ge-jiu-jiao-xing-ji-suo-shi-me-qing-kuang-xia-hui-bian-cheng-suo-zhu-zheng-ge-biao" class="header-anchor">#</a></h2><p>A:<br>name ='李四’这句话， 如果name是索引列的话，就会加行锁<br>如果不是索引列， 就会变成表锁。<br>换言之， <strong>行锁的本质是在索引节点上加锁</strong><br>如果无法在索引节点上加锁，那就会直接变成整张表的锁，代价就会很大。</p><p>另外表锁也可以单独用lock table的语法手动加锁</p><hr><h2><span id="q-ru-guo-yi-ge-shi-wu-a-shen-qing-liao-xing-suo-suo-zhu-mou-yi-xing-ling-yi-ge-shi-wu-b-shen-qing-liao-biao-suo-na-b-hui-bei-zu-sai-ma"><strong>Q:  如果一个事务A申请了行锁，锁住某一行， 另一个事务B申请了表锁，那B会被阻塞吗？</strong></span><a href="#q-ru-guo-yi-ge-shi-wu-a-shen-qing-liao-xing-suo-suo-zhu-mou-yi-xing-ling-yi-ge-shi-wu-b-shen-qing-liao-biao-suo-na-b-hui-bei-zu-sai-ma" class="header-anchor">#</a></h2><p>A:<br>B事务既然申请表锁，说明可能会用到A中的每一行。<br>B申请的流程可以是下面这样：</p><ol><li>判断表是否已被其他事务用表锁锁表</li><li>判断表中的每一行是否已被行锁锁住。<br>但2这一步也太耗时了。<br>因此A申请行锁前，会优先申请一个意向锁，再申请行锁。<br>然后B申请时，第2步改成判断意向锁即可，有意向锁就阻塞。</li></ol><p>简单点说， 意向锁就是行锁操作用来阻塞表锁用的。 但行锁和行锁之间不会互相阻塞，除非行有冲突。</p><hr><h2><span id="pai-ta-suo-gai-nian">排他锁概念</span><a href="#pai-ta-suo-gai-nian" class="header-anchor">#</a></h2><p>刚才看到的for update会限制其他并行事务的所有读写操作，而且是2个事务上都加了”for update“。<br>那么这个锁就叫做”排他锁“， 属于非常强势的锁， 相当于其他读写操作马上全部拦住了。</p><p>这里使用排他锁来解决脏读的原因是因为后面有<strong>查询余额+扣余额</strong>的代码，写这段代码的人必须做提前保护，<strong>以避免自己读到一个可能被修改的数据，导致判断和修改失误</strong>。</p><hr><h2><span id="gong-xiang-suo-gai-nian">共享锁概念</span><a href="#gong-xiang-suo-gai-nian" class="header-anchor">#</a></h2><p>和排他锁对应的是“共享锁”，也就是熟知的读写锁。<br>可以让多个事务同时读，但是不允许修改 。<br>手动加共享锁的方式:把for update改成  lock in share mode即可</p><h2><span id="q-na-me-shi-me-shi-hou-shi-yong-gong-xiang-suo-bi-pai-ta-suo-yao-hao-ni"><strong>Q: 那么什么时候使用共享锁比排他锁要好呢？</strong></span><a href="#q-na-me-shi-me-shi-hou-shi-yong-gong-xiang-suo-bi-pai-ta-suo-yao-hao-ni" class="header-anchor">#</a></h2><p>A:<br>可以看下面的例子：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463921737079966-1659020780298.png" alt="image.png"></p><p>可以看到没有查自身+更新自身的操作， 仅仅是查+更新其他表，表之间也互不关联，对余额的实时性也不是要求太高。</p><ul><li>如果都加排他锁，各种select操作就会很慢。</li><li>但如果不加共享锁， T6这边删除时，就可能产生冗余数据，所以还是得加锁。</li></ul><hr><h2><span id="q-na-wo-jia-de-gong-xiang-suo-s-suo-he-pai-ta-suo-x-shi-me-shi-hou-shi-fang-ni-shi-mei-ci-zhi-xing-wan-update-ma-shang-shi-fang-ma"><strong>Q: 那我加的共享锁（S锁）和排他锁（X)什么时候释放呢？是每次执行完update马上释放吗？</strong></span><a href="#q-na-wo-jia-de-gong-xiang-suo-s-suo-he-pai-ta-suo-x-shi-me-shi-hou-shi-fang-ni-shi-mei-ci-zhi-xing-wan-update-ma-shang-shi-fang-ma" class="header-anchor">#</a></h2><p>A:<br>这里就涉及了“两阶段锁”协议。</p><ul><li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li><li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li></ul><p>说人话， 就是在事务中需要加锁时再加锁， 直到commit完一次性解锁。</p><p>为什么要两阶段锁，看到的一句话是<br><strong>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</strong></p><hr><h2><span id="q-liang-jie-duan-suo-xie-yi-ke-yi-bi-mian-si-suo-ma"><strong>Q: 两阶段锁协议可以避免死锁吗？</strong></span><a href="#q-liang-jie-duan-suo-xie-yi-ke-yi-bi-mian-si-suo-ma" class="header-anchor">#</a></h2><p>A:<br>不能避免，但是可以通过死锁检测算法进行事务解除。</p><hr><p>重新回到张三李四转账+下单的场景上来。<br>for update这种锁，其实也是一种“悲观锁” ，加锁解锁比较耗时， 默认经常发生竞争。<br>但如果我的转账和下单过程要求非常快，每次只有几毫秒，那加悲观锁成本就太大了<br>这时候就可以手动使用乐观锁， 需要你自己在余额表里增加version列，增加后如下所示：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463991504080949-1659020780303.png" alt="image.png"></p><p>这样就不需要特地加锁了，每次循环判断即可，前提是冲突发生概率比较低，阻塞时间比较短。</p><hr><p>刚才一个小小的脏读，就已经解决了下面3个问题</p><ul><li>排他锁和共享锁的区别：前者是拒绝所有读写 ， 后者是允许并发读拒绝写</li><li>行锁和表锁的区别： 前者是对单行加锁 ， 后者是对整表加锁，  区别是 是否涉及索引</li><li>悲观锁和乐观锁的区别：  前者主动用数据库自带的锁， 后者自己添加version版本号<br>外加一个两阶段锁协议</li></ul><hr><h1><span id="ge-chi-ji-bie-he-mvcc-yuan-li">隔离级别和MVCC原理</span><a href="#ge-chi-ji-bie-he-mvcc-yuan-li" class="header-anchor">#</a></h1><p>继续回到脏读问题， 前面我们学习的所有概念，都是和数据库自身隔离级别无关，使用数据库的锁语法或者version版本号来避免。</p><p>但数据库发展这么强大，怎么可能需要我们频繁自己写这种复杂逻辑，于是数据库诞生了隔离级别设置。</p><p>前面会发生脏读的隔离级别， 叫做RU（read uncommited)<br>即RU级别时， 我可以在别的事务没完全commit好时就读到数据。</p><hr><h2><span id="q-xian-lai-ge-xiao-wen-ti-ru-ji-bie-mei-you-ren-he-suo-dui-ma"><strong>Q: 先来个小问题，RU级别没有任何锁，对吗？</strong></span><a href="#q-xian-lai-ge-xiao-wen-ti-ru-ji-bie-mei-you-ren-he-suo-dui-ma" class="header-anchor">#</a></h2><p>A:<br>错误， RU级别做update等增删改操作时，仍然会默认在事务更新操作中增加排他锁，避免update冲突。<br>切记脏读的发生原因，是查询+更新+回滚时没加锁导致其他查询操作出现失误判断。<br>即查询这块可能读到没提交的数据，导致错误，而不是更新的并发问题。</p><hr><h2><span id="q-dang-wo-men-de-shu-ju-ku-bei-she-zhi-cheng-rc-ji-bie-read-commited-shi-ke-yi-jie-jue-zang-du-na-me-bei-hou-shi-zen-me-jie-jue-de-ni"><strong>Q: 当我们的数据库被设置成RC级别（Read commited）时， 可以解决脏读， 那么背后是怎么解决的呢？</strong></span><a href="#q-dang-wo-men-de-shu-ju-ku-bei-she-zhi-cheng-rc-ji-bie-read-commited-shi-ke-yi-jie-jue-zang-du-na-me-bei-hou-shi-zen-me-jie-jue-de-ni" class="header-anchor">#</a></h2><p>A:<br>业界有两种方式</p><ul><li>LBCC基于锁的并发控制（Lock-Based Concurrency Control)）</li><li>MVCC基于多版本的并发控制协议(Multi-Version Concurrency Control)</li></ul><p>LBCC其实就是类似前面手动用悲观锁的方式， 事务操作中查询时默认试图加锁，因此就可能被update的排他锁阻塞住，避免了脏读。</p><p>但代价就是效率很低。很多场景下，select的次数是远大于update的。</p><p>所以InnoDb 基于乐观锁的概念， 想了一个MVCC，自己在事务的背后实现了一套类似乐观锁的机制来处理这种情况。 确保了尽可能不在读操作上加锁， 排他锁只对更新操作生效。</p><hr><h2><span id="q-mvcc-jiu-jing-shi-zen-me-zuo-de-ni"><strong>Q: MVCC究竟是怎么做的呢？</strong></span><a href="#q-mvcc-jiu-jing-shi-zen-me-zuo-de-ni" class="header-anchor">#</a></h2><p>A:<br>简单来说，就是默认给每个数据行加了一个版本号列TRX_ID和回滚版本链ROLL_BT，具体可以看《高性能mysql》书里的这段描述：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464034268062917-1659020780312.png" alt="image.png"></p><p>简而言之</p><ul><li>查的时候，只查当前事务之前的记录，或者回滚版本比当前大的已删记录。</li><li>增的时候，加新版本的记录</li><li>删的时候，把老记录标记上回滚版本</li><li>改的时候，本质上是加新记录， 同时把老记录标上回滚版本</li></ul><hr><h2><span id="q-mvcc-ji-zhi-xia-shi-me-shi-kuai-zhao-du-shi-me-shi-dang-qian-du"><strong>Q: MVCC机制下， 什么是快照读，什么是当前读？</strong></span><a href="#q-mvcc-ji-zhi-xia-shi-me-shi-kuai-zhao-du-shi-me-shi-dang-qian-du" class="header-anchor">#</a></h2><p>A:</p><ul><li>快照读：对于select读操作，统一默认不加锁，使用历史版本数据。</li><li>当前读：对于insert、update、delete操作，仍然需要加X锁，因为涉及了数据变更，必须使用最新数据进行修改</li></ul><hr><h2><span id="q-na-me-hui-dao-gang-cai-de-zang-du-wen-ti-mvcc-jiu-jing-shi-zen-me-zai-du-bu-jia-suo-de-qing-kuang-xia-jie-jue-zang-du-de"><strong>Q: 那么回到刚才的脏读问题，  MVCC究竟是怎么在读不加锁的情况下， 解决脏读的？</strong></span><a href="#q-na-me-hui-dao-gang-cai-de-zang-du-wen-ti-mvcc-jiu-jing-shi-zen-me-zai-du-bu-jia-suo-de-qing-kuang-xia-jie-jue-zang-du-de" class="header-anchor">#</a></h2><p>A:<br>首先，每次select都不用任何锁， 每次都是快照读，不会阻塞，因此会变成下面这样：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464042249047653-1659020780329.png" alt="image.png"></p><p>总结这个图，就是</p><ol><li>每次读时，会生成一个readView，用来记录当前还没提交的事务版本号。</li><li>根据自己事务的版本号version，去寻找小于自己当前版本且不在readView集合中的记录。</li></ol><p>这样的话就保证了读的数据必须是已经完成提交的，是不是很简单？</p><hr><h2><span id="q-ru-guo-shi-wu-b-zhong-bu-zuo-yu-e-pan-duan-zhi-chi-zhi-jie-she-zhang-kou-fei-na-shi-bu-shi-hui-dao-zhi-xian-kou-fei-ran-hou-hui-gun-cheng-0-zhe-yang-de-qing-kuang"><strong>Q: 如果事务B中不做余额判断，支持直接赊账+扣费， 那是不是会导致先扣费，然后回滚成0这样的情况？</strong></span><a href="#q-ru-guo-shi-wu-b-zhong-bu-zuo-yu-e-pan-duan-zhi-chi-zhi-jie-she-zhang-kou-fei-na-shi-bu-shi-hui-dao-zhi-xian-kou-fei-ran-hou-hui-gun-cheng-0-zhe-yang-de-qing-kuang" class="header-anchor">#</a></h2><p>A:<br>不会。<br>上面提过， MVCC中更新操作都是“当前读”，仍然需要<strong>加X锁</strong>， 且因为涉及了数据变更，必须使用<strong>最新数据版本</strong>进行修改</p><p>换言之， update等操作， 还是会加锁，且用最新版本更新，避免了脏更新的问题，如下：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464053974009576-1659020780335.png" alt="image.png"></p><hr><h2><span id="q-shang-mian-zhe-ge-guo-cheng-you-shi-me-yin-huan"><strong>Q: 上面这个过程有什么隐患</strong></span><a href="#q-shang-mian-zhe-ge-guo-cheng-you-shi-me-yin-huan" class="header-anchor">#</a></h2><p>A:<br>如果1个事务中连续读2次余额，可能有“不可重复读”的风险，即前后读的数据发生了不一致<br>如下所示<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464111781086895-1659020780344.png" alt="image.png"></p><p>因此RC隔离级别无法解决 “不可重复读的问题”</p><hr><h2><span id="q-rr-ke-chong-fu-du-repeat-read-de-ge-chi-ji-bie-you-shi-zen-me-jie-jue-shang-mian-zhe-ge-wen-ti-de"><strong>Q: RR（可重复读，Repeat Read)的隔离级别又是怎么解决上面这个问题的？</strong></span><a href="#q-rr-ke-chong-fu-du-repeat-read-de-ge-chi-ji-bie-you-shi-zen-me-jie-jue-shang-mian-zhe-ge-wen-ti-de" class="header-anchor">#</a></h2><p>A:<br>本质上就是readView生成时的区别<br>上面RC不可重复读的图中可以看到，每次读时，都取了最新的readView。 这可能导致事务A提交后， 事务B观察到的readView集合发生了变化。</p><p>因此RR机制改变了readView的生成方式， 每次读时只使用事务B最开始拿到的那个readView，这样永远就只取老的数据了。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464120144079067-1659020780350.png" alt="image.png"></p><hr><h2><span id="q-na-du-wen-ti-zhong-de-huan-du-you-shi-shi-me"><strong>Q: 那读问题中的幻读又是什么？</strong></span><a href="#q-na-du-wen-ti-zhong-de-huan-du-you-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>刚才的”不可重复读“，是一个事务中查询2次结果，<strong>发现值对不上</strong>。<br>而”幻读“，是指一个事务中查询2批结果，发现这2批<strong>数量对不上</strong>，就好象发生了幻觉。<br>就像下图所示展示：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464126365033284-1659020780356.png" alt="image.png"></p><hr><h2><span id="q-rr-ge-chi-ji-bie-zhong-de-mvcc-ji-zhi-ke-yi-jie-jue-shang-mian-de-wen-ti-ma"><strong>Q: RR隔离级别中的MVCC机制可以解决上面的问题吗？</strong></span><a href="#q-rr-ge-chi-ji-bie-zhong-de-mvcc-ji-zhi-ke-yi-jie-jue-shang-mian-de-wen-ti-ma" class="header-anchor">#</a></h2><p>A:<br>可以解决。<br>通过查询的快照读，能够保证只查询到同一批数据。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464132401059589-1659020780360.png" alt="image.png"></p><hr><h2><span id="q-na-ru-guo-xiang-xia-mian-zhe-yang-shi-wu-a-lian-xu-zuo-liang-ci-geng-xin-ni-dan-chun-kao-mvcc-neng-bi-mian-geng-xin-cao-zuo-de-huan-du-me"><strong>Q: 那如果像下面这样， 事务A连续做两次更新呢，单纯靠MVCC能避免更新操作的幻读么？</strong></span><a href="#q-na-ru-guo-xiang-xia-mian-zhe-yang-shi-wu-a-lian-xu-zuo-liang-ci-geng-xin-ni-dan-chun-kao-mvcc-neng-bi-mian-geng-xin-cao-zuo-de-huan-du-me" class="header-anchor">#</a></h2><p>A:<br>如果<strong>只依靠MVCC</strong>，那就无法避免了， 因为update操作是”当前读“，每次取最新版本做更新， 这会导致update中的读操作出现幻读，前后更新的记录数量不一样了。<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464140021048467-1659020780364.png" alt="image.png"></p><hr><h2><span id="q-na-shu-ju-ku-zen-me-chu-li-zhe-chong-2-ci-updete-zhong-jian-zuo-insert-de-huan-du-qing-kuang-ni"><strong>Q: 那数据库怎么处理这种2次updete中间做insert的幻读情况呢？</strong></span><a href="#q-na-shu-ju-ku-zen-me-chu-li-zhe-chong-2-ci-updete-zhong-jian-zuo-insert-de-huan-du-qing-kuang-ni" class="header-anchor">#</a></h2><p>A:<br>之前有了解到， update过程仍然会加锁，</p><p>RR级别会启用一个叫”间隙锁“（Gap锁）的玩意，专门来防这样情况。<br>即调用 update xxx where name ='李四’时， 不仅仅在李四的行上加锁，  更会在中间所有行的间隙、左右边界的两边，加上一个gap间隙锁，就像下面这个图一样：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464152390001303-1659020780369.png" alt="image.png"></p><p>可以看到，订单D的插入过程被update过程的间隙锁拦住了，于是无法插入，置到事务结束才会释放。<br>因此事务中两次update之间的幻读是可以避免的，也能。</p><hr><h2><span id="q-na-xing-suo-jian-xi-suo-next-key-suo-shi-shi-me-qu-bie"><strong>Q: 那行锁、间隙锁、next-key锁是什么区别？</strong></span><a href="#q-na-xing-suo-jian-xi-suo-next-key-suo-shi-shi-me-qu-bie" class="header-anchor">#</a></h2><p>A:<br>行锁就是单个行（单个索引节点）加锁<br>间隙锁就是在行（索引节点之间）加锁<br>next-key就是“行锁+间隙锁”，一起使用。</p><hr><h2><span id="q-ru-guo-name-zhe-ge-zi-duan-bu-shi-suo-yin-er-shi-pu-tong-zi-duan-na-jian-xi-suo-hui-zen-me-jia"><strong>Q: 如果name这个字段不是索引，而是普通字段，那间隙锁会怎么加？</strong></span><a href="#q-ru-guo-name-zhe-ge-zi-duan-bu-shi-suo-yin-er-shi-pu-tong-zi-duan-na-jian-xi-suo-hui-zen-me-jia" class="header-anchor">#</a></h2><p>A:<br>那就会给整个表的所有间隙都加上锁！<br>因为数据库无法确认到底是哪个范围，所以干脆全加上。<br>这就会导致整表锁住，性能很差。</p><hr><h2><span id="q-na-shi-bu-shi-zhi-yao-name-shi-suo-yin-jiu-bu-hui-gei-zheng-ge-biao-quan-jia-jian-xi-suo-liao"><strong>Q: 那是不是只要name是索引，就不会给整个表全加间隙锁了？</strong></span><a href="#q-na-shi-bu-shi-zhi-yao-name-shi-suo-yin-jiu-bu-hui-gei-zheng-ge-biao-quan-jia-jian-xi-suo-liao" class="header-anchor">#</a></h2><p>A:<br>不对， 如果where条件写的有问题，不符合最左匹配原则，那也会导致索引失效， 以至于给整个表加锁。</p><hr><h2><span id="q-gang-cai-kan-dao-shuo-rr-ke-yi-jie-jue-2-ci-select-zhi-jian-de-huan-du-ye-neng-jie-jue-2-ci-update-zhi-jian-de-huan-du-na-wei-shi-me-hen-duo-zi-liao-li-reng-ran-shuo-rr-bu-neng-jie-jue-huan-du"><strong>Q:  刚才看到说RR可以解决2次select之间的幻读， 也能解决2次update之间的幻读， 那为什么很多资料里，仍然说RR不能解决幻读？</strong></span><a href="#q-gang-cai-kan-dao-shuo-rr-ke-yi-jie-jue-2-ci-select-zhi-jian-de-huan-du-ye-neng-jie-jue-2-ci-update-zhi-jian-de-huan-du-na-wei-shi-me-hen-duo-zi-liao-li-reng-ran-shuo-rr-bu-neng-jie-jue-huan-du" class="header-anchor">#</a></h2><p>A:<br>这个问题我也是翻了好多资料， 终于找到了一个合理的解释。<br>看下面这个场景：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464161376010263-1659020780370.png" alt="image.png"></p><p>发现什么区别没，  事务B的insert操作，发生在了事务A的update之前。因此事务B的insert操作没有被间隙锁阻塞。</p><p>而update用的是当前读， 于是更新的数量和 最初select的数量匹配不上了。</p><p>Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读，所以这个场景下，算出现幻读了。</p><p>这也就是下面这个图的来源：<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464168471063981-1659020780375.png" alt="image.png"></p><hr><h2><span id="q-na-chuan-xing-hua-serializable-ge-chi-ji-bie-wei-shi-me-jiu-neng-bi-mian-huan-du-liao"><strong>Q: 那串行化serializable隔离级别，为什么就能避免幻读了？</strong></span><a href="#q-na-chuan-xing-hua-serializable-ge-chi-ji-bie-wei-shi-me-jiu-neng-bi-mian-huan-du-liao" class="header-anchor">#</a></h2><p>A:<br>Se级别时，会从MVCC并发控制退化为基于锁的并发控制（LCBB）。<br>不区别快照读和当前读<br>所有的读操作都是当前读，读加读锁(S锁)，写加写锁(X锁)。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</p><p>这就是我们文章最开头手动加锁的那个过程了。</p>]]></content>
      
      
      <categories>
          
          <category> 后台开发知识 </category>
          
          <category> SQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后台开发,SQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第303场周赛-463名-4题（pair类、var特性、双指针而不是二分）</title>
      <link href="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/"/>
      <url>/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ben-qi-zong-jie">本期总结：</a></li><li><a href="#2352-xiang-deng-xing-lie-dui-https-leetcode-cn-problems-equal-row-and-column-pairs">2352. 相等行列对</a></li><li><a href="#2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode-https-leetcode-cn-problems-design-a-food-rating-system">2353. 设计食物评分系统 - 力扣（LeetCode）</a></li><li><a href="#2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode-https-leetcode-cn-problems-number-of-excellent-pairs">2354. 优质数对的数目 - 力扣（LeetCode）</a></li></ul><!-- tocstop --></div> <p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658763277173.png" alt="1658763277173"></p><p>只记录一下对我而言比较有意义的题目</p><h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2><ol><li>考虑用Pair包装而不是设计class实体类</li><li>var特性可以简化变量名的打印</li><li>双点有序(&gt;k)等问题，优先考虑用双指针而不是二分， 先确定固定哪个点，再看怎么移动，最多就4种情况。</li></ol><h2><span id="2352-xiang-deng-xing-lie-dui"></span><a href="#2352-xiang-deng-xing-lie-dui" class="header-anchor">#</a></h2><p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658763341991.png" alt="1658763341991"></p><p>看着很简单啊，我的想法是直接对每一行搞成一个字符串， 然后做成hasMap，记录这个字符串出现的次数</p><p>在拿列去map里匹配即可</p><p>结果忘记了数字的范围是1-10^9， 并非0-9，不能直接拼，还得加逗号。痛失五分钟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">equalPairs</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ylen</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xlen</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        String[] rows = <span class="keyword">new</span> <span class="title class_">String</span>[ylen];</span><br><span class="line">        String[] cols = <span class="keyword">new</span> <span class="title class_">String</span>[xlen];</span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">                sb.append(grid[y][x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s)) &#123;</span><br><span class="line">                map.put(s, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(s).add(y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">                sb.append(grid[y][x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">                count += map.get(s).size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外java处理字符串和map问题确实比python要麻烦，如果要冲速度，我是不是得学一下python？</p><p>题解里的python，可以快速转数量统计的map</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalPairs</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cnt[col] <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">zip</span>(*grid))</span><br></pre></td></tr></table></figure><h2><span id="2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode"></span><a href="#2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode" class="header-anchor">#</a></h2><p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764007681.png" alt="1658764007681"></p><p>很明显就是一个会更新的优先队列集合</p><p>需要用优先队列加一个检查更新的map实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">            String name;</span><br><span class="line">            String cuisines;</span><br><span class="line">            <span class="type">int</span> rate;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String name, String cuisines, <span class="type">int</span> rate)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.cuisines = cuisines;</span><br><span class="line">                <span class="built_in">this</span>.rate = rate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Queue&lt;Food&gt;&gt; queues;</span><br><span class="line">        Map&lt;String, Food&gt; nowFoodMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FoodRatings</span><span class="params">(String[] foods, String[] cuisines, <span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> foods.length;</span><br><span class="line">            queues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">                <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(foods[i], cuisines[i], ratings[i]);</span><br><span class="line">                nowFoodMap.put(foods[i], food);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!queues.containsKey(cuisines[i])) &#123;</span><br><span class="line">                    queues.put(cuisines[i], <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(</span><br><span class="line">                            a.rate != b.rate ? (b.rate - a.rate): (a.name.compareTo(b.name)))));</span><br><span class="line">                &#125;</span><br><span class="line">                queues.get(cuisines[i]).offer(food);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeRating</span><span class="params">(String food, <span class="type">int</span> newRating)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cu</span> <span class="operator">=</span> nowFoodMap.get(food).cuisines;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(food, cu, newRating);</span><br><span class="line">            nowFoodMap.put(food, food1);</span><br><span class="line">            queues.get(cu).offer(food1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">highestRated</span><span class="params">(String cuisine)</span> &#123;</span><br><span class="line">            Queue&lt;Food&gt; queue = queues.get(cuisine);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (food != nowFoodMap.get(food.name)) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> food.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FoodRatings object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);</span></span><br><span class="line"><span class="comment"> * obj.changeRating(food,newRating);</span></span><br><span class="line"><span class="comment"> * String param_2 = obj.highestRated(cuisine);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>但是定义类的时候比较麻烦，后面可以考虑以下的效率优化：</p><ol><li><p>用Pair做二元组，避免定义内部类麻烦</p></li><li><p>用var避免定义变量类型</p></li></ol><p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764157594.png" alt="1658764157594"></p><h2><span id="2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode"></span><a href="#2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode" class="header-anchor">#</a></h2><p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764316137.png" alt="1658764316137"></p><p>其实这个脑筋急转弯通过纸上推演，很快能得到</p><p><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的1的个数，等同于num1和num2中1的个数总和</p><p>就变成就一个数组中，a[x] + a[y]共有多少对</p><p>这个子问题的解法我想复杂了，竟然想到用二分法。。。又因为很久没写了，对二分不熟了，导致浪费了大量时间确认二分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countExcellentPairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = Arrays.stream(nums).mapToObj(Integer::valueOf).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ontCounts = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span>[] newNums = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : set) &#123;</span><br><span class="line">            newNums[t++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = newNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            ontCounts[i] = Integer.bitCount(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ontCounts);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oneCount</span> <span class="operator">=</span> ontCounts[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">needOneCount</span> <span class="operator">=</span> k - oneCount;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  left + (right - left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ontCounts[mid] &lt; needOneCount) &#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ontCounts[mid] &gt;= needOneCount)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> right;</span><br><span class="line">            result += Math.max(<span class="number">0</span>, ontCounts.length - select);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比二分要更快速的可能是用双指针求解这类问题</p><p>但是双指针的方向可能要好好想想</p><p>即2个指针哪个优先固定， 再移动哪个，哪个方向移动</p><p>这题需要left=0, right=length， 固定住left， 让right移动找到一个位置后，right右边的所有点和left想家肯定都满足&gt; k</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ontCounts.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;left&lt;ontCounts.length;left++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt;=<span class="number">0</span> &amp;&amp; ontCounts[left] + ontCounts[right] &gt;= k) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    result += (ontCounts.length - <span class="number">1</span> - right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS和JUC核心原理</title>
      <link href="/2022/07/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2022/07/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#java-zhong-aqs-jiu-jing-shi-zuo-shi-me-de">java中AQS究竟是做什么的？</a></li><li><a href="#aqs-jian-yao-bu-zou">AQS简要步骤</a></li><li><a href="#aqs-de-zi-yuan-state">AQS的资源state</a><ul><li><a href="#state-ding-yi">state定义</a></li><li><a href="#yi-jing-you-cas-fang-fa-liao-wei-shi-me-zi-yuan-state-huan-yao-ding-yi-cheng-volatile-de">已经有CAS方法了，为什么资源state还要定义成volatile的？</a></li><li><a href="#dui-zi-yuan-de-cao-zuo-shi-me-shi-hou-yong-cas-shi-me-shi-yong-setstate">对资源的操作什么时候用CAS，什么使用setState？</a></li></ul></li><li><a href="#aqs-de-clh-dui-lie">AQS的CLH队列</a><ul><li><a href="#wei-shi-me-xu-yao-yi-ge-clh-dui-lie">为什么需要一个CLH队列</a></li><li><a href="#clh-ben-zhi-shi-yi-ge-queue-rong-qi-ma">CLH本质？是一个Queue容器吗</a></li><li><a href="#ru-dui-shi-zen-me-bao-zheng-an-quan-de">入队是怎么保证安全的？</a></li><li><a href="#chu-dui-guo-cheng-hui-fa-sheng-shi-me">出队过程会发生什么？</a></li></ul></li><li><a href="#aqs-xiang-xi-zi-yuan-huo-qu-liu-cheng">AQS详细资源获取流程</a><ul><li><a href="#1-tryacquire-chang-shi-huo-qu-zi-yuan">1. tryAcquire尝试获取资源</a><ul><li><a href="#reentrantlock-zhong-de-tryacquire-shi-xian">ReentrantLock中的tryAcquire实现</a></li></ul></li><li><a href="#2-addwaiter-tian-jia-dao-deng-dai-dui-lie">2.addWaiter 添加到等待队列</a></li><li><a href="#3-acquirequeued-xun-huan-zu-sai-jing-zheng">3. acquireQueued循环阻塞-竞争</a></li><li><a href="#4-shouldparkafterfailedacquire-jian-cha-shi-fou-ke-yi-zu-sai">4.shouldParkAfterFailedAcquire 检查是否可以阻塞</a></li><li><a href="#5-parkandcheckinterrupt-zu-sai-xian-cheng">5.parkAndCheckInterrupt() 阻塞线程</a><ul><li><a href="#locksupport-park-he-pu-tong-de-wait-notify-du-you-sha-qu-bie">lockSupport.park()和普通的wait|notify都有啥区别？</a></li></ul></li><li><a href="#6-zong-ti-liu-cheng-tu">6.总体流程图</a></li><li><a href="#pin-fan-chu-xian-de-interruptd-zhong-duan-biao-ji-shi-zuo-shi-me-yong-de">频繁出现的interruptd中断标记是做什么用的？</a></li></ul></li><li><a href="#aqs-de-xiang-xi-zi-yuan-shi-fang-liu-cheng">AQS的详细资源释放流程</a></li><li><a href="#aqs-ru-he-shi-xian-gong-ping-he-fei-gong-ping">AQS如何实现公平和非公平？</a><ul><li><a href="#gong-ping-he-fei-gong-ping-suo-de-you-dian-he-que-dian">公平和非公平锁的优点和缺点</a></li><li><a href="#lock-lei-shi-mo-ren-gong-ping-huan-shi-fei-gong-ping">Lock类是默认公平还是非公平？</a></li></ul></li><li><a href="#du-zhan-mo-shi-he-gong-xiang-mo-shi-de-aqs-qu-bie">独占模式和共享模式的AQS区别</a><ul><li><a href="#gong-xiang-mo-shi-xin-hao-liang-semaphore-de-sync-tong-bu-qi">共享模式信号量Semaphore的Sync同步器</a></li></ul></li><li><a href="#aqs-ru-he-chu-li-chong-ru">AQS如何处理重入</a></li><li><a href="#aqs-ru-he-xiang-ying-chao-shi">AQS如何响应超时</a><ul><li><a href="#spinfortimeoutthreshold-shi-shi-me">spinForTimeoutThreshold是什么？</a></li></ul></li><li><a href="#aqs-de-condition-tiao-jian-dui-lie">AQS的condition条件队列</a><ul><li><a href="#condition-de-yong-fa">condition的用法</a></li><li><a href="#condition-he-object-wait-notify-de-qu-bie">condition 和 object.wait/notify的区别</a></li><li><a href="#condition-yuan-li-fen-xi">condition原理分析</a><ul><li><a href="#chao-da-yuan-li-liu-cheng-tu">超大原理流程图</a></li><li><a href="#dai-ma-jie-gou-bu-fen">代码结构部分：</a></li><li><a href="#yuan-li-shi-xian-bu-fen">原理实现部分：</a><ul><li><a href="#deng-dai-dui-lie">等待队列：</a></li><li><a href="#deng-dai-guo-cheng">等待过程</a></li><li><a href="#huan-xing-guo-cheng-signal">唤醒过程signal()</a></li></ul></li></ul></li></ul></li><li><a href="#yong-yu-gao-bing-fa-de-aqs-shi-xian-suo">用于高并发的AQS实现锁</a><ul><li><a href="#du-xie-suo-reentrantreadwritelock">读写锁ReentrantReadWriteLock</a><ul><li><a href="#mei-you-reentrantreadwritelock-qian-jdk-shi-zen-me-shi-xian-du-xie-ji-zhi-de">没有ReentrantReadWriteLock前，jdk是怎么实现读写机制的？</a></li><li><a href="#yong-liao-reentrantreadwritelock-hou-ke-yi-zen-me-zuo">用了ReentrantReadWriteLock后可以怎么做？</a></li><li><a href="#reentrantreadwritelock-zhi-chi-de-te-xing">ReentrantReadWriteLock支持的特性</a></li><li><a href="#du-xie-suo-de-shi-xian-he-xin-yuan-li">读写锁的实现核心原理</a><ul><li><a href="#du-xie-suo-de-state-zi-yuan-zhuang-tai-she-ji">读写锁的state资源状态设计</a></li><li><a href="#xie-suo-de-huo-qu-he-shi-fang">写锁的获取和释放</a></li><li><a href="#du-suo-de-huo-qu-he-shi-fang">读锁的获取和释放</a></li></ul></li><li><a href="#du-xie-suo-de-suo-jiang-ji">读写锁的锁降级</a></li></ul></li><li><a href="#you-chuo-suo-stampedlock">邮戳锁StampedLock</a><ul><li><a href="#du-xie-suo-you-shi-me-que-dian">读写锁有什么缺点？</a></li><li><a href="#you-chuo-suo-wei-shi-me-neng-jie-jue-ji-e">邮戳锁为什么能解决饥饿</a></li><li><a href="#shi-me-shi-hou-yong-du-xie-suo-shi-me-shi-hou-yong-you-chuo-suo">什么时候用读写锁，什么时候用邮戳锁？</a></li><li><a href="#you-chuo-suo-de-que-dian">邮戳锁的缺点</a></li></ul></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="java-zhong-aqs-jiu-jing-shi-zuo-shi-me-de">java中AQS究竟是做什么的？</span><a href="#java-zhong-aqs-jiu-jing-shi-zuo-shi-me-de" class="header-anchor">#</a></h1><p>当你使用java实现一个线程同步的对象时，一定会包含一个问题：</p><p><strong>你该如何保证多个线程访问该对象时，正确地进行阻塞等待，正确地被唤醒？</strong></p><p>关于这个问题，java的设计者认为应该是一套通用的机制</p><p>因此将一套线程阻塞等待以及被唤醒时锁分配的机制称之为AQS</p><p>全称 <strong>A</strong>bstract<strong>Q</strong>uened<strong>S</strong>ynchronizer</p><p>中文名即抽象的队列式同步器 。</p><p>基于AQS，实现了例如ReentenLock之类的经典JUC类。</p><h1><span id="aqs-jian-yao-bu-zou">AQS简要步骤</span><a href="#aqs-jian-yao-bu-zou" class="header-anchor">#</a></h1><ol><li><p>线程访问资源，如果资源足够，则把线程封装成一个Node，设置为活跃线程进入CLH队列，并扣去资源</p></li><li><p>资源不足，则变成等待线程Node，也进入CLH队列</p></li><li><p>CLH是一个如下图所示的双向链式队列</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658065224905.png" alt="1658065224905"></p></li></ol><h1><span id="aqs-de-zi-yuan-state">AQS的资源state</span><a href="#aqs-de-zi-yuan-state" class="header-anchor">#</a></h1><h2><span id="state-ding-yi">state定义</span><a href="#state-ding-yi" class="header-anchor">#</a></h2><p>AQS中的资源是一个int值，而且是volatile的，并提供了3个方法给子类使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cas方法</span></span><br><span class="line">compareAndSetState(<span class="type">int</span> oldState, <span class="type">int</span> newState);</span><br></pre></td></tr></table></figure><p>如果state上限只有1，那么就是独占模式Exclusive，例如 ReentrantLock</p><p>如果state上限大于1，那就是共享模式Share，例如 Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p><h2><span id="yi-jing-you-cas-fang-fa-liao-wei-shi-me-zi-yuan-state-huan-yao-ding-yi-cheng-volatile-de">已经有CAS方法了，为什么资源state还要定义成volatile的？</span><a href="#yi-jing-you-cas-fang-fa-liao-wei-shi-me-zi-yuan-state-huan-yao-ding-yi-cheng-volatile-de" class="header-anchor">#</a></h2><p>对外暴露的getter/setter方法，是走不了CAS的。而且setter/getter没有被synchronized修饰。所以必须要volatile，保证可见性</p><p>这样基于AQS的实现可以直接通过getter/setter操作state变量，并且保证可见性，也避免重排序带来的影响。比如CountDownLatch，ReentrantReadWriteLock，Semaphore都有体现（各种getState、setState）</p><h2><span id="dui-zi-yuan-de-cao-zuo-shi-me-shi-hou-yong-cas-shi-me-shi-yong-setstate">对资源的操作什么时候用CAS，什么使用setState？</span><a href="#dui-zi-yuan-de-cao-zuo-shi-me-shi-hou-yong-cas-shi-me-shi-yong-setstate" class="header-anchor">#</a></h2><p>volatile的state成员有一个问题，就是如果是复合操作的话不能保证复合操作的原子性</p><p>因此涉及 state增减的情况，采用CAS</p><p>如果是state设置成某个固定值，则使用setState</p><h1><span id="aqs-de-clh-dui-lie">AQS的CLH队列</span><a href="#aqs-de-clh-dui-lie" class="header-anchor">#</a></h1><h2><span id="wei-shi-me-xu-yao-yi-ge-clh-dui-lie">为什么需要一个CLH队列</span><a href="#wei-shi-me-xu-yao-yi-ge-clh-dui-lie" class="header-anchor">#</a></h2><p>这个队列的目的是为了公平锁的实现</p><p>即为了保证先到先得，要求每个线程封装后的Node按顺序拼接起来。</p><h2><span id="clh-ben-zhi-shi-yi-ge-queue-rong-qi-ma">CLH本质？是一个Queue容器吗</span><a href="#clh-ben-zhi-shi-yi-ge-queue-rong-qi-ma" class="header-anchor">#</a></h2><p>不是的，本质上是一个链表式的队列</p><p>因此核心在于链表节点Node的定义</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658066659779.png" alt="1658066659779"></p><p>除了比较容易想到的prev和next指针外</p><p>还包含了该节点内的线程</p><p>以及 waitStatus 等待状态</p><p>4种等待状态如下：</p><ul><li>CANCELLED（1）： 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</li><li>SIGNAL（-1）：后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</li><li>CONDITION（-2） ： 点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</li><li>PROPAGATE（-3）   ： 表示下一次共享式同步状态获取将会无条件地传播下去</li><li>INIT（ 0）:</li></ul><h2><span id="ru-dui-shi-zen-me-bao-zheng-an-quan-de">入队是怎么保证安全的？</span><a href="#ru-dui-shi-zen-me-bao-zheng-an-quan-de" class="header-anchor">#</a></h2><p>入队过程可能引发冲突</p><p>因此会用CAS保障入队安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//多次尝试，直到成功为止</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置为尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="chu-dui-guo-cheng-hui-fa-sheng-shi-me">出队过程会发生什么？</span><a href="#chu-dui-guo-cheng-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2><p>一旦有节点出队，说明有线程释放资源了，队头的等待线程可以开始尝试获取了。</p><p>于是首节点的线程释放同步状态后，将会唤醒它的后继节点（next）</p><p>而后继节点将会在获取同步状态成功时将自己设置为首节点</p><p>**注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态 **</p><h1><span id="aqs-xiang-xi-zi-yuan-huo-qu-liu-cheng">AQS详细资源获取流程</span><a href="#aqs-xiang-xi-zi-yuan-huo-qu-liu-cheng" class="header-anchor">#</a></h1><h2><span id="1-tryacquire-chang-shi-huo-qu-zi-yuan">1. tryAcquire尝试获取资源</span><a href="#1-tryacquire-chang-shi-huo-qu-zi-yuan" class="header-anchor">#</a></h2><p>AQS使用的设计模式是模板方法模式。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 发现中断过，则触发中断异常</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即AQS抽象基类AbstractQueuedSynchronizer给外部调用时，都是调的acquire(int arg)方法。这个方法的内容是写死的。<br>而acquire中，需要调用<strong>tryAcquire(arg)， 这个方法是需要子类实现的，作用是判断资源是否足够获取arg个</strong></p><p><a href="https://blog.csdn.net/Mutou_ren/article/details/103864432">(2条消息) AQS子类的tryAcquire和tryRelease的实现_Mutou_ren的博客-CSDN博客_aqs tryacquire</a></p><h3><span id="reentrantlock-zhong-de-tryacquire-shi-xian">ReentrantLock中的tryAcquire实现</span><a href="#reentrantlock-zhong-de-tryacquire-shi-xian" class="header-anchor">#</a></h3><p>这里暂时只谈论一种容易理解的tryAcuire实现，其他附加特性的tryAcquire先不提。</p><p>里面主要就做这几件事：</p><ol><li>获取当前锁的资源数</li><li>资源数为0，说明可以抢， 确认是前置节点是头节点，进行CAS试图争抢，抢成功就返回true，并设置当前线程</li><li>没抢成功，返回false</li><li>如果是重入的，则直接set设置增加后的状态值，状态值此时不一定为0和1了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// state==0代表当前没有锁，可以进行获取</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 非公平才有的判断，会判断是否还有前驱节点，直接自己为头节点了或者同步队列空了才会继续后面的锁的获取操作</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() </span><br><span class="line">                     <span class="comment">//CAS设置state为acquires，成功后标记exclusiveOwnerThread为当前线程</span></span><br><span class="line">                    &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前占有线程等于自己，代表重入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="comment">// 出现负数，说明溢出了</span></span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// 因为是重入操作，可以直接进行state的增加，所以不需要CAS</span></span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="2-addwaiter-tian-jia-dao-deng-dai-dui-lie">2.addWaiter 添加到等待队列</span><a href="#2-addwaiter-tian-jia-dao-deng-dai-dui-lie" class="header-anchor">#</a></h2><p>当获取资源失败，会进行addWaiter(Node.EXCLUSIVE)， arg)。</p><p>目的是创建一个等待节点Node，并添加到等待队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过CAS竞争队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 竞争队尾失败，于是进行CAS频繁循环竞争队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-acquirequeued-xun-huan-zu-sai-jing-zheng">3. acquireQueued循环阻塞-竞争</span><a href="#3-acquirequeued-xun-huan-zu-sai-jing-zheng" class="header-anchor">#</a></h2><p>，并在 &quot;处于头节点时尝试获取资源-&gt;睡眠-&gt;唤醒“中循环。</p><p>当已经跑完任务的线程释放资源时，会唤醒之前阻塞的线程。</p><p>当被唤醒后，就会检查自己是不是头节点，如果不是，且认为可以阻塞，那就继续睡觉去了</p><p><a href="https://www.cnblogs.com/HuiShouGuoQu/p/13596507.html">AQS（acquireQueued(Node, int) 3）–队列同步器 - 小窝蜗 - 博客园 (cnblogs.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 标识是否获取资源失败                </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前线程是否被中断过</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前继节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前继节点为头结点，说明排队马上排到自己了，可以尝试获取资源，若获取资源成功，则执行下述操作</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 说明前继节点已经释放掉资源了，将其next置空，好让虚拟机提前回收掉前继节点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 获取资源成功，修改标记位</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若前继节点不是头结点，或者获取资源失败，</span></span><br><span class="line">            <span class="comment">// 则需要判断是否需要阻塞该节点持有的线程</span></span><br><span class="line">            <span class="comment">// 若可以阻塞，则继续执行parkAndCheckInterrupt()函数，</span></span><br><span class="line">            <span class="comment">// 将该线程阻塞直至被唤醒</span></span><br><span class="line">            <span class="comment">// 唤醒后会检查是否已经被中断，若返回true，则将interrupted标志置于true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终获取资源失败，则当前节点放弃获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2><span id="4-shouldparkafterfailedacquire-jian-cha-shi-fou-ke-yi-zu-sai">4.shouldParkAfterFailedAcquire 检查是否可以阻塞</span><a href="#4-shouldparkafterfailedacquire-jian-cha-shi-fou-ke-yi-zu-sai" class="header-anchor">#</a></h2><p>该方法不会直接阻塞线程，因为一旦线程挂起，后续就只能通过唤醒机制，中间还发生了内核态用户态切换，消耗很大。</p><p>因此会先不断确认前继节点的实际状态，在只能阻塞的情况下才会去阻塞。</p><p>并且会过滤掉cancel的线程节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取前继节点的等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果等待状态为Node.SIGNAL(-1)，则直接返回true即可以阻塞</span></span><br><span class="line">    <span class="comment">// 因为这说明前继节点完成资源的释放或者中断后，会主动唤醒后继节点的（这也即是signal信号的含义），因此方法外面不用再反复CAS了，直接阻塞吧</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前继节点的等待值大于0即CANCELLED（1）,说明前继节点的线程发生过cancel动作</span></span><br><span class="line">    <span class="comment">// 那就继续往前遍历，直到当前节点的前继节点的状态不为cancel</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 前继节点的等待状态不为SIGNAL(-1)，也不为Cancel(1)</span></span><br><span class="line">        <span class="comment">// 那么只能是PROPAGATE(-3)或者CONDITION(-2)或者INITIAL（0）</span></span><br><span class="line">        <span class="comment">// 直接设置成SIGNAL，下一次还没CAS成功，就直接睡觉了</span></span><br><span class="line">        <span class="comment">// 因此在前面所有节点没辩护的情况下， 最多一次之后就会返回true让外面阻塞</span></span><br><span class="line">       compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="5-parkandcheckinterrupt-zu-sai-xian-cheng">5.parkAndCheckInterrupt()  阻塞线程</span><a href="#5-parkandcheckinterrupt-zu-sai-xian-cheng" class="header-anchor">#</a></h2><p>使用LockSupport.park来阻塞当前这个对象所在的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">             LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">     <span class="comment">// 确认是否是中断导致的park结束，并清除中断标记</span></span><br><span class="line">             <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="locksupport-park-he-pu-tong-de-wait-notify-du-you-sha-qu-bie">lockSupport.park()和普通的wait|notify都有啥区别？</span><a href="#locksupport-park-he-pu-tong-de-wait-notify-du-you-sha-qu-bie" class="header-anchor">#</a></h3><ol><li>面向的主体不一样。LockSuport主要是针对Thread进进行阻塞处理，可以指定阻塞队列的目标对象，每次可以指定具体的线程唤醒。Object.wait()是以对象为纬度，阻塞当前的线程和唤醒单个(随机)或者所有线程。</li><li>实现机制不同。虽然LockSuport可以指定monitor的object对象，但和object.wait()，两者的阻塞队列并不交叉。可以看下测试例子。object.notifyAll()不能唤醒LockSupport的阻塞Thread.</li></ol><p><a href="https://www.jianshu.com/p/1f16b838ccd8">底层实现原理</a><br>简而言之，是用mutex和condition保护了一个_counter的变量，当park时，这个变量置为了0，当unpark时，这个变量置为1。<br>底层用的C语言的pthread_mutex_unlock、pthread_cond_wait 、pthread_cond_signal ，但是针对了mutex和_cond两个变量进行加锁。</p><h2><span id="6-zong-ti-liu-cheng-tu">6.总体流程图</span><a href="#6-zong-ti-liu-cheng-tu" class="header-anchor">#</a></h2><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658647899304.png" alt="1658647899304"></p><h2><span id="pin-fan-chu-xian-de-interruptd-zhong-duan-biao-ji-shi-zuo-shi-me-yong-de">频繁出现的interruptd中断标记是做什么用的？</span><a href="#pin-fan-chu-xian-de-interruptd-zhong-duan-biao-ji-shi-zuo-shi-me-yong-de" class="header-anchor">#</a></h2><p><a href="https://blog.csdn.net/u010499733/article/details/106982708/">(2条消息) JUC并发编程基石AQS之中断_LuxBai的博客-CSDN博客_aqs中断</a></p><p><a href="https://www.jianshu.com/p/218f7f81d2da">看！源码之AQS中断设计与实现(内涵jvm部分实现) - 简书 (jianshu.com)</a></p><p>对线程调用 t1.interrupt();时</p><p>会导致 LockSupport.park() 阻塞的线程重新被唤醒</p><p>即有两种唤醒情况： 被前置节点唤醒，或者被外部中断唤醒</p><p>这时候要根据调用的acuire类型决定是否在中断发生时结束锁的获取。</p><p>上面介绍的是不可中断锁。</p><p>在parkAndCheckInterrupt中，当park结束阻塞时时,使用的是 Thread.interrupted() 而不是 .isInterrupted() 来返回中断状态</p><p>因为前者会返回线程当前的中断标记状态<strong>同时清除中断标志位</strong>（置为false）</p><p>外层CAS循环时， 就不会让线程受中断标记影响，只是记录一下是否发生过中断</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658419508199.png" alt="1658419508199"></p><p>当获取锁成功后，如果发现有过线程中断，则会触发中断异常，</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658419648382.png" alt="1658419648382"></p><p>之后便由获取锁的调用者自己决定是否要处理线程中断。像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么另一种情况就是可中断锁了。</p><p>ReentranLock有一个lockInterruptibly()方法就是这种情况</p><p>线程被唤醒时，如果发现自己被中断过，就会直接抛异常而不是继续获取锁</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658419756962.png" alt="1658419756962"></p><p>因此如果你的线程对中断很敏感，那么就是用可中断锁，及时响应。</p><p>如果不敏感，也要注意处理中断异常。</p><h1><span id="aqs-de-xiang-xi-zi-yuan-shi-fang-liu-cheng">AQS的详细资源释放流程</span><a href="#aqs-de-xiang-xi-zi-yuan-shi-fang-liu-cheng" class="header-anchor">#</a></h1><p>首先AQS提供的模板方法为release方法。</p><p>核心逻辑就是对资源进行尝试性释放</p><p>如果成功，就唤醒等待队列中的第一个头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否释放成功，tryRelease是子类要实现的方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 判断头节点是否正在阻塞中，是的话唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒头节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下ReteenLock中的tryRelease实现</p><p>就是减一下资源值。</p><p>当资源值清零，则说明可以解除了对当前点的占用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">// 设置当前占用线程为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要CAS，因为只有持有锁的人才能做释放，不担心竞争</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="aqs-ru-he-shi-xian-gong-ping-he-fei-gong-ping">AQS如何实现公平和非公平？</span><a href="#aqs-ru-he-shi-xian-gong-ping-he-fei-gong-ping" class="header-anchor">#</a></h1><p>以ReteenLock为例，它内部tryAcquire有两种同步器的实现</p><ul><li><p>非公平同步器NonfairSync</p></li><li><p>公平同步器FairSync</p></li></ul><p>公平同步器和非公平同步器都是ReentrantLock中定义的一个static内部类</p><p>ReentrantLock根据配置的不同，使用这2个同步器做资源的获取和同步操作</p><p>他们二者的提供的lock操作，本质上就是AQS的acquire(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二者在公平和非公平的实现区别上，就是唤醒线程后，只有等待队列的队头节点才会尝试竞争。</p><p>而非公平锁是只要唤醒了就可以尝试竞争。</p><p>因此核心区别在于hasQueuedPredecessors方法！</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658665318338.png" alt="1658665318338"></p><h2><span id="gong-ping-he-fei-gong-ping-suo-de-you-dian-he-que-dian">公平和非公平锁的优点和缺点</span><a href="#gong-ping-he-fei-gong-ping-suo-de-you-dian-he-que-dian" class="header-anchor">#</a></h2><ol><li>饥饿问题</li></ol><p>非公平锁可能引发“饥饿”，即一个线程反复抢占获取，而其他线程一直拿不到。</p><p>而公平锁不存在饥饿，只要排上队了就一定能拿到</p><ol start="2"><li><p>性能问题</p><p>非公平锁的平均性能比公平锁要高， 因为非公平锁中所有人都可以CAS抢占，如果同步块的时间非常短，那么可能所有人都不需要阻塞，减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p></li></ol><p>性能测试中公平锁的耗时是非公平锁的94.3倍， 总切换次数是133倍</p><h2><span id="lock-lei-shi-mo-ren-gong-ping-huan-shi-fei-gong-ping">Lock类是默认公平还是非公平？</span><a href="#lock-lei-shi-mo-ren-gong-ping-huan-shi-fei-gong-ping" class="header-anchor">#</a></h2><p>默认是非公平的，原因就是上文考虑的性能差距过大问题， 因此公平锁只能用于特定对性能要求不高且饥饿发生概率不大的场景中。</p><h1><span id="du-zhan-mo-shi-he-gong-xiang-mo-shi-de-aqs-qu-bie">独占模式和共享模式的AQS区别</span><a href="#du-zhan-mo-shi-he-gong-xiang-mo-shi-de-aqs-qu-bie" class="header-anchor">#</a></h1><ul><li><p>名字上， 共享模式都会带一个shard</p></li><li><p>返回值上，独占模式相关acuire方法放回的是boolean类型， 而共享模式返回的是int值</p></li><li><p>核心概念上， 区别在于同一时刻能否有多个线程可以获取到其同步状态</p></li><li><p>释放时，共享模式需要用CAS进行释放， 而独占模式的release方法则不需要，直接setState即可。</p></li><li><p>共享模式应用：信号量、读写锁</p></li></ul><h2><span id="gong-xiang-mo-shi-xin-hao-liang-semaphore-de-sync-tong-bu-qi">共享模式信号量Semaphore的Sync同步器</span><a href="#gong-xiang-mo-shi-xin-hao-liang-semaphore-de-sync-tong-bu-qi" class="header-anchor">#</a></h2><p>先实现了一个静态内部类Sync</p><p>和上面的RLock类一个区别在于需要state初始化值，不一定为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="type">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再继承实现了FairSync和NoFairSync</p><p>使用CAS实现值的增加或者减少</p><p>公平/非公平的区别同样是hasQueuedPredecessors的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 队头判断，公平锁核心</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 信号量不足，直接返回负数</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 能抢成功，返回修改后的值，抢失败则for循环继续</span></span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="aqs-ru-he-chu-li-chong-ru">AQS如何处理重入</span><a href="#aqs-ru-he-chu-li-chong-ru" class="header-anchor">#</a></h1><p>通过current == getExclusiveOwnerThread()来判断并进行非CAS的setState操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">    <span class="comment">// 出现负数，说明溢出了</span></span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    <span class="comment">// 因为是重入操作，可以直接进行state的增加，所以不需要CAS</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意处理重入问题时，如果是独占锁，是可以直接setState而不需要CAS的，因为不会竞争式地重入！</p><p>ReentrantLock释放时，也会处理重入，关键点就是对getState() - release后的处理，是否返回true或者false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有资源数为0才会解锁</span></span><br><span class="line">        <span class="comment">// 才算释放成功，否则这锁还是占住了</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="aqs-ru-he-xiang-ying-chao-shi">AQS如何响应超时</span><a href="#aqs-ru-he-xiang-ying-chao-shi" class="header-anchor">#</a></h1><p>AQS提供的方法中带有Nanos后缀的方法就是支持超时中断的方法。</p><p>核心逻辑就是每次阻塞前，确认nanosTimeout是否已经超时了。</p><p>每次唤醒时，将nanosTimeout减去阻塞所花的时间，重新确认，并修改lastTime</p><p>关键部分见下图</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658648788193.png" alt="1658648788193"></p><h2><span id="spinfortimeoutthreshold-shi-shi-me">spinForTimeoutThreshold是什么？</span><a href="#spinfortimeoutthreshold-shi-shi-me" class="header-anchor">#</a></h2><p>首先这个值是写死的1000L即1000纳秒</p><p>1000纳秒是个非常小的数字，而小于等于1000纳秒的超时等待，无法做到十分的精确，那么就不要使用这么短的一个超时时间去影响超时计算的精确性，所以这时线程不做超时等待，直接做自旋就好了。</p><h1><span id="aqs-de-condition-tiao-jian-dui-lie">AQS的condition条件队列</span><a href="#aqs-de-condition-tiao-jian-dui-lie" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/glamour2015/article/details/105499426/">(2条消息) AQS条件队列及中断机制_glamour2015的博客-CSDN博客_aqs中断</a></p><h2><span id="condition-de-yong-fa">condition的用法</span><a href="#condition-de-yong-fa" class="header-anchor">#</a></h2><p>condition用于显式的等待通知，等待过程可以挂起并释放锁，唤醒后重新拿到锁。</p><p>和直接用lock\unlock去做等待通知的区别在于，lock是不会释放锁的，但是利用的condition的await则可以，且唤醒后会自动重新拿回锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// if(xxxx)判断不满足条件，等待，释放锁</span></span><br><span class="line">            condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 做完事情了，通知condition上等待的开始抢占</span></span><br><span class="line">            condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也提供了一些支持中断、支持超时的等待方法</p><h2><span id="condition-he-object-wait-notify-de-qu-bie">condition 和 object.wait/notify的区别</span><a href="#condition-he-object-wait-notify-de-qu-bie" class="header-anchor">#</a></h2><ol><li><p>object的wait依赖sync， 只能最多有一个等待队列。  而通过newCondition可以制造多个等待队列</p></li><li><p>wait不支持中断，而condition支持</p></li><li><p>condition支持等待特定时间</p></li></ol><h2><span id="condition-yuan-li-fen-xi">condition原理分析</span><a href="#condition-yuan-li-fen-xi" class="header-anchor">#</a></h2><h3><span id="chao-da-yuan-li-liu-cheng-tu">超大原理流程图</span><a href="#chao-da-yuan-li-liu-cheng-tu" class="header-anchor">#</a></h3><ul><li><p>await()， 简单来讲就是把当前线程放入condition的等待队列中，然后调用LockSupport.park拉起线程。如果被其他线程通过signal唤醒，则放入同步队列中竞争锁，竞争成功则返回，否则继续竞争。</p></li><li><p>signal方法，就是拿到condition的等待队列头节点，用cas修改节点状态，改成功则唤醒线程。但有可能被别人抢先，所以需要cas操作。</p></li></ul><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/7f51fc61f099394d01172d9c0b622ff815037302.png" alt="dd"></p><h3><span id="dai-ma-jie-gou-bu-fen">代码结构部分：</span><a href="#dai-ma-jie-gou-bu-fen" class="header-anchor">#</a></h3><p>​Lock提供了newCondition接口给外部锁调用</p><p>​而newCondition()返回的Condition是一个接口</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1659283503458.png" alt="1659283503458"></p><p>​这个接口的实现类是ConditionObject，放在AQS抽象类的内部类中</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1659283517022.png" alt="1659283517022"></p><h3><span id="yuan-li-shi-xian-bu-fen">原理实现部分：</span><a href="#yuan-li-shi-xian-bu-fen" class="header-anchor">#</a></h3><h4><span id="deng-dai-dui-lie">等待队列：</span><a href="#deng-dai-dui-lie" class="header-anchor">#</a></h4><ul><li><p>每个condition都有一个属于自己的等待队列</p></li><li><p>每次调用condition.await， 就插入到等待队列尾部</p></li><li><p>等待队列插入封装线程的节点时不需要在尾部CAS， 因为必须先获取锁，才能调用await，因此不用CAS竞争</p></li><li><p>每个Lock只有一个同步队列（用于lock()时阻塞和竞争用）， 但是可能会有多个等待队列（用于condition的await）</p></li></ul><h4><span id="deng-dai-guo-cheng">等待过程</span><a href="#deng-dai-guo-cheng" class="header-anchor">#</a></h4><ol><li><p>添加线程到condition的等待队列尾部</p></li><li><p>释放占用的锁，并唤醒同步队列的后继节点</p></li><li><p>此时肯定不在aqs的同步队列中了， 用park方法进入阻塞状态</p></li><li><p>被唤醒，唤醒时可能是通过sign()被人放入了同步队列， 也可能是被中断唤醒，因此要做checkInterruptWhileWaiting检查看是否继续， 如果同意继续，就继续睡眠，直到进入同步队列</p></li><li><p>尝试acquireQueued竞争和抢占state同步状态</p></li><li><p>退出前，顺带用unlinkCancelledWaiters清理已经不是CONDITION状态的等待队列节点</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 添加本线程到等待队列尾部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁，唤醒同步队列中的后继节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果已经在同步队列中了，说明被成功sign唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 阻塞挂起</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 确认是否需要中断时就退出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在同步队列中，那就按同步队列的规则在队列中用CAS竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 清理已经不是CONDITION状态的等待队列节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="huan-xing-guo-cheng-signal">唤醒过程signal()</span><a href="#huan-xing-guo-cheng-signal" class="header-anchor">#</a></h4><ol><li><p>检查调用signal时，是否当前线程获取了锁，不是则抛异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br></pre></td></tr></table></figure></li><li><p>获取condition队列中的第一个等待节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Node</span> first = firstWaiter;</span><br><span class="line"><span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">doSignal</span>(first);</span><br></pre></td></tr></table></figure></li><li><p>用CAS清除CONDITION状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>调用AQS的enq(firstWaitNode)，将这个节点放入到同步队列的队尾（需要CAS支撑？因为可能是共享的，即使获取了锁也需要竞争)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br></pre></td></tr></table></figure></li><li><p>移动入同步队列成功后（可能经历了几次CAS），再用unpark方法唤醒，那个线程就进入了上面代码中Park之后的部分了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">    LockSupport.unpark(node.thread);</span><br></pre></td></tr></table></figure></li><li><p>如果是signalAll方法，则等待队列中每个节点都执行一次signal方法，全部移入同步队列中并唤醒（唤醒后他们很可能还会因为抢不到资源而阻塞，但队列位置不同了，也无法再通过sign唤醒了）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">    first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    transferForSignal(first);</span><br><span class="line">    first = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h1><span id="yong-yu-gao-bing-fa-de-aqs-shi-xian-suo">用于高并发的AQS实现锁</span><a href="#yong-yu-gao-bing-fa-de-aqs-shi-xian-suo" class="header-anchor">#</a></h1><p><a href="https://segmentfault.com/a/1190000041266961?sort=newest">JAVA并发编程——ReentrantReadWriteLock锁降级和StampedLock - SegmentFault 思否</a></p><h2><span id="du-xie-suo-reentrantreadwritelock">读写锁ReentrantReadWriteLock</span><a href="#du-xie-suo-reentrantreadwritelock" class="header-anchor">#</a></h2><p>读写锁，顾名思义，用于读多写少的场景，这种情况下一般读是没必要强行做互斥的。</p><h3><span id="mei-you-reentrantreadwritelock-qian-jdk-shi-zen-me-shi-xian-du-xie-ji-zhi-de">没有ReentrantReadWriteLock前，jdk是怎么实现读写机制的？</span><a href="#mei-you-reentrantreadwritelock-qian-jdk-shi-zen-me-shi-xian-du-xie-ji-zhi-de" class="header-anchor">#</a></h3><p>jdk5之前是没有读写锁的。</p><p>因此需要手写一套等待和通知机制。</p><p>写操作开始时，所有晚于写操作的读操作会通过wait进入阻塞状态。</p><p>写操作完成后，主动用notifyAll进行通知，其他的读操作再继续执行</p><p>写操作和写操作之间的同步则通过sync关键字保障同步</p><h3><span id="yong-liao-reentrantreadwritelock-hou-ke-yi-zen-me-zuo">用了ReentrantReadWriteLock后可以怎么做？</span><a href="#yong-liao-reentrantreadwritelock-hou-ke-yi-zen-me-zuo" class="header-anchor">#</a></h3><p>提供了读锁和写锁</p><p>读的时候获取读锁</p><p>写的时候获取写锁</p><p>一旦写锁lock住，后面的读写都会阻塞住，直到写锁被释放。</p><p>代码示例: 一个用HashMap + 读写锁实现的安全Cache(代码出自《java并发编程艺术）)</p><p>关注里面什么时候用r.lock，什么时候用的w.lock</p><p>且都用了finally来保证锁的释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">    <span class="comment">// 获取一个key对应的value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        r.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> map.get(key);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    r.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置key对应的value，并返回旧的value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空所有的内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    map.clear();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="reentrantreadwritelock-zhi-chi-de-te-xing">ReentrantReadWriteLock支持的特性</span><a href="#reentrantreadwritelock-zhi-chi-de-te-xing" class="header-anchor">#</a></h3><p>支持公平和非公平锁的实现：提供了带Fair的读写锁，吞吐量仍旧是非公平优先</p><p>支持重进入： 写线程获取写锁后， 可以再次基于这个线程获取写锁或者读进行重入</p><h3><span id="du-xie-suo-de-shi-xian-he-xin-yuan-li">读写锁的实现核心原理</span><a href="#du-xie-suo-de-shi-xian-he-xin-yuan-li" class="header-anchor">#</a></h3><h4><span id="du-xie-suo-de-state-zi-yuan-zhuang-tai-she-ji">读写锁的state资源状态设计</span><a href="#du-xie-suo-de-state-zi-yuan-zhuang-tai-she-ji" class="header-anchor">#</a></h4><p>因为AQS只提供了getState()和setState（）两个方法来表示状态， 为了不引入新的成员破坏设计，仍旧基于一个state值来实现读写状态。</p><p>state是一个32位的int值， 此时前16位表示写锁的重入数量， 后16位表示为写锁持有的数量。</p><p>可直接通过excludesiveCount(getState())得到写锁的数量值。</p><h4><span id="xie-suo-de-huo-qu-he-shi-fang">写锁的获取和释放</span><a href="#xie-suo-de-huo-qu-he-shi-fang" class="header-anchor">#</a></h4><p>核心关键点：</p><ol><li><p>写锁属于独占锁，因此实现和调用的都是tryAcquire方法，不带shard</p></li><li><p>发现有读锁的时候，会直接false获取写锁失败</p></li><li><p>写锁支持重入，重入时同样不需要CAS</p></li><li><p>公平锁仍然会考虑头节点问题，非头节点直接获取写锁失败</p></li></ol><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658673384503.png" alt="1658673384503"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="du-suo-de-huo-qu-he-shi-fang">读锁的获取和释放</span><a href="#du-suo-de-huo-qu-he-shi-fang" class="header-anchor">#</a></h4><ol><li><p>读锁属于共享锁，因此相关方法都带了一个shard</p></li><li><p>读锁中对state的处理都多了一个1&lt;&lt;16</p></li><li><p>读锁是共享锁，所以tryAcquire方法中就已经在一直做CAS试图获取读锁</p><p><strong>读锁之间不存在阻塞只有CAS，除非遇到写锁，才有可能在外层阻塞</strong></p></li><li><p>存在写锁， 但如果是重入场景（即同一个线程），则允许读锁的重入，这是下文锁降级的应用基础</p></li><li><p>JDK6中引入了当前线程读取读锁的次数getHoldCount，增加了threadLocal来保存各线程读锁的次数情况，实现比较复杂。下面只给出去掉hold的代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">// 一直处理，读锁竞争都是CAS，不存在阻塞！</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 有写锁且不是重入，返回-1获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cas修改值</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) </span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="du-xie-suo-de-suo-jiang-ji">读写锁的锁降级</span><a href="#du-xie-suo-de-suo-jiang-ji" class="header-anchor">#</a></h3><p>说人话能一个线程同时加2个锁，支持逐步释放。就是当你在一个线程中需要操作完数据完后马上读数据，且希望数据在方法结束前不会变（避免脏读），可以先加写锁，在写完后加读锁，  然后释放写锁， 此时还会保留读锁（降级）， 就能保证data的正常使用。</p><p>锁降级并非一个特性， 只是一种应用做法，即当你涉及写完要马上读数据操作的情况，可以先加读锁，再释放写锁！</p><p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658670285725.png" alt="1658670285725"></p><h2><span id="you-chuo-suo-stampedlock">邮戳锁StampedLock</span><a href="#you-chuo-suo-stampedlock" class="header-anchor">#</a></h2><h3><span id="du-xie-suo-you-shi-me-que-dian">读写锁有什么缺点？</span><a href="#du-xie-suo-you-shi-me-que-dian" class="header-anchor">#</a></h3><p>读写锁容易造成写饥饿。例如读有9999+的时候，写动作就得等9999+结束才能触发</p><p>即读的动作占用了太多写动作的等待时间了。</p><h3><span id="you-chuo-suo-wei-shi-me-neng-jie-jue-ji-e">邮戳锁为什么能解决饥饿</span><a href="#you-chuo-suo-wei-shi-me-neng-jie-jue-ji-e" class="header-anchor">#</a></h3><p>邮戳锁提供了一个乐观读的方法</p><p>这个方法并不需解锁动作，它也不会去阻塞写动作</p><p>只有当发现邮戳（可以理解为数据库MVCC里的版本号）有变化</p><p>则升级为悲观读，以期待读到最新的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前邮戳，这个方法不会阻塞写方法！</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 校验此时是否邮戳不匹配</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 如果不匹配，说明发生了写操作！读动作最好等写动作结束后再触发！</span></span><br><span class="line"><span class="comment">// 锁升级 为悲观读readLock</span></span><br><span class="line">    stamp = stampedLock.readLock();<span class="comment">//锁升级为悲观读</span></span><br><span class="line">    <span class="comment">// 处理...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    stampedLock.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="shi-me-shi-hou-yong-du-xie-suo-shi-me-shi-hou-yong-you-chuo-suo">什么时候用读写锁，什么时候用邮戳锁？</span><a href="#shi-me-shi-hou-yong-du-xie-suo-shi-me-shi-hou-yong-you-chuo-suo" class="header-anchor">#</a></h3><p>读写锁是读可以阻塞写，读是优先的！</p><p>而邮戳锁中，只有写才可以阻塞读， 写是优先的！</p><p><strong>因此读动作重要的话选读写锁， 如果写动作（写要及时响应）比较重要的话则选邮戳锁</strong></p><h3><span id="you-chuo-suo-de-que-dian">邮戳锁的缺点</span><a href="#you-chuo-suo-de-que-dian" class="header-anchor">#</a></h3><ul><li><p>StampedLock 不支持重入，如果写锁之后再做写，就阻塞了</p></li><li><p>StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</p></li><li><p>使用 StampedLock一定不要调用中断操作，即不要调用interrupt() 方法</p></li></ul><p>​        如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly()和写锁writeLockInterruptibly()</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/2022/07/10/%E9%9A%8F%E7%AC%94/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/"/>
      <url>/2022/07/10/%E9%9A%8F%E7%AC%94/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/</url>
      
        <content type="html"><![CDATA[<h2><span id="bai-tuo-guo-qu-lun">摆脱过去论</span><a href="#bai-tuo-guo-qu-lun" class="header-anchor">#</a></h2><p>封闭自己不愿接触外界，因为自己遭遇了不公的对待</p><p>哀叹家暴，导致自己无法自立</p><p>因为脸红恐惧症，无法接触对方……</p><p>本质上都是因为害怕被别人讨厌，所以故意用过去的经历作为借口，来拒绝被讨厌的情况发生。</p><p>对于那些人来说，维持现状是最符合内心舒适的感觉，因此会制造很多的借口。</p><p>但现状所带来的后果又一直在折磨，反复循环。</p><h2><span id="fan-nao-de-gen-yuan">烦恼的根源</span><a href="#fan-nao-de-gen-yuan" class="header-anchor">#</a></h2><p>人的不幸都是自己选择的，不是社会或者世界，而是自己亲手选择的。</p><p>烦恼的根源，都来自于人际关系。</p><p>总是希望获得别人的认可，因此为了避免不认可的情况，刻意做出了逃避</p><h2><span id="ru-he-kan-dai-zi-bei-gan">如何看待自卑感</span><a href="#ru-he-kan-dai-zi-bei-gan" class="header-anchor">#</a></h2><p>认为我是世界的中心。</p><p>认为所有人都在关注我的一举一动</p><p>认为我的事情，就是别人的事情，  以及别人的看法，就是我的价值。</p><p>为了避免被讨厌，搬出自己不行的自卑，来逃避</p><h2><span id="zen-me-huo-de-bei-tao-yan-de-yong-qi">怎么获得被讨厌的勇气？</span><a href="#zen-me-huo-de-bei-tao-yan-de-yong-qi" class="header-anchor">#</a></h2><p>课题分离</p><p>我无法掌控他人，他人也无法掌控我。</p><p>我的选择是我的课题，他的想法干涉不了我。</p><p>他的选择是他的课题，我不需要去干涉他。</p><p>我只要尽力做我想做的， 他如何回应，他是接受还是讨厌，是他的课题。我不应该为之付出痛苦或者焦虑的情绪。</p><p>我不能可以追求对方的回报，我也不能无底线的回报别人的付出，分离！</p><h2><span id="zen-me-huo-de-xing-fu">怎么获得幸福？</span><a href="#zen-me-huo-de-xing-fu" class="header-anchor">#</a></h2><h4><span id="ta-ren-gong-xian">“他人贡献”</span><a href="#ta-ren-gong-xian" class="header-anchor">#</a></h4><p>只要知道自己的存在是有价值的，是对他人、社会、整体有贡献的</p><p>只有在感觉自己有价值的时候，才能有勇气。</p><p>这个价值不是别人赋予的，而是自己赋予的，自己认可的价值。</p><p><strong>他人贡献不代表为了他人的期待而活，共同体，范围要看广，不只是某个人不满意就不代表你没有了他人贡献！</strong></p><h4><span id="zhi-mian-ren-sheng-de-ke-ti-gong-zuo-jiao-you-ai">直面人生的课题（工作、交友、爱）</span><a href="#zhi-mian-ren-sheng-de-ke-ti-gong-zuo-jiao-you-ai" class="header-anchor">#</a></h4><p>自己主动动起来，而不是等着别人来赠予。</p><p>无论遇到什么不好的反馈，都是别人的课题，我只要做了自己希望做的事情就好！</p><h2><span id="ru-he-shi-bie-ta-ren-gong-xian-zhong-de-ta-ren">如何识别他人贡献中的“他人”？</span><a href="#ru-he-shi-bie-ta-ren-gong-xian-zhong-de-ta-ren" class="header-anchor">#</a></h2><ol><li><p>优先信任而不是怀疑</p><p>永远保持对人的信任，而不是怀疑……</p></li><li><p>共同体理论。</p></li></ol><p>当你的行为被某人讨厌， 这个人并不代表的全部，不代表整个“共同体”</p><p>你的行为或者存在可以放大， 学校、公司、社会、家庭，都是共同体。</p><p>因此不要因为部分人的讨厌而自责，你对其他的人肯定仍然存在着贡献，不一定是行为，仅仅是存在就可以是贡献。</p><h2><span id="ru-he-gai-bian">如何改变</span><a href="#ru-he-gai-bian" class="header-anchor">#</a></h2><p>不再关注过去，不再幻想未来。</p><p>关注此时此刻</p><p>此时此刻就像漫无目的的跳舞。</p><p>但只要跳了，做了，就有一定的微小变化，无论最终是否达到，只要享受此时此刻就好。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔,心理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常见容器使用原理（Map\List等)</title>
      <link href="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/"/>
      <url>/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><p>[toc]</p> <div class="toc"><!-- toc --><ul><li><a href="#arraylist-yuan-li">ArrayList原理</a></li><li><a href="#copyonwritearraylist-yuan-li">CopyOnWriteArrayList 原理</a><ul><li><a href="#wei-shi-me-xu-yao-xie-shi-fu-zhi">为什么需要写时复制？</a></li><li><a href="#ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu">如何避免多线程修改的冲突？</a></li><li><a href="#ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian">如何保证更新后，数组引用的变动能及时对外呈现？</a></li></ul></li><li><a href="#hashmap-he-xin-yuan-li">HashMap核心原理</a><ul><li><a href="#hashmap-wan-zheng-de-put-guo-cheng">hashMap完整的put过程</a></li><li><a href="#hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie">hashMap的扩容过程，java7和8扩容的区别</a></li><li><a href="#wei-shi-me-java8-yao-gai-cheng-wei-cha-fa">为什么java8要改成尾插法？</a></li><li><a href="#sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me">虽然解决了死循环问题， 但java8的hashMap仍然是线程不安全的，为什么？</a></li><li><a href="#ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni">具体到底满足什么情况，才会resize扩容呢？</a></li><li><a href="#kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni">扩容后，capacity扩容多少倍呢？</a></li></ul></li><li><a href="#concurrenthashmap-he-xin-yuan-li">ConcurrentHashMap 核心原理</a><ul><li><a href="#jdk6-7-zhong-de-shi-xian-yuan-li">JDK6-7中的实现原理</a><ul><li><a href="#chu-shi-hua-map">初始化map</a><ul><li><a href="#chu-shi-hua-segment-shu-zu-tong-guo-concurrencylevel-he-ssize">初始化segment数组（通过concurrencyLevel和ssize）</a></li><li><a href="#chu-shi-hua-segmentshift-duan-pian-yi-liang-he-segmentmask-duan-yan-ma">初始化segmentShift段偏移量和segmentMask段掩码</a></li><li><a href="#chu-shi-hua-mei-ge-segment">初始化每个segment</a></li></ul></li><li><a href="#ding-wei-segment">定位Segment</a></li><li><a href="#get-cao-zuo">get操作</a></li><li><a href="#put-cao-zuo">put操作</a></li><li><a href="#size-cao-zuo">size操作</a></li></ul></li><li><a href="#jdk8-de-gai-zao-sheng-ji-chong-yao">JDK8的改造升级（重要）</a></li></ul></li><li><a href="#concurrentlinkedqueue-he-xin-yuan-li">ConcurrentLinkedQueue核心原理</a></li></ul><!-- tocstop --></div> <h1><span id="arraylist-yuan-li">ArrayList原理</span><a href="#arraylist-yuan-li" class="header-anchor">#</a></h1><p>Q: 讲一下啊arrayList的扩容原理？<br>A:<br>比较简单，算出新容量后，直接Arrays.copy拷贝到新数组，搞定<br><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/c0f46fd3dbc58ac475051f1102dd4c43f80fc8e0.png" alt="c0f46fd3dbc58ac475051f1102dd4c43f80fc8e0"></p><p>扩容容量= 原容量 + (原容量右移1位，即0.5倍)= 1.5倍<br><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/395ae953519c9a0a9cba440644a6d8dd4999db66.png" alt="395ae953519c9a0a9cba440644a6d8dd4999db66"></p><hr><p>Q: arrayList的初始最大容量是多少？可以更改吗？<br>A:<br>初始容量为10。不可修改<br><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/11f8400ec134b045dae9118f28877a284924b1c3.png" alt="11f8400ec134b045dae9118f28877a284924b1c3"></p><h1><span id="copyonwritearraylist-yuan-li">CopyOnWriteArrayList 原理</span><a href="#copyonwritearraylist-yuan-li" class="header-anchor">#</a></h1><p>就是一个写时复制列表</p><p>当发生“删除/修改/新增”时，会先新建一个数组，更新后的数据拷贝到数组中</p><p>最后再更新到CopyOnWriteArrayList的数组成员引用上。</p><h2><span id="wei-shi-me-xu-yao-xie-shi-fu-zhi">为什么需要写时复制？</span><a href="#wei-shi-me-xu-yao-xie-shi-fu-zhi" class="header-anchor">#</a></h2><p>针对多线程环境下，读多写少的情况，如果每个读都加线程同步，太浪费了</p><p>因此可以读的时候不加锁</p><p>只有写的时候加锁，写完更新</p><p>读的时候可能会有点延迟的数据，但不影响。</p><h2><span id="ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu">如何避免多线程修改的冲突？</span><a href="#ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu" class="header-anchor">#</a></h2><p>加了一个sync锁，修改动作是线程安全的。</p><h2><span id="ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian">如何保证更新后，数组引用的变动能及时对外呈现？</span><a href="#ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian" class="header-anchor">#</a></h2><p>数组成员设置成volatile</p><h1><span id="hashmap-he-xin-yuan-li">HashMap核心原理</span><a href="#hashmap-he-xin-yuan-li" class="header-anchor">#</a></h1><h2><span id="hashmap-wan-zheng-de-put-guo-cheng">hashMap完整的put过程</span><a href="#hashmap-wan-zheng-de-put-guo-cheng" class="header-anchor">#</a></h2><ol><li>首先，要获取key的哈希值。<br>如果为空，就统一是0<br>否则，调用对象的.hashCode()方法，接着再与自己的右移16位进行异或，以便充分利用高位信息。</li><li>接着判断内部node数组是否为空，如果是，先进行初始化扩容。默认为16。</li><li>根据(n-1)&amp;hash值，获取哈希表索引位置。 （&amp;的性能比取余要高,具体讨论见<a href="https://www.zhihu.com/question/21070971">CPU取余原理</a>）</li><li>哈希表的node数组中，存放的是每组链表的头节点。<br>先检查头节点是否和自己要存放的key完全匹配 （hash值相同，key值相同，先hash再key，是因为hash的判断简单，key的equals判断可能会复杂）<br>如果匹配，得到需要替换的节点。</li><li>头节点和自己要放的key不匹配，则判断一下这个头节点是否是红黑树节点，如果是，说明已经升级成红黑树了，调用putTree插入到红黑树中。</li><li>如果不是红黑树， 那就是遍历链表，完全匹配就得到需要替换的节点。如果到尾部了，也没匹配的，则插入新节点。</li><li>如果前面找到了要替换的节点，则判断一下是否可以替换（是否没要求putIfAbsent，或者value为null），是就替换，不是就结束</li><li>如果前面是插入了新节点，非替换， 则要modCount++（方便迭代器确认map是否更新），  同时++size， 然后和扩容阈值做判断， 如果太大，就resize进行扩容<br><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/61d85897f346fb06cb884b84.png" alt="hashMap-put详解"></li></ol><hr><h2><span id="hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie">hashMap的扩容过程，java7和8扩容的区别</span><a href="#hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie" class="header-anchor">#</a></h2><ol><li>java7：</li></ol><ul><li>当resize时，新建一个数组newTable</li><li>遍历原table中的每个链表和节点，重新hash，找到新的位置放入</li><li>放入的方式是头插法，即始终插在链表的头节点。</li></ul><ol start="2"><li>java8:</li></ol><ul><li>不再每个点rehash放置，而是最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标. 避免了频繁的哈希计算和搬移过程。</li><li>使用尾插法在链表上插入节点</li><li>桶内元素超过8个，链表转成红黑树</li></ul><hr><h2><span id="wei-shi-me-java8-yao-gai-cheng-wei-cha-fa">为什么java8要改成尾插法？</span><a href="#wei-shi-me-java8-yao-gai-cheng-wei-cha-fa" class="header-anchor">#</a></h2><p>A:<br>多线程时，java7的map-put可能造成死循环。<br>A线程扩容到那一半， 还处在遍历链表做头插法搬移的过程时，存了2个局部变量，当前链点now指向a， next指向b，正准备搬移（a-&gt;b-&gt;c这样的链表，a是头节点）</p><p>B线程则同时完成线程扩容，但是map里都是引用，浅拷贝，** 因为是头插法， 会导致顺序变化**， 原本a-&gt;b-&gt;c 变成了c-&gt;b-&gt;a。<br>因此A恢复时， 链点还是a，next还是b， 于是往下走到了b， 取bbs的next时，已经变成了a， 于是发生了a-&gt;b-&gt;a的循环<br>导致后续操作的next都是错误操作，引发环形指针。</p><p>java8里改成尾插法，这样做resize时，a-&gt;b-&gt;c 如果仍然哈希到同一个节点， 顺序是不会发生变化的。</p><hr><h2><span id="sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me">虽然解决了死循环问题， 但java8的hashMap仍然是线程不安全的，为什么？</span><a href="#sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me" class="header-anchor">#</a></h2><p>A:<br>因为缺乏同步，导致同节点发生哈希碰撞时，if条件的判断都可能是有问题的，导致本该插在链表头节点后面的，结果直接作为链表头覆盖到数组上了。</p><hr><h2><span id="ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni">具体到底满足什么情况，才会resize扩容呢？</span><a href="#ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni" class="header-anchor">#</a></h2><p>A:<br>　HashMap负载因子 LoadFactor，默认值为0.75f。<br>　衡量HashMap是否进行Resize的条件如下：<br>　HashMap.Size &gt;= Capacity * LoadFactor</p><p>另一种情况。JDK1.8源码中，执行树形化之前，会先检查数组长度，如果长度小于64，则对数组进行扩容，而不是进行树形化</p><hr><h2><span id="kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni">扩容后，capacity扩容多少倍呢？</span><a href="#kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni" class="header-anchor">#</a></h2><p>A:<br>哈希表每次扩容是两倍</p><h1><span id="concurrenthashmap-he-xin-yuan-li">ConcurrentHashMap 核心原理</span><a href="#concurrenthashmap-he-xin-yuan-li" class="header-anchor">#</a></h1><p>CHM结构</p><p>每个concurrentHashMap里有一个segment数组</p><p>每个segment里有HashEntry数组</p><p>每个hashEntry可以演变为链表或者红黑树</p><p><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/1659369632360.png" alt="1659369632360"></p><p><a href="https://blog.csdn.net/qq_18300037/article/details/123795776">https://blog.csdn.net/qq_18300037/article/details/123795776</a></p><p><a href="https://blog.csdn.net/every__day/article/details/114293107">https://blog.csdn.net/every__day/article/details/114293107</a></p><h2><span id="jdk6-7-zhong-de-shi-xian-yuan-li">JDK6-7中的实现原理</span><a href="#jdk6-7-zhong-de-shi-xian-yuan-li" class="header-anchor">#</a></h2><h3><span id="chu-shi-hua-map">初始化map</span><a href="#chu-shi-hua-map" class="header-anchor">#</a></h3><h4><span id="chu-shi-hua-segment-shu-zu-tong-guo-concurrencylevel-he-ssize">初始化segment数组（通过concurrencyLevel和ssize）</span><a href="#chu-shi-hua-segment-shu-zu-tong-guo-concurrencylevel-he-ssize" class="header-anchor">#</a></h4><p>sszie即segment size，是seg数组的大小</p><p>ssize一定是2的N次方，且一定是 大于等于concurrencyLevel的最小值</p><p>sszie的最大值为65535</p><p>ssize的默认值是16</p><h4><span id="chu-shi-hua-segmentshift-duan-pian-yi-liang-he-segmentmask-duan-yan-ma">初始化segmentShift段偏移量和segmentMask段掩码</span><a href="#chu-shi-hua-segmentshift-duan-pian-yi-liang-he-segmentmask-duan-yan-ma" class="header-anchor">#</a></h4><p>这2个变量用于后面定位segment的散列算法使用</p><p>sshift  是 ssize的2的次方数</p><p>segmentShift  = 32 - sshift   默认等于32-4=28</p><p>segmentMask =  ssize -1  默认等于15</p><h4><span id="chu-shi-hua-mei-ge-segment">初始化每个segment</span><a href="#chu-shi-hua-mei-ge-segment" class="header-anchor">#</a></h4><p>每个segment里有一个entry数组</p><p>这个数组的大小cap也是2的N次方，  且大于等于 initialCapacity(就是你传的初始容量值) / ssize 即<strong>平均每段数量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure><p>loadFactor默认0.75</p><p>initialCapatity默认值为16</p><h3><span id="ding-wei-segment">定位Segment</span><a href="#ding-wei-segment" class="header-anchor">#</a></h3><p>对于一个key ，先是获取hashcode， 然后对hashcode进行变种算法再散列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个算法能保证各位都能利用上，尽可能均匀， 相比hashmap里单纯和高16位做异或不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br></pre></td></tr></table></figure><p>可以看出</p><p>segmentShift的作用是让hash通过右移动，只保留符合ssize的2进制位数长度</p><p>顺便通过和segmentMask进行&amp;操作，剔除其他的位</p><p>总目的就是为了让32位的hash偏移后保持在ssize的范围内</p><p>按默认值而言，即   (hash&gt;&gt;&gt;28) &amp; 15</p><h3><span id="get-cao-zuo">get操作</span><a href="#get-cao-zuo" class="header-anchor">#</a></h3><p>先按照上文进行哈希， 获取segment后再进行get操作</p><p>整个过程都不需要加锁！</p><p>除非读到的值时空的，才会加锁重读确认（可能是被修改过了）</p><p>获取segment这个操作中，涉及的数组count、存储HashEntry的value，都涉及成了volatile，保持可见性。</p><h3><span id="put-cao-zuo">put操作</span><a href="#put-cao-zuo" class="header-anchor">#</a></h3><p>put操作处理共享变量（例如count等）是一定会加锁的。</p><p>区别在于扩容时，只对某一个segment扩容，不会影响其他的segment</p><p>扩容时会先创建容量两倍的数组，重新放入后在修改引用。</p><p>CHM是插入前先判断，再选择是否扩容</p><p>而hashMap是插入后判断，再选择是否扩容</p><h3><span id="size-cao-zuo">size操作</span><a href="#size-cao-zuo" class="header-anchor">#</a></h3><p>size自然是要把所有segment里的size进行相加</p><p>但是for循环相加可能会有前面的segment被修改，导致size变化，但如果加锁又太耗时间</p><p>因此引入了modCount，如果统计完成过程中发现modCount变化，则会加锁的方式重新统计。</p><h2><span id="jdk8-de-gai-zao-sheng-ji-chong-yao">JDK8的改造升级（重要）</span><a href="#jdk8-de-gai-zao-sheng-ji-chong-yao" class="header-anchor">#</a></h2><p>在`JDK8中，它进行了以下重要改进：</p><ol><li><p>取消分段锁机制<code>（Segment）</code>，进一步降低冲突概率; 使用桶的概念。</p><p>其内部虽然仍然有 <code>Segment</code> 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构 上的用处。</p><p>因为不再使用 <code>Segment</code>，初始化操作大大简化，修改为 <code>lazy-load</code> 形式，这样可以有效避免 初始开销</p></li><li><p>size()方法做了优化，表达范围变大。原来<code>map</code>原有的<code>size</code>方法最大只能表达2的31次方减一，现在额外提供<code>mappingCount</code>方法，最大表示为2的63次方减一</p></li><li><p>使用 <code>Unsafe</code>、<code>LongAdder</code> 之类底层手段，进行极端情况的优化。使用 <code>CAS</code> 等操作，在特定场景进行无锁并发操作。 即get使用volatile读， 而put则使用cas进行并发put。</p></li><li><p>类似hashMap引入红黑树解构，同一个哈希槽元素个数超过一定的阙值后，单链表转化成红黑树;</p></li><li><p>支持多线程并发扩容，大大提升扩容速度。</p></li></ol><p><a href="https://blog.csdn.net/zguoshuaiiii/article/details/78495332">(4条消息) java8中concurrentHashmap的改进_庄国帅哥的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40277163/article/details/122957808">(1条消息) JDK 8 ConcurrentHashMap_黄泥川水猴子的博客-CSDN博客_concurrenthashmap jdk8</a></p><h1><span id="concurrentlinkedqueue-he-xin-yuan-li">ConcurrentLinkedQueue核心原理</span><a href="#concurrentlinkedqueue-he-xin-yuan-li" class="header-anchor">#</a></h1><p>核心是使用CAS而不是锁来处理链式队列。</p><p>比较容易想到的是每次用cas来处理next指针的跟新以及tail指针的指向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">                Node&lt;E&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        Node&lt;E&gt; t = tail;</span><br><span class="line">                        <span class="keyword">if</span> (t.casNext(<span class="literal">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是缺点在于及时没有并发，也要频繁cas更新tail节点。</p><p>实际上只需要用到tail节点的时候再去定位即可。</p><p>所以设置了一个HOPS值</p><p>当tail节点和实际尾节点的距离大于等于HOPS值，才去定位并cas更新tail节点，否则只更新next指针。</p><p><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/1659795490061.png" alt="1659795490061"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">        Node&lt;E&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">            Node&lt;E&gt; t = tail;</span><br><span class="line">            <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">            Node&lt;E&gt; p = t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hops</span> <span class="operator">=</span> <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">                Node&lt;E&gt; next = succ(p);</span><br><span class="line">    <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                    <span class="comment">// 需要退出2层for循环，重新定位tail节点了</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                        <span class="keyword">continue</span> retry; </span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, n)) &#123;</span><br><span class="line">                    <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                      更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                        casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = succ(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代价是距离越长，入队时定位队尾的时间越长。</p><p>但是效率总体上提升了， 因为通过增加对volatile变量的读操作来减少对volatile变量的写操作。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> java常见应用原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java常见应用原理m </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-next主题使用笔记</title>
      <link href="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p> <div class="toc"><!-- toc --><ul><li><a href="#tu-pian-zhi-chi-fang-da">图片支持放大</a></li><li><a href="#tian-jia-fang-wen-liang">添加访问量</a></li><li><a href="#valine-ping-lun-guo-nei-ban">valine评论（国内版）</a></li><li><a href="#she-jiao-lian-jie">社交链接</a></li><li><a href="#ban-quan">版权</a></li><li><a href="#sheng-ji-markdown-xuan-ran-qi-zhi-chi-cha-jian">升级markdown渲染器，支持插件</a></li><li><a href="#chao-lian-jie-yan-se-gai-bian">超链接颜色改变</a></li><li><a href="#xiu-gai-zuo-ce-cai-dan-lan">修改左侧菜单栏</a></li><li><a href="#zeng-jia-she-jiao-lian-jie">增加社交链接</a></li><li><a href="#xian-shi-zhan-dian-wen-zhang-zong-zi-shu-ling-yi-chong-tong-ji-zhan-dian-zong-zi-shu-de-fang-fa">显示站点文章总字数（另一种统计站点总字数的方法）</a></li><li><a href="#tian-jia-bo-ke-bei-jing-tu-pian">添加博客背景图片</a></li><li><a href="#she-zhi-next-zi-dai-de-dong-tai-bei-jing">设置next自带的动态背景</a></li><li><a href="#tian-jia-sou-suo-kuang">添加搜索框</a><br>- [1、安装本地搜索插件 <a href="https://so.csdn.net/so/search?q=hexo&amp;spm=1001.2101.3001.7020">hexo</a>-generator-search](#1-an-zhuang-ben-di-sou-suo-cha-jian-hexo-https-so-csdn-net-so-search-q-hexo-spm-1001-2101-3001-7020-generator-search)<br>- <a href="#2-xiu-gai-zhan-dian-pei-zhi-wen-jian-ru-guo-shang-yi-bu-mei-you-zhao-dao-search-xml-wen-jian-ze-ke-yi-tiao-guo">2、修改站点配置文件(如果上一步没有找到 <code>search.xml</code>文件 则可以跳过 )</a><br>- <a href="#3-zhu-ti-pei-zhi-wen-jian">3、主题配置文件</a></li><li><a href="#wen-zhang-shou-ye-zhi-ding">文章首页置顶</a></li></ul><!-- tocstop --><p>[toc]用于编辑时目录跳转</p><h1><span id="tu-pian-zhi-chi-fang-da">图片支持放大</span><a href="#tu-pian-zhi-chi-fang-da" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/wugenqiang/article/details/89057323">https://blog.csdn.net/wugenqiang/article/details/89057323</a><br>fancybox本地无法使用，会导致加载失败<br>主要是因为默认配置的cdn我们无法访问<br><a href="https://blog.csdn.net/Aelous_dp/article/details/107643344">https://blog.csdn.net/Aelous_dp/article/details/107643344</a><br>需要改为如下：<br>vendor:<br>jquery: <a href="//code.jquery.com/jquery-2.0.3.min.js">//code.jquery.com/jquery-2.0.3.min.js</a><br>fancybox: <a href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js">//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js</a><br>fancybox_css: <a href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css</a><br>主要是本地无法连接他默认配置的那个CDN</p><h1><span id="tian-jia-fang-wen-liang">添加访问量</span><a href="#tian-jia-fang-wen-liang" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/baidu_34310405/article/details/102665373">https://blog.csdn.net/baidu_34310405/article/details/102665373</a></p><h1><span id="valine-ping-lun-guo-nei-ban">valine评论（国内版）</span><a href="#valine-ping-lun-guo-nei-ban" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/weixin_48927364/article/details/123321038">https://blog.csdn.net/weixin_48927364/article/details/123321038</a><br><a href="https://blog.csdn.net/blue_zy/article/details/79071414">https://blog.csdn.net/blue_zy/article/details/79071414</a><br>Valine交流群: 480972291<br>配置再next的config里的valine:</p><p>waline国外版</p><h1><span id="she-jiao-lian-jie">社交链接</span><a href="#she-jiao-lian-jie" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/weixin_44634406/article/details/122777058">https://blog.csdn.net/weixin_44634406/article/details/122777058</a></p><p>themes/next下的_config.yml，搜索social</p><p>图标库</p><p><a href="http://www.fontawesome.com.cn/faicons/#web-application">http://www.fontawesome.com.cn/faicons/#web-application</a></p><p>想要其他的国内软件图标：</p><p><a href="https://blog.csdn.net/weixin_44634406/article/details/122777058">https://blog.csdn.net/weixin_44634406/article/details/122777058</a></p><p><a href="https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a">https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a</a></p><h1><span id="ban-quan">版权</span><a href="#ban-quan" class="header-anchor">#</a></h1><p>hexo next config 中找到creative_commons， 各种设置为true</p><p>主config中设置url: ‘<a href="http://breakdawncoder.com/">http://breakdawncoder.com/</a>’</p><p>复制黏贴时带版权信息：<br><a href="https://blog.csdn.net/qq_33430083/article/details/105626840">(1条消息) 新手如何给Hexo博客在复制时添加版权声明_只是学习学习的博客-CSDN博客</a></p><h1><span id="sheng-ji-markdown-xuan-ran-qi-zhi-chi-cha-jian">升级markdown渲染器，支持插件</span><a href="#sheng-ji-markdown-xuan-ran-qi-zhi-chi-cha-jian" class="header-anchor">#</a></h1><p><a href="https://www.jianshu.com/p/0bfc3029c980">https://www.jianshu.com/p/0bfc3029c980</a></p><h1><span id="chao-lian-jie-yan-se-gai-bian">超链接颜色改变</span><a href="#chao-lian-jie-yan-se-gai-bian" class="header-anchor">#</a></h1><p>打开 <code>Blog\themes\next\source\css\_common\components\post</code> 路径下的<code>post.styl</code> , 并在底部添加如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span>:<span class="title function_">not</span>(<span class="params">.btn</span>)&#123;</span><br><span class="line">  <span class="attr">color</span>: #6495ED; <span class="comment">//超链接显示颜色</span></span><br><span class="line">  border-<span class="attr">bottom</span>: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line"><span class="attr">color</span>: #0000FF;  <span class="comment">//鼠标移动上去后超链接颜色</span></span><br><span class="line">font-<span class="attr">weight</span>: bold;</span><br><span class="line">text-<span class="attr">decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>颜色码链接:</strong> <a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">RGB颜色值与十六进制颜色码转换工具 (sioe.cn)</a></li></ul><h1><span id="xiu-gai-zuo-ce-cai-dan-lan">修改左侧菜单栏</span><a href="#xiu-gai-zuo-ce-cai-dan-lan" class="header-anchor">#</a></h1><p>themes/next下的_config.yml，查找menu</p><p>图标库：<a href="http://www.fontawesome.com.cn/faicons/#web-application">http://www.fontawesome.com.cn/faicons/#web-application</a></p><p>新添加的菜单需要翻译对应的中文，打开theme/next/languages/zh-CN.yml，在menu下设置</p><h1><span id="zeng-jia-she-jiao-lian-jie">增加社交链接</span><a href="#zeng-jia-she-jiao-lian-jie" class="header-anchor">#</a></h1><p>打开<strong>主题配置文件</strong>即themes/next下的_config.yml，搜索social：</p><h1><span id="xian-shi-zhan-dian-wen-zhang-zong-zi-shu-ling-yi-chong-tong-ji-zhan-dian-zong-zi-shu-de-fang-fa">显示站点文章总字数（另一种统计站点总字数的方法）</span><a href="#xian-shi-zhan-dian-wen-zhang-zong-zi-shu-ling-yi-chong-tong-ji-zhan-dian-zong-zi-shu-de-fang-fa" class="header-anchor">#</a></h1><p>从根目录Blog打开Git Bash，执行下面的命令，安装插件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在/themes/next/layout/_partials/footer.swig文件尾部加上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>再加上这里面的文章字数统计和阅读时常统计，关闭站点统计，站点统计用上面的这个</p><p><a href="https://blog.csdn.net/qq_44082148/article/details/105701427">https://blog.csdn.net/qq_44082148/article/details/105701427</a></p><p>如果出现NAN，尝试hexo clean即可</p><p><img src="/images/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/1660668978986.png" alt="1660668978986"></p><p><img src="/images/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/1660669009040.png" alt="1660669009040"></p><h1><span id="tian-jia-bo-ke-bei-jing-tu-pian">添加博客背景图片</span><a href="#tian-jia-bo-ke-bei-jing-tu-pian" class="header-anchor">#</a></h1><p>打开主题配置文件即themes/next下的_config.yml，将 style: source/_data/styles.styl 取消注释：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure><p>打开根目录Blog/source创建文件_data/styles.styl，添加以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line">body &#123;</span><br><span class="line">      background: url(/images/background.png);//自己喜欢的图片地址</span><br><span class="line">      background-size: cover;</span><br><span class="line">      background-repeat: no-repeat;</span><br><span class="line">      background-attachment: fixed;</span><br><span class="line">      background-position: 50% 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>images目录处于source\images下</p><p>注意图片名字不能带中文</p><p><a href="https://www.cnblogs.com/cscshi/p/15196114.html">Hexo-NexT 设置博客背景图片 - 锦瑟，无端 - 博客园 (cnblogs.com)</a></p><p>里面backgroud的属性是css的常见属性</p><h1><span id="she-zhi-next-zi-dai-de-dong-tai-bei-jing">设置next自带的动态背景</span><a href="#she-zhi-next-zi-dai-de-dong-tai-bei-jing" class="header-anchor">#</a></h1><p>在themes/next目录下打开Git Bash，输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-three source/lib/three</span><br></pre></td></tr></table></figure><p>打开主题配置文件即themes/next下的_config.yml，找到three，这里有三种风格，可以试一下看看喜欢哪种风格，直接将false改为true就行了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># JavaScript 3D library.</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-three</span><br><span class="line">three:</span><br><span class="line">  enable: true</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: false</span><br><span class="line">  canvas_sphere: false</span><br></pre></td></tr></table></figure><h1><span id="tian-jia-sou-suo-kuang">添加搜索框</span><a href="#tian-jia-sou-suo-kuang" class="header-anchor">#</a></h1><p><a href="https://blog.csdn.net/fly_wugui/article/details/108638358">(5条消息) hexo+next 增加搜索功能_moguPeople的博客-CSDN博客_next 搜索</a></p><p><img src="/images/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/1661444579928.png" alt="1661444579928"></p><p>注意里面关于跳过的部分，不设置根目录的配置反而可以用</p><h4><span id="1-an-zhuang-ben-di-sou-suo-cha-jian-hexo-generator-search">1、安装本地搜索插件 -generator-search</span><a href="#1-an-zhuang-ben-di-sou-suo-cha-jian-hexo-generator-search" class="header-anchor">#</a></h4><p>在博客<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E7%9B%AE%E5%BD%95&amp;spm=1001.2101.3001.7020">根目录</a>安装搜索插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  # 安装插件，用于生成博客索引数据（在博客根目录下执行下列命令）：</span><br><span class="line">  npm install hexo-generator-search --save</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>安装之后，会在站点目录的 <code>public</code> 文件夹下创建一个 <code>search.xml</code> 文件。（如果没有 <code>search.xml</code> 文件，请继续往下看）</p><h4><span id="2-xiu-gai-zhan-dian-pei-zhi-wen-jian-ru-guo-shang-yi-bu-mei-you-zhao-dao-search-xml-wen-jian-ze-ke-yi-tiao-guo">2、修改站点配置文件(如果上一步没有找到 <code>search.xml</code>文件 则可以跳过 )</span><a href="#2-xiu-gai-zhan-dian-pei-zhi-wen-jian-ru-guo-shang-yi-bu-mei-you-zhao-dao-search-xml-wen-jian-ze-ke-yi-tiao-guo" class="header-anchor">#</a></h4><p>在主题配置文件中的 <code>_config.yml</code> 中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  # Search</span><br><span class="line">  search:</span><br><span class="line">    path: ./public/search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><ul><li>path：索引文件的路径，相对于站点根目录</li><li>field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面</li><li>limit：限制搜索的条目数</li></ul><h4><span id="3-zhu-ti-pei-zhi-wen-jian">3、主题配置文件</span><a href="#3-zhu-ti-pei-zhi-wen-jian" class="header-anchor">#</a></h4><p>在主题配置文件 <code>_config.yml</code> 中找到如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  local_search:</span><br><span class="line">    enable: true</span><br><span class="line">    trigger: auto</span><br><span class="line">    top_n_per_article: 1</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>确保 <code>enable</code> 设成 <code>true</code>。</p><p><code>top_n_per_article</code> 字段表示在每篇文章中显示的搜索结果数量，设成 <code>-1</code> 会显示每篇文章的所有搜索结果数量。</p><p>然后，重新部署网站即可愉快的使用本地搜索功能了。</p><h1><span id="wen-zhang-shou-ye-zhi-ding">文章首页置顶</span><a href="#wen-zhang-shou-ye-zhi-ding" class="header-anchor">#</a></h1><p><a href="https://www.jianshu.com/p/a9922c3ebb61/?u_atoken=48398f9d-56fa-47ae-b352-d6f98a585d91&amp;u_asession=01D0epQEbPKNe5im73eJHf1zhLFNNNaZ2r3_hyeDf7G7N0h-c7I99XrTtE218yIj9nX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K9ZZBQrBAZ937Lye44MvEAWh4gB_rorF7cG9vr14abfLGBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05I1UluhUtlBU6IPgFB9X73nBobkqeOiroamAnWq6SY9Y4Y91yc9AHoLFiWyJab4vyKxb8PD0jcXasm_sJliwRoiz3iPrGlohYW1IirblvY-_25BkSJc8gQV17fCryvphordTqTfCboHCn5HNG95_qL6XfiryECFWBeNwOJX4Gupv9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzSEodxxfYtIZIZ15WTKOyAGdT8FnClDtcccr9WuAAHTZU-X92pnuaZyu-ch7KXFYKu3h9VXwMyh6PgyDIVSG1W_DtwjsIQBBBNwqqPYWHp9EUHGNTZVYh5kLqUgoKImAp0-CG4QEz8LXnuJ0LGm0hazZSoSqH6dvG0i5QtUX8zIhmWspDxyAEEo4kbsryBKb9Q&amp;u_aref=UzxWAS6uUNlVSvL07sozZ%2BTDAiQ%3D">Hexo nexT主题之文章置顶 - 简书 (jianshu.com)</a></p><p>但是好像只能首页指定，不能分类置顶。。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编译优化和语法糖</title>
      <link href="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zao-qi-bian-yi-you-hua">早期编译优化</a><ul><li><a href="#di-yi-bu">第一步：</a><ul><li><a href="#ci-fa-fen-xi">-------词法分析：</a></li><li><a href="#yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan">-------语法分析（注意实际上只是生成一个语法树，还没做语法的校验）：</a></li><li><a href="#tian-chong-fu-hao-biao">-------填充符号表：</a></li></ul></li><li><a href="#di-er-bu">第二步：</a><ul><li><a href="#zhu-jie-chu-li-qi">-------注解处理器：</a></li></ul></li><li><a href="#di-san-bu">第三步：</a><ul><li><a href="#yu-yi-fen-xi">-------语义分析：</a></li><li><a href="#jie-yu-fa-tang">-------解语法糖:</a></li><li><a href="#zi-jie-ma-sheng-cheng">-------字节码生成：</a></li></ul></li></ul><ul><li><a href="#java-yu-fa-tang">java语法糖</a><ul><li><a href="#fan-xing-ca-chu">泛型擦除:</a></li><li><a href="#signature">Signature:</a></li><li><a href="#zi-dong-zhuang-xiang-chai-xiang-xun-huan">自动装箱拆箱、循环</a></li><li><a href="#tiao-jian-bian-yi">条件编译：</a></li></ul></li></ul></li><li><a href="#wan-qi-bian-yi-you-hua">晚期编译优化</a><ul><li><a href="#jie-shi-qi-interperter">解释器Interperter</a></li><li><a href="#bian-yi-qi">编译器</a></li></ul></li><li><a href="#wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou">晚期优化的一些常见措施(即运行中才会做优化的步骤）</a><ul><li><a href="#re-dian-dai-ma">----热点代码</a></li><li><a href="#rong-yu-fang-wen-xiao-chu">—冗余访问消除:</a></li><li><a href="#gong-gong-zi-biao-da-shi-xiao-chu">----公共子表达式消除</a></li><li><a href="#shu-zu-bian-jie-jian-cha">—数组边界检查：</a></li><li><a href="#yin-shi-yi-chang-chu-li">—隐式异常处理：</a></li><li><a href="#fang-fa-nei-lian">----方法内联:</a></li><li><a href="#tao-yi-fen-xi">----逃逸分析：</a></li><li><a href="#java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie">----java和C++， 即时编译和静态编译的区别：</a></li></ul></li><li><a href="#bian-yi-you-hua-wen-da-ti">编译优化问答题</a><ul><li><a href="#zao-qi-bian-yi-guo-cheng">早期编译过程</a></li><li><a href="#wan-qi-bian-yi-you-hua-1">晚期编译优化</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="zao-qi-bian-yi-you-hua">早期编译优化</span><a href="#zao-qi-bian-yi-you-hua" class="header-anchor">#</a></h1><p>编译过程大致分为3类：</p><ol><li>解析与填充符号表</li><li>注解处理</li><li>分析与字节码生成</li></ol><p>源码JavaCompiler里的关键过程：<br>第一步：</p><p><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/da80a1a1a8f52928a88e81bac0766d8a0eeab3ed.png" alt="da80a1a1a8f52928a88e81bac0766d8a0eeab3ed"></p><p>第二步语法分析、词法分析</p><p><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/e87a2122c8d20662ac01c4a7f8af159ee4c8a865.png" alt="e87a2122c8d20662ac01c4a7f8af159ee4c8a865"><br>第三步:</p><p><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/2fe67bfe0e1f3e543deba464130880231b32df7d.png" alt="2fe67bfe0e1f3e543deba464130880231b32df7d"><br>第四步：<br>执行注解处理<br><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/08cce0ef45b40e3db03ec3c0362444eb3dee4a24.png" alt="08cce0ef45b40e3db03ec3c0362444eb3dee4a24"></p><p>接着就是语义分析及字节码生成<br><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/19956ec4da3e080289d22e64e04b58e9253e0de0.png" alt="19956ec4da3e080289d22e64e04b58e9253e0de0"></p><p>以上的关键点:</p><ul><li>词法语法解析是第一步，生成符号</li><li>注解处理是第二步</li><li>然后语法糖、字节码都是第三步的事情。</li></ul><hr><p>上述步骤的详细解释：</p><h3><span id="di-yi-bu">第一步：</span><a href="#di-yi-bu" class="header-anchor">#</a></h3><h4><span id="ci-fa-fen-xi">-------词法分析：</span><a href="#ci-fa-fen-xi" class="header-anchor">#</a></h4><p>就是代码转成token标记。<br>例如int a=b+2 转成   Int \a=\b+\2  这6个token。</p><h4><span id="yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan">-------语法分析（注意实际上只是生成一个语法树，还没做语法的校验）：</span><a href="#yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan" class="header-anchor">#</a></h4><p>根据生成的token，构造一个抽象语法树。</p><h4><span id="tian-chong-fu-hao-biao">-------填充符号表：</span><a href="#tian-chong-fu-hao-biao" class="header-anchor">#</a></h4><p>生成一个符号地址和符号信息构成的表格。<br>(后面第三步的阶段会用于语义分析中的标注检查，  比如名字的使用是否和说明一致，也会用于产生中间代码）<br>符号表是目标代码生成时的地址分配的依据</p><h3><span id="di-er-bu">第二步：</span><a href="#di-er-bu" class="header-anchor">#</a></h3><h4><span id="zhu-jie-chu-li-qi">-------注解处理器：</span><a href="#zhu-jie-chu-li-qi" class="header-anchor">#</a></h4><p>注解处理器会扫描抽象语法树中带注解的元素， 并进行语法树的更新。<br>更新之后我们会重新走回解析与填充的过程，重新处理。<br>这个处理器是一种插件，我们可以自己不断往其中去添加。</p><p>注意，上面这2步只是简单去对源文件做转换， 还不涉及任何语法相关的规则。</p><h3><span id="di-san-bu">第三步：</span><a href="#di-san-bu" class="header-anchor">#</a></h3><h4><span id="yu-yi-fen-xi">-------语义分析：</span><a href="#yu-yi-fen-xi" class="header-anchor">#</a></h4><p>判断语法树是否正确。分为2种检查：</p><ol><li><p>标注检查：   检查变量是否已被声明、 赋值、等式的数据类型是否匹配<br>标注检查中会进行常量折叠， 把a=1+2折叠成3<br>标注检查的范围比较小，不会有太多上下文依赖。</p></li><li><p>数据及控制流分析<br>对程序上下文逻辑更进一步验证<br>这里会涉及很多交互的上下文交互依赖<br>比如 带返回值的方法是否全路径都包含了返回、  受检异常是否被外部处理、局部变量使用前是否被赋值。</p></li></ol><p>final 局部变量（或者final参数）和非final局部变量，生成的class文件没有区别。<br>因为局部变量不会在常量池中持有符号引用， 所以不会有acesses_flasg信息。<br>所以class文件不知道局部变量是不是final， 因此final局部对运行期没有任何影响， 只会在编译期去校验。</p><h4><span id="jie-yu-fa-tang">-------解语法糖:</span><a href="#jie-yu-fa-tang" class="header-anchor">#</a></h4><p>虚拟机本身不支持这种语法， 但是会在编译阶段 把这些语法糖转为 普通的语法结构（换句话说做了把语法糖代码变成了普通代码，  例如自动装拆箱，可能就是转成了包装方法的特定调用）</p><h4><span id="zi-jie-ma-sheng-cheng">-------字节码生成：</span><a href="#zi-jie-ma-sheng-cheng" class="header-anchor">#</a></h4><p>对象的初始化顺序， 实际上会在字节码生成阶段， 收敛到一个<init>方法中。 即init中控制了那些成员、以及构造方法的调用顺序<br>类初始化同理，也是收敛到一个 <cinit>中<br>PS： 注意，默认构造器是在填充符号表阶段完成的。<br>字符串的替换（+操作转成sb） 是在字节码阶段生成的。<br>完成了对语法树的遍历之后，会把最终的符号表交给ClassWRITE类，设计概念从一个字节码和文件</cinit></init></p><hr><h2><span id="java-yu-fa-tang">java语法糖</span><a href="#java-yu-fa-tang" class="header-anchor">#</a></h2><p>Q: java语法糖属于早期优化还是晚期优化？<br>A: 属于早期优化。</p><h3><span id="fan-xing-ca-chu">泛型擦除:</span><a href="#fan-xing-ca-chu" class="header-anchor">#</a></h3><p>java中的泛型只在 程序源码中存在，  在编译后的字节码文件中已经替换为原生类型， 并会插入一些强制转换的代码。<br>即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">f</span><span class="params">(T  t)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">a</span> <span class="operator">=</span> T.getA();</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">实际上是</span><br><span class="line"></span><br><span class="line">T  <span class="title function_">f</span><span class="params">(Object t)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> （T）t.getA();</span><br><span class="line">    <span class="keyword">return</span> (T)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即只在会方法的入口 和方法的出口处，做强制转换， 而实际上传入的都是原生类型，可以理解为object</p><p>神奇的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个编译会报错，认为有2种相同的方法， 因为编译后被擦除了。</p><p>然后下面这个例子却是tm能ok的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释:<br>返回值不参与重载的选择，但是因为返回值作为描述符不一致，以至于可以在一个class文件中共存。<br>必须用Sun JDK1.6才能编译通过</p><h3><span id="signature">Signature:</span><a href="#signature" class="header-anchor">#</a></h3><p>用于解决泛型歹来的参数类型的识别问题。<br>可存储字节码层面的特征签名。<br>字节码层面：   方法名称、参数顺序、参数类型、 返回值、受检查异常， 这5个决定了1个字节码层面的方法是否唯一。<br>如果是java语法层面， 则签名只受方法名称、参数顺序、参数类型这3个的影响。</p><p>他会保存参数化类型的信息， 即虽然code里都转成了object， 但是其参数化类型还是通过signature保存到了元数据区， 可以通过反射获取参数化类型。</p><h3><span id="zi-dong-zhuang-xiang-chai-xiang-xun-huan">自动装箱拆箱、循环</span><a href="#zi-dong-zhuang-xiang-chai-xiang-xun-huan" class="header-anchor">#</a></h3><p>自动装箱拆箱:  就是在编译后， 自动把装拆箱的地方加上 Integer.valueOf()  或者  包装类型.intValue()</p><p>可变参数：被优化成一个数组<br>Arrays.asList(“1”,“2”,“3”,“4”)   =&gt;   Arrays.asList(new String[]{ “1”, “2”, “3”, “4”})</p><p>带iterator接口的  for循环：<br>for(String str :   listStr) {<br>}<br>被优化成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">Interator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); it.hasNext()) &#123;</span><br><span class="line">    xxx   it.next xxx...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line"><span class="type">Long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br></pre></td></tr></table></figure><p>// true, 小于128，用常量池里的常量比较<br>System.out.println(c == d);<br>// false,非常量池，用各自不同的地址比较<br>System.out.println(e == f );<br>// true， 同1<br>System.out.println(c == (a+b));<br>// true， Integer<br>System.out.println(c.equals(a+b));<br>// true， 这个为什么==是可以的，是因为Long小于128时，也会用常量池的值吗<br>System.out.println(g == (a+b));<br>// false , equals不处理数据转型的关系。<br>System.out.println(g.equals(a+b));</p><h3><span id="tiao-jian-bian-yi">条件编译：</span><a href="#tiao-jian-bian-yi" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">xxx</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    yyy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被优化成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure><p>因为编译器很明确只能走xxx这个分支。<br>只能用于if+常量</p><p>使用常量与其他带有条件判断能力的语句搭配，则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个会报错unreachable statement code<br><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/20210719233205601.png" alt="为什么呢？"><br>因为系统检测到这句代码是永远无法到达的分支，直接给你禁掉了</p><h1><span id="wan-qi-bian-yi-you-hua">晚期编译优化</span><a href="#wan-qi-bian-yi-you-hua" class="header-anchor">#</a></h1><p>HotSpot中，  <strong>解释器与编译器共存</strong>。<br>当程序刚启动时，会先马上使用解释器发挥作用。<br>在程序运行后， 编译器逐步发挥作用，把还没用到的代码逐步编译。<br>内存资源比较少的情况下，可以用解释器来跑程序，减少编译生成的文件。<br>如果编译器的优化出现bug，可以通过“逆优化”回退到最初的解释器模式来运行</p><h3><span id="jie-shi-qi-interperter">解释器Interperter</span><a href="#jie-shi-qi-interperter" class="header-anchor">#</a></h3><h3><span id="bian-yi-qi">编译器</span><a href="#bian-yi-qi" class="header-anchor">#</a></h3><p>有两种编译器</p><ul><li><p>Client Compiler ——C1编译器,  更高的编译速度</p></li><li><p>Server Compiler——C2编译器， 更好的编译质量<br>即选择了-client或者-server时会用到。</p></li><li><p>默认混合模式：  解释器和编译器共存， 即MixedMode。</p></li></ul><p>关于这2种编译器的参数：</p><ul><li>-Xint参数： 强制使用解释模式</li><li>-Xcomp参数： 强制使用编译模式（ 但是如果编译无法进行时，  解释会介入）</li></ul><hr><p>混合模式中， 解释器需要收集性能信息，提供给编译阶段判断和优化， 这个性能信息有点浪费<br>因此JDK7引入了<strong>分层编译</strong>策略：</p><ul><li>第0层：  解释执行。  不开启性能监控。</li><li>第1层： C1编译，  把字节码编译为本地代码，  进行一些简单优化，   加入性能监控</li><li>第2层： C2编译，   启动耗时较长的优化，  根据性能监控信息进行激进优化</li></ul><hr><p>CC和SC编译过程的区别：</p><ul><li><p>client Compiler 编译过程：<br>前端字节码-》  方法内联/常量传播（基础优化）-》 HIR（高级中间代码）-》 空值检查消除/范围检查消除<br>-》 后端把HIR转成LLR（低级中间代码）-》 线性扫描算法分配寄存器-》窥孔优化-》机器码生成-》本地代码生成<br>都是一些不需要运行期信息就能做优化的操作</p></li><li><p>serverCompiler编译过程：<br>会执行<strong>所有的经典优化动作</strong><br>会根据cc或者解释器提供的监控信息，进行<strong>激进的优化</strong><br>寄存器分配器是一个全局图着色分配器</p></li></ul><hr><h1><span id="wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou">晚期优化的一些常见措施(即运行中才会做优化的步骤）</span><a href="#wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou" class="header-anchor">#</a></h1><h3><span id="re-dian-dai-ma">----热点代码</span><a href="#re-dian-dai-ma" class="header-anchor">#</a></h3><ol><li>被多次调用的方法。  会触发JIT编译</li><li>被多次执行的循环体，  会触发OSR编译（栈上替换）， 发生在方法执行过程中， 所以是在栈上编译并切换方法。</li></ol><p>HotSpot 使用 计数器的热点探测法确定热点代码。<br>* 给每个方法建立方法计数器， 在一个周期中如果超过阈值， 就触发JIT编译，编译后替换方法入口。<br>* 如果一个周期内没超过，则计数器/2（半衰）<br>* 如果没有触发时， 都是用解释方式 按照字节码内容死板地运行。</p><blockquote><blockquote><p>该计数器的相关参数<br>-XX:-UserCounterDecay 关闭热度衰减<br>-XX: CounterHalfLifeTime  设置半衰期-XX:CompileThreshold 设置方法编译阈值</p></blockquote></blockquote><p>回边计数器就是计算循环次数的计数器<br>* 没有半衰<br>* 但是当触发OSR编译时，会把计数器降低，避免还在运行时重复触发。<br>* 会溢出， 并且会把方法计数器也调整到溢出。<br>*  clint模式和server模式中，  OSR的阈值计算公式不同，   clint= CompileThredshold * osr比率，    server= CompileThredshold * (osr比率 - 解释器监控比率）</p><h3><span id="rong-yu-fang-wen-xiao-chu">—冗余访问消除:</span><a href="#rong-yu-fang-wen-xiao-chu" class="header-anchor">#</a></h3><p>如果已经拿到了  a.value， 该方法内a.value一定不会变的话， 那么后续用到时就不再从a中取value了<br>复写传播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y=b.value</span><br><span class="line">z=<span class="type">y</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span> z + y</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = b.<span class="type">value</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="type">y</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span> y + y</span><br></pre></td></tr></table></figure><p>无用代码消除：<br>去掉上面的Y=y</p><h3><span id="gong-gong-zi-biao-da-shi-xiao-chu">----公共子表达式消除</span><a href="#gong-gong-zi-biao-da-shi-xiao-chu" class="header-anchor">#</a></h3><p>就是对一些比较长的计算公式做化简<br>a+（a+b）<em>2<br>会优化成<br>a</em>3+b*2<br>尽可能减少计算次数</p><h3><span id="shu-zu-bian-jie-jian-cha">—数组边界检查：</span><a href="#shu-zu-bian-jie-jian-cha" class="header-anchor">#</a></h3><p>如果能确定某个for循环里的数组取值操作一定不会超出数组范围，那么在做[]取值操作时，不会做数组边界检查。</p><h3><span id="yin-shi-yi-chang-chu-li">—隐式异常处理：</span><a href="#yin-shi-yi-chang-chu-li" class="header-anchor">#</a></h3><p>if(a == null) {<br>xxx<br>}<br>else{<br>throw Exception<br>}<br>优化成<br>try {<br>xxx<br>} catch(Exception e) {<br>throw e<br>}</p><p>为什么隐式异常处理不能放在早期优化？<br><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/f25fce1b1f632496074589dad0c260c0f1cc936a.png" alt="f25fce1b1f632496074589dad0c260c0f1cc936a"></p><h3><span id="fang-fa-nei-lian">----方法内联:</span><a href="#fang-fa-nei-lian" class="header-anchor">#</a></h3><p>不能被继承重写的方法，比如私有、构造器、静态之类的方法，可以直接在早期优化中做内联优化。<br>而其他会被抽象继承实现的方法在编译器无法做内联，因为他不知道实际是用哪一段代码。</p><ul><li>final方法并不是非虚方法（为什么呢）</li><li>类型继承关系分析CHA：   如果发现虚方法，CHA会查一下当前虚拟机内该方法是否有多个实现， 如果发现只有这一种实现，那么就可以直接内联。</li><li>如果后续有其他的class动态加载进来后，该方法有多个实现了，并且被使用到了，那么就会抛弃已编译的内联代码，回退到解释状态执行。</li><li>内联缓存：  即使程序中发现该方法有多个实现， 依然对第一个使用的那个方法做内联，除非有其他重写方法被调用（即虽然你定义了，但是你很可能不用，所以我一直使用你的第一个方法，除非你真的用了多种重写方法去跑。</li></ul><h3><span id="tao-yi-fen-xi">----逃逸分析：</span><a href="#tao-yi-fen-xi" class="header-anchor">#</a></h3><p>分析new 出来的对象是否不会逃逸到方法外，  如果确认只在方法内使用，外部不会有人引用他， 那么就会做优化，比如：<br>* 不把new出来的对象放到堆，而是放到方法栈上，方法结束了对象直接消失。<br>* 不需要对这种对象做加锁、同步操作了<br>* 标量替换:   把这个对象里的最小基本类型成员拆出来作为局部变量使用。</p><h3><span id="java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie">----java和C++，  即时编译和静态编译的区别：</span><a href="#java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie" class="header-anchor">#</a></h3><ol><li>即时编译可能会影响用户体验，如果在运行中出现较大影响的延迟的话<br>2.<br>java中虚方法比C<ins>要多， 因为做各种内联分析消耗的检查和优化的就越多越大<br>3.<br>java中总是要做安全检查， C</ins>中不做，出错了我就直接崩溃了越界了<br>4.<br>C<ins>中内存释放让用户控制， 无需后台弄一个垃圾回收器总是去检查和操作<br>5.<br>java好处： 即时编译能够以运行期的性能监控进行优化，这个是C</ins>无法做到的。</li></ol><p><a href="https://blog.csdn.net/qq_40925525/article/details/98363179">https://blog.csdn.net/qq_40925525/article/details/98363179</a></p><hr><h1><span id="bian-yi-you-hua-wen-da-ti">编译优化问答题</span><a href="#bian-yi-you-hua-wen-da-ti" class="header-anchor">#</a></h1><p>@[toc]<br>首先提出一个问题，为什么C++的编译速度会比java慢很多？二者运行程序的速度差异子啊那？  了解了java的早期和晚期过程，就能理解这个问题了。</p><p>这里会提15个问题确认是否真的理解，如果完全没这方面的概念，则好好看一下前面的<a href>早期和晚期编译优化读书笔记</a></p><h3><span id="zao-qi-bian-yi-guo-cheng">早期编译过程</span><a href="#zao-qi-bian-yi-guo-cheng" class="header-anchor">#</a></h3><hr><p>Q: java早期编译过程分为哪3步？<br>A:</p><ol><li>词法语法解析、填充符号表</li><li>注解处理</li><li>语义分析与字节码生成。</li></ol><hr><p>Q: 上面的步骤中， <strong>符号表</strong>是干吗的？<br>A:<br>符号表是符号地址和符号信息构成的表格。</p><ul><li>用于后面阶段做语法检查时，从表里取出信息进行对比。</li><li>符号表是目标代码生成时的地址分配的依据</li></ul><hr><p>Q: 注解处理器做的什么事情？<br>A: 注解处理器会扫描抽象语法树中带注解的元素， 并进行语法树的更新。<br>重点就是他是基于语法树做更新。<br>更新之后我们会重新走回解析与填充的过程，重新处理。</p><p>APT可以用来在编译时扫描和处理注解。<br>通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来<strong>自动的生成一些代码</strong>，省去了手动编写。 例如@Setter<br>注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。</p><hr><hr><p>Q: 上面的3个步骤中， 解语法糖是哪一步？<br>A:<br>是第三步，在生成字节码的时候才做的语法糖处理。</p><hr><p>Q: 什么是解语法糖？大概有哪些？<br>A:</p><ul><li>虚拟机本身不支持这种语法， 但是会在编译阶段 把这些语法糖转为 普通的语法结构。</li><li>包含自动装拆箱、 泛型强转应用。</li></ul><hr><p>Q: 生成字节码class文件的时候， final和非final的局部变量， 会有区别不？<br>A:<br>没有区别。<br>局部变量不会在常量池中持有符号引用， 所以不会有acesses_flasg信息。<br>** 因此final局部变量在运行期没有任何作用， 只会在编译期去校验。**</p><hr><p>Q:   a= 1 + 2会在什么阶段进行优化？<br>A: 会在早期编译过程的语义分析过程中，进行常量折叠， 变成a=3<br>同理， 字符串+号优化成stringBuilder.append()这个动作也是该阶段优化的。</p><hr><p>Q:  类对象加载的过程有一堆顺序（具体见<a href="xxx">类初始化顺序</a>，  这个顺序在字节码中体现的吗？还是运行的时候再判断顺序？<br>A:<br>字节码中体现的。</p><ul><li>在字节码生成时，  编译器针对对象new的过程，会生成了一个<init>方法，里面写明了成员、构造方法的调用顺序。</init></li><li>类静态成员的调用顺序同理封装在<cinit>中。</cinit></li></ul><hr><h3><span id="wan-qi-bian-yi-you-hua">晚期编译优化</span><a href="#wan-qi-bian-yi-you-hua" class="header-anchor">#</a></h3><p>Q:<br>早期编译优化和晚期编译优化的区别？<br>A:</p><ul><li>早期编译优化， 是把 java文件转成字节码，转字节码的过程中做一些简单优化和语法糖处理。</li><li>晚期编译优化，是将字节码转机器码执行的过程中，结合一些信息进行动态优化，或者应用上很多的机器码优化措施。</li></ul><hr><p>Q: java程序运行的时候，是直接全部转成优化后的机器码再运行吗？<br>A:<br>错误。</p><ul><li>当程序刚启动时，会先马上使用<strong>解释器</strong>发挥作用，这时候没做太多优化，直接解释执行。</li><li>在程序运行后， <strong>编译器</strong>逐步发挥作用，把还没用到的代码逐步编译成机器码。</li></ul><blockquote><blockquote><p>注意这里的编译器和之前提到的编译器的区别，一个是编译成字节码，另一个是编译成机器码。</p></blockquote></blockquote><hr><hr><p>Q: JIT是什么？<br>A:<br>为了提高执行速度，便引入了 JIT 技术。<br>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。</p><hr><p>Q: 有两种晚期优化编译器</p><ul><li>Client Compiler ——C1编译器</li><li>Server Compiler——C2编译器<br>他们二者的区别是什么？</li></ul><p>A:</p><ul><li>速度和质量的区别：<br>C1编译器,  更高的编译速度，编译质量一般。<br>C2编译器， 更好的编译质量，但是速度慢。</li><li>优化特性的区别<br>C1编译器都是一些不需要运行期信息就能做优化的操作。<br>C2编译器则会根据解释器提供的监控信息，进行<strong>激进且动态的优化</strong></li></ul><hr><p>Q: java中怎么区分用C1还是C2？<br>A:<br>关于这2种编译器的参数：</p><ul><li>-Xint参数： 强制使用解释模式</li><li>-Xcomp参数： 强制使用编译模式（ 但是如果编译无法进行时，  解释会介入）</li><li>选择编译模式时，有-client、-server还有MixedMode(混合模式）可以选择</li></ul><blockquote><blockquote><p>混合模式中， JDK7引入了<strong>分层编译</strong>策略：<br>第0层：  解释执行。  不开启性能监控。<br>第1层： C1编译，  把字节码编译为本地代码，  进行一些简单优化，   加入性能监控<br>第2层： C2编译，   启动耗时较长的优化，  根据性能监控信息进行激进优化</p></blockquote></blockquote><hr><p>Q: 分层优化中，如果正在运行，jvm是怎么知道需要对哪些代码做JIT或者OSR优化？<br>A:</p><ol><li>被多次调用的方法。  会触发JIT编译（热点代码计数器）</li><li>被多次执行的循环体，  会触发OSR编译（栈上替换）， 发生在方法执行过程中， 所以是在栈上编译并切换方法。（使用回边计数器）</li></ol><hr><p>Q: 哪些方法会在早期优化中做内联，哪些方法会在晚期优化中做内联？<br>A:</p><ul><li>不能被继承重写的方法，比如私有、构造器、静态之类的方法，可以直接在早期优化中做内联优化。</li><li>其他会被<strong>抽象继承实现的方法</strong>在早期无法做内联，因为他不知道实际是用哪一段代码.</li><li>晚期优化中可以根据一些运行信息，判断是否总是只用某个子类方法跑，是的话做一下尝试内联，如果后面来了其他的子类就切回去。</li></ul><hr><p>Q: java数组一般都会自动做边界检查，不满足就抛异常。 什么情况下会优化掉这个自动检查？<br>A:<br>运行期，发现传入的参数放到数组中用的时候， 肯定不会超出边界，则会优化掉这个检查动作。</p><hr><p>看完上面的，就可以给出C++和java编译和运行速度差距的原因了：</p><ol><li>java即时编译可能会影响用户体验，如果在运行中出现较大影响的延迟的话。</li><li>java中虚方法比C++要多， 因为做各种内联分析消耗的检查和优化的就越多越大</li><li>java中总是要做安全检查， C++中不做，出错了我就直接崩溃了越界了</li><li>C++中内存释放让用户控制， 无需后台弄一个垃圾回收器总是去检查和操作</li><li>java好处： 即时编译能够以运行期的性能监控进行优化，这个是C++无法做到的</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> jvm原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,深入理解jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized关键字原理超级详解</title>
      <link href="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wei-shi-me-shuo-xian-cheng-qie-huan-hui-hen-man">为什么说线程切换会很慢？</a></li><li><a href="#dui-xiang-tou-zhong-de-mark-word">对象头中的mark-word</a><ul><li><a href="#suo-zhuang-tai-biao-zhi-wei-pian-xiang-suo-biao-ji-wei-2bit-1bit">锁状态标志位 +偏向锁标记位（2bit + 1bit）</a><ul><li><a href="#wei-shi-me-wu-suo-pian-xiang-suo-de-biao-zhi-wei-shi-01-er-qing-liang-ji-suo-de-biao-zhi-wei-shi-00">为什么无锁/偏向锁的标志位是01，而轻量级锁的标志位是00？</a></li></ul></li><li><a href="#hashcode-31bit">hashcode（31bit）</a><ul><li><a href="#markword-zhong-de-hashcode-shi-na-ge-fang-fa-sheng-cheng-de">markword中的hashcode是哪个方法生成的？</a></li><li><a href="#markword-zhong-de-hashcode-shi-shi-me-shi-hou-sheng-cheng">markword中的hashcode是什么时候生成？</a></li><li><a href="#hashcode-zai-qi-ta-suo-zhuang-tai-zhong-qu-na-liao">hashcode在其他锁状态中去哪了？</a></li></ul></li><li><a href="#gc-fen-dai-nian-ling-4bit">gc分代年龄（4bit）</a></li><li><a href="#cms-free">cms_free</a></li></ul></li><li><a href="#suo-sheng-ji-si-ge-jie-duan-chao-ji-xiang-jie">锁升级四个阶段超级详解</a><ul><li><a href="#wu-suo">无锁</a><ul><li><a href="#chu-yu-wu-suo-zhuang-tai-de-tiao-jian-huo-zhe-shi-ji-shi-shi-me">处于无锁状态的条件或者时机是什么？</a></li><li><a href="#dui-xiang-cong-mei-jin-ru-tong-bu-kuai-wei-shi-me-pian-xiang-suo-biao-zhi-wei-que-shi-1">对象从没进入同步块，为什么偏向锁标志位却是1？</a></li></ul></li><li><a href="#pian-xiang-suo">偏向锁</a><ul><li><a href="#wei-shi-me-yao-you-pian-xiang-suo">为什么要有偏向锁？</a></li><li><a href="#pian-xiang-suo-de-markword-xiang-jie">偏向锁的markword详解</a><ul><li><a href="#markword-zhong-de-dang-qian-xian-cheng-id">markword中的当前线程id</a><ul><li><a href="#java-de-xian-cheng-id-shi-yi-ge-long-lei-xing-an-li-shuo-shi-64-wei-dan-wei-shi-me-zhi-lei-de-xian-cheng-id-zhi-you-54-wei">java的线程id是一个long类型， 按理说是64位，但为什么之类的线程id只有54位？</a></li><li><a href="#xian-cheng-id-ru-he-xie-ru">线程id如何写入？</a></li></ul></li><li><a href="#ha-xi-code-qu-na-liao">哈希code去哪了</a></li><li><a href="#epoch-shi-shi-me">epoch是什么？</a></li></ul></li><li><a href="#pian-xiang-suo-yun-zuo-xiang-jie">偏向锁运作详解</a><ul><li><a href="#pian-xiang-suo-shang-suo-shi-ru-he-bi-mian-chong-tu-he-jing-zheng">偏向锁上锁时，如何避免冲突和竞争？</a></li><li><a href="#chi-kai-tong-bu-dai-ma-kuai-shi-markword-zhong-de-xian-cheng-id-hui-chong-xin-bian-wei-0-ma">离开同步代码块时， markword中的线程id会重新变为0吗？</a></li><li><a href="#pian-xiang-suo-fa-sheng-jing-zheng-shi-de-qie-suo-huo-zhe-sheng-ji-cao-zuo">偏向锁发生竞争时的切锁或者升级操作。</a><ul><li><a href="#wei-shi-me-yao-deng-dai-an-quan-dian-cai-neng-zuo-che-xiao-cao-zuo">为什么要等待安全点，才能做撤销操作？</a></li><li><a href="#wei-shi-me-yao-xian-tui-hua-cheng-wu-suo-zhuang-tai-zai-shi-tu-jing-zheng-cheng-pian-xiang-suo-bu-neng-zhi-jie-pian-xiang-ma">为什么要先退化成无锁状态，再试图竞争成偏向锁？不能直接偏向吗？</a></li><li><a href="#wei-shi-me-yuan-pian-xiang-xian-cheng-zai-tong-bu-dai-ma-kuai-zhong-shi-jiu-bi-xu-sheng-ji-wei-qing-liang-ji-suo-neng-fou-tong-yang-che-xiao-wu-suo-lai-jing-zheng">为什么原偏向线程在同步代码块中时，就必须升级为轻量级锁？能否同样撤销无锁来竞争？</a></li></ul></li><li><a href="#pi-liang-chong-pian-xiang-yi-ji-epoch-de-ying-yong">批量重偏向，以及epoch的应用</a></li><li><a href="#pi-liang-che-xiao">批量撤销</a></li><li><a href="#pian-xiang-suo-zai-jin-cheng-yi-kai-shi-jiu-qi-yong-liao-ma">偏向锁在进程一开始就启用了吗</a></li></ul></li><li><a href="#pian-xiang-suo-de-chong-yao-yan-bian-li-shi-he-si-kao">偏向锁的重要演变历史和思考</a></li></ul></li><li><a href="#qing-liang-ji-suo">轻量级锁</a><ul><li><a href="#yuan-xian-markword-zhong-de-xin-xi-du-qu-na-li-liao">原先markword中的信息都去哪里了？</a></li><li><a href="#qing-liang-ji-suo-ru-he-chu-li-xian-cheng-chong-ru-wen-ti">轻量级锁如何处理线程重入问题？</a></li><li><a href="#qing-liang-ji-suo-jia-suo-guo-cheng">轻量级锁加锁过程</a></li><li><a href="#qing-liang-ji-suo-de-jie-suo-liu-cheng">轻量级锁的解锁流程</a></li><li><a href="#zi-xuan-ci-shu-de-shang-xian-yi-ding-shi-10-ci-ma">自旋次数的上限一定是10次吗？</a></li></ul></li><li><a href="#chong-liang-ji-suo">重量级锁</a><ul><li><a href="#sheng-ji-wei-chong-liang-ji-suo-de-tiao-jian">升级为重量级锁的条件</a></li></ul></li><li><a href="#markword-qu-na-liao">markword去哪了</a><ul><li><a href="#chong-liang-ji-suo-tong-bu-de-yuan-li-tu-jie">重量级锁同步的原理图解</a></li></ul></li></ul></li><li><a href="#guan-yu-synchronized-guan-jian-zi-de-si-kao">关于synchronized关键字的思考</a></li></ul><!-- tocstop --></div><p>[toc]</p><h1><span id="wei-shi-me-shuo-xian-cheng-qie-huan-hui-hen-man">为什么说线程切换会很慢？</span><a href="#wei-shi-me-shuo-xian-cheng-qie-huan-hui-hen-man" class="header-anchor">#</a></h1><p>所谓的用户态和内核态之间的切换仅仅是一方面， 并非全部， 更关键的在于， 多CPU的机器中，<strong>当你切换了线程，意味着线程在原先CPU上的缓存也许不再有用</strong>，  因为当线程重新触发时，可能在另一个CPU上执行了。</p><p>正因如此，不建议没事就挂起线程， 让线程自旋会比挂起后切换CPU好很多。</p><p>正与基于这一点，才有了后面的sync锁升级机制，理解了为什么要锁升级，才能逐步理解锁升级过程，</p><h1><span id="dui-xiang-tou-zhong-de-mark-word">对象头中的mark-word</span><a href="#dui-xiang-tou-zhong-de-mark-word" class="header-anchor">#</a></h1><p>java每个对象的对象头中， 都有32或者64位的mark-word。</p><p>mark-word是理解锁升级过程的重要部分，且后面的锁升级过程都会涉及，因此这里会进行一个非常详细的解释。这部分只对一个对象必有的属性做解释（即一般不会随着锁状态变化而消失的属性）。对于各锁状态独有的属性，会在锁升级过程中做详细的解释。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655422124426.png" alt="1655422124426"></p><h2><span id="suo-zhuang-tai-biao-zhi-wei-pian-xiang-suo-biao-ji-wei-2bit-1bit">锁状态标志位 +偏向锁标记位（2bit + 1bit）</span><a href="#suo-zhuang-tai-biao-zhi-wei-pian-xiang-suo-biao-ji-wei-2bit-1bit" class="header-anchor">#</a></h2><p>除了markword中的2位锁状态标志位， 其他62位都会随着锁状态标志位的变化而变化。</p><p>这里先列出各锁状态标志位代表的当前对象所用锁的情况。后面会详细解释各种锁的含义和运行原理。</p><ul><li>锁状态标志位为01： 属于无锁或者偏向锁状态。<strong>因此还需要额外的偏向锁标记位1bit来确认是无锁还是偏向锁</strong></li><li>锁状态标志位为00： 轻量级锁</li><li>锁状态标志位为10： 重量级锁</li><li>锁状态标志位为11： 已经被gc标记，即将释放</li></ul><h3><span id="wei-shi-me-wu-suo-pian-xiang-suo-de-biao-zhi-wei-shi-01-er-qing-liang-ji-suo-de-biao-zhi-wei-shi-00">为什么无锁/偏向锁的标志位是01，而轻量级锁的标志位是00？</span><a href="#wei-shi-me-wu-suo-pian-xiang-suo-de-biao-zhi-wei-shi-01-er-qing-liang-ji-suo-de-biao-zhi-wei-shi-00" class="header-anchor">#</a></h3><p>即按理说，无锁是锁状态的初始情况，为什么标志位不是从00开始？</p><p>个人查询到的一个解释，是因为 轻量级锁除了锁标志位外，另外62位都是一个指针地址。</p><p>如果将轻量级锁标志位设置为00， 那么在判断标志位为00后， <strong>jvm无需再额外做一次markWord&gt;&gt;2的操作，而是直接将markWord拿来当作地址使用即可！</strong></p><p>可以从这里看到jvm的设计者还是非常细节的，并没有随意地定义各状态的标志位</p><h2><span id="hashcode-31bit">hashcode（31bit）</span><a href="#hashcode-31bit" class="header-anchor">#</a></h2><p>哈希code很容易理解，将对象存储到一些map或者set里时，都需要hashcode来确认插入位置。</p><p>但markword里的hashcode，和我们平时经常覆写的hashCode()还是有区别的。</p><h3><span id="markword-zhong-de-hashcode-shi-na-ge-fang-fa-sheng-cheng-de">markword中的hashcode是哪个方法生成的？</span><a href="#markword-zhong-de-hashcode-shi-na-ge-fang-fa-sheng-cheng-de" class="header-anchor">#</a></h3><p>很多人误以为，markword中的hashcode是由我们经常覆写的hashcode（）方法生成的。</p><p>实际上， markword中的hashcode只由底层 JDK C++ 源码计算得到（java侧调用方法为 System.identityHashCode() ）， 生成后固化到markword中，</p><p>如果你覆写了hashcode()方法， 那么每次都会重新调用<code>hashCode()</code>方法重新计算哈希值。</p><p>根本原因是因为你覆写hashcode()之后，该方法中很可能会利用被修改的成员来计算哈希值，所以jvm不敢将其存储到markword中。</p><p>**因此，如果覆写了hashcode（）方法，对象头中就不会生成hashcode，而是每次通过hashcode()方法调用 **</p><h3><span id="markword-zhong-de-hashcode-shi-shi-me-shi-hou-sheng-cheng">markword中的hashcode是什么时候生成？</span><a href="#markword-zhong-de-hashcode-shi-shi-me-shi-hou-sheng-cheng" class="header-anchor">#</a></h3><p>很容易误以为会是对象一创建就生成了。</p><p>实际上，是采用了<strong>延迟加载技术</strong>，只有在用到的时候才生成。</p><p>毕竟有可能对象创建出来使用时，并不需要做哈希的操作。</p><h3><span id="hashcode-zai-qi-ta-suo-zhuang-tai-zhong-qu-na-liao">hashcode在其他锁状态中去哪了？</span><a href="#hashcode-zai-qi-ta-suo-zhuang-tai-zhong-qu-na-liao" class="header-anchor">#</a></h3><p>这个问题会在后面锁升级的3个阶段中，解释hashcode的去向。其他的例如分代年龄同理。</p><h2><span id="gc-fen-dai-nian-ling-4bit">gc分代年龄（4bit）</span><a href="#gc-fen-dai-nian-ling-4bit" class="header-anchor">#</a></h2><p>在jvm垃圾收集机制中， 决定年轻代什么时候进入老年代的根据之一， 就是确认他的分代年龄是否达到阈值，如下图所示。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655422054870.png" alt="1655422054870"></p><p>分代年龄只有4bit可以看出，最大值只能是15。因此我们设置的进入老年代年龄阈值 -XX:MaxTenuringThreshold 最大只能设置15。</p><h2><span id="cms-free">cms_free</span><a href="#cms-free" class="header-anchor">#</a></h2><p>在无锁和偏向锁中，还可以看到有1bit的cms_free。</p><p>实际上就是只有CMS收集器用到的。但最新java11中更多用的是G1收集器了，这一位相当于不怎么常用，因此提到的也非常少。</p><p>从上述可以看出， 只有锁状态标记位、 hashcode、 分代年龄、cms_free是必有的， 但是从markword最初的示意图来看， hashcode、 分代年龄、cms_free似乎并非一直存在，那么他们去哪了呢？会在后面的锁升级过程进行详细解释。</p><h1><span id="suo-sheng-ji-si-ge-jie-duan-chao-ji-xiang-jie">锁升级四个阶段超级详解</span><a href="#suo-sheng-ji-si-ge-jie-duan-chao-ji-xiang-jie" class="header-anchor">#</a></h1><h2><span id="wu-suo">无锁</span><a href="#wu-suo" class="header-anchor">#</a></h2><p>无锁状态的markword如下所示，可以看到上文提到的信息都存在</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655337139035.png" alt="1655337139035"></p><h3><span id="chu-yu-wu-suo-zhuang-tai-de-tiao-jian-huo-zhe-shi-ji-shi-shi-me">处于无锁状态的条件或者时机是什么？</span><a href="#chu-yu-wu-suo-zhuang-tai-de-tiao-jian-huo-zhe-shi-ji-shi-shi-me" class="header-anchor">#</a></h3><p>无锁状态用于对象刚创建，<strong>且还未进入过同步代码块的时候</strong></p><p>这一点很重要， 意味着如果你没有同步代码块或者同步方法， 那么将是无锁状态。</p><h3><span id="dui-xiang-cong-mei-jin-ru-tong-bu-kuai-wei-shi-me-pian-xiang-suo-biao-zhi-wei-que-shi-1">对象从没进入同步块，为什么偏向锁标志位却是1？</span><a href="#dui-xiang-cong-mei-jin-ru-tong-bu-kuai-wei-shi-me-pian-xiang-suo-biao-zhi-wei-que-shi-1" class="header-anchor">#</a></h3><p>上面这个问题说过，没进入同步块， 不会上偏向锁。</p><p>但是我们如果用java的jol工具测试打印新对象，会看到低3位是101</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655537149976.png" alt="1655537149976"></p><p>这其实是jvm后面加入的一种优化， 对每个新对象，预置了一个**“可偏向状态”<strong>，也叫做</strong>匿名偏向状态**，是对象初始化中，JVM 帮我们做的。</p><p>注意此时 markword中高位是不存在ThreadID的， 都是0， 说明此时并没有线程偏向发生，因此也可以理解成是无锁。</p><p>好处在于后续做偏向锁加锁时，无需再去改动偏向锁标记位，只需要对线程id做cas即可。</p><h2><span id="pian-xiang-suo">偏向锁</span><a href="#pian-xiang-suo" class="header-anchor">#</a></h2><p>一旦代码第一次进入sync同步方法块，就<strong>可能</strong>从无锁状态进入偏向锁状态。</p><p>另外很多人应该都知道， 偏向锁只存储了当前偏向的线程id， 只有线程id不同的才会触发升级。</p><p>但这是非常简化的说法， 实际上中间的细节和优化非常之多！这里将为你详细讲述。</p><h3><span id="wei-shi-me-yao-you-pian-xiang-suo">为什么要有偏向锁？</span><a href="#wei-shi-me-yao-you-pian-xiang-suo" class="header-anchor">#</a></h3><p>理解这个才能理解偏向锁中的各种设计。   假设我们new出来的对象带有同步代码块方法，但在整个生命周期中只被一个线程访问，那么是否有必要做消耗消耗的竞争动作，甚至引入额外的内存开销？没有必要。</p><p>因此针对的是 <strong>对象有同步方法调用，但是实际不存在竞争的场景</strong></p><h3><span id="pian-xiang-suo-de-markword-xiang-jie">偏向锁的markword详解</span><a href="#pian-xiang-suo-de-markword-xiang-jie" class="header-anchor">#</a></h3><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655534605569.png" alt="1655534605569"></p><p>这个markword和无锁对比，  偏向标志位变成了1，   hashcode没了，多了个epoch和线程id。</p><h4><span id="markword-zhong-de-dang-qian-xian-cheng-id">markword中的当前线程id</span><a href="#markword-zhong-de-dang-qian-xian-cheng-id" class="header-anchor">#</a></h4><p>这个id就是在进入了对象同步代码块的线程id。</p><h5><span id="java-de-xian-cheng-id-shi-yi-ge-long-lei-xing-an-li-shuo-shi-64-wei-dan-wei-shi-me-zhi-lei-de-xian-cheng-id-zhi-you-54-wei">java的线程id是一个long类型， 按理说是64位，但为什么之类的线程id只有54位？</span><a href="#java-de-xian-cheng-id-shi-yi-ge-long-lei-xing-an-li-shuo-shi-64-wei-dan-wei-shi-me-zhi-lei-de-xian-cheng-id-zhi-you-54-wei" class="header-anchor">#</a></h5><p>具体没有找到解释，可能是jvm团队认为54位线程id足够用了，不至于会创建2^54那么多的线程，真的有需要创建这么频繁的程序，也会优先采用线程池池才对</p><h5><span id="xian-cheng-id-ru-he-xie-ru">线程id如何写入？</span><a href="#xian-cheng-id-ru-he-xie-ru" class="header-anchor">#</a></h5><p>线程id是直接写入markword吗？ 不对， 一定要注意到这时候是存在同时写的可能的。</p><p>因此会<strong>采用CAS的方式进行线程id的写入</strong>。 简而言之， 就是先取原线程id后，再更新线程id，更新后检查一下是否和预期一致，不一致则说明被人改动过，则线程id写入失败，说明存在竞争，升级为轻量级锁。</p><h4><span id="ha-xi-code-qu-na-liao">哈希code去哪了</span><a href="#ha-xi-code-qu-na-liao" class="header-anchor">#</a></h4><p>我们注意到无锁时的hashcode不见了。</p><p>对于偏向锁而言， <strong>一旦在对象头中设置过hashcode， 那么进入同步块时就不会进入偏向锁状态</strong>，会直接跳到轻量级锁，毕竟偏向锁里没有存放hashcode的地方（下文的轻量级锁和重量级锁则有存储的地方）</p><p>因此凡是做过类似hashmap.put(k,v)操作且没覆写hashcode的k对象， 以后加锁时，都会直接略过偏向锁。</p><h4><span id="epoch-shi-shi-me">epoch是什么？</span><a href="#epoch-shi-shi-me" class="header-anchor">#</a></h4><p>这个属性很多人叫它“偏向时间戳”， 却鲜有人进行详细解释。</p><p>主要是因为它涉及到了偏向锁中非常重要的2个优化（批量重偏向和批量撤销）</p><p>对于这个epoch，放到下文的偏向锁解锁过程进行解释。</p><p>你可以先简单理解为，<strong>通过epoch，jvm可以知道这个对象的偏向锁是否过期了，过期的情况下允许直接试图抢占，而不进行撤销偏向锁的操作。</strong></p><h3><span id="pian-xiang-suo-yun-zuo-xiang-jie">偏向锁运作详解</span><a href="#pian-xiang-suo-yun-zuo-xiang-jie" class="header-anchor">#</a></h3><h4><span id="pian-xiang-suo-shang-suo-shi-ru-he-bi-mian-chong-tu-he-jing-zheng">偏向锁上锁时，如何避免冲突和竞争？</span><a href="#pian-xiang-suo-shang-suo-shi-ru-he-bi-mian-chong-tu-he-jing-zheng" class="header-anchor">#</a></h4><p>我们知道偏向锁其实就是将线程id设置了进去，但是如果存在冲突怎么办？</p><p>因此，jmv会<strong>通过CAS</strong>来设置偏向线程id，一旦设置成功那么这个偏向锁就算挂上了。</p><p>后面每次访问时，检查线程id一致，就直接进入同步代码块执行了。</p><blockquote><p>CAS概念补充：</p><p>CAS是一个原子性操作， 调用者需要给定修改变量的期望值 和 最终值</p><p>当内存中该变量的值和期望值相等时，才更新为最终值，   这个相等的比较和更新的操作是原子操作</p></blockquote><p>对于到偏向锁加锁过程， 其实就是先取出线程id部分， 如果为空， 则进行（期望值：空  ， 最终值：当前线程id）的CAS操作， 如果发现期望值不匹配，就说明被抢先了 。</p><h4><span id="chi-kai-tong-bu-dai-ma-kuai-shi-markword-zhong-de-xian-cheng-id-hui-chong-xin-bian-wei-0-ma">离开同步代码块时， markword中的线程id会重新变为0吗？</span><a href="#chi-kai-tong-bu-dai-ma-kuai-shi-markword-zhong-de-xian-cheng-id-hui-chong-xin-bian-wei-0-ma" class="header-anchor">#</a></h4><p>并不会，这个偏向锁线程id会一直挂着， 后面只要识别到id一致，就不用做特殊处理。</p><h4><span id="pian-xiang-suo-fa-sheng-jing-zheng-shi-de-qie-suo-huo-zhe-sheng-ji-cao-zuo">偏向锁发生竞争时的切锁或者升级操作。</span><a href="#pian-xiang-suo-fa-sheng-jing-zheng-shi-de-qie-suo-huo-zhe-sheng-ji-cao-zuo" class="header-anchor">#</a></h4><p>但当有其他线程来访问时，之前设置的偏向锁就有问题了，说明存在多线程访问同一个对象的情况。</p><p><strong>注意！！！这里并非像很多资料里说的那样， 一旦发生多线程调用， 偏向锁就升级成轻量级锁</strong>，而是做了很多的细节处理，来尽可能避免轻量级锁这种耗费CPU的操作。</p><p>首先，jvm考虑到了这种场景：</p><p>最开始1h内，都是线程A在调用大量的对象obj， 于是偏向锁一直都是线程A。</p><p>后来线程A不跑了， 对象obj的调用交给了线程B，即未来都是线程B来调用。</p><p>那么这时候，有必要马上升级轻量级锁吗？</p><p>没必要！因为未来仍然是单线程调用，仅仅是线程不同而已，也许可以尝试仍旧用偏向锁？</p><p>于是就有了如下的撤销偏向锁的动作：</p><ol><li>当线程B发现是偏向锁，且线程id不为自己时，开始撤销操作</li><li>首先，线程B会一直等待 对象obj 到达jvm<strong>安全点</strong>。</li><li>到达安全点后， 线程B检查线程A是否正处在obj的同步代码块内。</li><li>如果线程A正在同步代码块中， 则没得商量了，直接升级为轻量级锁。</li><li>如果线程A不在同步代码块中， 那么线程B还有机会， 它先把偏向锁改成无锁状态，然后再用CAS的方式尝试重新竞争，如果能竞争到，那么就会偏向自己。</li></ol><p>完整过程如下图所示：</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655599370757.png" alt="1655599370757"></p><h5><span id="wei-shi-me-yao-deng-dai-an-quan-dian-cai-neng-zuo-che-xiao-cao-zuo">为什么要等待安全点，才能做撤销操作？</span><a href="#wei-shi-me-yao-deng-dai-an-quan-dian-cai-neng-zuo-che-xiao-cao-zuo" class="header-anchor">#</a></h5><p>这是为了保证撤销操作的安全性。否则可能出现jvm正在撤销的时候， 另一个线程又开始对该对象做操作，引发错误。</p><h5><span id="wei-shi-me-yao-xian-tui-hua-cheng-wu-suo-zhuang-tai-zai-shi-tu-jing-zheng-cheng-pian-xiang-suo-bu-neng-zhi-jie-pian-xiang-ma">为什么要先退化成无锁状态，再试图竞争成偏向锁？不能直接偏向吗？</span><a href="#wei-shi-me-yao-xian-tui-hua-cheng-wu-suo-zhuang-tai-zai-shi-tu-jing-zheng-cheng-pian-xiang-suo-bu-neng-zhi-jie-pian-xiang-ma" class="header-anchor">#</a></h5><p>因为你无法预测A是否会卷土重来，置成无锁后， A和B可以公平竞争。</p><h5><span id="wei-shi-me-yuan-pian-xiang-xian-cheng-zai-tong-bu-dai-ma-kuai-zhong-shi-jiu-bi-xu-sheng-ji-wei-qing-liang-ji-suo-neng-fou-tong-yang-che-xiao-wu-suo-lai-jing-zheng">为什么原偏向线程在同步代码块中时，就必须升级为轻量级锁？能否同样撤销无锁来竞争？</span><a href="#wei-shi-me-yuan-pian-xiang-xian-cheng-zai-tong-bu-dai-ma-kuai-zhong-shi-jiu-bi-xu-sheng-ji-wei-qing-liang-ji-suo-neng-fou-tong-yang-che-xiao-wu-suo-lai-jing-zheng" class="header-anchor">#</a></h5><p>不可以，因为同步代码块还在执行的话，那B线程此时是注定无法立刻得到锁的，注定了它必须升级为轻量级锁，通过轻量级锁中的循环能力来做获取锁的操作。</p><h4><span id="pi-liang-chong-pian-xiang-yi-ji-epoch-de-ying-yong">批量重偏向，以及epoch的应用</span><a href="#pi-liang-chong-pian-xiang-yi-ji-epoch-de-ying-yong" class="header-anchor">#</a></h4><p>上文提到，  线程B重新抢偏向锁时，会试图等待安全点，撤销成无锁，再做公平抢占。 这个动作还是比较费时的。</p><p>假设有一个场景， 我们new 了30个obj对象， 最初都是由A线程使用，后面通过for循环都由B线程使用，那么会发现在很短的时间内，连续发生了偏向锁撤销为无锁，且未因同步块竞争而发生轻量升级的情况。</p><p>那么，jvm猜测此时后面都是类似的情况，于是B线程调用obj对象时，不再撤销了，直接CAS竞争threadId，因为jvm预测A不会来抢了，具体步骤如下所示：</p><ol><li><p>jvm会在obj对象的<strong>类class对象</strong>中， 定义了一个偏向撤销计数器以及epoch偏向版本。</p></li><li><p>每当有一个对象被撤销偏向锁， 都会让偏向撤销计数器+1。</p></li><li><p>一旦加到20， 则认为出现大规模的锁撤销动作。 于是class类对象中的epoch值+1（但是epoch一般只有2位即0~3）。</p></li><li><p>接着， jvm会找到所有正处在同步代码块中的obj对象， 让他的epoch等于class类对象的epoch。</p></li><li><p>其他不在同步代码块中的obj对象，则不修改epoch。</p></li><li><p>当B线程来访问时，发现obj对象的epoch和class对象的epoch不相等，则不再做撤销动作，直接CAS抢占。  <strong>因为当epoch不等时，这说明该obj对象之前一直没被原主人使用， 但它的兄弟们之前纷纷投降倒戈了， 那我应该直接尝试占用就好，没必要那么谨慎了！</strong></p></li></ol><p>详细过程如下图所示：</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655542634901.png" alt="1655542634901"></p><h4><span id="pi-liang-che-xiao">批量撤销</span><a href="#pi-liang-che-xiao" class="header-anchor">#</a></h4><p>但如果短时间内该类的撤销动作超过40个， jvm会认为这个数量太多了， 不保险，数量一多，预测就不准了。</p><p>jvm此时会将 obj对象的类class对象中的偏向标记**（注意是类中的偏向锁开启标记，而不是对象头中的偏向锁标记）**设置为禁用偏向锁。  后续该对象的new操作将直接走轻量级锁的逻辑。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655600519145.png" alt="1655600519145"></p><h4><span id="pian-xiang-suo-zai-jin-cheng-yi-kai-shi-jiu-qi-yong-liao-ma">偏向锁在进程一开始就启用了吗</span><a href="#pian-xiang-suo-zai-jin-cheng-yi-kai-shi-jiu-qi-yong-liao-ma" class="header-anchor">#</a></h4><p>即使你开启了偏向锁，但是这个偏向锁的启用是有延迟，大概 4s左右。</p><p><strong>即java进程启动的4s内，都会直接跳过偏向锁</strong>，有同步代码块时直接使用轻量级锁。</p><p>原因是 JVM 初始化的代码有很多地方用到了synchronized，如果直接开启偏向，产生竞争就要有锁升级，会带来额外的性能损耗，jvm团队经过测试和评估， 选择了启动速度最快的方案， 即强制4s内禁用偏向锁，所以就有了这个延迟策略 （当然这个延迟时间也可以通过参数自己调整）</p><h3><span id="pian-xiang-suo-de-chong-yao-yan-bian-li-shi-he-si-kao">偏向锁的重要演变历史和思考</span><a href="#pian-xiang-suo-de-chong-yao-yan-bian-li-shi-he-si-kao" class="header-anchor">#</a></h3><p>偏向锁在JDK6引入,  且默认开启偏向锁优化, 可通过JVM参数-XX:-UseBiasedLocking来禁用偏向锁。</p><p>jdk的演变过程中， 为偏向锁做了如上所述的批量升级、撤销等诸多动作。</p><p>但随着时代发展，发现偏向锁带来的维护、撤销成本， 远大于轻量级锁的少许CAS动作。</p><p>官方说明中有这么一段话: since the introduction of biased locking into HotSpot also change the amount of uncontended operations needed for that relation to remain true。</p><p>即<strong>随着硬件发展，原子指令成本变化，导致轻量级自旋锁需要的原子指令次数变少(或者cas操作变少 个人理解)，所以自旋锁成本下降，故偏向锁的带来的优势就更小了</strong>。</p><p>于是jdk团队<strong>在Jdk15之后， 再次默认关闭了偏向锁</strong>。</p><p>也许你会问，那前面学习了那么一堆还有啥意义，都不推荐使用了。</p><p>但大部分java应用还是基于jdk8开发的， 并且偏向锁里的思想还是值得借鉴的。</p><p>还有就是奥卡姆剃刀原理， 如果增加的内容带来很大的成本，不如大胆的废除掉，接受一点落差，将精力放在提升度更大的地方。</p><h2><span id="qing-liang-ji-suo">轻量级锁</span><a href="#qing-liang-ji-suo" class="header-anchor">#</a></h2><p>轻量级锁的markword如下所示，可以看到除了锁状态标记位，其他的都变成了一个栈帧中lockRecord记的地址。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655603492133.png" alt="1655603492133"></p><h3><span id="yuan-xian-markword-zhong-de-xin-xi-du-qu-na-li-liao">原先markword中的信息都去哪里了？</span><a href="#yuan-xian-markword-zhong-de-xin-xi-du-qu-na-li-liao" class="header-anchor">#</a></h3><p>之前提到markword中有分代年龄、cms_free、hashcode等固有属性。</p><p>这些信息会被存储到对应线程栈帧中的<strong>lockRecord</strong>中。</p><p>lockRecord格式以及存储/交换过程如下：</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656209393501.png" alt="1656209393501"></p><p>**另外注意， 当轻量级锁未上锁时， 对象头中的markword存储的还是markword内容，并没有变成指针，只有当上锁过程中，才会变成指针。 **</p><p><strong>因此轻量级锁是存在反复的加锁解锁操作的（偏向锁只有在更换偏向线程时才会有类似动作）</strong></p><p>解锁过程同理，通过CAS，将对象头替换回去。</p><h3><span id="qing-liang-ji-suo-ru-he-chu-li-xian-cheng-chong-ru-wen-ti">轻量级锁如何处理线程重入问题？</span><a href="#qing-liang-ji-suo-ru-he-chu-li-xian-cheng-chong-ru-wen-ti" class="header-anchor">#</a></h3><p>对于同一个线程，如果反复进入同步块，在sync语义上来说是支持重入的（即持有锁的线程可以多次进入锁区域）， 对轻量级锁而言，必须实现这个功能。</p><p>因此线程的lockRecord并非单一成员，<strong>他其实是一个lockRecord集合，可以存储多个lockRecord</strong>。</p><p>每当线程离开同步块，lockRecord减少1个， 直到这个lockReocrd中包含指针，才会做解锁动作。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656209539382.png" alt="1656209539382"></p><h3><span id="qing-liang-ji-suo-jia-suo-guo-cheng">轻量级锁加锁过程</span><a href="#qing-liang-ji-suo-jia-suo-guo-cheng" class="header-anchor">#</a></h3><p>根据上述CAS和重入相关，可以得到进入同步代码块时的加锁过程：</p><ol><li><p>进入同步块前，检查是否已经储存了lockRecord地址，且地址和自己当前线程一致 。如果已经存了且一致，说明正处于重入操作，走重入逻辑，新增lockRecord</p></li><li><p>如果未重入，检查lockRecord是否被其他线程占用，如果被其他线程占用，则自旋等待，自旋超限后升级重量级锁</p></li><li><p>如果未重入，且也没被其他线程占用，则取出lockRecord中存的指针地址，然后再用自己的markword做CAS替换</p></li><li><p>替换失败，则尝试自旋重新CAS，失败次数达到上限，也一样升级</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/62b7cb401e0853156072c623-1656212698507.png" alt="img"></p></li></ol><h3><span id="qing-liang-ji-suo-de-jie-suo-liu-cheng">轻量级锁的解锁流程</span><a href="#qing-liang-ji-suo-de-jie-suo-liu-cheng" class="header-anchor">#</a></h3><p>根据上面重入的问题，可以得到轻量级锁的退出流程如下：</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656211852407.png" alt="1656211852407"></p><h3><span id="zi-xuan-ci-shu-de-shang-xian-yi-ding-shi-10-ci-ma">自旋次数的上限一定是10次吗？</span><a href="#zi-xuan-ci-shu-de-shang-xian-yi-ding-shi-10-ci-ma" class="header-anchor">#</a></h3><p>在JDK 6中对自旋锁的优化，引入了自适应的自旋。</p><p>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。</p><p>另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了</p><h2><span id="chong-liang-ji-suo">重量级锁</span><a href="#chong-liang-ji-suo" class="header-anchor">#</a></h2><p>重量级锁如下：</p><p>每个对象会有一个objectMonitor的C<ins>对象生成， 通过地址指向对方，后面的逻辑都是通过C</ins>来实现。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656831726425.png" alt="1656831726425"></p><h3><span id="sheng-ji-wei-chong-liang-ji-suo-de-tiao-jian">升级为重量级锁的条件</span><a href="#sheng-ji-wei-chong-liang-ji-suo-de-tiao-jian" class="header-anchor">#</a></h3><ol><li><p>从轻量级锁升级为重量级锁的条件：  自旋超过10次 或者达到自适应自旋上限次数</p></li><li><p>从无锁/偏向锁直接升级为重量级锁的条件：<strong>调用了object.wait()方法，则会直接升级为重量级锁！</strong></p><p>第二个条件容易被忽略的</p></li></ol><h2><span id="markword-qu-na-liao">markword去哪了</span><a href="#markword-qu-na-liao" class="header-anchor">#</a></h2><p>对象头中的markwod，和轻量级锁中的处理类似， 被存入了objectMonitor对象的header字段中了。</p><h3><span id="chong-liang-ji-suo-tong-bu-de-yuan-li-tu-jie">重量级锁同步的原理图解</span><a href="#chong-liang-ji-suo-tong-bu-de-yuan-li-tu-jie" class="header-anchor">#</a></h3><p>每个对象的重量级锁指向一个独有的objectMonitor</p><p>这个对象是C++实现的</p><p>里面的东西比较多，内容非常复杂，里面关于cxq、entryList、qmod之间的关系非常复杂，这里只会简单解释部分过程，不一定全部正确或者包含所有细节。</p><p>因此特地拿出一句我认为说的很好的话：</p><p><strong>“与其费劲心机研究C++实现的objectMonitor，不如去研究使用java实现的AQS原理，二者的核心思想大部分一致，AQS源码在语言上对java人而言更为友好 ，能让你更好理解线程排队、等待、唤醒的各种过程”</strong></p><p>但这篇文章毕竟说的是sync关键字，所以还是简要说一下monitor的过程：</p><ol><li><p>当线程第一次调用monitorEntry执行且是重量级锁的情况下，会先进入cxq队列</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836560641.png" alt="1656836560641"></p></li><li><p>当涉及锁的频繁竞争且需要阻塞时，需要进入entryList队列中。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836632599.png" alt="1656836632599"></p></li><li><p>如果线程能CAS竞争到onwer指针，就说明占有同步代码块成功， 如果CAS竞争不到，则block阻塞。</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836734369.png" alt="1656836734369"></p></li><li><p>monitorExit退出时，会让entryList中block阻塞的线程唤醒重新竞争</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836830029.png" alt="1656836830029"></p></li><li><p>如果调用了object.wait()方法， onwer线程会进入等待队列（注意，因为竞争失败的线程，不会进入waitSet，waitSet只服务于那些wait()方法引发的线程）</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836839076.png" alt="1656836839076"></p></li><li><p>当调用的object.notify()或者notifyAll， 等待队列中的线程会根据qmod模式的不同，进入cxq或者进入entryList。</p></li></ol><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836900003.png" alt="1656836900003"></p><p>简要版流程如下：</p><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836348826.png" alt="1656836348826"></p><h1><span id="guan-yu-synchronized-guan-jian-zi-de-si-kao">关于synchronized关键字的思考</span><a href="#guan-yu-synchronized-guan-jian-zi-de-si-kao" class="header-anchor">#</a></h1><p>终于写完了，说点其他的。</p><p>众所周知，随着jdk的不断升级， 官方提供的JUC以及衍生同步组件越来越强大， sync与其相比，功能相当少，背后逻辑却异常复杂，甚至因为过于复杂，还在中间对偏向锁的功能进行了默认关闭的操作。</p><p>那么这个关键字是否还有存在的必要呢？</p><p>首先，很多历史代码以及内部某些jdk代码实现，都还是会依赖这个关键字进行同步处理，没法全部替换成AQS。</p><p>另外，不考虑背后升级的复杂逻辑， sync使用起来绝对是比JUC简单很多的， 当你的场景很简单，但确实有同步的问题， 用sync会提升不少开发的效率。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile和CPU-MESI协议底层原理</title>
      <link href="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>《深入理解Java虚拟机》第二版中，关于volatile的原理，特地先讲述了如下图所示的JMM内存模型：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652969587838877545.png" alt="image.png"><br>它用了8种内存操作，以及多种规则，来告诉你特定情况下线程间的数据会如何同步。<br><strong>然而这个模型实际上已经在JDK5之后的虚拟机规范中被废弃了。</strong><br>最新官方文档中是采用“happens-before”模型来帮助java程序员分析多线程环境下的运行情况。<br>关于happends-before模型的详细解释，建议阅读《java并发编程的艺术》一书的第三章节。<br>本文并不讨论happends-before模型，只讨论底层原理，希望借着理解volatile，去理解一下它和CPU之间的关系。关于这部分内容，网上其实有很多错误的解读，根本原因在于没有从真正底层运行的原理考虑，导致了很多误区的产生。</p><p>本文将为你解答一下三大误区问题：</p><ol><li>MESI缓存一致性，为什么要设置4种状态这么复杂？是否都是同步、阻塞地保证缓存一致？</li><li>更新变量后，另一个线程真的永远不可见吗？多线程问题的本质是什么？</li><li>volatile保证一致性的真正底层运行逻辑是什么？</li></ol><p>以上问题，我将从CPU的层面，以超长图解和文字的形式，为你完整呈现。</p><div class="toc"><!-- toc --><ul><li><a href="#jmm-nei-cun-mo-xing-he-cpu">JMM内存模型和CPU</a><ul><li><a href="#wei-shi-me-xu-yao-zhe-ge-jmm-mo-xing-yong-lai-zuo-shi-me-de">为什么需要这个JMM模型？用来做什么的？</a></li><li><a href="#shang-shu-mo-xing-he-bei-hou-cao-zuo-xi-tong-cpu-shi-xian-you-shi-me-guan-xi-gong-zuo-nei-cun-dui-ying-shi-me-zhu-nei-cun-dui-ying-shi-me">上述模型和背后操作系统、CPU实现有什么关系？工作内存对应什么，主内存对应什么？</a></li><li><a href="#shi-me-shi-cpu-huan-cun-cpu-huan-cun-chang-shi-me-yang">什么是CPU缓存？CPU缓存长什么样？</a></li><li><a href="#2-ge-cpu-tong-shi-geng-xin-shu-ju-shi-you-shi-me-ban-fa-bi-mian-tong-shi-xiu-gai-zhu-cun">2个CPU同时更新数据时，有什么办法避免同时修改主存？</a></li></ul></li><li><a href="#mesi-xie-yi-chao-ji-xiang-jie">MESI协议超级详解</a><ul><li><a href="#wei-shi-me-yao-she-ji-du-zhan-zhuang-tai">为什么要设计独占状态？</a></li><li><a href="#wei-shi-me-cpu2-dui-a-zhi-de-huo-qu-neng-gou-xiu-gai-cpu1-de-zhuang-tai">为什么CPU2对a值的获取，能够修改CPU1的状态？</a></li><li><a href="#xiu-gai-wan-m-zhuang-tai-hou-fa-sheng-liao-shi-me-shi-zhi-jie-tong-bu-hui-nei-cun-ma">修改完M状态后，发生了什么？是直接同步回内存吗？</a></li><li><a href="#bu-ke-jian-de-wu-qu-li-zi">不可见的误区例子</a></li></ul></li><li><a href="#chong-tou-xi-you-mesi-bao-zheng-ke-jian-xing-de-xia-wei-shi-me-huan-you-hui-duo-xian-cheng-wen-ti">重头戏：有MESI保证可见性的下，为什么还有会多线程问题？</a><ul><li><a href="#cpu1-deng-dai-qi-ta-cpu-qing-kong-huan-cun-de-zu-sai-deng-dai-xing-wei-hui-bu-hui-tai-man-liao">CPU1等待其他CPU清空缓存的阻塞等待行为会不会太慢了？</a></li><li><a href="#you-shi-me-ban-fa-neng-jia-kuai-xiang-ying-su-du-invalid-xiao-xi-de-xiang-ying-su-du-ni">有什么办法能加快响应速度Invalid消息的响应速度呢？</a></li><li><a href="#duo-xian-cheng-wen-ti-yu-storebuffer-invalid-queue-zhi-jian-de-guan-xi">多线程问题与StoreBuffer、Invalid-Queue之间的关系</a></li></ul></li><li><a href="#volatile-you-shi-ru-he-bi-mian-cpu-geng-xin-yan-chi-wen-ti-de">volatile又是如何避免CPU更新延迟问题的？</a></li><li><a href="#tu-jie-zong-jie">图解总结</a></li></ul><!-- tocstop --></div><hr><p>[toc]</p><h1><span id="jmm-nei-cun-mo-xing-he-cpu">JMM内存模型和CPU</span><a href="#jmm-nei-cun-mo-xing-he-cpu" class="header-anchor">#</a></h1><h2><span id="wei-shi-me-xu-yao-zhe-ge-jmm-mo-xing-yong-lai-zuo-shi-me-de">为什么需要这个JMM模型？用来做什么的？</span><a href="#wei-shi-me-xu-yao-zhe-ge-jmm-mo-xing-yong-lai-zuo-shi-me-de" class="header-anchor">#</a></h2><p>这是为了给java开发者提供屏蔽平台差异性的、统一的多线程执行语义<br>不同的操作系统或者不同的CPU，其对多线程并发问题的支持情况是不同的，但jvm尽量在背后将其实现成一套统一的逻辑。<br><strong>即你按照我的关键字操作，就可以像JMM模型里那样运作，不需要关心背后的CPU怎么跑的</strong></p><h2><span id="shang-shu-mo-xing-he-bei-hou-cao-zuo-xi-tong-cpu-shi-xian-you-shi-me-guan-xi-gong-zuo-nei-cun-dui-ying-shi-me-zhu-nei-cun-dui-ying-shi-me">上述模型和背后操作系统、CPU实现有什么关系？工作内存对应什么，主内存对应什么？</span><a href="#shang-shu-mo-xing-he-bei-hou-cao-zuo-xi-tong-cpu-shi-xian-you-shi-me-guan-xi-gong-zuo-nei-cun-dui-ying-shi-me-zhu-nei-cun-dui-ying-shi-me" class="header-anchor">#</a></h2><p><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652969950678545272.png" alt="image.png"></p><ul><li>主内存对应于java堆中的对象实例部分（物理硬件的内存）</li><li>工作内存对应于虚拟机栈中的部分区域（ 寄存器，高速缓存， 线程主要访问读写的都是工作内存）</li></ul><h2><span id="shi-me-shi-cpu-huan-cun-cpu-huan-cun-chang-shi-me-yang">什么是CPU缓存？CPU缓存长什么样？</span><a href="#shi-me-shi-cpu-huan-cun-cpu-huan-cun-chang-shi-me-yang" class="header-anchor">#</a></h2><p>CPU缓存可以理解为一个容量有限的哈希表。<br>将某地址数据根据地址做哈希，映射到缓存的某一行，并且有替换的情况。<br>而划分两列，则是避免一出现hash冲突，就马上淘汰原内容的情况。<br>因此增加了备用列。通过这样一个多行两列的结构，根据内存地址实现了缓存的功能。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652970057734778836.png" alt="image.png"></p><h2><span id="2-ge-cpu-tong-shi-geng-xin-shu-ju-shi-you-shi-me-ban-fa-bi-mian-tong-shi-xiu-gai-zhu-cun">2个CPU同时更新数据时，有什么办法避免同时修改主存？</span><a href="#2-ge-cpu-tong-shi-geng-xin-shu-ju-shi-you-shi-me-ban-fa-bi-mian-tong-shi-xiu-gai-zhu-cun" class="header-anchor">#</a></h2><ul><li>一种方式是使用总线锁：确保CPU在持有总线锁期间，处理器可以独占任何共享内存。</li></ul><p>总线锁的代价是开销很大，其他CPU会一直在等待总线释放，读和写操作都无法处理。</p><ul><li>另一种方式是缓存锁，锁住各自的缓存，并<strong>通过缓存一致性协议MESI来进行和主存的同步。</strong></li></ul><h1><span id="mesi-xie-yi-chao-ji-xiang-jie">MESI协议超级详解</span><a href="#mesi-xie-yi-chao-ji-xiang-jie" class="header-anchor">#</a></h1><p>画了很多张图，顺便带上很多文字，来解释MESI协议的原理：<br>首先，CPU1和CPU2中的缓存都是空的， 因此缓存状态位是“I”（Invalid）<br>后面会相继提到各个状态的变化。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652970611412999019.png" alt="image.png"></p><hr><p>此时主存会将a的数据返回给CPU1， 并把CPU1的缓存状态<strong>设置为独占E（Exclude)</strong><br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652970706864127998.png" alt="image.png"></p><h2><span id="wei-shi-me-yao-she-ji-du-zhan-zhuang-tai">为什么要设计独占状态？</span><a href="#wei-shi-me-yao-she-ji-du-zhan-zhuang-tai" class="header-anchor">#</a></h2><p>目的是为了<strong>减少不必要的全局同步消息。</strong><br>当这个a变量只有CPU1使用时，无论CPU1怎么修改，也只有CPU1在查看，没必要把信息同步给其他CPU，从而提升了效率， 对于一些不参与竞争的变量来说，非常有用。</p><hr><p>好，独占的问题搞定，那么当CPU2也读取时，会发生什么？<br>此时就会不再是独占状态了，2个CPU同时被修改为共享状态S（Share）<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652971231021900637.png" alt="image.png"></p><h2><span id="wei-shi-me-cpu2-dui-a-zhi-de-huo-qu-neng-gou-xiu-gai-cpu1-de-zhuang-tai">为什么CPU2对a值的获取，能够修改CPU1的状态？</span><a href="#wei-shi-me-cpu2-dui-a-zhi-de-huo-qu-neng-gou-xiu-gai-cpu1-de-zhuang-tai" class="header-anchor">#</a></h2><p>这是因为CPU可以通过总线广播+监听消息来变更状态， 也称嗅探机制。<br><strong>即CPU核心都会经常监听总线上的广播事件，根据事件（消息）类型，来做不同的应对。</strong><br>因此当CPU2更改后，总线会广播read消息，当CPU1收到read消息，并确认这个数据的地址和自己缓存中的地址是一致的时候，就会修改状态为S了。</p><hr><p>上述问题搞定，再看最关键的<strong>修改缓存</strong>的部分了！</p><ol><li>当CPU1触发对a变量的修改时，会先发送一个Invalid消息。</li><li>CPU1此时会等待不动，停止任何操作，类似于阻塞了，它在等待其他CPU给他回应。</li><li>当其他的CPU收到Invalid消息时，会将缓存中的a变量修改为I（Invalid）无效状态</li><li>当所有CPU都处理完成时，总线为CPU1返回Invalid ack消息，CPU1才放心的将S状态修改为了M（modify）状态。<br>结合下面的图进行阅读更佳，注意图中的序号：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652971828729412023.png" alt="image.png"><br>很容易想到， 要将其他CPU设置为无效的原因，是为了保证其他CPU后面再次试图取a值时，取到的是最新的，而不是缓存的错误数据。</li></ol><h2><span id="xiu-gai-wan-m-zhuang-tai-hou-fa-sheng-liao-shi-me-shi-zhi-jie-tong-bu-hui-nei-cun-ma">修改完M状态后，发生了什么？是直接同步回内存吗？</span><a href="#xiu-gai-wan-m-zhuang-tai-hou-fa-sheng-liao-shi-me-shi-zhi-jie-tong-bu-hui-nei-cun-ma" class="header-anchor">#</a></h2><p>不是的！M状态此时就像“独占状态”一样，贪婪地占有这个缓存，后续的修改、读取，都直接读这个缓存，不再走任何总线</p><p>其目的和独占状态E一样，都是为了减少非竞争情况下不必要的总线消耗<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652972577879290980.png" alt="image.png"></p><hr><p>那么什么时候Modify状态会变化呢？<br>当其他的CPU试图获取a值，就会发生变化。其过程与 Exclude独占状态到Share状态 是类似的<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652972743188732799.png" alt="image.png"><br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652972759885249610.png" alt="image.png"></p><p>上面的内容给我一种感觉，MESI协议中，一直在给我们传达一个信息：<strong>MESI设置那么多状态，主要是为了避免每次都竞争。竞争只是偶然发生的，我们要尽可能少地乱锁总线！</strong></p><h2><span id="bu-ke-jian-de-wu-qu-li-zi">不可见的误区例子</span><a href="#bu-ke-jian-de-wu-qu-li-zi" class="header-anchor">#</a></h2><p>从上面可以看到，当我们修改缓存时，会通过触发对其他缓存的无效化，达到变量对其他线程“可见”的效果。<br>因此，<strong>MESI缓存一致性协议已经实现了缓存的可见性</strong>，<br>下面这种例子中，当flag=true时， 其他CPU通过MESI协议，是能够感知到flag的变化的，因为缓存一定会在那个时刻被设置为无效，从而获取最新的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">               num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">1255362997</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="chong-tou-xi-you-mesi-bao-zheng-ke-jian-xing-de-xia-wei-shi-me-huan-you-hui-duo-xian-cheng-wen-ti">重头戏：有MESI保证可见性的下，为什么还有会多线程问题？</span><a href="#chong-tou-xi-you-mesi-bao-zheng-ke-jian-xing-de-xia-wei-shi-me-huan-you-hui-duo-xian-cheng-wen-ti" class="header-anchor">#</a></h1><p>首先可以看这个知乎问题的回答，如果看不懂，可以看我为你整理的详细解释：<br><a href="https://www.zhihu.com/question/277395220">https://www.zhihu.com/question/277395220</a></p><hr><p>每个java线程有自己的寄存器。<br>线程寄存器和CPU缓存的关系？</p><hr><p>上面的MESI协议图中，其实缺少了2个关键的优化，这2个优化点，也成了可见性问题的根源。<br>为了好好讲清楚这2个优化点带来的影响，我特地放到这里才讲述，也将会帮助你大大理解“可见性”问题的本质！</p><p>首先我们回到CPU1修改a值时的那张图：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652973240336374790.png" alt="image.png"></p><p>里面提到，CPU1会等待所有CPU都将状态位置为I（无效）后，才开始修改状态并更新。那么有个问题：</p><h2><span id="cpu1-deng-dai-qi-ta-cpu-qing-kong-huan-cun-de-zu-sai-deng-dai-xing-wei-hui-bu-hui-tai-man-liao">CPU1等待其他CPU清空缓存的阻塞等待行为会不会太慢了？</span><a href="#cpu1-deng-dai-qi-ta-cpu-qing-kong-huan-cun-de-zu-sai-deng-dai-xing-wei-hui-bu-hui-tai-man-liao" class="header-anchor">#</a></h2><p>如果CPU1后面有好几条和a无关的指令（例如b=3,d=e等)，都在为了等待a的更新而不执行，未免太浪费时间了！</p><p>因此MESI设计了一个叫做 <strong>“StoreBuffer”</strong> 的东西，它会接收CPU1的修改动作，并由StoreBuffer来触发“阻塞等待-&gt;全部收到-&gt;修改状态M”的动作。<br>而CPU1则继续管自己去执行后续与a无关的指令。<br>因此<strong>StoreBuffer就像是一个异步的“生产者消息队列”。</strong>，如下所示：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652973451807966252.png" alt="image.png"></p><p>但是还有个问题，因为是等待所有CPU将a状态改为I，这个修改动作是需要时间的。<br>如果有一个CPU修改的比较慢，可能会导致 StoreBuffer这个生产者队列出现队满的情况，于是继续引发了阻塞。</p><h2><span id="you-shi-me-ban-fa-neng-jia-kuai-xiang-ying-su-du-invalid-xiao-xi-de-xiang-ying-su-du-ni">有什么办法能加快响应速度Invalid消息的响应速度呢？</span><a href="#you-shi-me-ban-fa-neng-jia-kuai-xiang-ying-su-du-invalid-xiao-xi-de-xiang-ying-su-du-ni" class="header-anchor">#</a></h2><p>那就是<strong>再引入一个“异步的消费者队列”，名叫Invalid Queue</strong><br>这样其他CPU收到消息时，先别急着处理，而是存到这个Queue中，然后直接返回Invalid消息，这样响应就变快了！ 也就是更新动作，和失效消息的接收，都加了一个队列！<br>如下图所示：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652973806095977745.png" alt="image.png"></p><h2><span id="duo-xian-cheng-wen-ti-yu-storebuffer-invalid-queue-zhi-jian-de-guan-xi">多线程问题与StoreBuffer、Invalid-Queue之间的关系</span><a href="#duo-xian-cheng-wen-ti-yu-storebuffer-invalid-queue-zhi-jian-de-guan-xi" class="header-anchor">#</a></h2><p>终于来到了关键的部分了。<br>从刚才的描述中，可以看到CPU引入了2个异步的队列，来处理数据的更新动作。<br>那么就可能存在赋值的动作被放入异步队列，导致延迟触发的情况。<br>而正是这个延迟放入的动作，可能导致数据延迟修改，<strong>即使没有发生指令重排序。</strong><br>这样干讲比较难懂，还是需要结合代码和图解。<br>首先是这个经典的多线程代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">           a = <span class="number">1</span>;                  <span class="comment">// 1</span></span><br><span class="line">           flag = <span class="literal">true</span>;            <span class="comment">// 2</span></span><br><span class="line">       &#125;</span><br><span class="line">       Public <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (flag != <span class="literal">true</span>) &#123;            <span class="comment">// 3</span></span><br><span class="line">             ;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span>  a * <span class="number">2</span>;     <span class="comment">// 4</span></span><br><span class="line">           …………</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照设想，程序员本是希望有如下的表现：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653490107416809220.png" alt="image.png"><br>但是事与愿违，当reader方法中离开了flag循环时，a的值仍然是初始化值0，导致c的值为0。</p><p>那么在了解了刚才的CPU原理后，我们终于可以开始分析这段代码为什么会发生这种问题了：</p><ol><li><p>当线程writer执行a=1时，CPU要做更新，会通过上面提到的异步机制进行更新。如果这个CPU此时堆积了很多的写操作，会导致a=1这个动作在异步队列中处于等待。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492190388870916.png" alt="image.png"></p></li><li><p>时间片切换，线程writer切到了另一个CPU上<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492292075803742.png" alt="image.png"><br>注意一个很重要的点：<br><strong>线程执行指令，并非只在1个CPU上运行，是可以通过时间片轮转切换的。因此CPU和线程并非完全绑定的关系</strong></p></li><li><p>flag=true动作在CPU2上迅速响应，很快完成了缓存一致性<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492398662891252.png" alt="image.png"></p></li></ol><p>4.reader线程读到了最新的flag，却没有读到新的a，导致了a还在用旧的值。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492531372457392.png" alt="image.png"></p><p>因此可以看到，<strong>正是CPU之间缓存更新的延迟，导致了多线程不同步问题的发生</strong></p><h1><span id="volatile-you-shi-ru-he-bi-mian-cpu-geng-xin-yan-chi-wen-ti-de">volatile又是如何避免CPU更新延迟问题的？</span><a href="#volatile-you-shi-ru-he-bi-mian-cpu-geng-xin-yan-chi-wen-ti-de" class="header-anchor">#</a></h1><p>这里不谈论那让人费解的内存屏障， 只要记住一点：<br><strong>对于volatile变量，一旦更新，不会走CPU异步更新，而是在这个CPU阻塞住，直到写动作完整完成，才会继续下一个指令的运行</strong><br>本质上是利用的#LOCK指令。<br>它的作用就是必须等待该变量的storeBuffer的清空，读取时也必须等待InvalidQueue的清空，才能去做写和读。从而保证不会出现因异步导致的多线程不同步问题</p><hr><h1><span id="tu-jie-zong-jie">图解总结</span><a href="#tu-jie-zong-jie" class="header-anchor">#</a></h1><p>写文章不容易，学习也不容易，给我点个关注点个赞，未来会持续更新具有思考深度的学习文章。欢迎在华为云社区共同交流和学习。</p><p>MESI缓存一致性原理图解如下：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/625af1a7e0b34d1a88113212.png" alt="image.png"></p><p>多线程同步问题如下：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492544846491616.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第296场周赛-209名-36分钟4题</title>
      <link href="/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/"/>
      <url>/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438529701.png" alt="1654438529701"></p> <div class="toc"><!-- toc --><ul><li><a href="#zong-jie">总结：</a></li><li><a href="#di-yi-ti-jian-dan-bian-li-ti">第一题：简单遍历题</a></li><li><a href="#di-er-ti-pai-xu-yu-chu-li">第二题：排序预处理</a></li><li><a href="#di-san-ti">第三题</a></li><li><a href="#di-si-ti-lian-biao-mo-ni-zui-you-ze-shi-zhan-mo-ni">第四题：链表模拟，最优则是栈模拟</a><ul><li><a href="#lian-biao-mo-ni">链表模拟：</a></li><li><a href="#shi-yong-zhan-shi-xian-5-fen-zhong-xie-wan">使用栈实现，5分钟写完：</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><p>题目简单， 速度不够快。</p><h1><span id="zong-jie">总结：</span><a href="#zong-jie" class="header-anchor">#</a></h1><ol><li><p>再提升1分钟的速度即可进前200</p></li><li><p>这种光标左右移动的题目，只划分左右两边的情况，使用双栈会比链表更合适。</p></li></ol><h1><span id="di-yi-ti-jian-dan-bian-li-ti">第一题：简单遍历题</span><a href="#di-yi-ti-jian-dan-bian-li-ti" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438568104.png" alt="1654438568104"></p><p>重点在于能否快速理解并迅速编写，用一个递归可以快速搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMaxGame</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] newNums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;newNums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            newNums[i] = Math.min(nums[<span class="number">2</span>*i], nums[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNums[i] = Math.max(nums[<span class="number">2</span>*i], nums[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minMaxGame(newNums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="di-er-ti-pai-xu-yu-chu-li">第二题：排序预处理</span><a href="#di-er-ti-pai-xu-yu-chu-li" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438642853.png" alt="1654438642853"></p><p>题目说是子序列（即可以不连在一起），然后要求每个序列内差值尽可能满足小于k。</p><p>那很容易想到先排序，再选取即可，就是预处理的思想</p><p>可惜这里还是思考的慢了点，用了5分钟才做完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partitionArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            lastNum = nums[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[i]  - lastNum &gt; k) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            lastNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1><span id="di-san-ti">第三题</span><a href="#di-san-ti" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438926785.png" alt="1654438926785"></p><p>这里如果能快速理解不需要考虑相同的整数，无论如何替换都是保证数组中互不相同的话，那就非常简单了，直接使用1个map进行处理即可。</p><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438971349.png" alt="1654438971349"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] arrayChange(<span class="type">int</span>[] nums, <span class="type">int</span>[][] operations) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numToIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        numToIndexMap.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] op : operations) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> op[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> op[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (numToIndexMap.containsKey(a)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> numToIndexMap.get(a);</span><br><span class="line">            numToIndexMap.remove(a);</span><br><span class="line">            nums[index] = b;</span><br><span class="line">            numToIndexMap.put(b, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="di-si-ti-lian-biao-mo-ni-zui-you-ze-shi-zhan-mo-ni">第四题：链表模拟，最优则是栈模拟</span><a href="#di-si-ti-lian-biao-mo-ni-zui-you-ze-shi-zhan-mo-ni" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654439021956.png" alt="1654439021956"></p><p>想了5分钟，决定模拟一个链表，  很久没写了，写得很慢，每次还得画图。</p><h2><span id="lian-biao-mo-ni">链表模拟：</span><a href="#lian-biao-mo-ni" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            Node last;</span><br><span class="line">            Node next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.c = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node cursorNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TextEditor</span><span class="params">()</span> &#123;</span><br><span class="line">            cursorNode = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c:text.toCharArray()) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(c);</span><br><span class="line">                node.last = lastNode;</span><br><span class="line">                node.next = cursorNode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">                cursorNode.last = node;</span><br><span class="line">                lastNode = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteText</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deleCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cursorNode.last != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">deleNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> deleNode.last;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = cursorNode;</span><br><span class="line">                &#125;</span><br><span class="line">                cursorNode.last = lastNode;</span><br><span class="line">                deleCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">cursorLeft</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cursorNode.last != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> cursorNode.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = nextNode;</span><br><span class="line">                    <span class="keyword">if</span> (lastNode.last != <span class="literal">null</span>) &#123;</span><br><span class="line">                        lastNode.last.next = cursorNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cursorNode.last = lastNode.last;</span><br><span class="line">                    cursorNode.next = lastNode;</span><br><span class="line">                    lastNode.last = cursorNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextNode.last = lastNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getLeftStr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getLeftStr</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span>(lastNode != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(lastNode.c);</span><br><span class="line">                lastNode = lastNode.last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">cursorRight</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cursorNode.next != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> cursorNode.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextNode.last = lastNode;</span><br><span class="line">                    <span class="keyword">if</span> (nextNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        nextNode.next.last = cursorNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cursorNode.next = nextNode.next;</span><br><span class="line">                    cursorNode.last = nextNode;</span><br><span class="line">                    nextNode.next = cursorNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getLeftStr();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor obj = new TextEditor();</span></span><br><span class="line"><span class="comment"> * obj.addText(text);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteText(k);</span></span><br><span class="line"><span class="comment"> * String param_3 = obj.cursorLeft(k);</span></span><br><span class="line"><span class="comment"> * String param_4 = obj.cursorRight(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>关于这一题，更好的做法是用2个栈，因为始终只划分左右两边，且都是相邻移动，不会直接跳转，用2个栈是更合适的一种实现。</p><h2><span id="shi-yong-zhan-shi-xian-5-fen-zhong-xie-wan">使用栈实现，5分钟写完：</span><a href="#shi-yong-zhan-shi-xian-5-fen-zhong-xie-wan" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Character&gt; leftStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Character&gt; rightStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TextEditor</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : text.toCharArray()) &#123;</span><br><span class="line">            leftStack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteText</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleCount</span> <span class="operator">=</span> Math.min(k, leftStack.size());</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            leftStack.pop();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">cursorLeft</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; k--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            rightStack.push(leftStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getLeftStr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLeftStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; k--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(leftStack.pop());                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.reverse().toString();</span><br><span class="line">        addText(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">cursorRight</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!rightStack.isEmpty() &amp;&amp; k--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            leftStack.push(rightStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getLeftStr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor obj = new TextEditor();</span></span><br><span class="line"><span class="comment"> * obj.addText(text);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteText(k);</span></span><br><span class="line"><span class="comment"> * String param_3 = obj.cursorLeft(k);</span></span><br><span class="line"><span class="comment"> * String param_4 = obj.cursorRight(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第301场周赛-808名-3题</title>
      <link href="/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC301%E5%9C%BA%E5%91%A8%E8%B5%9B-808%E5%90%8D-3%E9%A2%98/"/>
      <url>/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC301%E5%9C%BA%E5%91%A8%E8%B5%9B-808%E5%90%8D-3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div> <p><a href="https://leetcode.cn/contest/weekly-contest-301/">第 301 场周赛 - 力扣（LeetCode）</a></p><p><img src="/images/%E7%AC%AC301%E5%9C%BA%E5%91%A8%E8%B5%9B-808%E5%90%8D-3%E9%A2%98/1657468677496.png" alt="1657468677496"></p><p>第四题要点：</p><ol><li><p>我直接站在n（10^4)的角度去推演和动规，  却忘记了必须是连续被整除的条件。</p><p>即使n=100， maxValue=32， 实际上大部分都是重复的数字，  连续被整除的关键点最长只有1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;32，  这是最长的6个关键点， 剩下的就是从n=100中选6个放入关键点，其他数字保持一致。</p></li><li><p>因此dp关键点方案数的数组的定义不是dp[n][maxValue],   而是dp[log2(maxValue)][maxValue]</p></li><li><p>基于dp和排列组合方式， 联合计算</p></li><li><p>排列组合方式求解。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c[n][m],数组下标就是m，n-1是固定的了</span></span><br><span class="line"><span class="type">long</span>[][] c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键点1：预处理的话，如果C（n,m)的m比较小，就用杨辉三角来预处理，记住杨辉三角特点，纵轴是n，横轴是m</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getC</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    c = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意这里判断</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;=m) &#123;</span><br><span class="line">            c[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m &amp;&amp; j &lt; i;j++) &#123;</span><br><span class="line">            c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>] + c[i-<span class="number">1</span>][j];</span><br><span class="line">            c[i][j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">idealArrays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> maxValue)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt;[] divNums = <span class="keyword">new</span> <span class="title class_">Set</span>[maxValue+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;=maxValue;i++) &#123;</span><br><span class="line">        divNums[i]= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">2</span>;value&lt;=maxValue;value++) &#123;</span><br><span class="line">        divNums[value].add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 关键点：求除数，只需要根号(value)即可求解出来，不需要遍历整个value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> <span class="number">2</span>; div  * div &lt;= value;div++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value % div == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意加上value/div</span></span><br><span class="line">                divNums[value].add(div);</span><br><span class="line">                divNums[value].add(value/div);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何快速求log2?</span></span><br><span class="line">    <span class="comment">// 关键点：x-&gt;y-&gt;z-&gt;maxValue， 最大变化长度为log2(mavValue)，其他数字全是相同的</span></span><br><span class="line">    <span class="comment">// 因此不需要以n做动态规划</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDivCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> maxValue;</span><br><span class="line">    <span class="keyword">while</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value /= <span class="number">2</span>;</span><br><span class="line">        maxDivCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[maxDivCount+<span class="number">1</span>][maxValue+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以变换点个数做数组长度进行动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (value = <span class="number">0</span>; value &lt;=maxValue;value++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=maxDivCount;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][value] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> div : divNums[value]) &#123;</span><br><span class="line">                dp[i][value] += dp[i-<span class="number">1</span>][div];</span><br><span class="line">                dp[i][value] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合数</span></span><br><span class="line">    getC(n-<span class="number">1</span>, maxDivCount);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (value = <span class="number">1</span>;value &lt;= maxValue;value++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">divCount</span> <span class="operator">=</span> <span class="number">1</span>; divCount &lt;=maxDivCount;divCount++) &#123;</span><br><span class="line">            <span class="comment">// value作为末尾点，长度为divCount，不相同时的方案数，  乘上(n-1)里面选(divCount-1）的组合数</span></span><br><span class="line">            sum += c[n-<span class="number">1</span>][divCount-<span class="number">1</span>] * dp[divCount][value];</span><br><span class="line">            sum %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 力扣周赛记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-class类文件原理详解</title>
      <link href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>重读了一遍《深入理解java虚拟机》， 发现第一遍读类文件相关内容的时候，真的是囫囵吞枣，很多细节都被我跳过了，无论是符号引用的含义，还是属性表的理解，都没有弄懂，当时想着“反正也用不到，跳过吧”，却没注意到他们包含了许多java底层实现的核心原理。</p><p><strong>看来经典书籍要多读多总结，是有道理的。</strong></p><p>于是在阅读这个章节时，用processorOn做了一副超大的类文件解析图，方便自己通过浏览这个图能马上回忆起class文件的结构以及内部的指令。<br>下面的内容是拆分后的内容，对于每块拆分的内容，会有详细的解释。<br><strong>对于完整大图，我放在文末，需要收藏的可以自取</strong></p><p>好了下面我们开始，文章内容较长，建议收藏一下分时段阅读。</p> <div class="toc"><!-- toc --><ul><li><a href="#mo-shu-ban-ben-hao">魔数、版本号</a></li><li><a href="#chang-liang-chi-chang-liang-chi-ge-shu-duo-ge-chang-liang-xiang">常量池（常量池个数、多个常量项）</a><ul><li><a href="#chang-liang-chi-zhong-de-chang-liang-dao-di-shi-gan-ma-de-he-wo-men-li-jie-de-static-final-string-xxx-chang-liang-shi-yi-ge-yi-si-ma">常量池中的常量到底是干嘛的？和我们理解的static final String xxx常量是一个意思吗？</a></li><li><a href="#chang-liang-chi-de-suo-yin-ji-shu-wei-shi-me-cong-1-kai-shi-ji-qi-ta-di-fang-yao-shi-yong-chang-liang-chi-de-di-yi-ge-chang-liang-shi-bi-xu-xie-cheng-1-er-bu-shi-0">常量池的索引计数为什么从1开始（即其他地方要使用常量池的第一个常量时，必须写成1而不是0）？</a></li></ul></li><li><a href="#lei-ding-yi-de-di-yi-xing-lei-fang-wen-biao-zhi-ben-lei-fu-lei-shi-xian-jie-kou">类定义的第一行（类访问标志、本类、父类、实现接口）</a><ul><li><a href="#wei-shi-me-yao-zhe-yang-duo-zou-yi-ceng-wei-shi-me-bu-neng-zhi-jie-zhi-xiang-yi-ge-zi-fu-chuan-chang-liang">为什么要这样多走一层？为什么不能直接指向一个字符串常量？</a></li></ul></li><li><a href="#zi-duan-biao-zi-duan-shu-liang-ge-zi-duan-xiu-shi-fu-ming-lei-xing-shu-xing">字段表（字段数量，各字段（修饰符、名、类型、属性））</a><ul><li><a href="#zi-duan-xiu-shi-fu-zhong-de-synchetics-zhi-de-shi-bian-yi-qi-zi-dong-sheng-cheng-de-zi-duan-zen-me-li-jie-ni-shi-me-qing-kuang-xia-hui-yong-dao">字段修饰符中的synchetics指的是编译器自动生成的字段，怎么理解呢？什么情况下会用到？</a></li><li><a href="#shang-mian-ke-yi-kan-dao-mei-ge-zi-duan-xiang-de-zui-hou-bao-han-shu-xing-shu-liang-he-shu-xing-chang-du-na-me-class-zhong-de-shu-xing-he-shang-mian-de-zi-duan-ming-zi-duan-lei-xing-you-shi-me-qu-bie-ni">上面可以看到每个字段项的最后包含属性数量和属性长度，那么class中的属性和上面的“字段名”、“字段类型”有什么区别呢？</a></li></ul></li><li><a href="#fang-fa-biao-fang-fa-shu-liang-fang-fa-xiang-xiu-shi-fu-ming-miao-shu-shu-xing">方法表（方法数量、方法项（修饰符、名、描述、属性））</a><ul><li><a href="#fang-fa-xiu-shi-fu-zhong-de-qiao-jie">方法修饰符中的桥接</a></li><li><a href="#shu-xing-de-jie-gou">属性的结构</a></li><li><a href="#zui-guan-jian-de-code-shu-xing">最关键的Code属性</a><ul><li><a href="#cao-zuo-shu-zhan-ju-bu-bian-liang-biao-da-xiao-zhi-ling-ma-shu-liang">操作数栈、局部变量表大小、指令码数量</a></li><li><a href="#zhi-ling-ma-jie-du">指令码解读</a><ul><li><a href="#shu-ju-ji-suan-yong-de-zhi-ling-ma">数据计算用的指令码</a></li><li><a href="#dui-xiang-cao-zuo-de-zhi-ling-ma">对象操作的指令码</a><ul><li><a href="#wei-shi-me-dui-xiang-cao-zuo-zhi-ling-ma-zhong-zhi-bao-han-liao-lei-yin-yong-he-ming-cheng-ni-wo-zen-me-zhi-dao-wo-diao-yong-de-shi-na-ge-dui-xiang-de-zi-duan">为什么对象操作指令码中只包含了类引用和名称呢，我怎么知道我调用的是哪个对象的字段？</a></li><li><a href="#new-dui-xiang-he-new-shu-zu-yong-de-shi-2-ge-bu-tong-de-zhi-ling-wei-shi-me-yao-you-qu-fen-bu-neng-ba-shu-zu-dang-cheng-yi-ge-java-dui-xiang-ma">new对象和new数组，用的是2个不同的指令，为什么要有区分？不能把数组当成一个java对象吗</a></li></ul></li><li><a href="#cao-zuo-shu-zhan-zhi-ling-pop-deng">操作数栈指令（pop等）</a></li><li><a href="#fang-fa-diao-yong-zhi-ling-invokevirtual-deng">方法调用指令（invokevirtual等)</a></li></ul></li><li><a href="#yi-chang-biao-shu-xing">异常表属性</a><ul><li><a href="#na-finally-de-cao-zuo-bei-fang-dao-na-liao-catch-cao-zuo-wan-liao-zhi-hou-ta-zen-me-zhi-dao-yao-tiao-zhuan-dao-na-li">那finally的操作被放到哪了？catch操作完了之后，它怎么知道要跳转到哪里？</a></li><li><a href="#dui-yu-synchronized-guan-jian-zi-ta-ben-zhi-shi-sheng-cheng-liao-monitorenter-he-monitorexit-liang-ge-zhi-ling-shang-mian-fang-fa-diao-yong-zhi-ling-li-de-zui-hou-2-ge-dan-ru-guo-fa-sheng-liao-yi-chang-na-hui-bu-hui-wu-fa-monitorexit-liao">对于synchronized关键字，它本质是生成了monitorenter和monitorexit两个指令（上面方法调用指令里的最后2个）。但如果发生了异常，那会不会无法monitorexit了？</a></li><li><a href="#qian-mian-ti-dao-fang-fa-shu-xing-zhong-yi-jing-you-yi-ge-ming-jiao-exception-de-shu-xing-he-zhe-ge-code-shu-xing-zhong-de-yi-chang-biao-you-shi-me-qu-bie">前面提到方法属性中，已经有一个名叫“Exception”的属性，和这个code属性中的异常表有什么区别？</a></li></ul></li><li><a href="#code-de-kuo-zhan-shu-xing">Code的扩展属性</a></li><li><a href="#qi-ta-de-fang-fa-shu-xing">其他的方法属性</a></li></ul></li></ul></li><li><a href="#lei-shu-xing">类属性</a><ul><li><a href="#wei-shi-me-nei-bu-lei-shu-xing-zhong-yao-bao-han-su-zhu-lei-de-lei-ming-nan-dao-su-zhu-lei-bu-jiu-shi-ta-ben-shen-ma">为什么内部类属性中，要包含宿主类的类名？难道宿主类，不就是它本身吗？</a></li></ul></li><li><a href="#zui-hou-de-wan-zheng-tu">最后的完整图</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h1><span id="mo-shu-ban-ben-hao">魔数、版本号</span><a href="#mo-shu-ban-ben-hao" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652269180508772459.png" alt="image.png"></p><ul><li>每类文件都有一个魔数，用于快速校验文件类型。</li><li>对于高低版本号，只要明确java11\java8这种版本是主版本号</li><li>永远向下兼容， <strong>即高版本jvm可以读取低版本的class文件， 但是低版本的jvm无法读取高版本的class文件</strong>。</li></ul><hr><h1><span id="chang-liang-chi-chang-liang-chi-ge-shu-duo-ge-chang-liang-xiang">常量池（常量池个数、多个常量项）</span><a href="#chang-liang-chi-chang-liang-chi-ge-shu-duo-ge-chang-liang-xiang" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652269423338180081.png" alt="image.png"><br>大部分文件协议格式中，都会先给定一个某项的数量长度，再决定某项的个数，方便确认遍历几次才结束。常量池的设置也是这个原理。<br><strong>因此学习java的class格式，对我们设计某些文件格式或者协议都是一种不错的借鉴。</strong></p><hr><h2><span id="chang-liang-chi-zhong-de-chang-liang-dao-di-shi-gan-ma-de-he-wo-men-li-jie-de-static-final-string-xxx-chang-liang-shi-yi-ge-yi-si-ma">常量池中的常量到底是干嘛的？和我们理解的static final String xxx常量是一个意思吗？</span><a href="#chang-liang-chi-zhong-de-chang-liang-dao-di-shi-gan-ma-de-he-wo-men-li-jie-de-static-final-string-xxx-chang-liang-shi-yi-ge-yi-si-ma" class="header-anchor">#</a></h2><p>不对！代码中定义的final类型字符串常量只是一种用途。更重要的一种用途是符号引用。<br>而对符号引用的理解，是对java类文件原理最难也最重要的地方。<br>直接去解释符号引用的话，还是很难理解的，因此我们按下不表，在第4部分“类索引”部分会给出详细解释。</p><hr><h2><span id="chang-liang-chi-de-suo-yin-ji-shu-wei-shi-me-cong-1-kai-shi-ji-qi-ta-di-fang-yao-shi-yong-chang-liang-chi-de-di-yi-ge-chang-liang-shi-bi-xu-xie-cheng-1-er-bu-shi-0">常量池的索引计数为什么从1开始（即其他地方要使用常量池的第一个常量时，必须写成1而不是0）？</span><a href="#chang-liang-chi-de-suo-yin-ji-shu-wei-shi-me-cong-1-kai-shi-ji-qi-ta-di-fang-yao-shi-yong-chang-liang-chi-de-di-yi-ge-chang-liang-shi-bi-xu-xie-cheng-1-er-bu-shi-0" class="header-anchor">#</a></h2><p>因为要留一个0，表示不引用任何常量</p><blockquote><blockquote><ul><li>举例：匿名类就是没有名字的，但是类文件结构中，类名那边总需要填入类名常量索引，因此可以填入0，表示“没有类名”的意思。</li><li>再来一个例子：object类，是没有父类的，所以他的父类那一栏填的常量索引也是0</li></ul></blockquote></blockquote><ul><li>对于常量池的作用，后面会有更详细的体现和解释。</li></ul><h1><span id="lei-ding-yi-de-di-yi-xing-lei-fang-wen-biao-zhi-ben-lei-fu-lei-shi-xian-jie-kou">类定义的第一行（类访问标志、本类、父类、实现接口）</span><a href="#lei-ding-yi-de-di-yi-xing-lei-fang-wen-biao-zhi-ben-lei-fu-lei-shi-xian-jie-kou" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652271151313964089.png" alt="image.png"></p><p>为什么叫类定义的第一行，因为这就来自我们写每个类时的第一行内容。<br>例如<br>public abstract class A extend B implement C,D<br>这句话对应的所有信息就包含在了上图中，因此我叫他“类定义的第一行”</p><hr><p>CONSTANT_class_info这个类常量到底是干嘛的？<br>从图上可以看到，他其实就是指向了一个表示类名的字符串常量。<br>这里也可以看到，java文件中的所有名称例如类名、方法名、字段名，都会以Utf_info的形式，存储在常量池中。<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652272385081190034.png" alt="image.png"></p><hr><h2><span id="wei-shi-me-yao-zhe-yang-duo-zou-yi-ceng-wei-shi-me-bu-neng-zhi-jie-zhi-xiang-yi-ge-zi-fu-chuan-chang-liang">为什么要这样多走一层？为什么不能直接指向一个字符串常量？</span><a href="#wei-shi-me-yao-zhe-yang-duo-zou-yi-ceng-wei-shi-me-bu-neng-zhi-jie-zhi-xiang-yi-ge-zi-fu-chuan-chang-liang" class="header-anchor">#</a></h2><p>这个问题我没找到解释，但可以理解为这是最基础的一层封装。</p><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652271891308501334.png" alt="image.png"></p><hr><h1><span id="zi-duan-biao-zi-duan-shu-liang-ge-zi-duan-xiu-shi-fu-ming-lei-xing-shu-xing">字段表（字段数量，各字段（修饰符、名、类型、属性））</span><a href="#zi-duan-biao-zi-duan-shu-liang-ge-zi-duan-xiu-shi-fu-ming-lei-xing-shu-xing" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652275768314487190.png" alt="image.png"></p><hr><p>可以看到，字段名、字段类型分别对应了2个字符串常量。<br>特别注意字段类型使用一个字符串来表示的，而不是一个constant_field_info。<br>那么constant_field_info是干嘛的呢？</p><hr><h2><span id="zi-duan-xiu-shi-fu-zhong-de-synchetics-zhi-de-shi-bian-yi-qi-zi-dong-sheng-cheng-de-zi-duan-zen-me-li-jie-ni-shi-me-qing-kuang-xia-hui-yong-dao">字段修饰符中的synchetics指的是编译器自动生成的字段，怎么理解呢？什么情况下会用到？</span><a href="#zi-duan-xiu-shi-fu-zhong-de-synchetics-zhi-de-shi-bian-yi-qi-zi-dong-sheng-cheng-de-zi-duan-zen-me-li-jie-ni-shi-me-qing-kuang-xia-hui-yong-dao" class="header-anchor">#</a></h2><p>找到一个简单的例子(<a href="https://zhuanlan.zhihu.com/p/228854843">代码出处:知乎-不凋花</a>),用枚举做switch：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foobar</span> &#123;</span><br><span class="line">    FOO,</span><br><span class="line">    BAR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(Foobar var0)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var0) &#123;</span><br><span class="line">            <span class="keyword">case</span> FOO:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> BAR:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch的原理，我们应该很容易想到，就是做一次顺序检查，那么检查时，肯定程序里需要有一个列表吧，因此上面switch的背后逻辑代码是长这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test$1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] $SwitchMap$Foobar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        $SwitchMap$Foobar = <span class="keyword">new</span> <span class="title class_">int</span>[Foobar.values().length];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $SwitchMap$Foobar[Foobar.FOO.ordinal()] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldError e) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $SwitchMap$Foobar[Foobar.BAR.ordinal()] = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldError e) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有一个“static final int[] $SwitchMap$Foobar;”， 这个静态数组字段，就是编译器帮忙生成的字段，他会被标记成synchetics</p><hr><h2><span id="shang-mian-ke-yi-kan-dao-mei-ge-zi-duan-xiang-de-zui-hou-bao-han-shu-xing-shu-liang-he-shu-xing-chang-du-na-me-class-zhong-de-shu-xing-he-shang-mian-de-zi-duan-ming-zi-duan-lei-xing-you-shi-me-qu-bie-ni">上面可以看到每个字段项的最后包含属性数量和属性长度，那么class中的属性和上面的“字段名”、“字段类型”有什么区别呢？</span><a href="#shang-mian-ke-yi-kan-dao-mei-ge-zi-duan-xiang-de-zui-hou-bao-han-shu-xing-shu-liang-he-shu-xing-chang-du-na-me-class-zhong-de-shu-xing-he-shang-mian-de-zi-duan-ming-zi-duan-lei-xing-you-shi-me-qu-bie-ni" class="header-anchor">#</a></h2><p>属性是可有可无的，而且提供了高度的“jvm可扩展性”。<br>换言之，在jvm虚拟机规范中，“字段修饰符”、“字段名”、“字段类型”都是必备的，而属性则没有限制。<br><strong>因此我们甚至可以自己实现一个虚拟机，定义新的属性，在class中加上属性项然后自己使用</strong></p><p>对于属性作用的更详细理解，可以看后面的方法章节，方法中的属性是比较重要且用得最多的。</p><hr><p>从字段属性可以看到， 类似于static final int a =10这种常量，就是通过属性里的constant属性来设置的。</p><p>有个泛型签名的属性，可能不太好马上理解，后面在方法章节中会一并提到这个属性的作用！</p><h1><span id="fang-fa-biao-fang-fa-shu-liang-fang-fa-xiang-xiu-shi-fu-ming-miao-shu-shu-xing">方法表（方法数量、方法项（修饰符、名、描述、属性））</span><a href="#fang-fa-biao-fang-fa-shu-liang-fang-fa-xiang-xiu-shi-fu-ming-miao-shu-shu-xing" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652317738015425066.png" alt="image.png"><br>class文件中，最值得学习的就是常量池和方法表了！</p><hr><h2><span id="fang-fa-xiu-shi-fu-zhong-de-qiao-jie">方法修饰符中的桥接</span><a href="#fang-fa-xiu-shi-fu-zhong-de-qiao-jie" class="header-anchor">#</a></h2><p>对于方法修饰符，大部分都很好理解，有2个修饰符需要关注：“bridge”和“synthetic”。</p><p>其实很多bridge桥接方法本身也是synthetics系统生成的，所以我不太想去区分二者，只要关注他们2个用来做什么。</p><p>思考下面这个问题：<br><strong>1. 假设有个非公开的类A，A中有个public方法f()，有个继承自A的公开类B，没有重写f()，那么外部是否可以调用b.f()？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">f() &#123;..&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> extend A&#123;</span><br><span class="line"><span class="comment">// 不重写任何方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">   b.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易可以得出b.f()可以调用的结论。<br>但由于B没有重写f(), 所以对于编译后的B.class而言，这意味着不会在class文件中包含f方法。<br>那么当执行f时，通过多态，会定位到A.f()，此时A是非公开的类，权限就会出错，因为不允许直接引用非公开的类的方法，只能间接使用。</p><p>如何解决？要修改多态的动态分派校验机制吗？</p><p>不需要，<strong>编译器为了方便，直接为我们在B中重写了f()来间接调用父类方法</strong>，类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">super.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话就不用担心外部调用者没有权限使用A.f()了。</p><p><strong>2. 有个泛型基类Base&lt;T&gt;，包含一个方法f(T t),  有个子类Sub&lt;String&gt;, 实现了方法f(String s)， 两个f方法的入参并不一致，为什么还多态的机制还能生效？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&lt;T&gt; &#123;</span><br><span class="line">f(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> extend Base&lt;String&gt;&#123;</span><br><span class="line">f(String t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这2个方法的入参确实不同， 前者的方法签名是f(Ljava/lang/Object;)V，  后者是f(Ljava/lang/String;)V。 多态（动态分派）的规则也没有变，确实是要求入参一致。<br>因此编译器为Sub类自动生成了一个f(Ljava/lang/Object;)V,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.f((String)o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样多态的机制也能实现了。<br><strong>可以看到这一切都是为了适配多态，同时避免过多的特殊逻辑，因此使用桥接方法，来生成了我们看不到的重写方法</strong></p><hr><p>从下面可以看到， 方法描述符是一个**包含“入参和返回值”**的描述符<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652355928364525434.png" alt="image.png"></p><p>因此，java是允许 <strong>同入参、同方法名、不同返回值</strong>的方法存在于同一个class文件中的。</p><p>这是不是有点反常识？这种情况我们好像编写不出来的，编译器不会通过！</p><p>其实这也是桥接+自动生成才会有这种情况。<br>前文的泛型例子，用泛型T做入参，会生成一个桥接方法，和父类的匹配。</p><p>那么如果泛型T是一个返回值呢:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&lt;T&gt; &#123;</span><br><span class="line">T <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> extend Base&lt;String&gt;&#123;</span><br><span class="line">String <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么也是一样的道理，桥接了一个父类的f方法，但仅仅是返回值不同而已。所以会出现只有返回值不同的方法。</p><hr><p>方法表的属性和字段的属性类似， 也是属性数量 + N个属性项。<br>但是方法表属性里的干货就更多了！</p><h2><span id="shu-xing-de-jie-gou">属性的结构</span><a href="#shu-xing-de-jie-gou" class="header-anchor">#</a></h2><p>之前字段属性中没提到属性到底长啥样，以方法中的throws异常属性为例，：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652395329500135926.png" alt="image.png"></p><p>从这里可以看到，每个属性都有个属性名，和常量不同，区分不同常量用的是1个2字节的数字，而属性则是用一个字符串来表示。<br>这样的区别就是因为常量个数有限，而属性为了扩展性，不能存在数量限制。</p><p>另外从这也可以知道， 我们在方法名上写的f() throws IOException 都是存在于异常属性中的。</p><hr><h2><span id="zui-guan-jian-de-code-shu-xing">最关键的Code属性</span><a href="#zui-guan-jian-de-code-shu-xing" class="header-anchor">#</a></h2><p>Code属性是方法属性中最最最重要的属性。<br>他告诉我们编译器是怎样将我们的文本代码封装成一个class文件的。<br>首先，code属性的属性名就是一个“Code”<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652395457163163025.png" alt="image.png"></p><h3><span id="cao-zuo-shu-zhan-ju-bu-bian-liang-biao-da-xiao-zhi-ling-ma-shu-liang">操作数栈、局部变量表大小、指令码数量</span><a href="#cao-zuo-shu-zhan-ju-bu-bian-liang-biao-da-xiao-zhi-ling-ma-shu-liang" class="header-anchor">#</a></h3><p>接着会包含3个重要的内容：max_stack、max_local和code_length<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652395539642165989.png" alt="image.png"><br>从max_stack和max_local我们可以看到，操作数栈和局部变量表的大小，已经在class文件中计算出来了，因此当开辟一个新的栈帧时，jvm便能够知道给这个方法开辟多大的空间，不用担心栈上分配不够的问题。<br><strong>注意，是操作数栈的大小，而不是程序执行的栈的深度，程序可没法感知我们能够递归多少次。</strong></p><hr><h3><span id="zhi-ling-ma-jie-du">指令码解读</span><a href="#zhi-ling-ma-jie-du" class="header-anchor">#</a></h3><p>code_length代表了我们这个方法在编译后，有多少条字节码指令，而后面紧跟着的，就是对应数量的java字节码指令了。<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652397966852235844.png" alt="image.png"></p><p>指令码种类非常多，这里只列举关键的一些信息。</p><h4><span id="shu-ju-ji-suan-yong-de-zhi-ling-ma">数据计算用的指令码</span><a href="#shu-ju-ji-suan-yong-de-zhi-ling-ma" class="header-anchor">#</a></h4><p>首先，每种涉及基本数据类型的计算指令，都会在指令最前方，携带一个T，如图：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652396223751707461.png" alt="image.png"><br>里面有句话：<strong>“不是每种数据类型和每个操作都有指令对应（否则数量太多）”</strong><br>这句话怎么理解呢，可以结果图上右侧的表格，从而得知，有些指令是不包含所有类型的，所以可能会借用一些的技巧，比如把byte、short都视为int在操作上去操作。</p><h4><span id="dui-xiang-cao-zuo-de-zhi-ling-ma">对象操作的指令码</span><a href="#dui-xiang-cao-zuo-de-zhi-ling-ma" class="header-anchor">#</a></h4><p>另一个类指令码是和对象操作有关，例如：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652396601906806136.png" alt="image.png"><br>可以看到，当试图获取一个类字段时，他指向的是一个class_field_info常量索引，这个常量会提前被放进class文件的常量池中。</p><hr><h5><span id="wei-shi-me-dui-xiang-cao-zuo-zhi-ling-ma-zhong-zhi-bao-han-liao-lei-yin-yong-he-ming-cheng-ni-wo-zen-me-zhi-dao-wo-diao-yong-de-shi-na-ge-dui-xiang-de-zi-duan">为什么对象操作指令码中只包含了类引用和名称呢，我怎么知道我调用的是哪个对象的字段？</span><a href="#wei-shi-me-dui-xiang-cao-zuo-zhi-ling-ma-zhong-zhi-bao-han-liao-lei-yin-yong-he-ming-cheng-ni-wo-zen-me-zhi-dao-wo-diao-yong-de-shi-na-ge-dui-xiang-de-zi-duan" class="header-anchor">#</a></h5><p>A: 你要调用的对象，已经通过前面提到的操作数栈相关指令，把引用放到了操作数栈的第一个，因此，jvm只要取栈顶对象，然后根据名字进行字段操作即可，后面的方法调用也是一样的道理。</p><hr><h5><span id="new-dui-xiang-he-new-shu-zu-yong-de-shi-2-ge-bu-tong-de-zhi-ling-wei-shi-me-yao-you-qu-fen-bu-neng-ba-shu-zu-dang-cheng-yi-ge-java-dui-xiang-ma">new对象和new数组，用的是2个不同的指令，为什么要有区分？不能把数组当成一个java对象吗</span><a href="#new-dui-xiang-he-new-shu-zu-yong-de-shi-2-ge-bu-tong-de-zhi-ling-wei-shi-me-yao-you-qu-fen-bu-neng-ba-shu-zu-dang-cheng-yi-ge-java-dui-xiang-ma" class="header-anchor">#</a></h5><p>这要从对象的内存结构，以及类加载机制上去思考。<br>因为数组的对象头，和普通对象的对象头是不一样的。</p><ul><li>数组的对象头中包含了数组长度，而普通对象没有</li><li>new一个数组时，数组中包含的类并不会做类加载。<br>有这么多区别，肯定是新增一个单独针对数组的指令来处理，要简单很多</li></ul><hr><h4><span id="cao-zuo-shu-zhan-zhi-ling-pop-deng">操作数栈指令（pop等）</span><a href="#cao-zuo-shu-zhan-zhi-ling-pop-deng" class="header-anchor">#</a></h4><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652397315515649848.png" alt="image.png"><br>其他指令好理解， 但操作数栈指令有个dup_x指令，例如dup1_1 就是复制栈顶并再放入1个。为什么需要这么一个指令？</p><p>其实当我们调用 A a = new A()时，这一句话生成的指令中就包含了dup指令<br>因为当我们new出1个A引用时，它有两件事要做：</p><ol><li>调用A的构造函数。</li><li>把引用地址赋值给a这个局部变量<br>而每件事都会消耗一个A的引用！所以才需要赋值。<br>因此可以看到，<strong>指令码很多时候都是基于操作数栈进行操作的，每操作一个数据或引用，就消耗一个</strong></li></ol><h4><span id="fang-fa-diao-yong-zhi-ling-invokevirtual-deng">方法调用指令（invokevirtual等)</span><a href="#fang-fa-diao-yong-zhi-ling-invokevirtual-deng" class="header-anchor">#</a></h4><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652397689648709059.png" alt="image.png"><br>对于方法调用指令，和前面的类字段调用有点像，也是一个方法常量，方法常量包含类索引和方法描述索引。<br>对于方法究竟是如何触发调用实现多态的、invokevirtual指令和invokedynamic指令有什么区别，这个内容就更多了，后面我会放到类加载的图解笔记中讲解。</p><h3><span id="yi-chang-biao-shu-xing">异常表属性</span><a href="#yi-chang-biao-shu-xing" class="header-anchor">#</a></h3><p>指令码结束后，后面会紧跟着一个异常表。表中的每一行长这样：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398026144920939.png" alt="image.png"><br>是不是恍然大悟，原来try-catch代码的逻辑在这边， 它本质上就是抛异常时，根据try的位置和异常类型，这个异常表中进行查找到对应的catch代码位置，从而实现异常处理。</p><hr><h4><span id="na-finally-de-cao-zuo-bei-fang-dao-na-liao-catch-cao-zuo-wan-liao-zhi-hou-ta-zen-me-zhi-dao-yao-tiao-zhuan-dao-na-li">那finally的操作被放到哪了？catch操作完了之后，它怎么知道要跳转到哪里？</span><a href="#na-finally-de-cao-zuo-bei-fang-dao-na-liao-catch-cao-zuo-wan-liao-zhi-hou-ta-zen-me-zhi-dao-yao-tiao-zhuan-dao-na-li" class="header-anchor">#</a></h4><p>finally模块在java语言中是必须执行的，在编译的时候，通过将finally中代码块分别在try模块的最后和catch模块的最后都复制了一份，通过这样来保证finally的必定执行</p><hr><h4><span id="dui-yu-synchronized-guan-jian-zi-ta-ben-zhi-shi-sheng-cheng-liao-monitorenter-he-monitorexit-liang-ge-zhi-ling-shang-mian-fang-fa-diao-yong-zhi-ling-li-de-zui-hou-2-ge-dan-ru-guo-fa-sheng-liao-yi-chang-na-hui-bu-hui-wu-fa-monitorexit-liao">对于synchronized关键字，它本质是生成了monitorenter和monitorexit两个指令（上面方法调用指令里的最后2个）。但如果发生了异常，那会不会无法monitorexit了？</span><a href="#dui-yu-synchronized-guan-jian-zi-ta-ben-zhi-shi-sheng-cheng-liao-monitorenter-he-monitorexit-liang-ge-zhi-ling-shang-mian-fang-fa-diao-yong-zhi-ling-li-de-zui-hou-2-ge-dan-ru-guo-fa-sheng-liao-yi-chang-na-hui-bu-hui-wu-fa-monitorexit-liao" class="header-anchor">#</a></h4><p>生成code字节码时，jvm会自动为synchronized生成1个默认的异常表和throw指令，保证中间同步块发生异常时，monitorexit能够正确被指令（类似于放了一个自动生成的try-catch代码，或者在已有的catch操作后添加）。</p><hr><h4><span id="qian-mian-ti-dao-fang-fa-shu-xing-zhong-yi-jing-you-yi-ge-ming-jiao-exception-de-shu-xing-he-zhe-ge-code-shu-xing-zhong-de-yi-chang-biao-you-shi-me-qu-bie">前面提到方法属性中，已经有一个名叫“Exception”的属性，和这个code属性中的异常表有什么区别？</span><a href="#qian-mian-ti-dao-fang-fa-shu-xing-zhong-yi-jing-you-yi-ge-ming-jiao-exception-de-shu-xing-he-zhe-ge-code-shu-xing-zhong-de-yi-chang-biao-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>上面code<strong>异常表</strong>指的是代码执行时try-catch的逻辑部分<br>而方法中的<strong>exception属性</strong>则是方法名上所声明的throws异常。</p><h3><span id="code-de-kuo-zhan-shu-xing">Code的扩展属性</span><a href="#code-de-kuo-zhan-shu-xing" class="header-anchor">#</a></h3><p>在code属性中，竟然还携带了属性，也就是说，是允许“属性中的属性”。毕竟属性的实现是可以完全自定义的，那么自己给自己新增额外特性完全是允许的。<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398314647685943.png" alt="image.png"><br>里面有个属性叫“局部变量描述属性”，长这样：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398431353725133.png" alt="image.png"><br>从这里，你就能明白，为什么你从IDEA里看到反解后的class文件，有时候是var1、var2之类莫名其妙的局部变量，有时候却又能看到完整的变量名了吧？就是通过这个属性决定的。毕竟存储局部变量名的代价还是很高的。</p><h3><span id="qi-ta-de-fang-fa-shu-xing">其他的方法属性</span><a href="#qi-ta-de-fang-fa-shu-xing" class="header-anchor">#</a></h3><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398713702736921.png" alt="image.png"><br>泛型签名这个属性很迷惑，不是有泛型擦除吗，为什么还需要这个属性？<br><strong>其实泛型签名属性是为了方便反射的。</strong><br>我们通过前面关于桥接的原理，可以知道编译时会发生泛型擦除，方法入参都变成了object。<br>但是反射API可能希望获取泛型信息因此可通过这个扩展属性进行获取。所以会增加这个属性，从而能感知一些泛型属性相关的信息。</p><h1><span id="lei-shu-xing">类属性</span><a href="#lei-shu-xing" class="header-anchor">#</a></h1><p>既然方法和字段都有属性，那么类肯定也有属性：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652399133483878712.png" alt="image.png"><br>其他属性都比较好理解或者不重要，重点讲一下内部类属性。<br>通过内部类属性，我们可以看到内部类并不是直接包含在这个class文件中，它其实是生成了另一个class文件，所以才需要一个内部类属性，来确认对应的名字，方便类加载时能找到内部类。</p><hr><h2><span id="wei-shi-me-nei-bu-lei-shu-xing-zhong-yao-bao-han-su-zhu-lei-de-lei-ming-nan-dao-su-zhu-lei-bu-jiu-shi-ta-ben-shen-ma">为什么内部类属性中，要包含宿主类的类名？难道宿主类，不就是它本身吗？</span><a href="#wei-shi-me-nei-bu-lei-shu-xing-zhong-yao-bao-han-su-zhu-lei-de-lei-ming-nan-dao-su-zhu-lei-bu-jiu-shi-ta-ben-shen-ma" class="header-anchor">#</a></h2><p>因为，内部类中，还可以继续定义内部类</p><hr><p>另外，从上面的一些属性中可以看到， <strong>很多debug用的调试、展示信息，都会包含在class中</strong><br>因此，当我们希望调试一些环境上执行的程序时，如果想提供最为贴近原代码，那就需要class文件中能有充足的信息，如果想要class文件小，那就去掉，具体怎么去掉或者添加，肯定就是一些编译选项的区别了。</p><hr><hr><h1><span id="zui-hou-de-wan-zheng-tu">最后的完整图</span><a href="#zui-hou-de-wan-zheng-tu" class="header-anchor">#</a></h1><p>好累，终于写完了，感觉能看到最后的人不会太多，但一通详细地分析和解决中间发现的问题，还是收获了不少。<br>最后贴上完整的大图，欢迎保存和收藏。<br><a href="https://www.processon.com/view/link/5d1a2d97e4b07c7231731b02">图片在线查看</a><br><a href="https://www.processon.com/view/link/5d1a2d97e4b07c7231731b02">https://www.processon.com/view/link/5d1a2d97e4b07c7231731b02</a></p><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/5d1a2d97e4b0f7ca49d84a3a.png" alt="完整大图"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> jvm原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,深入理解jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk动态代理原理解析</title>
      <link href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#jdk-dong-tai-dai-li">jdk动态代理</a></li><li><a href="#shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou">实现jdk动态代理时需要哪些步骤？</a></li><li><a href="#jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me">JDK动态代理的invoke原理是什么？</a></li><li><a href="#wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi">为什么Proxy.newProxyInstance必须要传入一个类加载器？</a></li><li><a href="#wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me">为什么jdk动态代理必须依赖一个接口？底层逻辑是什么？</a></li><li><a href="#na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni">那么spring里AOP所用的CGLIB为啥不需要接口呢？</a></li><li><a href="#na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao">那么CGLIB和jdk动态代理哪个更好？</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h2><span id="jdk-dong-tai-dai-li">jdk动态代理</span><a href="#jdk-dong-tai-dai-li" class="header-anchor">#</a></h2><h2><span id="shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou">实现jdk动态代理时需要哪些步骤？</span><a href="#shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou" class="header-anchor">#</a></h2><ol><li>有一个目标类Class， 目标类必须implment某个行为接口Inteface</li><li>有一个代理类XxxProxy，实现自InvocationHandler接口</li><li>代理类必须实现一个invoke方法， invoke方法的入参是  被代理对象（目标对象）、执行方法（method的反射对象）、执行参数<br>通过调用“ 执行方法.invoke(被代理对象，执行参数)” 这个常见的反射操作，  即可执行实际调用方法，然后你可以在这个方法的前后做各种处理或者改造。</li><li>使用Proxy.newProxyInstance(被代理类的类加载器， 被代理类的接口， 这个proxy代理对象)生成一个做过绑定的代理对象，能被调用的方法都是行为接口Inteface里的。</li></ol><hr><h2><span id="jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me">JDK动态代理的invoke原理是什么？</span><a href="#jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me" class="header-anchor">#</a></h2><p>proxy类里面真正的那个代理方法字节码类似如下（这个类就是给被别人调用的代理类，是newProxyxxx（）操作后的那个类，不是invokeHandler类）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Proxy0.class</span><br><span class="line">public final void sayHello(object[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// this.h就是继承了invokeHandler的那个类对象</span><br><span class="line">this.h.invoke(this, m3, args);</span><br><span class="line">&#125; catch(Excetion ...) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">static &#123;</span><br><span class="line">m3 = Class.forname(&quot;那个接口的类名&quot;).getMethod(&quot;sayHello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m3就是通过static初始化阶段生成一个m方法， 然后调用sayHello时，调用invokeHandler.invoke，从而走进他里面实现的那个方法。</p><p>Proxy.newProxyInstance()会通过调用sun.misc.ProxyGenerator.generateProxyClass()来生成一个字节码，从而得到一个描述代理类的字节码数组。<br>生成字节码的过程就是根据class文件的格式规范去拼装字节码。</p><p>更多源码逻辑见<a href="https://blog.csdn.net/Trunks2009/article/details/123106582">Proxy源码解析</a></p><hr><h2><span id="wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi">为什么Proxy.newProxyInstance必须要传入一个类加载器？</span><a href="#wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi" class="header-anchor">#</a></h2><p><img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/48a3a4503f728f9ce9520a2c4820e9a9858c237a.png" alt="48a3a4503f728f9ce9520a2c4820e9a9858c237a"><br>因为他需要创建一个新的proxy类时，必须要基于接口去构造一个新的类对象，后面再使用类对象去反射一个实际代理对象<br><img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/08a7c84b1abfab8a47fa544fd0de4603c1699e88.png" alt="08a7c84b1abfab8a47fa544fd0de4603c1699e88"></p><hr><h2><span id="wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me">为什么jdk动态代理必须依赖一个接口？底层逻辑是什么？</span><a href="#wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me" class="header-anchor">#</a></h2><p>因为真正给用户调用的那个代理对象类XXXProxy$0， 实际上他为了做相关的代理操作（比如将inovkeHnandler作为成员，并调用各种字节码生产方法），需要extends Proxy这个类<br>也就是说他的类结构长这样：<br><img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5d5edf4370eff2c399096e1fefdd76e9cb7c90ee.png" alt="5d5edf4370eff2c399096e1fefdd76e9cb7c90ee"><br>因为java是单继承，导致父类已经被Proxy占用了，但你有需要对Worker对象做代理封装，并提供这个接口对外提供的方法，因此只能用implements的形式。</p><p>另一个更好的解释：</p><blockquote><blockquote><p>Cglib代理实际上是通过继承，也就是生成一个继承被代理对象的类，编译成class文件时还会额外生成一个fastclass文件<br>该文件记录各个method的class索引（类名+方法名+参数），当执行某个方法时，通过计算索引，定位到具体的方法，代理对象执行该方法，然后super调用父类（执行了被代理对象的方法）。<br>生成代理对象时通过fastclass索引机制直接定位到被代理对象的class文件，从而实现反复调用，等于说是class复用，每次都是直接拿被代理对象的class内容执行的。</p></blockquote></blockquote><hr><h2><span id="na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni">那么spring里AOP所用的CGLIB为啥不需要接口呢？</span><a href="#na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni" class="header-anchor">#</a></h2><p>因为CGLIB是直接继承被代理类做字节码增加的，相当于做了字节码改造。</p><p>而jdk动态代理需要继承自Proxy类，利用父类的机制引用invokeHandler+反射的方法，来做代理操作。</p><hr><h2><span id="na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao">那么CGLIB和jdk动态代理哪个更好？</span><a href="#na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao" class="header-anchor">#</a></h2><ol><li>性能上比较</li></ol><ul><li>jdk动态代理生成类速度快，调用慢</li><li>cglib生成类速度慢，但后续调用快</li></ul><p>但是实际上JDK的速度在版本升级的时候每次都提高很多性能,而CGLIB仍止步不前.<br>在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p><p><a href="https://www.jianshu.com/p/eea9a3acbaad">JDK 动态代理和Cglib性能对比</a></p><ol start="2"><li>稳定性上比较</li></ol><ul><li>jdk动态代理Java本身支持，不用担心依赖问题，随着版本稳定升级和优化。</li><li>而CGLIB是外部技术，字节码库需要进行更新以保证在新版java上能运行<br>；</li></ul><ol start="3"><li>使用上比较<br>jdk动态代理必须依赖接口，CGLIB不需要，在设计不当的历史包袱下<br>如果必须对非接口对象做代理，那么只能用CGLIB临时过度。</li></ol><p>因此spring实现AOP时，都是优先使用jdk动态代理，如果没有实现接口，才改成CGLIB过度，这也是为什么我们spring里的service类一般都要先定义1个接口，即使你只有1个service实现类。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> java常见应用原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java常见应用原理m </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载全过程详解</title>
      <link href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu">关于类初始化的时机和误区</a></li><li><a href="#you-wu-dao-de-jia-zai-san-bu-qu">有误导的“加载三部曲”</a></li><li><a href="#jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu">加载：不仅仅是读取字节流</a><ul><li><a href="#lei-jia-zai-qi">类加载器</a><ul><li><a href="#shuang-qin-wei-pai">双亲委派</a><ul><li><a href="#shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa">双亲委派的详细执行过程和中间方法</a></li><li><a href="#shuang-qin-wei-pai-de-hao-chu">双亲委派的好处</a></li><li><a href="#fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban">父加载器中要加载某个类A时，A需要使用子加载器来加载，但是父加载器没有子加载器的代码，怎么办？</a></li></ul></li><li><a href="#osgi-wang-zhuang-lei-jia-zai-qi">OSGI网状类加载器</a><ul><li><a href="#wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi">为什么OSGI可以实现热部署，但是双亲委派不可以？</a></li></ul></li></ul></li><li><a href="#shu-zu-lei-shi-ru-he-jia-zai-de">数组类是如何加载的？</a></li></ul></li><li><a href="#lian-jie">连接</a><ul><li><a href="#yan-zheng">验证</a><ul><li><a href="#wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui">文件格式校验（class文件对不对）</a></li><li><a href="#yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui">元数据验证（我的父亲对不对）</a><ul><li><a href="#yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi">元数据验证中的类解析</a></li></ul></li><li><a href="#zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui">字节码验证（我的指令对不对）</a></li><li><a href="#fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui">符号引用验证（我的指令调用的目标对不对）</a><ul><li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi">符号引用验证中的字段解析</a></li><li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi">符号引用验证中的类方法解析</a></li><li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi">符号引用验证中的接口方法解析</a><ul><li><a href="#yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma">疑问1：为什么接口方法还要解析？接口里不是没有代码吗？</a></li><li><a href="#yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me">疑问2：为什么要区分类的方法和接口方法？不能用同一种思路去解析么？</a></li></ul></li></ul></li></ul></li><li><a href="#zhun-bei">准备</a><ul><li><a href="#lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei">类静态成员默认值的准备</a></li><li><a href="#fang-fa-biao-de-zhun-bei">方法表的准备</a><ul><li><a href="#chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma">重要问题：interface的接口方法，会有方法表吗？</a></li><li><a href="#wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao">为什么接口不能有方法表？</a></li><li><a href="#java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie">java的虚表和C++的虚表有什么区别？</a></li><li><a href="#java-xu-biao-de-sheng-cheng-guo-cheng">java虚表的生成过程</a></li></ul></li></ul></li><li><a href="#jie-xi">解析</a><ul><li><a href="#jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan">解析的误区：并不是一个单纯的阶段</a></li><li><a href="#jing-tai-jie-xi">静态解析</a></li><li><a href="#jie-xi-he-fen-pai-de-qu-bie">解析和分派的区别</a></li></ul></li></ul></li><li><a href="#chu-shi-hua">初始化</a><ul><li><a href="#cinit-fang-fa-xi-jie-jie-xi">cinit方法细节解析</a><ul><li><a href="#yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de">疑问1：cinit方法中的代码是如何生成的？</a></li><li><a href="#yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma">疑问2：cinit类初始化是线程安全的吗？</a></li></ul></li><li><a href="#chu-shi-hua-zhong-de-dong-tai-jie-xi">初始化中的动态解析</a></li><li><a href="#kuo-zhan-invoke-dynamic-shi-shi-me">扩展:invoke_dynamic是什么</a><ul><li><a href="#dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie">动态语言和静态语言的区别</a></li><li><a href="#java-de-methodhandle-yong-fa">java的MethodHandle用法</a></li><li><a href="#methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa">methodHandle典型应用场景：如何调用爷爷类的虚方法</a></li><li><a href="#java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma">java的methodHandle机制和reflection的反射有什么区别吗？</a></li><li><a href="#invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi">invoke_dynamic指令原理。是否涉及动态分派、类加载和解析？</a></li></ul></li></ul></li><li><a href="#zui-hou-de-wan-zheng-da-tu">最后的完整大图</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu">关于类初始化的时机和误区</span><a href="#guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu" class="header-anchor">#</a></h1><p>书籍的第一步部分上来就先讲了类初始化的时机，整理成图片如下：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652581844567633533.png" alt="image.png"><br>看起来非常多，很难记住，很折磨。</p><p>个人认为，书籍把这一部分放到章节的最前面不太合理，曾经一度让我把上面的这些事件，理解成了类加载的时机，也不懂这些规则的缘由（根本原因还是此时读者对类加载的理解不够深。）</p><p>先贴一下类加载和类初始化的区别：</p><ul><li>类加载概念：将class文件加载到jvm中并生成class对象，并根据情况做初始化。</li><li>类初始化概念：调用类class文件中默认存在的&lt;cinit&gt;类初始化方法。</li></ul><p>而我们容易产生误解的原因，是因为书中没有这句话：：<strong>所谓的类初始化时机，只是针对cinit类初始化方法的调用，并不是指的类加载时机！</strong></p><p>以上图中红色的部分为例：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652582629860693478.png" alt="image.png"><br>这里书籍中没有解释这3个规则的原因，在没理解原理前，强行记忆这3条是没有任何意义的。我认为是作者的失误。</p><p>在这里我挑其中一个做补充：<br><strong>“使用类里的static final 常量，不会触发初始化”</strong><br>想要理解这个规则，需要先理解class文件原理。<br>对于类的static final常量字段，它的常量值是存放在字段的constanValue属性中。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652583662013743457.png" alt="image.png"><br>正因为如此，static final常量并不需要通过cinit方法中的指令来完成赋值。<br>所以也就没有必要在这时候调用&lt;cinit&gt;方法了。</p><p>因此对于“儿子类调用父类的静态成员，不用对儿子类做类初始化”也是一个道理，儿子类的类静态成员没有被使用到，没必要做cinit。</p><p>对于上面的分析，可以浓缩为一句话：<br><strong>“如果我们急需使用static成员，且这个成员的值是要通过cinit方法赋值的，那么我们才做cinit初始化”</strong></p><p><strong>新的疑问</strong>：那为什么仅仅是new一个对象时，也一定要做cinit类初始化呢？<br>假设此时我还没用到static成员，那么new一个对象时，是否可以省去cinit，等用到静态成员的时候，再去触发cinit？</p><p>这涉及到了类初始化的另一个容易被忽视的点：<strong>“cinit类初始化方法，并不仅仅是做类成员的赋值，其实还可能包含一些初始化行为调用”</strong>，这可以是资源的启动或者加载等类对象必须要用到的内容。</p><p>因此在一切可能触发类对象实际行为前，必须触发cinit避免出错。</p><p>所以刚才的长篇大论，可以再次进行优化，浓缩为：<br><strong>“当需要用到static成员的初始赋值，或者对类对象进行正式使用时，才会触发cinit类初始化，目的是为了保证类对象或者类成员的正确使用”</strong><br>拿着这一句话，去回看前面的类初始化时机的触发时机和不触发的时机时，相信你就会有更深的理解了，甚至也不需要强行去记忆每一条规则了。</p><hr><h1><span id="you-wu-dao-de-jia-zai-san-bu-qu">有误导的“加载三部曲”</span><a href="#you-wu-dao-de-jia-zai-san-bu-qu" class="header-anchor">#</a></h1><p>有一个很经典的回答，叫做<strong>类加载三部曲：加载、连接、初始化</strong><br>好像类加载过程就是这三步按照顺序串行拼装起来的。</p><p>实际上这3个过程是存在交叉的！<br>只能说，“最早发生”的时机，是按照这个顺序发生，但是中间加载过程是有很多的，具体后面会结合我画的图以及原理解释进行呈现。</p><h1><span id="jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu">加载：不仅仅是读取字节流</span><a href="#jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu" class="header-anchor">#</a></h1><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652594910504257328.png" alt="image.png"><br>对于加载，很容易只理解成只是“从文件里加载二进制字节到内存”。<br>这个过程显然是必须最先执行的，否则连类的基本信息都获取不到。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595413217848779.png" alt="image.png"><br>可以看到这个过程很灵活，只要你从你能想到的地方拿到字节流即可，任意形式都行。</p><p>然而，对于“加载”，除了获取字节流，实际上还包含了“把字节流转成方法区里的数据结构，进行存储defineClass”、“生成一个class对象，存储在堆中”这两步。</p><p>这2步是穿插在连接过程中的。<br>比如字节流转数据结构的过程，必须在确认字节流的正确性之后完成。<br>而生成class对象同理，符合一个class对象的条件时，才能将其在堆中生成。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595269171806676.png" alt="image.png"><br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595359889871663.png" alt="image.png"></p><p>加载过程是由类加载器classloader完成的，在这里对classLoader也顺便做一个详细的分析。</p><h2><span id="lei-jia-zai-qi">类加载器</span><a href="#lei-jia-zai-qi" class="header-anchor">#</a></h2><h3><span id="shuang-qin-wei-pai">双亲委派</span><a href="#shuang-qin-wei-pai" class="header-anchor">#</a></h3><p>类加载时的双亲委派模型，反正就记得优先去父类加载器中看类是否能加载。</p><p>这个过程和多态方法调用是相反的，多态方法是子类覆写了的话则优先子类调用，类加载则是父加载器能加载则加载。</p><p><strong>注意：Bootsrap不是ClassLoader的子类，他是C++编写的。</strong><br>而ExtClassLoader和AppClassLoader都是继承自ClassLoader的</p><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/a4c77999a2f8a0d5bc6401d05efeca9cdcecef43.png" alt="a4c77999a2f8a0d5bc6401d05efeca9cdcecef43"></p><h4><span id="shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa">双亲委派的详细执行过程和中间方法</span><a href="#shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa" class="header-anchor">#</a></h4><p>loaderClass（className）  双亲加载实现（这里会体现先去父亲找，再自己）<strong>注意，jdk1.2之后不提倡覆盖loadClass方法，这个方法可以理解为一个模板方法</strong>。</p><p><strong>但如果确实有需要破坏双亲委派的需求，则可以重写loaderClass方法，解除双亲委派机制</strong></p><p>findClass()  如何根据名字，寻找并生成1个class（内部需要借助defineClass）<br>defineClass()  通过这个方法将字节码生成1个class类，基本不用改动。</p><p>例如需要根据类目，从某个远端网络加载获取这个类， 而且获取过来的时候还是加密的，需要在findClass里对byte数组做解密，解密完成，再调用defineClass生成class类。</p><p><a href="https://blog.csdn.net/zzti_erlie/article/details/82757435">https://blog.csdn.net/zzti_erlie/article/details/82757435</a></p><h4><span id="shuang-qin-wei-pai-de-hao-chu">双亲委派的好处</span><a href="#shuang-qin-wei-pai-de-hao-chu" class="header-anchor">#</a></h4><p>书中提到的原因就一个： java类随着类加载器，具备了带有优先级的层次关系。<br>保证了例如object类在每个环境里都是同一种，不会出现混乱。</p><h4><span id="fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban">父加载器中要加载某个类A时，A需要使用子加载器来加载，但是父加载器没有子加载器的代码，怎么办？</span><a href="#fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban" class="header-anchor">#</a></h4><p>可以使用线程上下文TCCL机制， 例如java的JNDI服务，JNDI是在启动类加载器里入加载的（JDK1.3的rt.jar)， 但是JNDI会加载很多扩展性很强的新资源类。</p><p>因此可以在JNDI加载类的过程中，从TCCL这个context对象中，拿到set进去的用户加载器，然后进行加载即可。（JDBC、JBI等SPI机制都是如此）</p><h3><span id="osgi-wang-zhuang-lei-jia-zai-qi">OSGI网状类加载器</span><a href="#osgi-wang-zhuang-lei-jia-zai-qi" class="header-anchor">#</a></h3><p>OSGI中， 每一个程序模块（bundle）都有一个自己的类加载器，当需要更换一个bundle时，就把bundle连同类加载器一起换掉，实现代码的热替换</p><p>它是一个网状的类加载结构，只有java.*以及委派名单的，才会用双亲委派机制，否则都是各种网状的加载。加载过程如下所示：</p><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/62408d2e1e08530789333ccd-1651765505820.png" alt="OSGI加载"></p><h4><span id="wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi">为什么OSGI可以实现热部署，但是双亲委派不可以？</span><a href="#wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi" class="header-anchor">#</a></h4><p>首先，理解双亲委派模型下，不能热部署的原因：<br><strong>如果有新升级的同名类要加入，它只能在新给出的一个加载器去加载， 但是双亲模型限定了必须是先交给父加载器加载，这导致了升级困难，无法让新的加载器去做抢先加载。</strong></p><p>OSGi类加载模型则是网络图状的，可以在bundle间互相委托<br>例如bundleA、B都依赖于bundleC，当他们访问bundleC中的类时，就会委托给bundleC的类加载器，由它来查找类；如果它发现还要依赖bundleE中的类，就会再委托给bundleE的类加载器。</p><blockquote><blockquote><p>另一篇文章的解释：</p></blockquote><ul><li>由于类加载机制的原因，导致一个类一旦加载进去就再也无法释放，因此，OSGi引入了基于插件的类加载机制</li><li>举例说明：plugin1里有examples.Test1类，而pulgin2里也有examples.Test1类，在载入这两个插件时，两个类是可以同时载入进入到类缓存中，这归功于OSGi实现的插件类加载器(ClassLoader)</li><li>我们把“examples.Test”服务的 Service Ranking 属性更改成了 100，那么其他bundle使用这个bundle对应的example类时，就会用优先级最高的类。</li><li>在不需要停止服务和其他插件都不用更新的情况下，我们只需要再安装一个更新版本的插件，其所注册的服务就可以自动更新并应用到所有调用该插件的插件中，达到了热部署的目的。<br><a href="https://blog.csdn.net/yipsilon/article/details/83369177">OSGi的热部署特性及实现</a></li></ul></blockquote><h2><span id="shu-zu-lei-shi-ru-he-jia-zai-de">数组类是如何加载的？</span><a href="#shu-zu-lei-shi-ru-he-jia-zai-de" class="header-anchor">#</a></h2><p>数组类是由AppClassLoader加载的。<br>数组类打印className时，前面会有个[Lxx类<br>二维数组就是[[Lxxx类<br><strong>数组类的父类型是Object</strong></p><p>注意此时加载的是数组类，而数组类里面的对象是不会做自动加载的<br>因此xx类的静态代码并不会被直接调用</p><h1><span id="lian-jie">连接</span><a href="#lian-jie" class="header-anchor">#</a></h1><p>连接过程可以说是最难记住的一个过程， 里面包含了各种校验啊之类的，让人摸不清头脑。这里会通过更细致的解释和图解，让你明白连接过程究竟做了什么。<br>首先连接过程分为 验证、准备和解析，<strong>“解析”并不是连接的最后一步，而是在验证过程中实时发生的！</strong>。 下文会为你详细解释为什么。</p><h2><span id="yan-zheng">验证</span><a href="#yan-zheng" class="header-anchor">#</a></h2><h3><span id="wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui">文件格式校验（class文件对不对）</span><a href="#wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui" class="header-anchor">#</a></h3><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652596406384448149.png" alt="image.png"><br>注意这里的校验，都是一些最简单的校验，相当于无需做太多的语法分析操作等操作， 都是基于class文件格式定义进行的基础校验。</p><p>然而如果对加载的文件有充分的自信，来源可靠，那么确实可以省去这个步骤，提升连接效率，因此会有一个-Xverify:none的选项供使用。</p><h3><span id="yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui">元数据验证（我的父亲对不对）</span><a href="#yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui" class="header-anchor">#</a></h3><p>这里验证了class文件里面继承特性相关的重要信息，例如继承关系是否合理、是否实现了抽象类或接口的方法<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652596978343390083.png" alt="image.png"></p><p>注意，这个元数据验证的过程，<strong>会触发父类或者接口的解析（加载）操作！</strong><br>书上提到了4个解析情况以及流程：</p><ul><li>类解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析<br>却没有解释这4个解析过程是在哪里发生的。后面我会逐一提到，来真正理解这4个解析过程。</li></ul><h4><span id="yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi">元数据验证中的类解析</span><a href="#yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi" class="header-anchor">#</a></h4><p>还记得class文件中，父类是指向一个constant_class_info吗？这个东西当时看就是一个utf字符串，没什么意义。你没法知道父类究竟有什么方法，是不是抽象类。<br>因此必须拿到父类的类信息，要么是已经在方法区中，要么需要重新加载。<br>而类解析的过程如下：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598263182568128.png" alt="image.png"><br>可以看到这个过程中也会发生加载，甚至好多次加载。</p><hr><h3><span id="zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui">字节码验证（我的指令对不对）</span><a href="#zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui" class="header-anchor">#</a></h3><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598525735605413.png" alt="image.png"><br>这个验证不要和前面的“文件格式验证”搞混了。<br>前面的“元数据验证”都只是针对类、方法、字段等和父类进行确认、校验。<br>但是还没有涉及到每个方法里的code属性。</p><p>code属性虽然在编译出来时是正确的，但是无法保证传输过程中被人篡改。<br>如果发生操作操作数栈时，栈里没东西，或者试图在局部变量表边界外写入局部变量，就可能导致不可估量的后果。</p><p>因此此刻会进行最基本的指令分析，确认对操作数栈、局部变量表的操作是安全、正确的。</p><p>但是，逐个指令分析，会不会太慢了？如果代码很长的话。</p><p>还记得class文件的code属性中，还包含了一个stackMapTable属性么，估计很多人都跳过了这个属性。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598909384718936.png" alt="image.png"><br>这个属性就是用在字节码验证这个过程，可以立即让编译器编译出class时，提前把各位置的情况写入stackMap中，jvm加载时只对这个stackMap做校验确认是对的即可。<br>但代价就是可能不安全了，因为这个stackMap是可以被篡改的。</p><h3><span id="fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui">符号引用验证（我的指令调用的目标对不对）</span><a href="#fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui" class="header-anchor">#</a></h3><p>注意前面的“字节码验证”是简单的确认，但不会持有过多的其他类的信息。<br>但是方法肯定会涉及对其他类的调用。</p><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652599879633278954.png" alt="image.png"></p><p>此时就会涉及到符号引用验证，确认自己是否拥有对方方法的访问权限。<br>那么你就需要找到目标类的类信息存放地址，确认方法权限，或者字段权限。<br>于是会在这里触发字段解析、类方法解析或者接口解析！<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652601092434475198.png" alt="image.png"><br>书上只提到了这3个解析过程的流程，却没有详细解释其中的一些缘由，我会做更详细的补充。</p><h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi">符号引用验证中的字段解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi" class="header-anchor">#</a></h4><p>class中的constant_filed_info终于露出了它的真面目，原来是用在这个地方，即和字段相关的指令会用到它，并通过字段符号引用， 解析到这个字段真正的定义位置。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652601973522659730.png" alt="image.png"><br>像经常遇到的NoSuchFieldError报错，就是在这个过程中爆出来的。<br>而且接口字段的优先级是大于父类的字段的。</p><h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi">符号引用验证中的类方法解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi" class="header-anchor">#</a></h4><p>当调用方法前，需要先确认对象方法是否有权限访问。那么就必须这个类的信息进行确认。<br><strong>注意：这个过程并不是动态分派的那个过程，此刻并没有触发任何的方法调用！仅仅是确认代码中静态类型的访问权限是否正确之类的！</strong><br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652602585506110322.png" alt="image.png"></p><ul><li>对类方法做解析的时候，会判断此时是类还是接口。如果是接口，竟然会报“IncompatibleClassChangeError”。</li><li>还有如果是抽象类，也会报“AbstractMethodError”，因为正常情况下，你的jvm指令调用的方法，必须是实例化的对象所对应的方法，不可能直接调用抽象类方法的。</li></ul><h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi">符号引用验证中的接口方法解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi" class="header-anchor">#</a></h4><p>看起来像是将类方法解析中的接口和方法互换了位置。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652603187639739722.png" alt="image.png"></p><h5><span id="yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma">疑问1：为什么接口方法还要解析？接口里不是没有代码吗？</span><a href="#yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma" class="header-anchor">#</a></h5><p>因为接口类里每个interface方法，本身也是一个方法，只不过没有详细的code属性。但方法的访问修饰符之类的都存在，因此验证阶段还是需要进行校验。</p><h5><span id="yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me">疑问2：为什么要区分类的方法和接口方法？不能用同一种思路去解析么？</span><a href="#yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me" class="header-anchor">#</a></h5><p>我理解的几个原因：</p><ol><li>向上搜索时的逻辑不同，对于类方法，直接找父类即可， 而接口则需要遍历所有父接口。而且类方法还要考虑抽象类的问题，接口不需要。</li><li>类方法和接口方法本身就是两个不同的符号引用， 一个是constant_method_ref，另一个是constant_interface_ref，用2套逻辑没什么毛病</li><li>如果硬要问为什么要区分这2个符号引用，明明内容都是类索引+描述符索引？<br>这是因为后面在实际调用方法时，二者有显著区别，具体见下文的“方法表的准备”。</li></ol><h2><span id="zhun-bei">准备</span><a href="#zhun-bei" class="header-anchor">#</a></h2><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652604139278590043.png" alt="image.png"></p><h3><span id="lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei">类静态成员默认值的准备</span><a href="#lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei" class="header-anchor">#</a></h3><p>对于准备阶段，大家一般只记得需要对一些非final的类静态成员做默认初始值操作。</p><h3><span id="fang-fa-biao-de-zhun-bei">方法表的准备</span><a href="#fang-fa-biao-de-zhun-bei" class="header-anchor">#</a></h3><p>除了这个默认值赋值，还有一个动作，是准备方法表。<br>方法表就是为了多态而生，简化动态分派时频繁的迭代循环带来的不必要消耗：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652604259330823080.png" alt="image.png"><br>通过前面的验证过程，我们已经获知了父类信息。<br>因此可以准备一个方法表，把父类方法堆到最前面，自己的方法堆到后面，后面直接根据索引获取方法调用地址即可！</p><h4><span id="chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma">重要问题：interface的接口方法，会有方法表吗？</span><a href="#chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma" class="header-anchor">#</a></h4><p>intefacer接口是不具有方法表的！<br>因此这可能也是jvm特地区分了class_inteface_info和class_method_info这2个常量，以及特地用invoke_inteface和invoke_virtual指令来区分2类方法的调用。因为他们的调用逻辑可能大相径庭。</p><h4><span id="wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao">为什么接口不能有方法表？</span><a href="#wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao" class="header-anchor">#</a></h4><p>这是由于Java可以实现多个接口，不同的类可能会实现了多个或者不同的接口，在虚表里该接口所实现方法的索引会不一致。</p><p>假设有A、B、C三个接口类</p><ul><li>类X实现了A、B两个接口，假设A和B接口放在虚表里，那么调用A接口方法我们假设它是在t位置。</li><li>类T实现了B、C、A接口，按照实现顺序，先放B的方法，再放A的方法，最后放C的方法。这样调用接口A时，就不一定是t位置了，我们无法直接确定A里面方法的位置，因为一个类可以实现多个接口，而且顺序可以随意更改！</li></ul><p>这样每次解析的虚表索引都可能会不同，因此不能进行缓存，需要每次都进行重新的解析。<br><strong>因此，接口的方法调用会比普通的子类继承的虚函数调用要慢。</strong></p><h4><span id="java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie">java的虚表和C++的虚表有什么区别？</span><a href="#java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>C++：<br>当编译器遇到调用虚方法的代码时，是通过vtable指针以及对应方法在虚表里的offset，然后获取对应的函数指针实现的，由于offset在编译过程就已经固定了，这样在执行过程中几乎没有产生任何额外的计算就实现了多态调用，效率相当高。<br><strong>缺点就是当你修改了一个dll链接文件，另一个dll链接文件可能还是用的老的偏移，这导致你即使重启程序了，仍然还是错误的调用。 你必须将两个链接文件都重新编译才可以。</strong></p><p>但对于java而言，只需要替换一个jar包即可， 类之间的方法调用关系，方法偏移，都是可以类加载过程中去生成的。</p><p>换言之，最大的区别就是修改部分方法带来的影响，java是最小的</p><h4><span id="java-xu-biao-de-sheng-cheng-guo-cheng">java虚表的生成过程</span><a href="#java-xu-biao-de-sheng-cheng-guo-cheng" class="header-anchor">#</a></h4><ol><li>在加载该类的时候，常量池的所有<strong>虚函数的签名</strong>（包括调用的以及自身定义的）都会<strong>添加到全局的符号表</strong>（事实上是一个HashTable）。</li><li><strong>首先对字符值进行Hash值计算，然后在全局HashTable进行查找</strong>，如果发现已经存在对应的Hash值，则返回对应的符号指针Symbol *，否则创建新的Symbol并添加到HashTable中，然后返回新创建的Symbol *。这样常量池就把字符串的引用转换成符号的引用。另外这个过程可以确保所有字符串在jvm只存有一个引用。、</li><li>当在某个类对象调用虚方法的时候，通过调用函数的符号和自身定义的符号进行比较（由于这里都是引用全局符号表的唯一符号，因此可以通过内存地址进行快速比较），就会解析出调用虚函数的信息，<strong>通过信息就可以获取虚表的索引，然后调用对应的虚函数字节码</strong></li><li>为了提高调用时的性能，Java采用的是Lazy解析，<strong>第一次解析出虚表的索引后，则会保留到cache里面</strong>，这样下次调用就可以从缓存直接获取索引</li></ol><h2><span id="jie-xi">解析</span><a href="#jie-xi" class="header-anchor">#</a></h2><h3><span id="jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan">解析的误区：并不是一个单纯的阶段</span><a href="#jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan" class="header-anchor">#</a></h3><p>解析其实分为“静态解析”和“动态解析”。<br>因此将解析说成是“连接”中的一部分是不严谨的， 只有静态解析，才是“连接”的一部分。</p><p>静态解析在初始化前发生，但动态解析则可能在初始化或者初始化之后才去使用。</p><h3><span id="jing-tai-jie-xi">静态解析</span><a href="#jing-tai-jie-xi" class="header-anchor">#</a></h3><p>静态解析用于解析私有方法、父类构造器、final方法等不存在多态可能的方法。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652605263696340667.png" alt="image.png"></p><h3><span id="jie-xi-he-fen-pai-de-qu-bie">解析和分派的区别</span><a href="#jie-xi-he-fen-pai-de-qu-bie" class="header-anchor">#</a></h3><p>静态分派、动态分派， 指的是2个方法的不同阶段，他们不存在冲突的关系，即方法会先触发静态分派，再触发动态分派。</p><p>静态分派可以理解为编译器在编写class文件时，通过方法名+描述符+优先级，确定了这个位置调用的是哪个方法。</p><p>但是由于多态的特性，具体执行者可能不同，因此后面还会触发动态分派。</p><p>而静态解析和动态解析是2个不同的解析，前者是默认定死了方法引用位置，后者则必须依赖动态分派，对一个方法而言不可能同时存在动态和静态解析的情况。</p><h1><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor">#</a></h1><h2><span id="cinit-fang-fa-xi-jie-jie-xi">cinit方法细节解析</span><a href="#cinit-fang-fa-xi-jie-jie-xi" class="header-anchor">#</a></h2><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606173785989291.png" alt="image.png"><br>关于初始化时机的解释，在开头就已经阐述过了，这里不再重复解释。</p><h3><span id="yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de">疑问1：cinit方法中的代码是如何生成的？</span><a href="#yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de" class="header-anchor">#</a></h3><p>cinit方法 是编译器收集所有类静态变量的赋值动作和静态语句块static{}中的语句合并产生，按照顺序收集。<br>因此类加载赋值的顺序和类定义顺序有关，原理就取决于cinit生成的原理。</p><h3><span id="yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma">疑问2：cinit类初始化是线程安全的吗？</span><a href="#yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h3><p>是线程安全的，虚拟机会保证一个类的加载和cinit方法会被正确的加锁、同步。<br>因此多线程场景下，同时使用一个之前没初始化过的类，且类初始化过程耗时非常久的话， 且可能会造成线程阻塞。<br>而这也是可以利用类初始化+内部类的方式，来做单例模式的实现的原理：</p><h2><span id="chu-shi-hua-zhong-de-dong-tai-jie-xi">初始化中的动态解析</span><a href="#chu-shi-hua-zhong-de-dong-tai-jie-xi" class="header-anchor">#</a></h2><p>而初始化过程中，可能会涉及其他对象实例方法的调用，因此是可能发生动态解析过程的！<br>类方法和接口方法的解析过程如下<br>类方法的解析可以借助虚方法表简化解析过程。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606407501364079.png" alt="image.png"></p><h2><span id="kuo-zhan-invoke-dynamic-shi-shi-me">扩展:invoke_dynamic是什么</span><a href="#kuo-zhan-invoke-dynamic-shi-shi-me" class="header-anchor">#</a></h2><h3><span id="dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie">动态语言和静态语言的区别</span><a href="#dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie" class="header-anchor">#</a></h3><p>动态类型语言： 类型检查的主体是运行期而不是编译器。 例如PHP、Lua\python<br>而静态类型语言就是编译器将类型都检查完，比如C++、java</p><p>静态语言的好处：在编译器就能确定类型，可以进行严谨的类型检查， 代价就是代码会很臃肿。<br>动态语言编写时更为随意，可以快速开发和运行。</p><h3><span id="java-de-methodhandle-yong-fa">java的MethodHandle用法</span><a href="#java-de-methodhandle-yong-fa" class="header-anchor">#</a></h3><p>jdk1.7之后提供的 MethodHandle， 类似于C/C++里的函数指针， 或者C#里的delegate。<br>C里面可以<br>sort(list, size,  int (* compare)(int, int))<br>即传入一个函数指针，这个函数是哪个类调用的？不知道</p><p>java提供了methodHandle用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is a print:&quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodHandle <span class="title function_">getPrintlnMethodHandle</span><span class="params">(Object object)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 返回值，入参</span></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup()</span><br><span class="line">                <span class="comment">// 找到对象所对应的类，确认是否存在方法</span></span><br><span class="line">                .findVirtual(object.getClass(), <span class="string">&quot;println&quot;</span>, methodType)</span><br><span class="line">                <span class="comment">// 这个对对象绑定上去调用. java的反射不是也能做到吗》？</span></span><br><span class="line">                .bindTo(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">ClassA</span> <span class="variable">classA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line">        <span class="comment">// invokeExact：执行并传入参数，classA和System.out不是同一个父类或者接口，但是可以执行相同的方法</span></span><br><span class="line">        getPrintlnMethodHandle(classA).invokeExact(<span class="string">&quot;afdsafds&quot;</span>);</span><br><span class="line">        getPrintlnMethodHandle(System.out).invokeExact(<span class="string">&quot;afdsafds&quot;</span>);</span><br><span class="line">        <span class="comment">// 以后排序就可以这样做了：  sort(list, MethodHandle mt)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中methodHandle背后就是由invoke_dynamic指令触发的。</p><h3><span id="methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa">methodHandle典型应用场景：如何调用爷爷类的虚方法</span><a href="#methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa" class="header-anchor">#</a></h3><p>如何在儿子类中，分派调用祖父类的虚方法？ 且儿子类和父类都已经实现了这个虚方法。父类不能提供新的方法</p><p>通过loopup().findSpecial(祖父类， “方法名”， MethodHandle.methodType(返回值，入参),  当前类)<br>拿到一个方法句柄mh<br>然后方法句柄mh.invoke(this)，即可调用祖父类的方法。</p><h3><span id="java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma">java的methodHandle机制和reflection的反射有什么区别吗？</span><a href="#java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma" class="header-anchor">#</a></h3><ol><li>调用指令层面：</li></ol><ul><li>reflection是模拟java代码调用，不关心底层指令</li><li>而methodHandle是模拟了字节码的执行，上面的Loopup().findVirtual，等同于invokevirtual指令（同理还有invokestatic\invokeinteface\invokespecial)</li></ul><ol start="2"><li>method对象大小问题</li></ol><ul><li>reflection返回的method对象，包含的信息更多，例如签名、描述、属性等，返回的method比较重量级</li><li>而methodHandle仅包含执行方法相关的信息，是轻量级、</li></ul><ol start="3"><li>可以基于methodHandle手动做虚拟机的相关调用优化（例如内联），而反射无法实现。</li><li>从最终设计目的而言，反射只针对java， 而methodHandle的核心目的在于可以将其他无类型的语言运行在java迅即之上！</li></ol><h3><span id="invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi">invoke_dynamic指令原理。是否涉及动态分派、类加载和解析？</span><a href="#invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi" class="header-anchor">#</a></h3><p>我们首先看下invoke_dynamic指令调用的dynamic_info常量长什么样的：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606577911480954.png" alt="image.png"><br>可以看到它只包含了一个方法索引和描述，但似乎没包含方法属于哪个类。</p><p>它的作用是用java实现一些类似于脚本语言的逻辑，脚本语言不关心静态类型，不做编译检查，只关心运行期的内容。所以invoke_dynamic以及constant_dynamic_info应运而生。但书本和工作中对这块的接触都不是太深，因此我的理解也只能局限于此了。</p><p>书上还有句话可以记一下：<strong>除了invokeddynamic动态调用指令， 其他的invokevirual之类的，都会缓存解析结果。</strong></p><hr><h1><span id="zui-hou-de-wan-zheng-da-tu">最后的完整大图</span><a href="#zui-hou-de-wan-zheng-da-tu" class="header-anchor">#</a></h1><p><a href="https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8">在线地址</a><br><a href="https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8">https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8</a></p><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/5e7eed6ce4b08b6157409373.png" alt="完整大图"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> jvm原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,深入理解jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾收集器演进和原理详解</title>
      <link href="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>重读了一遍《深入理解java虚拟机》， 发现第一遍读垃圾回收器相关的进化历程时，没有细细去研究各自的区别，觉得太多了记不住。<br>实际上理解了这个进化过程，这对于我们理解回收器是有很大帮助的。</p><p><strong>看来经典书籍要多读多总结，是有道理的。</strong><br>于是在阅读这个章节时，画了一张大的演化图，方便理解变化和区别。</p> <div class="toc"><!-- toc --><ul><li><a href="#serial-old-he-serial-dan-xian-cheng-shou-ji-qi">Serial Old和Serial（单线程收集器）</a><ul><li><a href="#serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma">Serial类型的收集器被淘汰了吗？它还有优势吗？</a></li><li><a href="#q-shi-me-shi-hou-ke-yi-hong-fa-stopworld-an-quan-dian-gc-shi-jian-dian">Q: 什么时候可以触发stopWorld？（安全点,GC时间点）</a></li><li><a href="#4-ge-an-quan-dian-de-she-ji-si-lu-shi-shi-me">4个安全点的设计思路是什么？</a></li><li><a href="#q-he-an-quan-dian-dui-ying-de-an-quan-qu-you-shi-shi-me">Q: 和安全点对应的安全区又是什么？</a></li></ul></li><li><a href="#parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi">ParOld和ParNew收集器（多线程收集器）</a></li><li><a href="#parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan">Parallel Scavenge收集器（对回收时间的优化开端）</a><ul><li><a href="#ru-he-li-jie-tun-tu-liang">如何理解吞吐量</a></li><li><a href="#parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de">Parallel Savenge收集器是如何控制吞吐量的</a></li><li><a href="#dai-jie-shi-shi-me">代价是什么？</a></li></ul></li><li><a href="#cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu">CMS收集器（Concurrent Mark Sweep, 并发收集概念的重大提出）</a><ul><li><a href="#cms-jie-duan-1-chu-shi-biao-ji">CMS阶段1：初始标记</a><ul><li><a href="#gcroot-de-xuan-qu-yuan-ze-shi-shi-me">GCRoot的选取原则是什么？</a></li><li><a href="#parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma">ParNew年轻代收集时，需要遍历CMS老年代的所有GCROOT吗？</a></li></ul></li><li><a href="#cms-jie-duan-2-bing-fa-biao-ji">CMS阶段2：并发标记</a><ul><li><a href="#bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de">并发标记用了怎样的算法去标记的？</a></li><li><a href="#bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng">并发标记时如何记录引用变更？</a></li><li><a href="#shi-me-shi-kua-dai-yin-yong">什么是跨代引用？</a></li><li><a href="#ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang">如何避免跨代引用，保障并发标记安全（写屏障</a></li></ul></li><li><a href="#cms-jie-duan-3-chong-xin-biao-ji">CMS阶段3：重新标记</a></li><li><a href="#cms-jie-duan-4-bing-fa-qing-chu">CMS阶段4：并发清除</a><ul><li><a href="#wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa">为什么是要用“标记-清除”这么缺点大的方法？</a></li><li><a href="#cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang">CMS如何解决标记-清除后碎片过多，无法放入新对象的情况？</a></li><li><a href="#bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban">并发回收过程中，如果工作线程突然生成大量新垃圾，导致内存不足怎么办？</a></li></ul></li></ul></li><li><a href="#hun-he-shi-yong-shou-ji-qi-cms-parnew">混合使用收集器（CMS+parNew)</a><ul><li><a href="#q-fullgc-he-monorgc-fen-bie-fa-sheng-zai-lao-nian-dai-qu-huan-shi-xin-sheng-dai-qu">Q： fullGC和monorGC分别发生在老年代区还是新生代区？</a></li><li><a href="#q-xin-sheng-dui-xiang-shi-me-shi-hou-ke-yi-chang-shi-jin-ru-lao-nian-dai">Q: 新生对象什么时候可以尝试进入老年代？</a></li><li><a href="#q-eden-nian-qing-dai-qu-he-survivor-qu-de-bi-li-wei-shi-me-shi-8-bi-1-bi-1">Q: Eden年轻代区和survivor区的比例为什么是8比1比1</a></li><li><a href="#q-jiang-yi-xia-lao-nian-dai-de-dan-bao-ce-lue-shi-zuo-shi-me-de">Q: 讲一下老年代的担保策略是做什么的？</a></li><li><a href="#xin-sheng-dai-lao-nian-dai-de-jiao-hu-liu-cheng">新生代、老年代的交互流程：</a></li></ul></li><li><a href="#g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi">G1收集器（回收概念发生诸多变革，目前最先进收集器）</a><ul><li><a href="#g1-xiang-bi-cms-de-chong-da-sheng-ji-dian">G1相比CMS的重大升级点：</a></li><li><a href="#g1-li-de-region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma">G1里的region之间都要通过BFS遍历吗？</a></li></ul></li><li><a href="#wan-zheng-da-tu">完整大图</a></li><li><a href="#qi-ta-wen-ti">其他问题</a><ul><li><a href="#q-fang-fa-qu-li-de-class-dui-xiang-ji-lei-dui-xiang-shi-me-shi-hou-hui-bei-hui-shou">Q： 方法区里的class对象（即类对象）什么时候会被回收？</a></li><li><a href="#q-shi-me-shi-hou-hui-diao-yong-dui-xiang-de-finalized-fang-fa">Q： 什么时候会调用对象的finalized方法</a></li></ul></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="serial-old-he-serial-dan-xian-cheng-shou-ji-qi">Serial Old和Serial（单线程收集器）</span><a href="#serial-old-he-serial-dan-xian-cheng-shou-ji-qi" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830465493764891.png" alt="image.png"></p><ul><li>Serial Old指的是老年代收集器，使用标记-整理清理垃圾</li><li>Serial指的是年轻代收集器，使用复制算法清理垃圾。</li></ul><p>Serial就是单线程的意思，不仅代表它使用单线程做回收，<strong>更意味着他会进行stop world暂停工作线程</strong></p><h2><span id="serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma">Serial类型的收集器被淘汰了吗？它还有优势吗？</span><a href="#serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma" class="header-anchor">#</a></h2><p>没有，它是client模式下默认的收集器。<br>优势在于，它具有<strong>最高的单线程收集效率</strong><br>而client模式一般不会用于处理大量请求，因此非常适合serial。</p><p>除了client，书上还提了另外2个功能：</p><ul><li>Serial Old收集器会作为CMS的后备预案</li><li>与Parallel Scavenge搭配使用</li></ul><h2><span id="q-shi-me-shi-hou-ke-yi-hong-fa-stopworld-an-quan-dian-gc-shi-jian-dian">Q: 什么时候可以触发stopWorld？（安全点,GC时间点）</span><a href="#q-shi-me-shi-hou-ke-yi-hong-fa-stopworld-an-quan-dian-gc-shi-jian-dian" class="header-anchor">#</a></h2><ul><li>方法返回之前</li><li>调用某个方法之后</li><li>抛出异常的位置</li><li>循环的末尾</li></ul><h2><span id="4-ge-an-quan-dian-de-she-ji-si-lu-shi-shi-me">4个安全点的设计思路是什么？</span><a href="#4-ge-an-quan-dian-de-she-ji-si-lu-shi-shi-me" class="header-anchor">#</a></h2><p>当垃圾收集需要中断用户线程的时候, 不直接对线程操作,而是设置一个标志位.</p><p>各个用户线程执行过程中会轮询这个标志位的状态.</p><p>一旦用户线程轮询到标志位被设置过, 就在最近的安全点主动挂起,所有用户线程都挂起, 垃圾收集真正进行</p><h2><span id="q-he-an-quan-dian-dui-ying-de-an-quan-qu-you-shi-shi-me">Q: 和安全点对应的安全区又是什么？</span><a href="#q-he-an-quan-dian-dui-ying-de-an-quan-qu-you-shi-shi-me" class="header-anchor">#</a></h2><p>A:<br>程序可能因为blocked或者sleep，无法到达安全点。<br>这是可以设置一个安全区域，这个安全区域对应的代码段，引用关系不会变。JVM检测到程序在安全区域时，可以进行GC。<br>程序运行出安全区域时，检测GC没有结束的话，自我中断。</p><h1><span id="parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi">ParOld和ParNew收集器（多线程收集器）</span><a href="#parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830556269329780.png" alt="image.png"><br>Par收集器就是Serial收集器的多线程版本，其他策略则都与serial一致。</p><p><strong>注意， 虽然是多线程收集器，但是用户的工作线程仍然是暂停状态（为了防止收集过程中发生变化导致回收错误</strong></p><p>ParNew收集器可以与CMS收集器配合使用。</p><h1><span id="parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan">Parallel Scavenge收集器（对回收时间的优化开端）</span><a href="#parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830818239387635.png" alt="image.png"></p><p>Parallel Scavenge 收集器是一个<strong>新生代收集器</strong>，他不包含老年代。<br>前两代的收集器，默认必须收集完成，对工作线程影响巨大。<br><strong>这是首次开始关注回收时间对工作线程影响的一代收集器，成为了垃圾收集器升级优化的一个重要开端。</strong></p><h2><span id="ru-he-li-jie-tun-tu-liang">如何理解吞吐量</span><a href="#ru-he-li-jie-tun-tu-liang" class="header-anchor">#</a></h2><p>虚拟机运行了100分钟， 垃圾收集花掉了一分钟，那么吞吐量就是100%。</p><h2><span id="parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de">Parallel Savenge收集器是如何控制吞吐量的</span><a href="#parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de" class="header-anchor">#</a></h2><p>通过控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数，以及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br>通过修改这2个参数，jvm可以计算一个合适的新生代空间，<strong>空间越小，回收时间越快</strong>，他的停顿时间便能够满足吞吐量要求。</p><ul><li>换句话说，本质上就是通过你设定的吞吐量或者暂停时间，自适应地得到一个新生代空间大小而已。</li></ul><h2><span id="dai-jie-shi-shi-me">代价是什么？</span><a href="#dai-jie-shi-shi-me" class="header-anchor">#</a></h2><p>新生代越小，那么意味着老年代的空间就越大。</p><p>虽然能做到基本不停顿或者停顿间隔很小，但这样就会<strong>导致新生代频繁发生minorGc，并不断将垃圾扔给老年代收集器</strong>，容易在下一个时间段触发更多的fullGc。<br>因此这个策略仅仅是饮鸠止渴，无法真正解决问题。</p><ul><li>注意，这里ParaleelSavenge的吞吐量，指的就是新生代的吞吐量，不代表fullGc占用的时间。</li></ul><h1><span id="cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu">CMS收集器（Concurrent Mark Sweep, 并发收集概念的重大提出）</span><a href="#cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652831748531127900.png" alt="image.png"><br>而从这一代开始，jvm终于想到了可以如何尽可能少地暂停工作线程的方式，提出了并发收集的概念。</p><p>首先明确并行收集和并发收集的区别</p><ul><li>并行收集：指用多线程来收集，但是工作线程仍然暂停</li><li>并发收集：收集线程和工作线程允许不冲突地交替并发执行</li></ul><hr><p>CMS是老年代收集器，必须和parNew等结合使用<br>使用的是回收-清除算法，有较多碎片。</p><hr><h2><span id="cms-jie-duan-1-chu-shi-biao-ji">CMS阶段1：初始标记</span><a href="#cms-jie-duan-1-chu-shi-biao-ji" class="header-anchor">#</a></h2><p>初始标记就是对GCRoot对象进行标记，以GCroot作为起点。<br>GCRoot的那4种经典对象，瞄一眼就好</p><blockquote><blockquote><p>虚拟机栈（栈帧中的本地变量表）中的引用的对象<br>方法区中的类静态属性引用的对象<br>方法区中的常量引用的对象<br>本地方法栈中JNI（Native方法）的引用对象</p></blockquote></blockquote><h3><span id="gcroot-de-xuan-qu-yuan-ze-shi-shi-me">GCRoot的选取原则是什么？</span><a href="#gcroot-de-xuan-qu-yuan-ze-shi-shi-me" class="header-anchor">#</a></h3><p>这个问题很有意思，为什么要这样选择？如果能理解这个问题，也就不需要去死记硬背上面的内容了。</p><p>首先，可能有很多个方法栈，每个栈都有一个栈顶的栈帧，说明这是<strong>正在执行</strong>的方法， 在此刻是一定不需要被回收的！<br>因此选取了2种栈的栈顶作为GCRoot选取位置。</p><p>而方法区中的对象一般不会被释放，长期持有，因此方法区中的静态引用对象、常量引用对象也是稳定能被使用的。</p><h3><span id="parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma">ParNew年轻代收集时，需要遍历CMS老年代的所有GCROOT吗？</span><a href="#parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma" class="header-anchor">#</a></h3><p>CMS是老年代的收集器， 经常要和年轻代收集器例如ParDoNew配合。（因此上面4个阶段都是处理老年代回收的，年轻代内存占用小，不需要那么麻烦）<br>那么当ParNew年轻代回收时，是否也要把老年代的所有GCROOT都算上？后面全部遍历的话，时间是不是太久了？</p><p>因此才有了<strong>卡表</strong>的出现！<br>卡表作为一个比特位的集合，每一个比特位可以用来表示年老代的某一区域中的所有对象是否持有新生代对象的引用。<br>这样新生代在GC时，可以先扫描卡表，只有卡表的标记位为1时，才需要扫描给定区域的年老代对象。而卡表位为0的所在区域的年老代对象，一定不包含有对新生代的引用，从而提高了年轻代的回收效率！</p><h2><span id="cms-jie-duan-2-bing-fa-biao-ji">CMS阶段2：并发标记</span><a href="#cms-jie-duan-2-bing-fa-biao-ji" class="header-anchor">#</a></h2><p>这时候不会做stopWorld。标记线程和工作线程同时进行。</p><h3><span id="bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de">并发标记用了怎样的算法去标记的？</span><a href="#bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de" class="header-anchor">#</a></h3><p>当通过gcRoot做并发标记的时候，是一种bfs搜索。<br>有一种三色标记法可以作为参考：</p><ul><li>白色：还没有搜索过的对象（白色对象会被当成垃圾对象）</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象（不会当成垃圾对象，不会被GC）</li></ul><ol><li>默认起始是白色节点。</li><li>是每次标记当前搜索节点的引用节点（类似于相邻点）为灰色，入队列。</li><li>当相邻点全部入队列完成，则把当前搜索节点置黑色。然后根据队列取队头继续处理灰色节点</li></ol><p>是不是和数据结构的bfs非常类似？</p><h3><span id="bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng">并发标记时如何记录引用变更？</span><a href="#bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng" class="header-anchor">#</a></h3><p>对于CMS在并发标记时的引用变更，书上没有细讲，只是一笔带过，个人认为错失了许多精华。<br>有些类似的概念确实有在G1收集器里简单阐述，但是很难让人马上和CMS中对应起来。个人认为应该在CMS的章节就提前给出。<br>下面以我自己的理解，给出对CMS并发标记过程的理解。</p><h3><span id="shi-me-shi-kua-dai-yin-yong">什么是跨代引用？</span><a href="#shi-me-shi-kua-dai-yin-yong" class="header-anchor">#</a></h3><p>首先基于上面提到的三色标记，给出跨代引用问题的例子和解释。<br>假设此时正处于并发标记中，且正好在bfs处理A这个节点。<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652881948481607802.png" alt="image.png"><br>这时取消了A对B的引用，以及B对C的引用，同时新增了A对C的引用，变成如图所示：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652881964705631549.png" alt="image.png"><br>那么当继续搜索入队的B时，将无法再走到C，C永远被标记为白色，就会出现严重的后果：误杀了C，从而导致A对C调用时报错！<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882075127270117.png" alt="image.png"></p><h3><span id="ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang">如何避免跨代引用，保障并发标记安全（写屏障</span><a href="#ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang" class="header-anchor">#</a></h3><p>CMS引入了一个叫“写屏障”的东西，写屏障工作示意如下：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882482680209447.png" alt="image.png"><br>而标记栈就会在后面的“重新标记”阶段用上。</p><h2><span id="cms-jie-duan-3-chong-xin-biao-ji">CMS阶段3：重新标记</span><a href="#cms-jie-duan-3-chong-xin-biao-ji" class="header-anchor">#</a></h2><p>前面的写屏障为我们把为标记却被新增引用的对象放入了栈中。<br>此时会进入StopWorld，我们可以从栈中取出标记对象进行“重新标记”了。<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882580296867154.png" alt="image.png"></p><h2><span id="cms-jie-duan-4-bing-fa-qing-chu">CMS阶段4：并发清除</span><a href="#cms-jie-duan-4-bing-fa-qing-chu" class="header-anchor">#</a></h2><p>最后清除的时候，选用了“标记-清除”算法，来进行回收和处理。<br>同时采用并发机制，避免影响了工作线程。<br>“标记-清除”算法的示意图如下：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652883305646281243.png" alt="image.png"></p><h3><span id="wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa">为什么是要用“标记-清除”这么缺点大的方法？</span><a href="#wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa" class="header-anchor">#</a></h3><p>因为老年代算法，要么是标记-整理，要么是标记-清除<br><strong>而标记-整理算法是无法和工作线程并发执行的</strong><br>所以才选择标记-清除，这也导致了碎片带来的隐患</p><h3><span id="cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang">CMS如何解决标记-清除后碎片过多，无法放入新对象的情况？</span><a href="#cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang" class="header-anchor">#</a></h3><p>当因为碎片过多，无法放入新对象时，会触发fullGC，此时会做1次内存碎片的合并（整理）操作</p><p>还提供了一个参数，设置多少次非合并的fullGC时，可做一次碎片的集中合并和整理。</p><h3><span id="bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban">并发回收过程中，如果工作线程突然生成大量新垃圾，导致内存不足怎么办？</span><a href="#bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban" class="header-anchor">#</a></h3><p>因为并发回收时工作线程还在运行，可能产生大量的对象，导致老年代被填满。<br>这时候CMS会触发一个“Concurrent Mod Failure”机制，并紧急替换为SerialOld收集进行stopWorld回收。<br>因此，<strong>CMS可能存在临时退化为SerialOld的可能</strong></p><h1><span id="hun-he-shi-yong-shou-ji-qi-cms-parnew">混合使用收集器（CMS+parNew)</span><a href="#hun-he-shi-yong-shou-ji-qi-cms-parnew" class="header-anchor">#</a></h1><p>G1收集器出现之前， 都是老年代和年轻代一起使用， 例如CMS+parNew的组合</p><h2><span id="q-fullgc-he-monorgc-fen-bie-fa-sheng-zai-lao-nian-dai-qu-huan-shi-xin-sheng-dai-qu">Q： fullGC和monorGC分别发生在老年代区还是新生代区？</span><a href="#q-fullgc-he-monorgc-fen-bie-fa-sheng-zai-lao-nian-dai-qu-huan-shi-xin-sheng-dai-qu" class="header-anchor">#</a></h2><p>A:</p><p>fullGC只会发生在老年代区。 会用上CMS那堆很复杂的操作</p><p>相反，minorGC一般发送在新生代区，直接用parNew那种复制算法，很快。</p><h2><span id="q-xin-sheng-dui-xiang-shi-me-shi-hou-ke-yi-chang-shi-jin-ru-lao-nian-dai">Q: 新生对象什么时候可以尝试进入老年代？</span><a href="#q-xin-sheng-dui-xiang-shi-me-shi-hou-ke-yi-chang-shi-jin-ru-lao-nian-dai" class="header-anchor">#</a></h2><ol><li><p>发生minorGC后， E区和survivor区都放不下了</p></li><li><p>在survivor区待的时间过长，gc分代年龄超过阈值</p></li><li><p>该GC分代年龄对象总和大于等于s区的一半</p></li><li><p>新生对象的大小大于某个阈值</p></li></ol><h2><span id="q-eden-nian-qing-dai-qu-he-survivor-qu-de-bi-li-wei-shi-me-shi-8-bi-1-bi-1">Q: Eden年轻代区和survivor区的比例为什么是8比1比1</span><a href="#q-eden-nian-qing-dai-qu-he-survivor-qu-de-bi-li-wei-shi-me-shi-8-bi-1-bi-1" class="header-anchor">#</a></h2><p>A:</p><p>正常预留10%内存空间， 大于90%进行minorGC<br>但为了复制算法需要， 得有这10%的复制</p><p>且有-XX:SurvivorRatio=8 这个参数值可以修改</p><h2><span id="q-jiang-yi-xia-lao-nian-dai-de-dan-bao-ce-lue-shi-zuo-shi-me-de">Q:  讲一下老年代的担保策略是做什么的？</span><a href="#q-jiang-yi-xia-lao-nian-dai-de-dan-bao-ce-lue-shi-zuo-shi-me-de" class="header-anchor">#</a></h2><p>用于确认此时到底是做minorGC还是做fullGc。</p><ol><li>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</li><li>如果这个条件成立，那么Minor GC可以确保是安全的。</li><li>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</li><li>如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</li><li>如果大于平均大小，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，有可能把老年代搞满（这时候还没有fullGC！）；</li><li>如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC即全量GC，而不是minor小gc。</li></ol><p>换言之， 要么选择minorGc，要么选择fullGc， 感觉有风险时，就fullGc。</p><h2><span id="xin-sheng-dai-lao-nian-dai-de-jiao-hu-liu-cheng">新生代、老年代的交互流程：</span><a href="#xin-sheng-dai-lao-nian-dai-de-jiao-hu-liu-cheng" class="header-anchor">#</a></h2><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1660746972644.png" alt="1660746972644"></p><h1><span id="g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi">G1收集器（回收概念发生诸多变革，目前最先进收集器）</span><a href="#g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652884348846944605.png" alt="image.png"></p><p>G1收集器，书上感觉并没有讲得特别深，很多概念、区别都没讲好，个人认为是种遗憾，因此我在透彻学习G1之前，我也只能简单写写了。</p><h2><span id="g1-xiang-bi-cms-de-chong-da-sheng-ji-dian">G1相比CMS的重大升级点：</span><a href="#g1-xiang-bi-cms-de-chong-da-sheng-ji-dian" class="header-anchor">#</a></h2><ol><li><strong>回收范围不同</strong>。 CMS是老年代收集器，必须和parNew等结合使用。  G1则可以同时管理老年代和年轻代。</li><li><strong>停顿目标不同</strong>。 CMS会让停顿时间尽可能小， G1则建立了可预测的时间模型。</li><li><strong>清理方式不同</strong>。 CMS是标记-清除，  G1是标记-整理，碎片大大减少。</li><li><strong>G1支持筛选回收</strong> G1可以根据每个region的价值进行回收，CMS则不行。</li><li><strong>并发标记后的最终标记处理方式不同</strong><br>这个标记方式的区别讲述起来有点抽象，简而言之就是：</li></ol><ul><li>CMS是希望记录所有新增的引用，并重新做好多次BFS，保证没有疏漏，代价非常大。</li><li>G1则是只更新o = null这种删除引用的情况。对于新增的引用，直接认为那个对象不需要杀。<br>换句话说，<strong>CMS更严谨，做细致的重新检查。 而G1为了性能，会漏掉一些本该被回收的对象，但是无关大雅，大不了就下次再回收</strong>。</li></ul><h2><span id="g1-li-de-region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma">G1里的region之间都要通过BFS遍历吗？</span><a href="#g1-li-de-region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma" class="header-anchor">#</a></h2><p>这个问题，和之前CMS中回收年轻代时， 是否要走一遍全量的老年代是一个道理。</p><p>G1里用的是一个RememberSet来避免全region扫描的。<br>每个G1的region都有一个<strong>记忆集(Rset)</strong><br>记忆集会记录下当前这个region中的对象被哪些对象所引用。<br>例如，region2中的两个对象分别被region1中的对象和region3中的对象所引用，那么，region2的记忆集记录的就是region1和region3中的引用region2的对象的引用。</p><p>这样一来在回收region2的时候，就不用扫描全部的region了，只需要访问记忆集，就知道当前region2里面的对象被哪些对象所引用，判断其是不是存活对象。</p><p><strong>简单来说，就是标记我这个region被哪些region引用，简化扫描，避免不必要的检索。</strong></p><hr><p>但是书上提到了一句话（P85)：</p><blockquote><blockquote><p>“通过cardTable卡表把相关引用信息记录到被引用对象所属的region的rememberedSet之中”</p></blockquote></blockquote><p>这里我就点没看懂，卡表不是老年代对年轻代的引用么，为什么G1里也有？不是用了记忆集吗？不解，等以后有解答了，再来修改这里的内容。</p><hr><p>Q: G1里的minorGc、 majorGc、mixedGc、fullGc的区别？</p><p>A:</p><ul><li>minorGc也就是youngGc。工作流程很简单：线程跑，然后就进行青年代Region的回收，把需要回收的YoungRegion，放入YoungCSet中，在YGC阶段就进行对年轻代CSet中的Region进行回收。因为大部分都是垃圾，且用了复制回收算法，基本只需要较短时间的STW就能完全回收了。 这里不会触发</li><li>MixedGc等于年轻代+部分老年代gc。当老年代垃圾达到一个阀值的时候，会触发，这里就会用到G1里的并发标记、最终标记、筛选回收等操作。但不会针对所有老年代，只筛选需要处理的老年代。</li><li>FullGc，等于整个堆空间的清理。 当新对象进入老年代时空间不足， G1便会触发担保机制，执行一次STW（stopWorld)式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。 注意这时候不会用到并发之类的，直接暂停了。</li></ul><h1><span id="wan-zheng-da-tu">完整大图</span><a href="#wan-zheng-da-tu" class="header-anchor">#</a></h1><p>关于垃圾收集，书上倾向于先将一些基本概念或者基本回收思路，再讲发展流程，同时对G1缺少更细致的解释，这就容易混杂起来，导致垃圾收集器的进化那一章节看得很迷。</p><p>后面找到了一本书，叫做《The Garbage Collection Handbook》，已经收藏，有时间的话可以看看，据说对G1做了非常细致的讲解<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652885621080294993.png" alt="image.png"></p><p>最后送上完整大图：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/5d139636e4b065dc2c6b9a50.png" alt="垃圾收集器大图"></p><h1><span id="qi-ta-wen-ti">其他问题</span><a href="#qi-ta-wen-ti" class="header-anchor">#</a></h1><h2><span id="q-fang-fa-qu-li-de-class-dui-xiang-ji-lei-dui-xiang-shi-me-shi-hou-hui-bei-hui-shou">Q： 方法区里的class对象（即类对象）什么时候会被回收？</span><a href="#q-fang-fa-qu-li-de-class-dui-xiang-ji-lei-dui-xiang-shi-me-shi-hou-hui-bei-hui-shou" class="header-anchor">#</a></h2><p>A： 所有实例都被回收、对应classLoader也被回收、class对象不会再被引用或者反射（这个咋确定？当初书里看到的，没懂）</p><h2><span id="q-shi-me-shi-hou-hui-diao-yong-dui-xiang-de-finalized-fang-fa">Q： 什么时候会调用对象的finalized方法</span><a href="#q-shi-me-shi-hou-hui-diao-yong-dui-xiang-de-finalized-fang-fa" class="header-anchor">#</a></h2><p>A： JVM启动垃圾回收，且该对象要被回收时。</p><p>finalized应该更多是规范吧，很多规范里都要求我们不要自己实现finalized了，毕竟不确定性太大。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> jvm原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,深入理解jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm内存区域原理</title>
      <link href="/2022/05/29/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/"/>
      <url>/2022/05/29/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>重读了一遍《深入理解java虚拟机》， 发现第一遍读“运行时数据区”相关内容的时候，只关注了最简单的概念部分，对于其中的细节部分没有深入探究，觉得那些东西太底层了，没啥用。<br>其实他们背后的原理，和我们平时运行进程时的各种报错息息相关。<br>另外如果能理解运行时数据区，也能够对“代码究竟是如何运行的”有更深的理解。</p><p><strong>看来经典书籍要多读多总结，是有道理的。</strong><br>于是在阅读这个章节时，针对每个结构，思考了非常多的问题，提出了很多QA，方便进行深度的思考和学习。</p> <div class="toc"><!-- toc --><ul><li><a href="#jvm-quan-ju-jie-gou">jvm全局结构</a></li><li><a href="#java-dui">java堆</a><ul><li><a href="#q-dui-shi-xian-cheng-zhi-jian-gong-yong-de-dan-zhe-yang-hui-dao-zhi-pin-fan-fa-sheng-chong-tu-shi-fou-yao-kao-lu-bing-fa-wen-ti-zen-me-ban">Q: 堆是线程之间共用的，但这样会导致频繁发生冲突，是否要考虑并发问题？怎么办？</a></li><li><a href="#q-dan-shi-ru-guo-qia-qiao-duo-ge-xian-cheng-zai-shi-tu-jing-zheng-tong-yi-ge-tlab-yu-liu-kong-jian-shi-ji-du-zai-shi-tu-kuo-rong-fa-sheng-chong-tu-zen-me-ban">Q: 但是如果恰巧多个线程在试图竞争同一个TLAB预留空间时（即都在试图扩容），发生冲突怎么办？</a></li><li><a href="#q-fen-pei-de-shi-hou-zai-tlab-qu-yu-li-zen-me-zhi-dao-fang-zai-na-ge-wei-zhi-ni">Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？</a></li></ul></li><li><a href="#cheng-xu-ji-shu-qi">程序计数器</a><ul><li><a href="#q-pc-ji-shu-qi-shi-zheng-ge-jvm-gong-you-de-ma">Q:PC计数器是整个jvm共有的吗？</a></li><li><a href="#q-pc-ji-shu-qi-you-sha-yong-na-ru-guo-mei-you-pc-ji-cun-qi-ni-wo-bu-shi-ye-neng-yi-tiao-tiao-zhi-xing-yu-dao-return-zhi-ling-fan-hui-dui-ying-di-zhi-ji-ke-xu-yao-pc-ji-cun-qi-zuo-sha">Q:PC计数器有啥用？ 那如果没有PC寄存器呢？ 我不是也能一条条执行，遇到return指令，返回对应地址即可，需要PC寄存器做啥？</a></li><li><a href="#q-wei-shi-me-native-fang-fa-de-cheng-xu-ji-shu-qi-wei-0-undefine-ru-guo-fa-sheng-xian-cheng-qie-huan-zen-me-ban">Q:为什么native方法的程序计数器为0（undefine）？如果发生线程切换，怎么办？</a></li><li><a href="#q-pc-ji-shu-qi-li-cun-de-dao-di-shi-sha-shi-zhi-ling-di-zhi-ma">Q: PC计数器里存的到底是啥？是指令地址吗？</a></li><li><a href="#q-na-me-zen-me-zhi-dao-shi-ji-de-zi-jie-ma-wei-zhi">Q: 那么怎么知道实际的字节码位置？</a></li></ul></li><li><a href="#xu-ni-ji-zhan-qu-yu">虚拟机栈区域</a><ul><li><a href="#xian-cheng-zhan-zheng">线程栈帧</a><ul><li><a href="#q-shi-me-shi-zhan-zheng">Q： 什么是栈帧？</a></li><li><a href="#q-zhan-zheng-li-bao-han-shi-me">Q： 栈帧里包含什么？</a></li><li><a href="#q-zhan-zheng-de-da-xiao-shi-me-shi-hou-que-ding">Q: 栈帧的大小什么时候确定？</a></li></ul></li><li><a href="#cao-zuo-shu-zhan">操作数栈</a><ul><li><a href="#q-shi-me-shi-cao-zuo-shu-zhan">Q： 什么是操作数栈</a></li><li><a href="#q-wei-shi-me-yi-ding-yao-you-cao-zuo-shu-zhan">Q: 为什么一定要有操作数栈？</a></li></ul></li><li><a href="#ju-bu-bian-liang-biao">局部变量表</a><ul><li><a href="#q-shi-me-shi-ju-bu-bian-liang-biao">Q: 什么是局部变量表？</a></li><li><a href="#q-ju-bu-bian-liang-de-cao-you-shi-shi-me">Q: 局部变量的槽又是什么？</a></li><li><a href="#q-ju-bu-bian-liang-biao-li-de-returnaddress-he-zhan-zheng-li-de-fan-hui-di-zhi-returnaddress-you-sha-qu-bie">Q: 局部变量表里的returnAddress和栈帧里的返回地址returnAddress有啥区别？</a></li><li><a href="#q-ju-bu-bian-liang-biao-de-slot-ke-yi-bei-fu-gai-ma-zhe-ge-she-ji-you-shi-me-hao-chu">Q: 局部变量表的slot可以被覆盖吗？这个设计有什么好处</a></li><li><a href="#q-she-zhi-null-zhi-jiu-yi-ding-hui-fu-gai-slot-ma">Q: 设置null值，就一定会覆盖slot吗？</a></li><li><a href="#q-wei-shi-me-java-zhong-ju-bu-bian-liang-mei-you-mo-ren-chu-shi">Q:为什么java中局部变量没有默认初始？</a></li><li><a href="#q-zhan-zheng-zhi-jian-ke-neng-cun-zai-gong-xiang-bian-liang-biao-de-qing-kuang-ma">Q: 栈帧之间可能存在共享变量表的情况吗？</a></li></ul></li><li><a href="#dong-tai-lian-jie">动态链接</a><ul><li><a href="#q-zhan-zheng-li-de-dong-tai-lian-jie-you-shi-sha">Q : 栈帧里的动态链接又是啥？</a></li></ul></li><li><a href="#fan-hui-di-zhi">返回地址</a><ul><li><a href="#q-ji-ran-you-pc-ji-cun-qi-zhan-zheng-li-de-fan-hui-di-zhi-de-zuo-yong-shi-shi-me">Q: 既然有PC寄存器，栈帧里的返回地址的作用是什么？</a></li><li><a href="#q-zhan-zheng-zhong-de-fang-fa-tui-chu-shi-hui-hong-fa-na-xie-dong-zuo">Q: 栈帧中的方法退出时，会触发哪些动作？</a></li><li><a href="#q-zhan-zheng-chu-liao-shang-mian-ti-dao-de-ji-ge-huan-you-qi-ta-de-xin-xi-ma">Q: 栈帧除了上面提到的几个，还有其他的信息吗？</a></li></ul></li></ul></li><li><a href="#fang-fa-qu">方法区</a><ul><li><a href="#q-fang-fa-qu-li-cun-de-shi-class-zi-jie-ma-ma">Q: 方法区里存的是class字节码吗？</a></li><li><a href="#q-yuan-kong-jian-yu-yong-jiu-dai-dao-di-shi-zen-me-hui-shi">Q: 元空间与永久代到底是怎么回事？</a></li><li><a href="#q-wei-shi-me-yao-ti-huan-yong-jiu-dai">Q: 为什么要替换永久代</a></li></ul></li><li><a href="#zui-hou-de-gan-xiang">最后的感想</a></li></ul><!-- tocstop --></div> <p>[toc]</p><hr><h1><span id="jvm-quan-ju-jie-gou">jvm全局结构</span><a href="#jvm-quan-ju-jie-gou" class="header-anchor">#</a></h1><p>首先是一张经典的jvm运行时内存区域划分的图，我自己画了一张：</p><p><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1653815416671.png" alt="1653815416671"></p><hr><p>Q: 存在多个线程时，刚才提到的5个区域是怎么分布的？<br>A:<br>每个线程，都有自己独立的虚拟机栈、独立的程序计数器PC。</p><p>而方法区和堆是线程们共用的。</p><hr><h1><span id="java-dui">java堆</span><a href="#java-dui" class="header-anchor">#</a></h1><p>java堆的内容比较多，这里不探究对象分配的原理，后面会补充新的文章。这里只讨论堆的一些其他细节问题。</p><hr><h2><span id="q-dui-shi-xian-cheng-zhi-jian-gong-yong-de-dan-zhe-yang-hui-dao-zhi-pin-fan-fa-sheng-chong-tu-shi-fou-yao-kao-lu-bing-fa-wen-ti-zen-me-ban">Q: 堆是线程之间共用的，但这样会导致频繁发生冲突，是否要考虑并发问题？怎么办？</span><a href="#q-dui-shi-xian-cheng-zhi-jian-gong-yong-de-dan-zhe-yang-hui-dao-zhi-pin-fan-fa-sheng-chong-tu-shi-fou-yao-kao-lu-bing-fa-wen-ti-zen-me-ban" class="header-anchor">#</a></h2><p>A:<br>线程分配堆空间时，会先根据TLAB进行独立分配。</p><blockquote><blockquote><p>TLAB ——Thread Local Allocation Buffer， 中文名为线程本地分配缓冲区。<br>启用了 TLAB 之后(-XX:+UseTLAB, 默认是开启的)，JVM 会针对每一个线程在 Java 堆中预留一个内存区域。<br>一旦某个区域确定划分给某个线程，之后<strong>该线程需要分配内存的时候，会优先在这片区域中申请</strong>。这个区域针对分配内存这个动作而言是该线程私有的，因此在分配的时候不用进行加锁等保护性的操作</p></blockquote></blockquote><hr><h2><span id="q-dan-shi-ru-guo-qia-qiao-duo-ge-xian-cheng-zai-shi-tu-jing-zheng-tong-yi-ge-tlab-yu-liu-kong-jian-shi-ji-du-zai-shi-tu-kuo-rong-fa-sheng-chong-tu-zen-me-ban">Q: 但是如果恰巧多个线程在试图竞争同一个TLAB预留空间时（即都在试图扩容），发生冲突怎么办？</span><a href="#q-dan-shi-ru-guo-qia-qiao-duo-ge-xian-cheng-zai-shi-tu-jing-zheng-tong-yi-ge-tlab-yu-liu-kong-jian-shi-ji-du-zai-shi-tu-kuo-rong-fa-sheng-chong-tu-zen-me-ban" class="header-anchor">#</a></h2><p>A:<br>在预留这个动作发生的时候，需要进行加锁或者采用** CAS（compareAndSet) **等操作进行保护，避免多个线程预留同一个区域</p><hr><h2><span id="q-fen-pei-de-shi-hou-zai-tlab-qu-yu-li-zen-me-zhi-dao-fang-zai-na-ge-wei-zhi-ni">Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？</span><a href="#q-fen-pei-de-shi-hou-zai-tlab-qu-yu-li-zen-me-zhi-dao-fang-zai-na-ge-wei-zhi-ni" class="header-anchor">#</a></h2><p>A:<br>具体的分配内存有两种情况（和垃圾回收机制有关）</p><ol><li>第一种情况是内存空间绝对规整。（对应使用回收-整理/复制算法的垃圾回收区）</li><li>第二种情况是内存空间是不连续的。（对应使用回收-清除算法的垃圾回收区）</li></ol><p>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</p><p>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</p><h1><span id="cheng-xu-ji-shu-qi">程序计数器</span><a href="#cheng-xu-ji-shu-qi" class="header-anchor">#</a></h1><h2><span id="q-pc-ji-shu-qi-shi-zheng-ge-jvm-gong-you-de-ma">Q:PC计数器是整个jvm共有的吗？</span><a href="#q-pc-ji-shu-qi-shi-zheng-ge-jvm-gong-you-de-ma" class="header-anchor">#</a></h2><p>A:<br>不是的，是每个线程各自有一个， 而且是java自己定义的线程PC， 和CPU里的PC寄存器不同。</p><hr><h2><span id="q-pc-ji-shu-qi-you-sha-yong-na-ru-guo-mei-you-pc-ji-cun-qi-ni-wo-bu-shi-ye-neng-yi-tiao-tiao-zhi-xing-yu-dao-return-zhi-ling-fan-hui-dui-ying-di-zhi-ji-ke-xu-yao-pc-ji-cun-qi-zuo-sha">Q:PC计数器有啥用？ 那如果没有PC寄存器呢？ 我不是也能一条条执行，遇到return指令，返回对应地址即可，需要PC寄存器做啥？</span><a href="#q-pc-ji-shu-qi-you-sha-yong-na-ru-guo-mei-you-pc-ji-cun-qi-ni-wo-bu-shi-ye-neng-yi-tiao-tiao-zhi-xing-yu-dao-return-zhi-ling-fan-hui-dui-ying-di-zhi-ji-ke-xu-yao-pc-ji-cun-qi-zuo-sha" class="header-anchor">#</a></h2><p>A: PC寄存器的作用在于多线程切换的时候，能找到每个线程执行的位置，所以它是线程私有的一个寄存器，知道当前运行到哪了。如果没有，一旦随机切换就不知道咋办了。你总需要一个地方存储这个线程当前执行情况，但又要保持独立性，所以不可能存到其他线程的空间里。</p><hr><h2><span id="q-wei-shi-me-native-fang-fa-de-cheng-xu-ji-shu-qi-wei-0-undefine-ru-guo-fa-sheng-xian-cheng-qie-huan-zen-me-ban">Q:为什么native方法的程序计数器为0（undefine）？如果发生线程切换，怎么办？</span><a href="#q-wei-shi-me-native-fang-fa-de-cheng-xu-ji-shu-qi-wei-0-undefine-ru-guo-fa-sheng-xian-cheng-qie-huan-zen-me-ban" class="header-anchor">#</a></h2><p>A:<br>注意，jvm内存结构里的PC计数器是jvm自己定义的“字节码指令”执行寄存器。<br>对于native方法，并不在字节码的范围，不指向方法区里的任何指令位置。</p><p>因此native方法其实不是由jvm管理的，如果线程切换，他执行到哪边，取决于OS的底层机器码计数器实现。</p><blockquote><blockquote><p>以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。</p></blockquote></blockquote><hr><h2><span id="q-pc-ji-shu-qi-li-cun-de-dao-di-shi-sha-shi-zhi-ling-di-zhi-ma">Q: PC计数器里存的到底是啥？是指令地址吗？</span><a href="#q-pc-ji-shu-qi-li-cun-de-dao-di-shi-sha-shi-zhi-ling-di-zhi-ma" class="header-anchor">#</a></h2><p>A:<br>错误！ 存的不是地址，而是这个方法的字节码偏移。例如0、1、5、6这种。<br><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800419071211329.png" alt="image.png"></p><hr><h2><span id="q-na-me-zen-me-zhi-dao-shi-ji-de-zi-jie-ma-wei-zhi">Q: 那么怎么知道实际的字节码位置？</span><a href="#q-na-me-zen-me-zhi-dao-shi-ji-de-zi-jie-ma-wei-zhi" class="header-anchor">#</a></h2><p>A: 这个就要结合下文提到的栈帧中的动态链接，来联合计算实际字节码位置了。</p><h1><span id="xu-ni-ji-zhan-qu-yu">虚拟机栈区域</span><a href="#xu-ni-ji-zhan-qu-yu" class="header-anchor">#</a></h1><hr><h2><span id="xian-cheng-zhan-zheng">线程栈帧</span><a href="#xian-cheng-zhan-zheng" class="header-anchor">#</a></h2><h3><span id="q-shi-me-shi-zhan-zheng">Q： 什么是栈帧？</span><a href="#q-shi-me-shi-zhan-zheng" class="header-anchor">#</a></h3><p>A： 每个线程有一个自己的栈帧，然后运行到每个方法时，每个方法中都会可以理解为是摄影里的一帧。<br><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800601102172178.png" alt="image.png"></p><hr><h3><span id="q-zhan-zheng-li-bao-han-shi-me">Q： 栈帧里包含什么？</span><a href="#q-zhan-zheng-li-bao-han-shi-me" class="header-anchor">#</a></h3><p>A：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法返回地址</li></ul><p>其实与上面这4样配合的，还有个上文提到的“程序计数器”，才共同实现了jvm指令的执行。</p><hr><h3><span id="q-zhan-zheng-de-da-xiao-shi-me-shi-hou-que-ding">Q: 栈帧的大小什么时候确定？</span><a href="#q-zhan-zheng-de-da-xiao-shi-me-shi-hou-que-ding" class="header-anchor">#</a></h3><p>A：<br>在编译程序代码的时候.<br>注意， 图例提到的栈大小，并不是指线程堆栈的最大深度，<br>而是指“操作数栈”的最大深度。（注意这个深度存在类文件字节码中对应方法的属性表中）<br><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800735895914907.png" alt="image.png"></p><p>即jvm能够通过分析代码中可能存在多少个变量以及计算空间，来确定局部变量表和最大操作数栈的一个深度。</p><h2><span id="cao-zuo-shu-zhan">操作数栈</span><a href="#cao-zuo-shu-zhan" class="header-anchor">#</a></h2><h3><span id="q-shi-me-shi-cao-zuo-shu-zhan">Q： 什么是操作数栈</span><a href="#q-shi-me-shi-cao-zuo-shu-zhan" class="header-anchor">#</a></h3><p>A：<br>可以理解为jvm做计算时，需要一个临时的寄存器，把需要计算的数据或者传方法的参数放到栈中，然后做计算。<br><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800699980785954.png" alt="image.png"></p><hr><h3><span id="q-wei-shi-me-yi-ding-yao-you-cao-zuo-shu-zhan">Q: 为什么一定要有操作数栈？</span><a href="#q-wei-shi-me-yi-ding-yao-you-cao-zuo-shu-zhan" class="header-anchor">#</a></h3><p>如果要做a+b,我直接从变量表上取a的值和b的值，加起来不就好了？<br>A:<br>那我如果是 a + b<em>c呢，  这个b</em>c的值放哪里？<br>如果是a+b*(c+d)呢？<br>这时候如果你学习过数据结构里栈的应用 ，就会知道 模拟一个计算器，往往需要一个栈。<br>而操作数栈就是这个作用。<br>当你学习jvm指令时，就会看到有专门的指令就是取栈顶或者把值推送到栈顶的指令。<br>这样做加法的时候，也就不用关心变量的地址了，只要你把栈顶的值存好，我直接拿去加就行。</p><hr><h2><span id="ju-bu-bian-liang-biao">局部变量表</span><a href="#ju-bu-bian-liang-biao" class="header-anchor">#</a></h2><h3><span id="q-shi-me-shi-ju-bu-bian-liang-biao">Q: 什么是局部变量表？</span><a href="#q-shi-me-shi-ju-bu-bian-liang-biao" class="header-anchor">#</a></h3><p>A：<br>每个线程所在栈帧都会有一个自己的局部变量表，里面存储方法中使用到的局部变量。<br><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800897811439190.png" alt="image.png"></p><hr><h3><span id="q-ju-bu-bian-liang-de-cao-you-shi-shi-me">Q: 局部变量的槽又是什么？</span><a href="#q-ju-bu-bian-liang-de-cao-you-shi-shi-me" class="header-anchor">#</a></h3><p>A:</p><ul><li>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</li><li>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）</li><li>slot的长度可以随着处理器、操作系统的不同而变化， 不是绝对的32位。<br>jvm概念中说的是”slot一定能存放下1个boolean\byte\int\引用地址\返回地址returnAddress“等不包括long在内的内容。</li><li>如果要访问long，需要做2次局部变量slot的读取，读取n和n+1，不允许单独访问，如果有问题会在字节码校验中报错。</li></ul><hr><h3><span id="q-ju-bu-bian-liang-biao-li-de-returnaddress-he-zhan-zheng-li-de-fan-hui-di-zhi-returnaddress-you-sha-qu-bie">Q: 局部变量表里的returnAddress和栈帧里的返回地址returnAddress有啥区别？</span><a href="#q-ju-bu-bian-liang-biao-li-de-returnaddress-he-zhan-zheng-li-de-fan-hui-di-zhi-returnaddress-you-sha-qu-bie" class="header-anchor">#</a></h3><p>A:<br>局部变量表里的的returnAddress，是老版本jvm用于处理异常跳转的（jsr\jsr_w\ret指令，新版本基本都用code里的异常表来代替），而栈帧里的返回地址，是返回到上一层栈帧的代码调用位置，更新PC计数器用的。</p><hr><h3><span id="q-ju-bu-bian-liang-biao-de-slot-ke-yi-bei-fu-gai-ma-zhe-ge-she-ji-you-shi-me-hao-chu">Q: 局部变量表的slot可以被覆盖吗？这个设计有什么好处</span><a href="#q-ju-bu-bian-liang-biao-de-slot-ke-yi-bei-fu-gai-ma-zhe-ge-she-ji-you-shi-me-hao-chu" class="header-anchor">#</a></h3><p>A:</p><ul><li>可以减少局部变量表的空间，通过分析每个局部变量的使用生命周期，在某变量不再被使用后，让其他变量可以覆盖这个槽的位置。</li><li>另一方面，覆盖的机制，可以将一些局部变量上已经不使用的大对象解除引用，例如对一些大的变量做=null的操作，那么可以尽早进行垃圾回收（因为栈帧的局部变量表里的每个slot都是一个gcRoot）</li></ul><hr><h3><span id="q-she-zhi-null-zhi-jiu-yi-ding-hui-fu-gai-slot-ma">Q: 设置null值，就一定会覆盖slot吗？</span><a href="#q-she-zhi-null-zhi-jiu-yi-ding-hui-fu-gai-slot-ma" class="header-anchor">#</a></h3><p>A:<br>不一定，有时候JIT编译优化，可能会处理掉这个无用的=null的操作，且能正确处理slot中已经不被使用的变量。<br>按照书里的说法，正好有大对象，然后还停留在局部变量表里的概率是比较低的。不建议那么做了</p><hr><h3><span id="q-wei-shi-me-java-zhong-ju-bu-bian-liang-mei-you-mo-ren-chu-shi">Q:为什么java中局部变量没有默认初始？</span><a href="#q-wei-shi-me-java-zhong-ju-bu-bian-liang-mei-you-mo-ren-chu-shi" class="header-anchor">#</a></h3><p>A:<br>我的理解，局部变量在局部变量表中，而局部变量表是运行时生成的， 而非在堆上生成，因此不会有堆对象创建时的那个默认值赋值操作。 即jvm定义上， 就是局部变量没有初始化前的’准备‘这个阶段的，也就不存在默认赋值的指令行为。</p><p>如果硬要说为什么，如果每个局部变量都复制，肯定会影响执行效率，因此不如不赋值。，所以必须通过赋值指令在运行时给他赋值。（没找到很好的解释，有更好理解的可以帮忙回答一下，其实就是）</p><p>另外如果每个局部变量都有，那可能指令数量就会变多，因为你需要放入很多赋值指令？</p><p>阅读JMM内存模型时的另一个解释：</p><blockquote><blockquote><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性.<br>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来<br>对于全局变量（类对象成员），必须有默认初始化，为了满足多线程环境下的最小安全性。<br>但对于局部变量，不存在被多线程使用，因此一定后面可以拼接一个指令，所以不需要默认初始化的动作。</p></blockquote></blockquote><hr><h3><span id="q-zhan-zheng-zhi-jian-ke-neng-cun-zai-gong-xiang-bian-liang-biao-de-qing-kuang-ma">Q: 栈帧之间可能存在共享变量表的情况吗？</span><a href="#q-zhan-zheng-zhi-jian-ke-neng-cun-zai-gong-xiang-bian-liang-biao-de-qing-kuang-ma" class="header-anchor">#</a></h3><p>即执行多次方法，一个栈上有多个栈帧，每个栈帧都有各自的局部变量表和操作数栈，然后上下层之间共享</p><p>A:<br>可能存在。即上下两个栈帧之间， 可能有操作数栈可以直接操作另一个栈帧局部变量的情况。这样可以避免额外的参数复制传递。<br>什么时候触发？不清楚</p><hr><h2><span id="dong-tai-lian-jie">动态链接</span><a href="#dong-tai-lian-jie" class="header-anchor">#</a></h2><h3><span id="q-zhan-zheng-li-de-dong-tai-lian-jie-you-shi-sha">Q : 栈帧里的动态链接又是啥？</span><a href="#q-zhan-zheng-li-de-dong-tai-lian-jie-you-shi-sha" class="header-anchor">#</a></h3><p>A:<br>首先明确一点， 每一个栈帧，不一定是”动态”链接，但一定会有一个指向常量池中方法的引用。</p><p>为什么栈帧里需要存这个指向方法的引用？</p><p>首先，当你进入一个方法，准备生成一个栈帧，放到线程上时，你需要知道你这个代码执行的是什么代码，才能进行后面的操作。</p><p>如果是构造方法、final方法，则会编译器进行静态链接。<br>如果是虚方法，则会进行动态链接，运行期只是从类对象中，拿到了一个符号引用，</p><p>但是这个引用指向哪个方法？则通过下面的过程进行定位和寻找，把符号引用转成实际方法的直接引用。<br><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800987016832820.png" alt="image.png"><br>因此要提供一个引用，指向常量池里的方法。指向后，就能知道程序位置。<br>然后<strong>字节码实际引用位置 + PC计数器偏移</strong>，就能知道当前线程执行到哪个方法的哪一步指令上了。</p><p>（关于动态链接这个名称的由来，是因为“动态分派”的存在，你这个方法位置是不确定的，和实际对象+方法名有关， 所以称为动态链接。）</p><hr><h2><span id="fan-hui-di-zhi">返回地址</span><a href="#fan-hui-di-zhi" class="header-anchor">#</a></h2><h3><span id="q-ji-ran-you-pc-ji-cun-qi-zhan-zheng-li-de-fan-hui-di-zhi-de-zuo-yong-shi-shi-me">Q: 既然有PC寄存器，栈帧里的返回地址的作用是什么？</span><a href="#q-ji-ran-you-pc-ji-cun-qi-zhan-zheng-li-de-fan-hui-di-zhi-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h3><p>A:<br>方法A调用方法B的时候，PC寄存器会跟着移动到B方法去。当B执行完后，要能返回A继续执行，就需要A当时执行到的那条指令的地址。所以，在B的栈帧中保存A当时的指令地址（当时PC寄存器的值），当B执行完后，根据此返回地址跳回A。通过返回地址，从而知道当前线程的上一级应该从PC的第几行偏移开始。</p><p>另外除了正常通过ret指令退出，还可能是出现异常时，如果没有在异常表里被捕捉并处理，也会通过异常完成出口， 使用返回地址返回到上一层。</p><hr><h3><span id="q-zhan-zheng-zhong-de-fang-fa-tui-chu-shi-hui-hong-fa-na-xie-dong-zuo">Q: 栈帧中的方法退出时，会触发哪些动作？</span><a href="#q-zhan-zheng-zhong-de-fang-fa-tui-chu-shi-hui-hong-fa-na-xie-dong-zuo" class="header-anchor">#</a></h3><p>A:</p><ol><li>当前栈帧出栈</li><li>恢复上层方法的局部变量表和操作数栈</li><li>如果有返回值，把返回值压入操作数栈的栈顶（因为马上就要被调用了）</li><li>调整这个线程栈的PC计数器，改成returnAddress对应的那个指令位置地址，然后继续往下调用执行。</li></ol><hr><h3><span id="q-zhan-zheng-chu-liao-shang-mian-ti-dao-de-ji-ge-huan-you-qi-ta-de-xin-xi-ma">Q: 栈帧除了上面提到的几个，还有其他的信息吗？</span><a href="#q-zhan-zheng-chu-liao-shang-mian-ti-dao-de-ji-ge-huan-you-qi-ta-de-xin-xi-ma" class="header-anchor">#</a></h3><p>A:<br>有些支持调试的虚拟机，可能会补充很多调试相关的信息。</p><h1><span id="fang-fa-qu">方法区</span><a href="#fang-fa-qu" class="header-anchor">#</a></h1><h2><span id="q-fang-fa-qu-li-cun-de-shi-class-zi-jie-ma-ma">Q: 方法区里存的是class字节码吗？</span><a href="#q-fang-fa-qu-li-cun-de-shi-class-zi-jie-ma-ma" class="header-anchor">#</a></h2><p>A:<br>不是。经过类的加载、链接、初始化之后， class字节码对于进程来说就没用了。<br>存了以下内容：</p><ul><li>每个类的类型信息：类名、父类类名、修饰符、接口</li><li>字段信息field（域信息）：字段名、字段类型、字段修饰符</li><li>方法信息，包括方法名、类型、参数、修饰符、字节码、一场表<br>如下：</li><li>类的静态变量</li><li>常量池，存储常量<br>注意，符号引用、类引用、实际类名等信息等都是放在常量池中的。</li></ul><hr><h2><span id="q-yuan-kong-jian-yu-yong-jiu-dai-dao-di-shi-zen-me-hui-shi">Q:  元空间与永久代到底是怎么回事？</span><a href="#q-yuan-kong-jian-yu-yong-jiu-dai-dao-di-shi-zen-me-hui-shi" class="header-anchor">#</a></h2><p>A:<br>方法区和“PermGen space”又有着本质的区别。<br><strong>前者是 JVM 的规范，而后者则是 JVM 规范的一种实现</strong><br>并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p><p><strong>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小</strong><br>-XX:MetaspaceSize和-XX:MaxMetaspaceSize</p><hr><h2><span id="q-wei-shi-me-yao-ti-huan-yong-jiu-dai">Q: 为什么要替换永久代</span><a href="#q-wei-shi-me-yao-ti-huan-yong-jiu-dai" class="header-anchor">#</a></h2><p>A:<br>替换永久代的其他原因：</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li></ol><hr><h1><span id="zui-hou-de-gan-xiang">最后的感想</span><a href="#zui-hou-de-gan-xiang" class="header-anchor">#</a></h1><p>好累，终于写完了，感觉能看到最后的人不会太多，但一通详细地分析和解决中间发现的问题，还是收获了不少。</p><p>关于jvm运行时数据区，最重要的不是去死记硬背，而是试图在脑中构建一个指令运行的逻辑流程。</p><p>且对于很多没有学习过计算机底层原理（例如CSAPP这本书） 的人来说， 是很难接触到计算机是如何执行机器码指令的。<br>而java虚拟机栈可以更好理解 指令是如何运行的（虽然这不是机器码，而是jvm字节码）。<br>但是通过运行时数据区的各种行为和概念， 我们可以快速对应到java中常见的各种操作。<br>这对于很多入门时直奔删减改查的同学来说， 是不可多得的学习底层的机会。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> jvm原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,深入理解jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决失眠的科学疗法</title>
      <link href="/2022/05/06/%E9%9A%8F%E7%AC%94/sleep/"/>
      <url>/2022/05/06/%E9%9A%8F%E7%AC%94/sleep/</url>
      
        <content type="html"><![CDATA[<h1><span id="shui-mian-xian-zhi-fa">睡眠限制法</span><a href="#shui-mian-xian-zhi-fa" class="header-anchor">#</a></h1><ul><li><p>首要目标： 增加睡眠时间/卧床时间的占比，建立床=睡眠的潜意识。</p></li><li><p>主要方式： 在无法显著增加睡眠时间的情况下，减少卧床时间。</p></li><li><p>具体措施：</p><ol><li>根据之前往期的入睡统计，安排严格的上床和入睡。例如晚上12点睡，早上6点30起。</li><li>困了就上床，上床后不要玩手机，避免增加无效卧床时间。</li><li>如果在床上不困，就立刻起床，避免增加无效的卧床时间。</li><li>减少午睡甚至不午睡，将困意集中到晚上的时间。</li></ol></li></ul><h1><span id="ru-shui-fen-wei-de-gou-jian">入睡氛围的构建</span><a href="#ru-shui-fen-wei-de-gou-jian" class="header-anchor">#</a></h1><ol><li>睡前不要做需要耗费脑子导致精神集中无法放松的事情， 例如做算法题、高强度学习等。</li><li>提前1h洗澡、洗头，避免上床前才洗。</li><li>手机的新闻、游戏日常任务尽量白天能刷就刷，睡前告诉自己都已经刷过了，不需要再刷了。（可以将自己需要刷的东西列一个清单，睡前看一下自己是不是白天都刷过了）</li></ol><h1><span id="ru-he-chu-li-shui-mian-shi-de-jiao-lu">如何处理睡眠时的焦虑</span><a href="#ru-he-chu-li-shui-mian-shi-de-jiao-lu" class="header-anchor">#</a></h1><ol><li>睡少了 并不等于 第二天会完蛋。大部分人不会从事过于高精密的工作。</li><li>如果有睡眠外的焦虑， 尝试在睡前安排一定的”焦虑时间“，让自己充分将焦虑的想法念出来或者写出来，这样上床后如果还焦虑，可以告诉自己”刚才都已经焦虑过了，也写出来了，现在想也就没意义了“</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决失眠的科学疗法</title>
      <link href="/2022/05/06/%E9%9A%8F%E7%AC%94/%E5%A4%B1%E7%9C%A0%E7%96%97%E6%B3%95/"/>
      <url>/2022/05/06/%E9%9A%8F%E7%AC%94/%E5%A4%B1%E7%9C%A0%E7%96%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="shui-mian-xian-zhi-fa">睡眠限制法</span><a href="#shui-mian-xian-zhi-fa" class="header-anchor">#</a></h1><ul><li><p>首要目标： 增加睡眠时间/卧床时间的占比，建立床=睡眠的潜意识。</p></li><li><p>主要方式： 在无法显著增加睡眠时间的情况下，减少卧床时间。</p></li><li><p>具体措施：</p><ol><li>根据之前往期的入睡统计，安排严格的上床和入睡。例如晚上12点睡，早上6点30起。</li><li>困了就上床，上床后不要玩手机，避免增加无效卧床时间。</li><li>如果在床上不困，就立刻起床，避免增加无效的卧床时间。</li><li>减少午睡甚至不午睡，将困意集中到晚上的时间。</li></ol></li></ul><h1><span id="ru-shui-fen-wei-de-gou-jian">入睡氛围的构建</span><a href="#ru-shui-fen-wei-de-gou-jian" class="header-anchor">#</a></h1><ol><li>睡前不要做需要耗费脑子导致精神集中无法放松的事情， 例如做算法题、高强度学习等。</li><li>提前1h洗澡、洗头，避免上床前才洗。</li><li>手机的新闻、游戏日常任务尽量白天能刷就刷，睡前告诉自己都已经刷过了，不需要再刷了。（可以将自己需要刷的东西列一个清单，睡前看一下自己是不是白天都刷过了）</li></ol><h1><span id="ru-he-chu-li-shui-mian-shi-de-jiao-lu">如何处理睡眠时的焦虑</span><a href="#ru-he-chu-li-shui-mian-shi-de-jiao-lu" class="header-anchor">#</a></h1><ol><li>睡少了 并不等于 第二天会完蛋。大部分人不会从事过于高精密的工作。</li><li>如果有睡眠外的焦虑， 尝试在睡前安排一定的”焦虑时间“，让自己充分将焦虑的想法念出来或者写出来，这样上床后如果还焦虑，可以告诉自己”刚才都已经焦虑过了，也写出来了，现在想也就没意义了“</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>心理成长感悟</title>
      <link href="/2022/05/04/%E9%9A%8F%E7%AC%94/heart/"/>
      <url>/2022/05/04/%E9%9A%8F%E7%AC%94/heart/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</a></li><li><a href="#ji-hua-he-xing-dong">计划和行动</a></li><li><a href="#biao-da-nei-xin">表达内心</a></li><li><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</a></li><li><a href="#zuo-jue-ding-zuo-jue-ze">做决定/做抉择</a></li><li><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h2><span id="zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</span><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou" class="header-anchor">#</a></h2><ul><li><p>有时候，他人对你的疑问，例如“天气这么好，你怎么没出去玩呢？” ，<strong>也许仅仅只是他寒暄时提出的一个观点而已，并非对你做职责或者命令</strong>。 以此类推， 对于其他的一些疑问，不要过于恶意地揣测或者做过多想象。</p></li><li><p>不要因为身边大部分人做了什么就感到焦虑，他们的行为可以是你的参考，但并非是最适合你的。<strong>你需要清楚自己内心想要的是什么，内心的感受是怎样的，并尊重和理解自己的感受，坚持自己的那份个性</strong>，而不是为了迎合他人去隐瞒自己的喜好、感受或者真实想法。 无论是假期活动还是工作待遇等，都是如此。</p></li><li><p>“我想逃避”也是一种感受， 逃避是一种可以被理解的行为，但可能是一种不合时宜的行为，因为逃避更像是儿童时期做出的避险行为。<strong>自己需要意识到自己当前的行为模式是否是陈旧的</strong>，以及是否应当稍微找起来，尝试做点和儿童时期不一样的事情。</p></li></ul><h2><span id="ji-hua-he-xing-dong">计划和行动</span><a href="#ji-hua-he-xing-dong" class="header-anchor">#</a></h2><ul><li><p><strong>不要通过幻想，来给自己设定过于严苛的计划或者目的</strong>。 后果就是一旦发生阻碍或者完不成，挫败感会很重，以后做计划也会愈发纠结和犹豫。   因此尽量千万不要定“我xx月前必须怎么怎么”、“我必须每天xxx”，这样对意外情况容错性会降低，或者一次没成，后面就可能直接不再考虑 。</p></li><li><p><strong>想要做一件事， 核心不在于计划， 而在于是否开始逐步行动</strong>，这个行动是可以很小的，但只要你开了头，就相当于获取了这件事的入门门槛。 无论是写博客、跑步、学习、刷题，都是如此。不要把时间浪费在纠结上， 与其纠结，还不如先拆分好之后，随便挑一件做。</p><p>对于跑步，应该是“我想跑的时候就跑，这次简单跑个500米试试，并非要周三或者周五，只是想开个头而已”</p><p>例如博客，我想写的时候就写一下， 今天空，正好想做，就做了</p><p>例如去哪个地方，那就先提前做些小的准备，当你准备充分了，自然也就有选择的余地，而不是强行设置期限，导致自己陷入焦虑之中。</p></li><li><p>当很多想做的事情交叉重叠，<strong>先做影响最近的</strong>，例如洗澡、扫地、拖地，再做比较久远影响的。</p></li></ul><h2><span id="biao-da-nei-xin">表达内心</span><a href="#biao-da-nei-xin" class="header-anchor">#</a></h2><ul><li>尽可能真实地表达你的想法或者目的，并付诸以该想法为最首要的行为。以下是解释：</li></ul><ol><li>要避免为了掩盖想法，找别的理由去掩饰**</li></ol><p>例如你想送人笔记本电脑，却总是说不出”我想送你笔记本让你改善你的生活质量“这句话，特地找了  一堆理由，例如”我在公司看到一个便宜的内购“、”我多买了一台笔记本，不要了给你吧“， 却刻意掩埋 了自己的想法。</p><ol start="2"><li><p>要避免因为过分考虑后果，导致对”行为“频繁地做调整，当你试图期望让该‘行为’能适配所有的后果时，你的行为本身就不太符合根本目的了</p><p>例如你要送人一台新的笔记本电脑，却总是考虑被拒绝的后果，于是换成了一台旧电脑并自己装好系统，以准备被拒绝时可以转交给父母使用。   这样会导致收到礼物的对方并不会觉得开心和尊重。</p></li></ol><p><strong>实际上被拒绝后的事，应该是一种预案，但不能改变行为本身，偏离核心目的</strong>，例如被拒绝了，那你和父母说等你回来再安装即可，或者提供其他的措施，而不是为了后果，直接改变了礼物本身，偏离了希望交好的目的。</p><h2><span id="he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</span><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi" class="header-anchor">#</a></h2><ol><li>切忌二极管思维， <strong>不能一味的赞同别人或者听从别人， 也不能一味地要求别人听从自己的一切要求</strong>。前者是懦弱儿童思维，后者是霸道父亲思维，都是不可取的</li><li>不能因为别人不满足我的要求，<strong>就立刻在内心觉得不爽或者不舒服</strong>， 在产生一定的情绪前，先思考对方为什么会这么说/这么做，搞清楚原因后，再决定是发泄情绪还是做应对措施，<strong>“内心默默不爽”对于事情解决是没有任何意义的</strong></li></ol><h2><span id="zuo-jue-ding-zuo-jue-ze">做决定/做抉择</span><a href="#zuo-jue-ding-zuo-jue-ze" class="header-anchor">#</a></h2><ol><li>不做决定本身就是一种选择， 这种选择会浪费你的时间和机会成本。</li><li>当实在决定不了，先尝试性在2个决定上做一些前置工作，至少保证事情在推进。</li><li></li></ol><h2><span id="gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</span><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi" class="header-anchor">#</a></h2><ul><li><p>工作之内的事情一般会有目标和绩效。工作之外的事情，则要注意不要带入工作思维。</p></li><li><p>避免定过于高的目标，例如一定要完成xxxx，一定要达到xxx， 而忽略了做这件事的意义。</p></li><li><p>不如先开始做，做一部分，如果真的不喜欢就不要勉强</p></li><li><p>注意并不是只有工作技能上的提升才叫提升或者成长， 个人心理、生理状态等进步都是一种提升，因此不要只看这一周工作上有没有学习或者进步之类的。  如果人的焦虑、恐惧症状比前几周有改善，或者开始关注到自己的感受和内心想法，那么也是一种进步。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一阶段心理成长感悟</title>
      <link href="/2022/05/04/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/"/>
      <url>/2022/05/04/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</a></li><li><a href="#ji-hua-he-xing-dong">计划和行动</a></li><li><a href="#biao-da-nei-xin">表达内心</a></li><li><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</a></li><li><a href="#zuo-jue-ding-zuo-jue-ze">做决定/做抉择</a></li><li><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</a></li></ul><!-- tocstop --></div> <p>[toc]</p><h2><span id="zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</span><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou" class="header-anchor">#</a></h2><ul><li><p>有时候，他人对你的疑问，例如“天气这么好，你怎么没出去玩呢？” ，<strong>也许仅仅只是他寒暄时提出的一个观点而已，并非对你做职责或者命令</strong>。 以此类推， 对于其他的一些疑问，不要过于恶意地揣测或者做过多想象。</p></li><li><p>不要因为身边大部分人做了什么就感到焦虑，他们的行为可以是你的参考，但并非是最适合你的。<strong>你需要清楚自己内心想要的是什么，内心的感受是怎样的，并尊重和理解自己的感受，坚持自己的那份个性</strong>，而不是为了迎合他人去隐瞒自己的喜好、感受或者真实想法。 无论是假期活动还是工作待遇等，都是如此。</p></li><li><p>“我想逃避”也是一种感受， 逃避是一种可以被理解的行为，但可能是一种不合时宜的行为，因为逃避更像是儿童时期做出的避险行为。<strong>自己需要意识到自己当前的行为模式是否是陈旧的</strong>，以及是否应当稍微找起来，尝试做点和儿童时期不一样的事情。</p></li></ul><h2><span id="ji-hua-he-xing-dong">计划和行动</span><a href="#ji-hua-he-xing-dong" class="header-anchor">#</a></h2><ul><li><p><strong>不要通过幻想，来给自己设定过于严苛的计划或者目的</strong>。 后果就是一旦发生阻碍或者完不成，挫败感会很重，以后做计划也会愈发纠结和犹豫。   因此尽量千万不要定“我xx月前必须怎么怎么”、“我必须每天xxx”，这样对意外情况容错性会降低，或者一次没成，后面就可能直接不再考虑 。</p></li><li><p><strong>想要做一件事， 核心不在于计划， 而在于是否开始逐步行动</strong>，这个行动是可以很小的，但只要你开了头，就相当于获取了这件事的入门门槛。 无论是写博客、跑步、学习、刷题，都是如此。不要把时间浪费在纠结上， 与其纠结，还不如先拆分好之后，随便挑一件做。</p><p>对于跑步，应该是“我想跑的时候就跑，这次简单跑个500米试试，并非要周三或者周五，只是想开个头而已”</p><p>例如博客，我想写的时候就写一下， 今天空，正好想做，就做了</p><p>例如去哪个地方，那就先提前做些小的准备，当你准备充分了，自然也就有选择的余地，而不是强行设置期限，导致自己陷入焦虑之中。</p></li><li><p>当很多想做的事情交叉重叠，<strong>先做影响最近的</strong>，例如洗澡、扫地、拖地，再做比较久远影响的。</p></li></ul><h2><span id="biao-da-nei-xin">表达内心</span><a href="#biao-da-nei-xin" class="header-anchor">#</a></h2><ul><li>尽可能真实地表达你的想法或者目的，并付诸以该想法为最首要的行为。以下是解释：</li></ul><ol><li>要避免为了掩盖想法，找别的理由去掩饰**</li></ol><p>例如你想送人笔记本电脑，却总是说不出”我想送你笔记本让你改善你的生活质量“这句话，特地找了  一堆理由，例如”我在公司看到一个便宜的内购“、”我多买了一台笔记本，不要了给你吧“， 却刻意掩埋 了自己的想法。</p><ol start="2"><li><p>要避免因为过分考虑后果，导致对”行为“频繁地做调整，当你试图期望让该‘行为’能适配所有的后果时，你的行为本身就不太符合根本目的了</p><p>例如你要送人一台新的笔记本电脑，却总是考虑被拒绝的后果，于是换成了一台旧电脑并自己装好系统，以准备被拒绝时可以转交给父母使用。   这样会导致收到礼物的对方并不会觉得开心和尊重。</p></li></ol><p><strong>实际上被拒绝后的事，应该是一种预案，但不能改变行为本身，偏离核心目的</strong>，例如被拒绝了，那你和父母说等你回来再安装即可，或者提供其他的措施，而不是为了后果，直接改变了礼物本身，偏离了希望交好的目的。</p><h2><span id="he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</span><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi" class="header-anchor">#</a></h2><ol><li>切忌二极管思维， <strong>不能一味的赞同别人或者听从别人， 也不能一味地要求别人听从自己的一切要求</strong>。前者是懦弱儿童思维，后者是霸道父亲思维，都是不可取的</li><li>不能因为别人不满足我的要求，<strong>就立刻在内心觉得不爽或者不舒服</strong>， 在产生一定的情绪前，先思考对方为什么会这么说/这么做，搞清楚原因后，再决定是发泄情绪还是做应对措施，<strong>“内心默默不爽”对于事情解决是没有任何意义的</strong></li></ol><h2><span id="zuo-jue-ding-zuo-jue-ze">做决定/做抉择</span><a href="#zuo-jue-ding-zuo-jue-ze" class="header-anchor">#</a></h2><ol><li>不做决定本身就是一种选择， 这种选择会浪费你的时间和机会成本。</li><li>当实在决定不了，先尝试性在2个决定上做一些前置工作，至少保证事情在推进。</li><li></li></ol><h2><span id="gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</span><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi" class="header-anchor">#</a></h2><ul><li><p>工作之内的事情一般会有目标和绩效。工作之外的事情，则要注意不要带入工作思维。</p></li><li><p>避免定过于高的目标，例如一定要完成xxxx，一定要达到xxx， 而忽略了做这件事的意义。</p></li><li><p>不如先开始做，做一部分，如果真的不喜欢就不要勉强</p></li><li><p>注意并不是只有工作技能上的提升才叫提升或者成长， 个人心理、生理状态等进步都是一种提升，因此不要只看这一周工作上有没有学习或者进步之类的。  如果人的焦虑、恐惧症状比前几周有改善，或者开始关注到自己的感受和内心想法，那么也是一种进步。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java堆中分配对象的原理</title>
      <link href="/2022/05/03/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-object-in-heap/"/>
      <url>/2022/05/03/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-object-in-heap/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-dui-xiang-zai-dui-zhong-de-fen-pei-yuan-li">Java对象在堆中的分配原理</span><a href="#java-dui-xiang-zai-dui-zhong-de-fen-pei-yuan-li" class="header-anchor">#</a></h1><p>java对象new的一个过程<br><img src="/images/java-object-in-heap/7499e987f62965de977d2434a2587a1bcf9b3149.png" alt="7499e987f62965de977d2434a2587a1bcf9b3149"></p><hr><p>Q: 什么是TLAB?<br>A:<br>TLAB ——Thread Local Allocation Buffer<br>线程本地分配缓冲区</p><p>如果没有启用 TLAB，多个并发执行的线程需要创建对象、申请分配内存的时候，有可能在 Java 堆的同一个位置申请，这时就需要对拟分配的内存区域进行加锁或者采用 CAS 等操作，保证这个区域只能分配给一个线程。冲突概率很大</p><p>启用了 TLAB 之后(-XX:+UseTLAB, 默认是开启的)，JVM 会针对每一个线程在 Java 堆中预留一个内存区域<br>一旦某个区域确定划分给某个线程，之后该线程需要分配内存的时候，会优先在这片区域中申请。这个区域针对分配内存这个动作而言是该线程私有的，因此在分配的时候不用进行加锁等保护性的操作</p><hr><p>Q: TLAB给线程预分配空间的时候，如果多个线程竞争同一个预留空间冲突了怎么办？<br>A:<br>在预留这个动作发生的时候，需要进行加锁或者采用 CAS 等操作进行保护，避免多个线程预留同一个区域</p><hr><p>Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？<br>A:<br>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p><p>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。<br>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</p><hr><p>java对象在内存上的分配：<br><img src="/images/java-object-in-heap/9624dbbc45d4b10ae636df5b0766b5cc5bcfbe25.png" alt="9624dbbc45d4b10ae636df5b0766b5cc5bcfbe25"></p><hr><p>Q: 对象的hashcode确定是创建对象的时候生成的？<br>A:<br>不对。采用延迟加载技术</p><hr><p>Q: 如何计算一个java对象大小？<br>例如下面的person？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Xiaoming&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">married</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">birthday</span> <span class="operator">=</span> <span class="number">128902093242L</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sallary</span> <span class="operator">=</span> <span class="number">1200.00d</span>;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A:<br>这里假设使用64位机器，采用指针压缩，则对象头的大小为：8(_mark)+4(_klass) = 12（如果没开启，k_class即对象引用地址占8个字节）</p><p>然后实例数据的大小为： 4(age)+4(name) + 8(birthday) + 8(sallary) + 2(tag) +  4(引用，开启指针压缩) +  1或4(married)  = 31 or 34</p><p>因此最终的对象本身大小为：12+31+5(padding) = 48 或者 12+ 34 + 2(padding) = 48</p><blockquote><p>PS1: 注意布尔值可能是1或者4，根据虚拟机规范不同有不同，4字节的话好处是CPU</p></blockquote><blockquote><p>PS2: 注意，指针压缩不仅仅影响对象头，还影响了对象内的引用大小。</p></blockquote><p>更详细的见<a href="https://blog.csdn.net/yunqiinsight/article/details/80431831">如何计算Java对象所占内存的大小</a></p><hr><p>Q: 对象头里的markword到底是啥？<br>A:<br>markword根据锁标记的状态，里面存储的了不同的内容。<br><img src="/images/java-object-in-heap/ba9578e95096512cbd024da4b88b117e4a14e449.png" alt="ba9578e95096512cbd024da4b88b117e4a14e449"><br><img src="/images/java-object-in-heap/ff1ad3a49021dba3739e0c3cb66c2dd636ec242a.png" alt="ff1ad3a49021dba3739e0c3cb66c2dd636ec242a"><br><a href="https://blog.csdn.net/qq_26542493/article/details/90938070">java对象头 MarkWord</a></p><hr><p>Q: 哈希code 有锁的时候，hashcode又去哪了？<br>A:<br>identity_hashcode：31位的对象标识hashCode，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。</p><hr><p>Q: 对象内存字节为什么要按8字节对齐？<br>A:<br>对齐填充是底层CPU数据总线读取内存数据时的要求<br>例如，通常CPU按照字单位读取，如果一个完整的数据体不需要对齐，那么在内存中存储时，其地址有极大可能横跨两个字<br>例如某数据块地址未对齐，存储为1-4，而cpu按字读取，需要把0-3字块读取出来，再把4-7字块读出来，最后合并舍弃掉多余的部分。这种操作会很多很多，且很频繁<br>但如果进行了对齐，则一次性即可取出目标数据，将会大大节省CPU资源。</p><p>另一种说法：</p><blockquote><blockquote><p>Scott oaks在书上给出的理由是：<br>其实在JVM中（不管是32位的还是64位的），对象已经按8字节边界对齐了;对于大部分处理器，这种对齐方案都是最优的。所以使用压缩的oop并不会损失什么。如果JVM<br>中的第一个对象保存到位置0，占用57字节，那下一个对象就要保存到位置64，浪费了7<br>字节，无法再分配。<strong>这种内存取舍是值得的（而且不管是否使用压缩的oop，都是这样），因为在8字节对齐的位置，对象可以更快地访问</strong>。</p><p>不过这也是为什么JVM没有尝试模仿36位引用（可以访问64GB的内存）的原因。在那种情况下，对象就要在16字节的边界上对齐，在堆中保存压缩指针所节约的成本，就被为对齐对象而浪费的内存抵消了。<br>** 8字节对齐，是为了效率的提升，以空间换时间的一种方案**。当然你还可以16字节对齐。但是8字节是最优选择。</p></blockquote></blockquote><hr><p>Q: jvm的指针压缩原理是什么？<br>A:<br>我们都知道java中的对象都是8字节对齐的，8字节对齐有一个特点就是总是加上1 000。 发现了吗， 所有对象的指针后三位总是0。这就是指针压缩的点。</p><p>压缩原理就是两句话：<br>1：存储的时候，后三位抹除0.<br>就变成：test1=00，test2=10<br>2：使用的时候，后三位补0.</p><p>它的指针不再表示对象在内存中的精确位置，而是表示 偏移量 。这意味着 32 位的指针可以引用 40 亿个 对象 ， 而不是 40 亿个字节。最终， 也就是说堆内存增长到 32 GB 的物理内存，也可以用 32 位的指针表示。（4字节指针地址原先只能表示4个G的大小）</p><hr><p>Q: 指针压缩什么时候会失效？<br>A:<br>因为寄存器中2的32次方只能寻址到32g左右(不是准确的32g，有可能在31g就发生指压缩失效)<br>所以当你的内存超过32g时，jvm就默认停用压缩指针，用64位寻址来操作，这样可以保证能寻址到你的所有内存，但这样所有的对象都会变大，实际上未开启开启后的比较，40g的对象存储个数比不上30g的存储个数</p><hr><p>Q: 为什么对象头里的kclass也会受指针压缩的影响？class实例不是存储在方法区里么？<br>A:<br>JDK1.6中Class实例在方法区<br>JDK1.8之后， class实例本身就是一个对象，分配在java堆中。而class字节码加载后的各种细节内容则存储在永久代中。</p><p>HotSpot并不把永久代中的instanceKlass暴露给Java<br>而会另外创建对应的class对象instanceOopDesc来表示java.lang.Class对象（即这个对象里不会包含class细节字节码的内容），并将后者称为前者的“Java镜像”， 对象头里的klass就是持有指向类oopDesc引用(_java_mirror便是该instanceKlass对Class对象的引用)；</p><hr><p>Q: 在方法栈中执行代码时，如何通过引用定位到堆里的对象？<br>A:<br>两种方式，通过句柄池，或者通过指针。如下图所示<br><img src="/images/java-object-in-heap/5d0f1b24e4b024123de4f669.png" alt="引用对象"></p><hr><p>Q: 句柄和指针的区别是什么？<br>A:<br>句柄池， 引用中的句柄地址不会发生改变引用变动时，只会变动句柄中数据指针的内存<br>可以理解为，句柄池方式， 创建新对象后，句柄位置就定下来了。后面如果频繁修改引用， 只会修改句柄里的指针，但是本地变量表里寻找的位置都不会变化，因此不用经常跳到各种本地变量表去修改。</p><ul><li>频繁gc、修改引用的，用句柄池引用</li><li>频繁访问固定对象的，用指针引用</li></ul><hr><p>Q: 怎么确认用的是句柄引用还是指针引用？<br>A:<br>sun HotSpot用的指针引用，速度快<br>访问方式，取决于虚拟机的实现。</p><hr><p>Q： 方法里创建基本类型的局部变量时， 为什么不把基本类型放堆中呢？<br>A:<br>因为其占用的空间一般是 1~8 个字节——需要空间比较少，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的。</p><p>可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据</p><hr><p>Q: 那我new出来的对象， 一定都在堆中吗？<br>A:<br>HotSpot虚拟机引入了JIT优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p><hr><p>Q: 刚才new对象的过程，可能存在重排序吗？<br>A:<br>存在。<br>①「JVM」为对象分配一块内存M。<br>②在内存M上为对象进行初始化。<br>③将内存M的地址复制给singleton变量。<br>可以是「①②③」或者「①③②」。 这也导致了双重检查锁时，为什么有了sync还要加volatile。</p><p>但是另一种说法，是JDK高版本之后， 将这个new语句看成一个大号的volatile写，因此这个大号volatile写前后会有内存屏障，与volatile读隔离开来，因此虽然volatile读不知道大号volatile写的内部顺序，但是知道它的结果一定是执行完那三步的。<br>因此重排序仍然存在，但是会特地限制其他对该对象的new的过程是有屏障的。</p><hr><p>Q: 上面的过程的指令码是什么样的？<br>A:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: new           #16 // class jvm/fenixsoft/DynamicDispath$Man</span><br><span class="line">    3: dup   // 将栈顶复制一份再推进栈</span><br><span class="line">    4: invokespecial #18 // Method jvm/fenixsoft/DynamicDispach$Man.&quot;&lt;init&gt;&quot;:()V   调用初始化方法</span><br><span class="line">    7: astore_1  // 将引用赋值到局部变量表里</span><br></pre></td></tr></table></figure><p>那么为什么要进行备份呢？</p><p>一开始是new指令在堆上分配了内存并向操作数栈压入了指向这段内存的引用<br>之后dup指令又备份了一份，那么操作数栈顶就有两个<br>再后是调用invokespecial #18指令进行初始化，此时会消耗一个引用作为传给构造器的“this”参数， 注意这个指令会将栈顶的引用拿走，因此dup指令都是用于这种场景的，即栈顶的引用存在消耗。</p><p>那么还剩下一个引用，会被astore_1指令存储到局部变量表中，后面调用的代码会用到。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java高级原理 </category>
          
          <category> jvm原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,深入理解jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【反八股系列】一、为什么我们要学习java虚拟机栈的原理？</title>
      <link href="/2022/05/03/why-study-java-stack/"/>
      <url>/2022/05/03/why-study-java-stack/</url>
      
        <content type="html"><![CDATA[<p>曾经的八股文：</p><p>xxx</p><p>现在的八股文：</p><p>xxx</p><p>为了找回对编程最初的乐趣</p><p>决定自制反八股系列的知识视频</p><p>本系列的三大宗旨：</p><p>拒绝死记硬背</p><p>拒绝管中窥豹</p><p>拒绝浅尝则止</p><hr><p>对于jvm的虚拟机内存结构，大家应该都能背会有“2个堆”、“2个栈”、“1个计数器” 这种内容，就像下面这张图一样。  其中java的栈是虚拟机指令执行的关键。</p><p>那么，为什么我们要学习背后的这个虚拟机栈呢？ 我的代码能跑起来不就了可以吗？</p><p>哦，是面试要用么？然而个人不希望这些内容成为新一代的“科技八股文”。</p><p>因此本系列希望先从为什么学习入手，再深入到更深层次的东西，，希望能带来的是长久的收获，而非短暂的记忆。</p><hr><p>为什么我们要学习背后的虚拟机栈。</p><p>首先，你debug的时候，你都不知道这个是什么东西，瞎猜可不行，你要知道暂停时现在是个请什么情况， IDE上的东西到底是什么，他们对程序运行又有什么影响</p><p>[debug图片]</p><p>其次，虚拟机栈的内容是很多重要知识的前置知识点。  垃圾收集的GC-ROOT与栈有关， JIT优化和栈有关。如果你不知道，那么在遇到相关知识点，只会产生“这是啥”、“这又是啥”的连锁反应， 就有可能陷入背诵八股文的折磨却不知所以然的地步。</p><p>最后，java虚拟机栈为我们生动展示了 一个小心的迷你的CPU执行逻辑。</p><p>对于很多没有学习过计算机底层原理（例如CSAPP这本书） 的人来说， 是完全不知道计算机是如何执行机器码指令的。 而java虚拟机栈可以更好理解 指令是如何运行的， 虽然这个指令不是真正的机器码执行， 而是jvm字节码指令。  但是通过字节码指令， 我们可以快速对应到java中常见的各种操作。</p><p>这对于很多入门时直奔删减改查的同学来说， 是不可多得的学习底层的机会。</p><p>另外数据结构里学习的栈的知识也会在这里得以应用。</p><hr><p>清楚了上述好处后，我们开始深入了解虚拟机栈的细节。</p><p>首先，栈帧是什么？</p><p>不需要去记忆概念，就记得我们调试时，框框里的每一行，就是一个栈帧。 可以看到除了栈顶的方法正在执行外， 其他行都仿佛静止了一般， 因此就像拍照时的一帧。</p><p>对于栈帧里有什么， 经典背诵4件套：</p><p>局部变量表，</p><p>操作数栈，</p><p>动态链接，</p><p>方法返回地址，</p><p>其实与上面这4样配合的，还有个虚拟机栈所使用的“程序计数器”，才共同实现了jvm指令的执行。</p><p>首先对局部变量表而言， 为什么要有这个东西？</p><p>5 4 3 2 1 .</p><p>因为我们声明的局部变量a、b、c等， 都需要有一个地方存放， 但局部变量只有这个方法中才会使用， 所以才会在栈帧中开辟局部连量表的空间。</p><p>那么，变量表有多大呢？</p><p>编译时指定定死了</p><p>为什么能定死？</p><p>因为编译器很聪明，通过分析代码，他就能知道到底这个方法要用几个变量。</p><p>为什么我们需要思考这个问题？因为我们要考虑我们写的代码，可能会带来多大的局部栈的消耗。</p><p>例如，我在一个for循环里反复定义同一个变量，那局部变量表是不是在无限增大？我是不是要提前加大栈的分配内存？</p><p>其实不需要， 因为编译器支持变量表的复用，  它会知道你在重复声明变量，所以实际字节码指令中，它会明确写下“这个变量继续放到前面那个槽”的指令，  从而覆盖使用了之前的槽。</p><p>你问我怎么分析的？ 请阅读《编译原理》。</p><p>然后操作数栈又是干什么的？ 如果要做a+b,我直接从变量表上取a的值和b的值，加起来不就好了？</p><p>直接让CPU取a和b的值拿去算完回来，不就好了？</p><p>那我如果是 a + b*c呢</p><p>b*c的值放哪里？</p><p>如果是a+b*(c+d)呢？</p><p>这时候如果你学习过数据结构里栈的应用 ，就会知道 模拟一个计算器，往往需要一个栈。</p><p>而操作数栈就是这个作用。</p><p>当你学习jvm指令时，就会看到有专门的指令就是取栈顶或者把值推送到栈顶的指令。</p><p>这样做加法的时候，也就不用关心变量的地址了，只要你把栈顶的值存好，我直接拿去加就行。</p><p>那么动态链接又是个什么玩意？</p><p>就这么说， 你怎么知道这个方法此时要做哪些动作？</p><p>肯定有一段代码区（即jvm指令），让我一条条执行对吧？</p><p>那么这个代码区放哪呢？我总需要知道一个地址， 因此，动态链接，就是这个方法代码的位置。</p><p>那干嘛叫动态链接这么抽象啊？</p><p>因为有的方法往往是等运行的时候才知道地址， 所以统一就叫做动态链接了，这就是未来会提到的java多态的核心本质而。</p><p>那么返回地址比较好理解，方法执行完成， 返回上一层方法执行的位置。</p><p>等等，这个地址是实际的地址吗？例如0x2313212这种？</p><p>应该是把，不然怎么叫地址？</p><p>但是我已经有动态链接标记的方法指令的起始位置了，你为什么还要整这么长？</p><p>哦，那就用偏移值就可以了！</p><p>那现在再看，程序计数器，代表的是什么</p><p>很显然和方法返回地址一样， 也是指令偏移值，  这样通过动态链接 + 计数器， 就能知道这个方法当前执行到什么位置了， 即使发生了线程切换或者方法返回， 都不用担心了~！</p><p>那么再深度扩展一下，根据以上理解，是否能清楚下面这个的原因代码的原因</p><p>当你知道远离后，你就不需要记忆这种情况，而是一想背后的实现，就能明白这么写是不对的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">   System.out.println(<span class="string">&quot;value : &quot;</span> + getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        i++; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在执行 finally 语句块之前，try 或者 catch 语句块会保留其返回值到本地变量表（Local Variable Table）中。待 subroutine 执行完毕之后，再恢复保留的返回值到操作数栈中，然后通过 return 或者 throw 语句将其返回给该方法的调用者（invoker）</p><p>因为你要处理finally块时， 操作数栈要腾出来给finally使用， 因此返回值不能放在这，所以整了个局部变量ret放进去， 执行完成返回来。</p><p><a href="https://www.jb51.net/article/74771.htm">https://www.jb51.net/article/74771.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首页</title>
      <link href="/2022/05/02/home/"/>
      <url>/2022/05/02/home/</url>
      
        <content type="html"><![CDATA[<p>哈喽，我是破晓。<br>本博客主要有以下目的：</p><ol><li>整理自己历史以往学习过的所有知识点，温故知新</li><li>发布一些高质量的知识分享文章</li><li>记录一些只给部分人观看的个人生活记录</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21年10月-22年5月</title>
      <link href="/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/"/>
      <url>/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p>  <div class="toc"><!-- toc --><!-- tocstop --></div>  <p>刷题日记</p><p>😉   😢 😆 😋</p><p>[2022-05-09]</p><ul><li>给一个图，找入度为n、出度为0的唯一点，最少可以通过3n次查找，从0到n通过遍历a-&gt;b，逐步排除不可能的选项，最终只剩1个，然后再通过2次n确认入度和出度。  😄</li></ul><hr><p><a href="http://doc.minidown.cn/guinvg">2022-05-02</a></p><ul><li>s.indexOf(i, “}”) 可以快速得到下一个</li></ul><p><a href="http://doc.minidown.cn/scvmoj">2022-04-09</a></p><ul><li>要求ty通过反复减tx，要减到小于等于tx的话 那么就是ty%tx的值</li><li>对于自己推导中间过程比较麻烦的题目，就直接写个sout打印中间能很快观察到问题所在</li></ul><ol><li>先写个超时的答案</li><li>打印中间结果，看下哪里浪费了</li><li>对浪费的步骤做优化</li></ol><p><a href="http://doc.minidown.cn/jnxyjz">2022-0405-0406</a></p><ul><li>求1个数字N是否为质数的一个简单方式： 只遍历i=2到i=根号(n)，然后确认能否被整除即可。</li><li>优化1： 求二进制1的个数，没必要手动求解， 直接用Integer.bitCount()即可</li><li>优化2：质数如果总数比较小，可以直接手动大表，这题里最大数字范围为19 ，那么质数可以直接打表得到</li><li>找到一个最小高度的树的根节点，可以用拓扑排序，从最外围往内部逼近</li></ul><p><a href="http://doc.minidown.cn/ctpdxv/">2022-04-01</a></p><ul><li>n如果是整数，可能直接越界，需要提前强转</li><li>如果状态条件种要求不能连续的问题， 考虑状态是否多加一个,这题的状态方程就是,dp[当前位置][颜色][上一个点是否是该颜色]</li></ul><p><a href="http://doc.minidown.cn/fgsvki/">2022-0329-0330</a></p><ul><li>知道很多点的大小关系，求整个的大小关系，可用拓扑排序</li><li>Stringbuilder.reverse() 会导致自身翻转，所以切忌不要对搜索变量stringbuidler做翻转，要么记得转回来</li></ul><p><a href="http://doc.minidown.cn/nnjuyg/">2022-03-28</a></p><ul><li>如果二进制a都是0、1交替的，那么a ^ (a&gt;&gt;1) 则会变成除前置0外，全是1</li><li>如何判断某个二进制a全是1组成？a&amp;(a+1)==0， 则说明全是1</li><li>多个字符串编码成1个字符串，可以用非ascii码的字符做分隔符(char)257</li><li>涉及次数问题的题目，且题目次数一定小于某个总数，则可以考虑计数排序</li></ul><p><a href="http://doc.minidown.cn/unaalu/">2022-03-27</a></p><ul><li>涉及数字出现次数，求里面某几个特别的次数的数字时，记得使用分类，即想办法把他们分成不同的组，再分别做异或即可。</li><li>x&amp;（-x）是x=110100变000100,  x&amp;(x-1)是x=110100变111000</li><li>如何判断一个图是否是1课树？<br>方法1：首先保证边数=节点数-1,然后用bfs保证所有点相连<br>方法2：并查集，合并过程不能出现2个根节点相同（说明树内循环连接了），合并完成要求只有1个根节点</li></ul><p><a href="http://doc.minidown.cn/uwghjd">2022-03-26</a></p><ul><li>一个数组，如何求去掉每个位置时的数组中的最小值<br>维护最小值和第二小的值即可<br>注意，当更新最小值的时候，同时需要更新第二小的值！</li></ul><p><a href="http://doc.minidown.cn/mjkleh/">2022-03-24</a></p><ul><li>自定义迭代器注意点：迭代器特点，无论是hasNext还是next,都需要先找到下一个有效的点, 再去判断，而且是通过while循环查找。</li></ul><p><a href="http://doc.minidown.cn/jrogiy">2022-03-23</a></p><ul><li>int[] 截断成list，可以先转list，再用subList截断.<br>ret.subList(0, k);</li><li>寻找num在list中的位置：Collections.binarySearch(list, x);</li><li>用常量空间判断数组是否是二叉搜索树的先序？<br>遍历每个点，只测试右边方向的正确性</li><li></li></ul><p><a href="http://doc.minidown.cn/ymocky">2022-03-21</a></p><p>*1个有序数组，求2个数字的和满足target，可以用双指针最左和最右，然后根据大小情况移动左边或者右边。为什么不可能往回走？因为你之前已经走过的点，能确认右边那个位置是无法满足的</p><ul><li>中序遍历迭代树， 注意走下一个点时，要么右儿子为空往上走，要么走右儿子后，还得往左边一直走到底，才算是下一个点</li></ul><p><a href="http://doc.minidown.cn/tnetil">2022-03-19</a></p><ul><li>list[]初始化，直接for循环最简单</li></ul><p><a href="http://doc.minidown.cn/nweavt">2022-03-18</a></p><ul><li>一个java-stream的小点： 按照key分组并统计每组key的数量<br>Map&lt;String, Long&gt; strMap = Arrays.stream(strings)<br>.collect(Collectors.groupingBy(s -&gt; s, Collectors.counting()));<br>即groupingBy(key-&gt;key, Collectors.counting())<br>如果记不起来，马上改成用stream().foreach或者直接循环即可</li></ul><p><a href="http://doc.minidown.cn/xemgpw">2022-03-17</a></p><ul><li>2个单词在词典中的最短距离，最好方式是用双指针，如果i1&lt;i2，则i1++，这样子</li></ul><p><a href="http://doc.minidown.cn/dkceba">2022-03-15</a></p><ul><li>unicode形式的字符，尽可能用character对象，一个字符可能是多个字节表示，因此不能用数组下标来简单处理这类字符的哈希问题</li></ul><p><a href="http://doc.minidown.cn/actdba">2022-03-14</a></p><ul><li>如果求解二叉搜索树的第k个点，要求频繁查询的性能，则事先统计每个子树的节点总数量，即可快速判断在左边还是右边。（如果不平衡则要平衡树）</li><li>p、q最近公共祖先问题，可以不一定用父亲数组遍历2次， 而是用 该树是否包含p或者q的布尔值结果，通过先序遍历，找到第一个左右两边都有p\q的情况（也包括自己是p或者q)</li></ul><p><a href="http://doc.minidown.cn/elprds">2022-03-13</a></p><ul><li>如果希望使用双端队列而不是栈，请不要用Push和poll了，就用first和last两个语义处理，避免混乱</li><li>LinkedList push 施加在list头部. 等同于addFirst。 add 是加在list尾部。</li><li>如果一个式子中只有+号和-号，无括号，则直接将-号后的数字取负即可</li></ul><p><a href="http://doc.minidown.cn/aifjbh">2022-03-09</a></p><p>超期优先队列应用</p><p><a href="http://doc.minidown.cn/dapvqa">2022-03-08</a></p><ul><li>如果题目只需要你返回true或者false，即不需要中间所有结果，则考虑到一些情况可以不用过分担忧，如果有影响，则可能直接返回true了</li><li>完全二叉树的节点是否存在，可以用位运算来表示，往left走代表0，往right走代表1.</li></ul><p><a href="http://doc.minidown.cn/svrgqb">2022-02-20</a></p><ul><li>回文串最简单的判定s = 翻转(s)， 可以考虑字符串哈希等东西，或者KMP前缀后缀判定优化</li><li>字符串哈希，第0位数字不可为0，至少要有数字，因此不需要做s.charAt(i) - 'a’的操作</li></ul><p><a href="http://doc.minidown.cn/qgdvtd/">2022-02-19</a></p><ul><li>因此股票买卖，要考虑持有或者不持有，然后通过买入扣钱以及卖出加钱来计算</li><li>字典树问题，如果是考虑单词“全匹配”，则必须要在字典树末尾补充isEnd标志。</li></ul><p><a href="http://doc.minidown.cn/cwnymt">2022-02-18</a></p><ul><li>字符串只有10时，做substring和map.hashcode的时间都是可接受的，可直接用</li><li>子序列对应x进制的滑动窗口问题中，你可以先整体右移动，然后截断第一个位，再加上最后一个，即可。</li><li>如果窗口大小是的2的倍数，则可以继续用位运算，只不过偏移数量要变化<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/7897843fc21e6aee738cf9853605db09378a0ef0.png" alt="7897843fc21e6aee738cf9853605db09378a0ef0"></li><li>对于长度固定的窗口，你可以先预处理窗口剩1个， 然后再开始，避免重复判断<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/8b5ec292b0898702f3d8c0c1eb08127488982cb7.png" alt="8b5ec292b0898702f3d8c0c1eb08127488982cb7"></li></ul><p><a href="http://doc.minidown.cn/juumpq">2022-02-17</a></p><ul><li>如何O(h高度）遍历二叉搜索树？ 利用栈，每次把左左左放入，然后出栈时，右儿子放入后继续左左左放入</li><li>几个数字怎么排列乘一个数字后最大， 只要满足a+b&gt;b+a，那么a就放在前面即可。</li><li>字符串去除前置0的操作：.replaceAll(“^(0+)”, “”)</li><li>字符串a+b和b+a做比较觉得不好，可以改成long整数，分别乘高x10位加另一个数字来比较</li></ul><p><a href="http://doc.minidown.cn/ysesry">2022-02-16</a></p><ul><li>一个节点的祖先和后代节点集合， 一定包含在他父节点的祖先和后代节点集合</li><li>可根据各节点的祖先和后代节点数量，确认是否是祖先关系，父亲节点是数量最靠近自己的</li><li>后面暂时不做每日一题了，直接按面试高频题进行练习。</li></ul><p><a href="http://doc.minidown.cn/sndbof/">2022-01-27</a></p><ul><li>注意javaStream.filter中，是满足条件的留下， 而不是剔除。</li><li>边界比较麻烦的问题，要自己写一下UT用例，覆盖边界场景，再写代码，这样就算错了，给人留下的印象也会很不错</li></ul><p><a href="http://doc.minidown.cn/oswnef/">2022-01-26</a></p><ul><li>快速计算list或者map.values()的最小值方法：Collections.min(collection)</li><li>滑动窗口遵循下面的写法最简单：</li></ul><ol><li>只写一个while循环，即只默认循环加right</li><li>每次都直接把right放入窗口。</li><li>当窗口不满足，则移动左节点直到满足。如果左节点大于右节点，结束左节点的移动。</li><li>计算当前窗口结果。左大于右时，要能算为0</li><li>right++</li></ol><p><a href="http://doc.minidown.cn/riagcz">2022-01-24</a></p><ul><li>求List<integer>的int最大值时，需要先mapToInt， 再求最大值。 如果最大值可能不存在，要用orElse设置默认值</integer></li><li>分子/分母的整除对象做哈希键时，需要做4种处理</li></ul><ol><li>分子必须保证为非负数（如果小于0，则上下都乘-1即可）</li><li>需要求出gcd进行最小约分</li><li>用最大边界来表示这个二维值：（分子/gcd) * 最大边界 + (分母/gcd)</li><li>分子为0，那就简化成（0，1）， 分母为0，那就简化成（1，0）</li></ol><p><a href="http://doc.minidown.cn/bkiugo">2022-01-22</a></p><ul><li>每次提交代码前，必须看一下中间10^5范围的中间结果是否可能超出int范围。</li></ul><p><a href="http://doc.minidown.cn/qypqat">2022-01-21</a></p><ul><li>对链表题排序， 注意每次排序完部分链表时， 需要更新最后一个节点的next！</li><li>如何对链表做排序，且空间复杂度最小？使用迭代法的归并排序，即自底向上的归并排序。那么就很容易了</li><li>怎么划分2个需要合并的列表?提前把尾部设成null</li><li>合并两个链表时，可以弄一个局部头节点，这种不算空间复杂度，因为是局部变量， 后面会释放掉。</li></ul><p><a href="http://doc.minidown.cn/vwmdoh/">2022-01-20</a></p><ul><li>无法搜索的博弈论问题，尝试找规律， 当先手选某一步，之后大概率会陷入某类循环中，直到出现胜负。</li><li>不能很快得到公式时，不妨写土方法遍历1下看能否满足循环序列。</li><li>短时间想不到的博弈论问题，直接放弃，博弈论还是比较脑减急转弯的</li></ul><p><a href="http://doc.minidown.cn/dznylj">2022-01-19</a></p><ul><li>如何避免构建初始滑动窗口的麻烦？可以往右边遍历时，到达某一个边界，才开始删除，就不用构建初始窗口那么麻烦了。</li><li>用迭代模拟递归核心原理：</li></ul><ol><li>node局部变量，指代dfs方法中的node入参。</li><li>当前node还有用，但需要往下搜索时，把自身入栈，再更新node局部变量。</li><li>当stack.pop时，说明已经从dfs(left)或者dfs(right)中走出来了。 则按照递归代码，选择继续走right入栈，还是直接打印自身。</li><li>node=null指代什么？指代必须要用stack.pop，即开始回溯了。当你试图回溯时，不可自己做node=node.right的操作， 而是要通过stack.pop处理</li></ol><p><a href="http://doc.minidown.cn/jngnpk">2022-01-17</a></p><ul><li>因此动规适用于单个结果，不适用于动规路径或者排列。如果需要求路径组合或者一定条件的排列组合，请使用记忆化搜索而不是动态规划。因为记忆化搜索时，只有成功搜索到底部，才会得到记忆化结果</li><li>链表首尾不断相连的解法： 如果涉及从后向前处理的链表，考虑反转链表再操作。 对于中点，使用快慢指针。</li></ul><p><a href="http://doc.minidown.cn/lqhkby">2022-01-16</a></p><ul><li>感觉不好计算最终数组有几个位置的话，不如直接用list，最后toArrya(new xxx[0])即可<br>return results.toArray(new String[0]);</li><li>问题是分配问题，但是却需要你计算一个某最大长度结果，则可以考虑二分法，固定最大长度，再分配。</li></ul><p><a href="https://leetcode-cn.com/problems/single-number-ii/">2022-01-15</a></p><ul><li>位运算问题，可以考虑“各位的数量&quot;，例如只有1个数字是1个，其他都是3个3个出现，那么可以从每位的1的个数，推断出那个数字（其他肯定要么是1的3倍或者0倍，加起来）</li><li>上一个状态集合是[00,01,10,11]，和数字[0,1]碰撞后,得到一个新的状态集合[x,y…]，则可以画出一个卡诺图， 上一个状态集合看作a\b两个门， 数字[0,1]看作c这个门，从而得到a和b的新状态电路情况<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/a8eac0b3823f887071474d90e16e46f2475973e5.png" alt="a8eac0b3823f887071474d90e16e46f2475973e5"></li></ul><p><a href="http://doc.minidown.cn/mtrveo">2022-01-14</a></p><ul><li>有时候要求满足复杂规则情况下，求最优结果，则可以考虑拆分成多种规则，取每个位置的最大值或者最小值<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/9fc32c38f70bff95f29aa46ba21db777a3362488.png" alt="9fc32c38f70bff95f29aa46ba21db777a3362488"></li></ul><p><a href="https://leetcode-cn.com/problems/gas-station/">2022-01-13</a></p><ul><li>当从i往右滑动到j时，整个过程要求都满足区间和[i, k]大于等于0时， 一旦有[i,j]不满足， 则[i,j]中的任一点都无法作为起点， 因为[i,i]肯定满足&gt;=0，则[i+1,j]肯定变得更小了，以此类推（或者说[i,xxx]这个前缀和肯定都大于0，得到中间任一位置都无法满足）</li></ul><p><a href="http://doc.minidown.cn/ooypni">2022-01-11</a></p><ul><li>根据障碍数n，计算出一个能围住的最大格数max，如果a能bfs搜到的点大于max，说明没围住。 如果小于，则肯定围住了。<br>网格中，障碍个数n能围住的最大格子个数max= n*(n-1)/2</li><li>x=1000000，y=1000000, x<em>y不会超Long， 但是(x+1)</em>(y+1)可能会超</li></ul><p><a href="http://doc.minidown.cn/cgojnt">2022-01-10</a></p><ul><li>差距某个字母才算相邻的单词相邻问题，可以使用虚拟节点求解。（同理可以作用到数组相邻问题上）<br>例如abc可以和bc、ac、ab*这三个虚拟节点相邻。<br>其他一样处理， 这样就可以直接连起来<br>还要维护id到单词、单词到id的2个映射map。</li><li>双向bfs可以降低空间消耗，但是不能降低过多的时间复杂度</li><li>力扣不支持bigInteger。如果在35位范围内，可以尝试使用Double表示大整数。如果长达几百上千位，就只能自己写string大整数加法了。</li></ul><p><a href="http://doc.minidown.cn/pspxgi">2022-01-08</a></p><ul><li>力扣竞赛，示例的正确答案在右边，不要看错了</li><li>可以先写一些用例，在跑，减少罚分，养成习惯</li><li>给你一堆固定长宽矩形的左上顶点， 让你判断某个点是否被任一矩形包含，则 可以反向前缀和， 求这个点的左上矩形区间内是否包含矩形顶点即可</li><li>前缀和别写错，注意要-1的都是左上角顶点坐标<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/fd9f505ce39b64eaebad16f0e4445fe305526913.png" alt="fd9f505ce39b64eaebad16f0e4445fe305526913"></li></ul><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">2022-01-06</a></p><ul><li>组合数C(n,m)可以用杨辉三角求， 杨辉三角的n行m列等同于C(n,m)</li></ul><p><a href="http://doc.minidown.cn/swqraj">2022-01-05</a></p><ul><li>遍历小写字母， 用for(c = ‘a’;c&lt;=‘z’;c++)而不是for (j = 0; j &lt; 26; j++) { （char）(j+‘a’)}</li><li>能用spilt分割就用spilt，别自己分割,容易搞错</li><li>当给树添加新的指针，让你做常见遍历，却要你用常数空间时，一定是利用新指针当作线索来做遍历，避免了用栈或者队列。</li></ul><p><a href="http://doc.minidown.cn/xjzpvn">2022-01-04</a></p><ul><li>树的搜索， 用迭代替代递归的关键点：</li></ul><ol><li>node局部变量等同于dfs(Node node)里的node入参</li><li>while(node = node.left) 等同于走dfs(node.left)</li><li>取栈顶， 等同于if(node==null) return的这个边界</li><li>node.right 入栈， node = node.right 等同于dfs(node.right)</li></ol><ul><li>要求空间复杂度为1的树中序遍历， 考虑利用左子树的最右节点的right空闲指针，指向自己，来快速跳转</li><li>二叉搜索树寻找问题节点， 直接遍历得到list，然后排序，就能找到问题节点了。</li></ul><p><a href="http://doc.minidown.cn/odfefu">2022-01-03</a></p><ul><li>矩阵最大面积问题，提前想到单调栈，固定自身高度h，左右扩展。</li><li>计算星期几、日期相关题目， 统一用减去1970年12月31日的方式，拿到时隔多少天， 用天数去判断</li><li>子集问题，直接dfs，不要想着骚操作搞for循环，太容易写错了。避免重复，就是那个原则“必须连着选相同的，不能跨着选相同的”</li></ul><p><a href="http://doc.minidown.cn/ddyvlk">2022-01-01</a></p><ul><li>如果是单调栈的题目，最终肯定只需要使用栈头的元素。 如果你发现需要遍历栈中所有元素，导致高度和宽度全在变化导致无法计算， 可以看一下是不是改变计算思路，固定自身为某个高度，而不是去寻找前面的某个高度。</li><li>把上一组n阶的格雷码集合 都在头部加一个1， 然后倒序加进来即可。（可以理解为先头部加个1跳进去，然后反向走一遍，就肯定能保证走回去了）</li></ul><p><a href="http://doc.minidown.cn/cxdaku">2021-12-30</a></p><ul><li>不要看到总数为n，分组长度最大为n，就认为自己的双重for循环可能有O(n^2)的复杂度。<br>对于会提前结束/退出判断的情况来说， 双重for可能最多就O(n)，循环就会结束了</li></ul><p><a href="http://doc.minidown.cn/uynbou">2021-12-29</a></p><ul><li>a+b+c=d的等式问题， 可以转化为a+b=d-c问题</li><li>4个点的复杂滑动窗口问题， 可以只滑动中间点， 左边当区间复用历史结果， 右边做遍历。</li><li>从某序列变成某序列的“最短编辑距离”问题， 可以考虑动态规划， 判断从子序列A变成子序列B时，能通过做哪些动作实现部分匹配，再判断剩下子序列a和子序列b的最短距离即可。<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/b126300997a64998cce44f429188d3f512dbbed6.png" alt="b126300997a64998cce44f429188d3f512dbbed6"></li></ul><hr><p><a href="http://doc.minidown.cn/btbzyn">2021-12-28</a></p><ul><li>List&lt;int[]&gt; result如何转int[][]?      result.toArray(new int[0][0]);</li><li>问你某某走法的数量，却要求空间限制，无法动态规则，则考虑组合数。</li><li>组合数快速解法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(<span class="number">8</span>,<span class="number">3</span>) = <span class="number">8</span> * <span class="number">7</span> * <span class="number">6</span> /(<span class="number">3</span> * <span class="number">2</span>* <span class="number">1</span>) =( ((((<span class="number">6</span> / <span class="number">1</span>) * <span class="number">7</span>) / <span class="number">2</span>) * <span class="number">8</span>) / <span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">2021-12-27</a></p><ul><li>当数量很大，但是数值范围很小，却要你做二分、排序或者区间统计时，优先考虑直接用数组做计数排序/计数前缀和。</li></ul><p><a href="http://doc.minidown.cn/agaioj/">2021-12-26</a></p><ul><li>快速只保留末尾的1，其他全置0： b &amp;(-b)</li><li>快速剔除末尾的1： b &amp;(b-1)</li><li>全排列问题， 直接搜索每个位置能放谁，从0开始遍历+vis数组</li><li>重复问题的剪枝：只能连续插入重复的数字，不能跳跃着放重复数字。因为跳跃了的话，前面完全可以搜过一样的情况</li></ul><p><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">2021-12-23</a></p><ul><li>遇到特定长度的<strong>子串/子数组</strong>是否<strong>重复/已存在</strong>的问题，可以考虑用字符串哈希</li></ul><p><a href="https://leetcode-cn.com/problems/heaters/">2021-12-20</a></p><ul><li>二分的最大right记得想清楚，不确定的话直接Integer.MAX_Value就行</li></ul><p><a href="http://doc.minidown.cn/pdosib">2021-12-19</a></p><ul><li>问你最少替换几个数字， 可以变成递增序列， 其实 可以变成“求出最长递增子序列后， 剩下的就是要变的数字”。 或者说替换几个东西，可以变成xxxx， 是否可以改成求 最长的xxxxx，然后剩下的就是要改变的东西</li><li>如果设计key-value的value二分， 不要试图用treeMap，因为treeMap是基于key排序的。 做更新操作会恶心死自己，不如直接基于key二分，然后判断value</li></ul><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">2021-12-14</a></p><ul><li>数独判断的问题记得先写针对区间的check函数，再判断，会简化很多操作。<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/9c00e5b295a063c590a4e969521709d8d673cdb4.png" alt="9c00e5b295a063c590a4e969521709d8d673cdb4"></li></ul><p><a href="http://doc.minidown.cn/tlehxw">2021-12-13</a></p><ul><li>旋转数组二分问题，每次找有序的那段，再去判断</li><li>旋转数组如果有重复数字，提前处理左右边界都相等的情况，都+1和-1，这样就省了很多复杂场景了</li></ul><p><a href="https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/">2021-12-12</a></p><ul><li>滑动窗口求最大值问题时，不要忘记求初始窗口时的最大值更新。</li></ul><p><a href="http://doc.minidown.cn/dzqyun">2021-12-11</a></p><ul><li>排序过程如果涉及索引，可以考虑弄一个索引i的数组，对i做排序，不需要带着索引弄个二维数组很麻烦</li><li>Arrays.sort如果要对int[]数组自定义排序， 应该使用Integer[]而不是int[]数组。</li><li>如果滑动窗口如果发现删除点的操作比较麻烦，可以尝试事先利用数组特性预计算一些前缀和等数据，提前算好那个区间的值，而不需要去考虑移动时点的更新。</li><li>bfs时，一定要记得第一个入队的点需要设置vis[x] = true，这个很容易漏！</li></ul><hr><p>这下面的是从旧往前， 而最新的都改成了新的放上面</p><p><a href="http://doc.minidown.cn/waggvn">2021-10-07</a></p><ul><li>复杂字符串解析问题， 尽可能避免边解析边计算，可以分成2步来做，先解析成N个字符串，再依次判断和计算。</li><li>并查集问题，涉及边界相连的情况，可以将边界认为是一种集合。</li><li>二维点问题，尽可能用index = getIndex(y,x) 获取二维索引， 避免大量二维数组操作， 用InArea(y,x)方法减少判断代码。</li></ul><hr><p><a href="http://doc.minidown.cn/nfzhwn">2021-10-08</a></p><ul><li>相连、成环问题，都要想到可能和并查集有关</li><li>对于复杂的模拟过程题目，一定要自己在纸上把几种情况列出来，切忌脑测然后想出一个完全不合理的解决思路。</li></ul><p><a href="http://doc.minidown.cn/jnvvwv">2021-10-09</a></p><ul><li>字典树的使用和查询过程，切忌偷懒，不要漏了走到null节点结束查询的情况。</li><li>迷宫理论：  总共n种位置，走了2n步，则一定是死循环，无法走出（在博弈题里即平局）</li><li>动态规划，记得步长或者回合数是可以当状态的， 不要漏了这个，不要死脑筋只想着做状态压缩</li><li>位图状态压缩，力扣题几乎都是16位情况的压缩， 几乎不会出现32位以上的，超过这些，则考虑是否可以不需要记录走过的点之类的。</li></ul><p><a href="http://doc.minidown.cn/fatqmp">2021-10-10</a></p><ul><li>一组数字，如果只能加和减任意x，且要求最终相等， 他们必定互相之间的差值是x的倍数</li><li>求和问题、绝对值问题，注意最好先自己用数学公式推导一下，更容易快速理解思路，切忌胡思乱想</li></ul><hr><p><a href="http://doc.minidown.cn/kvplxk">2021-10-11</a></p><ul><li>交替复制的问题，可以使用双指针来做</li><li>优先队列：a是上面的点，b是下面的点（儿子节点），(a,b)返回大于0的时候，则交换</li><li>涉及排序变化，由数组A变成数组B的问题， 确定一下是否存在 ”稳定排序“，即不会跨相同数字变动， 能确定的话，就可以确定数组B中每个数字是由哪些位置的数字变化而来， 从而找到突破口</li></ul><hr><p><a href="http://doc.minidown.cn/giskpp">2021-10-15</a></p><ul><li>什么情况下Arrays.stream(数组)之后不需要boxed()？ 即不是int[]、long[]这种需要转包装类型才能变成list的情况</li><li>记忆一下.collect(Collectors.toList()))</li><li>滑动窗口， 建议先用for循环移动右边， 确定右边的位置后，再用while移动左边找到满足条件的左边界， 这样可以简化很多判断<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/d987e1f51885cc3c4a0c5d2b059a8e2ca5633145.png" alt="d987e1f51885cc3c4a0c5d2b059a8e2ca5633145"></li></ul><hr><p><a href="http://doc.minidown.cn/ibmlji">2021-10-16</a></p><ul><li>数组A和数组B个数相同，B里的每个值要通过+1、-1变成A时，需要的次数为 ”AB分别排序后，每个i位置的Math.abs(a[i] - b[i])总和“</li><li>即使心态不好， 也要仔细审题加看例子，不能不理会用例，错过用例很可能就理解错误导致gg</li><li>边比较少点比较多的情况时，如果要求最短路径， 则用bfs，不需要djkstra</li><li>bfs求最短路径时， 只需要newDis &lt; dis[node],再入队即可，且不需要做很多的vis判断。记住这个bfs求最短路<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/3c84111fe71f4a886bab0bd1b28816389c78b017.png" alt="3c84111fe71f4a886bab0bd1b28816389c78b017"></li></ul><hr><p><a href="http://doc.minidown.cn/lubjor">2021-10-17</a></p><ul><li>n个数小于16的时候， 如果题目涉及选或者不选，那么是可以直接暴力枚举出所有的情况的，不需要用dp缓存之类的。<br>利用下面的代码求某一位怎么用上，不需要vis数组或者while除2啥的很麻烦的那种</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">     <span class="comment">// 说明那个数字做过亦或，不需要vis数组</span></span><br><span class="line">     <span class="keyword">if</span> ( (i &amp; (<span class="number">1</span>&lt;&lt;j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 选中了nums[j]， 拿nums[j]做对应的操作;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li>某DAG点如果可以重复走，那么当你走到某个位置时，其最小路径和次小路径已可以在出现后确定，后面的情况斗则可以不用考虑。</li></ul><hr><p><a href="http://doc.minidown.cn/xacmxh/">2021-10-22</a></p><ul><li>字符串日期天数问题，可以直接取一个基线例如1971年来计算天数。</li><li>快速将map的key变成list的方式, 注意记忆.collect(Collectors.toList())：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; keyList = map.keySet().stream().collect(Collectors.toList())</span><br></pre></td></tr></table></figure><hr><p><a href="http://doc.minidown.cn/rubjpq">2021-10-23</a></p><ul><li>树的层序遍历打印不一定要用bfs， dfs也行的，就不用存object[]了。</li></ul><p><a href="http://doc.minidown.cn/jmcdff/">2021-10-24</a></p><ul><li>下次碰到复杂单词校验，如果正则忘记了，则直接上状态机，会简单很多。</li><li>状态变化设置不要放在枚举的构造器里做，初始化可能会出现null，如果顺序不对的话。放static块中做</li><li>注意Arrays.stream()不支持对char[]操作。</li><li>当遇到答案是乘起来或者很多数字加起来的时候， 最好直接改成long做计算，避免溢出。</li></ul><p><a href="http://doc.minidown.cn/dcugfw">2021-10-29</a></p><ul><li>链表转换题中，注意如果left和right会变化，则你原本想递归的东西可能会变动， 因此要提前缓存</li><li>Math.ceil（） 可以实现向上取整， floor向下取整</li><li>Math.log可以求 Math.log(a) /Math.log(b) 等同于loga（b）</li></ul><hr><p><a href="http://doc.minidown.cn/dcugfw">2021-10-30</a></p><ul><li>教训： 深度搜索时， 主要先确定层级，如果有n个东西必须做某件事，那就拿这东西做层级，中间for循环搜不同情况即可， 东西搜完了就说明符合条件</li><li>注意，涉及按时间在图上走的情况，是可以制造一个三维的图（数组），用时间做某一个维度即可避免冲突或者搞乱。</li></ul><hr><p>2021-11-21</p><ul><li>遇到边界问题很难受，不知道-1还是-0的，自己冷静下来模拟一下</li><li>1-9有9个<em>1位， 10-99的有90个</em>2位，   100-999有900个*3位， 问你第1000位是1-∞中的哪个数字。<br>这时候冷静处理闭上列出来    9个  180个  811个<br>811个中，分别是  100 101 102 103<br>让序号从0开始，则811-1 = 810， 然后用除法和取余即可。</li><li>注意要用到取余判断某位是什么时，记得序号从0开始</li></ul><hr><p>2021-11-22</p><ul><li>洗牌算法： 数组0-n，每次对n随机取余后，将对应位置的数字交换到最后一位，然后减少n，继续操作。</li><li>rand.nextInt()的范围是负无穷到正无穷， 如果rand.nextInt()%M， 则范围为-M 到M。 因此应该改成rand.nextInt(M)， 则范围为0-M-1</li></ul><p><a href="http://doc.minidown.cn/bsrxpi">2021-11-24</a></p><ul><li>stream中join的用法：.collect(Collectors.joining(“,”))，    而不是直接join</li><li>环形数组如果要求避免头尾相碰，  可以选择去掉头或者去掉尾，做2次， 就能不考虑环的问题了</li><li>动规、个数问题，优先考虑 dp[从i到末尾][某条件]  而非用区间去判断</li></ul><hr><p><a href="https://leetcode-cn.com/problems/boundary-of-binary-tree/submissions/">2021-11-25</a></p><ul><li>树的左边界、叶子、右边界问题，  如果时间紧急，用3次遍历解决即可。  如果追求代码精致， 则用2个标记，不断往下传递，根据情况变化，需要自己考虑好边界条件，慎用。<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/e0d7714912cb467741ce63ebb6430b7300a96e1e.png" alt="e0d7714912cb467741ce63ebb6430b7300a96e1e"></li></ul><hr><p><a href="https://leetcode-cn.com/problems/random-flip-matrix/">2021-11-26</a></p><ul><li>如果要求在10000*10000的数字中进行多次不重复的随机选取， 内存不够的情况下， 可以利用map映射，将已被选的数字和末尾数组数字进行映射。<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/4cb1e2e718d8888408ecc5093f3ba79375869d08.png" alt="4cb1e2e718d8888408ecc5093f3ba79375869d08"></li></ul><hr><p><a href="http://doc.minidown.cn/kiarwh">2021-11-28</a></p><ul><li>最大最小值问题，一定要注意如果最大最小是同一个值的情况</li><li>Math.abs(a-b)-1 误写成了 Math.abs(a-b-1)， 绝对值计算一定要注意-1是不是写错位置了</li><li>带条件的并查集（即满足条件才能相连）， 应当按时间顺序做尝试性连接， 连完后发现不符合条件，则要重置该节点的parent，避免后面连错。</li><li>并查集结果返回时，返回前的判断应该是 findParent(node) 是否满足而非parent[node]是否满足， 因为可能还没做压缩。</li></ul><hr><p><a href="http://doc.minidown.cn/lkizjq">2021-11-29</a></p><ul><li>迭代法前序遍历树： 往栈里放儿子时，直接倒序放入即可。</li><li>如果前面的信息可以利用，则考虑用滑动窗口，减少空间占用。（删掉一个元素以后全为 1 的最长子数组）</li><li>原地矩阵置0问题， 考虑用第一行和第一列来做临时存储，然后用标记变量判断第一列和第一行是否需要置0。</li></ul><hr><p><a href="http://doc.minidown.cn/vbvqcg/">2021-11-30</a></p><ul><li>数字不相邻排列问题，按数量从大到小插入，插入时先偶数位插入，再奇数位插入，则一定保证题目要求</li><li>统计子串中的唯一字串。碰到某些问x唯一的情况， 想办法从x的角度出发找唯一的串或者子序列。</li><li>想不到的时候，试着换一个维度去，原本是从a推b， 看下能否从b推a</li></ul><p><a href="https://leetcode-cn.com/problems/number-of-enclaves/">2021-12-01</a></p><ul><li>String自身按照字段序重新组合方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = str.toCharArray();</span><br><span class="line">Arrays.sort(cs);</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(cs).toString();</span><br></pre></td></tr></table></figure><ul><li>bfs题，注意y\x\ny\ny不要写错，每次写完检查一下<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/5f3365c64c94fd12501c5136b52bfca74ad582f6.png" alt="5f3365c64c94fd12501c5136b52bfca74ad582f6"></li></ul><p><a href="http://doc.minidown.cn/zwqvwy">2021-12-02</a></p><ul><li>求最长回文子串， 注意  i和前面某中心的对称节点j， 则j的回文长度信息是可以进行利用的。</li><li>全排列不一定要用dfs去搜索。因为 第4位时，它的可能性就是前面3位的可能性总和再拼上第四位。因此一直记录当前result全集， 然后走到第x位时，让第x位和result全集拼接，再生成一个新的result集合</li><li>k的子变量不要用kk， 同理不要用ii作为i的自变量， 很容易写错， 应该是indexK之类的，做到第一位不同，否则很容易写错。</li></ul><hr><p><a href="http://doc.minidown.cn/mvulve/">2021-12-04</a></p><ul><li>如果本来是可以利用哈希表，但要求原地算法的题目， 则可以考虑用数组本身作为哈希表</li><li>数组迭代期间不要试图取更新数组值，因为更新的话迭代的nums是会变的，并不是不变的。</li><li>涉及运算符的题目， 用switch+string的特性即可， 不用搞OP枚举，太容易错了</li><li>二维场景加？：表达式很容易漏加括号<br><img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/e0f19882380cf45d20ff05564b14a013cde11b8e.png" alt="e0f19882380cf45d20ff05564b14a013cde11b8e"></li><li>二维场景如果不想加边界判断， 可以用这种扩充边界思路， counts设置成 counts[m+2][n+2]， 然后坐标从1，1开始即可。</li></ul><hr><p><a href="http://doc.minidown.cn/nhyavd">2021-12-05</a></p><ul><li>简单题如果发现要很麻烦的dfs时，直接看下数据范围，确认能否从全集上去直接计算结果，而非从搜索去推导结果。</li><li>求公共祖先或者树点到树点路径， 除了向上求祖先之类的外， 还可以用前缀法， 即求出根到2个点的路径，去除相同前缀即可。</li><li>给一堆边，让你把他连成一条线（一笔画问题），且题目保证有借， 则考虑这是欧拉问题。 起点和终点是能明确的，直接用Hierholzer算法求。 具体见<a href>欧拉路径</a></li><li>即需要边搜索边删除’边’的情况， 可考虑存储边的迭代器引用后，再进行搜索</li></ul><hr><p><a href="http://doc.minidown.cn/cksuqu">2021-12-07</a></p><ul><li>括号的全排列问题， 可以用 (a)b的形式去利用a、b缓存逐步求解，不需要dfs</li><li>treeMap的floor 和celling总是记不清， floor——浮——水——    要找的值在水上，但是只有下面的水key</li></ul><hr><p><a href="http://doc.minidown.cn/ltmjvy">2021-12-09</a></p><ul><li>KMP算法的本质是[前缀-后缀]匹配算法， 后缀不匹配时，快速找到之前匹配部分的前缀位置。</li><li>是否可按线性跳跃到某点的问题，如果发现从后往前不好判断，会超时，则试着从前往后，根据当前最远到达位置判断， 有点类似于bfs。</li><li>a+b&gt;c时如果a+b可能溢出，则改成减法 a&gt;b-c</li></ul><p><a href="http://doc.minidown.cn/ppidmj/">2021-12-10</a></p><ul><li>不要做这种map.get()==map.get()的操作，高危操作。 Integer的==是引用。 要用equals。</li><li>滑动窗口中的个数匹配问题，用下面这种if-else去判断是+1还是-1。<br><img src="69541d637f6c32d66f7415fe3ea1026572937dd6.png" alt="69541d637f6c32d66f7415fe3ea1026572937dd6"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题日记 </category>
          
          <category> 2022年7月及以前 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
