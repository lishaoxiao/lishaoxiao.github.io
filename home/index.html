<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="破晓的知识屋">
<meta property="og:url" content="http://breakdawncoder.com/home/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/home/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/" class="post-title-link" itemprop="url">MYSQL语句调优手段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-23 00:47:49 / 修改时间：00:30:02" itemprop="dateCreated datePublished" datetime="2022-08-23T00:47:49+08:00">2022-08-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/23/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#cha-xun-wei-shi-me-hui-man">查询为什么会慢？</a></li>
<li><a href="#ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun">应用逻辑上处理低效查询</a>
<ul>
<li><a href="#ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju">应用层逻辑上，是不是返回了太多会被自己抛弃的数据</a></li>
<li><a href="#mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu">mysql中，是否在扫描额外的记录</a></li>
</ul>
</li>
<li><a href="#chong-gou-cha-xun-yu-ju">重构查询语句</a>
<ul>
<li><a href="#limit-qie-fen-cha-xun">limit切分查询</a></li>
<li><a href="#guan-lian-cha-xun-join-fen-jie">关联查询（join）分解</a></li>
<li><a href="#you-hua-in-cha-xun">优化In查询</a></li>
<li><a href="#you-hua-union-jia-limit">优化UNION加limit</a></li>
<li><a href="#suo-yin-he-bing-you-hua">索引合并优化</a></li>
<li><a href="#deng-zhi-chuan-di">等值传递</a></li>
<li><a href="#bing-xing-zhi-xing">并行执行？</a></li>
<li><a href="#ha-xi-guan-lian">哈希关联</a></li>
<li><a href="#song-san-suo-yin-sao-miao">松散索引扫描</a></li>
<li><a href="#zui-da-he-zui-xiao-zhi-you-hua">最大和最小值优化</a></li>
<li><a href="#tong-biao-cha-xun-he-geng-xin">同表查询和更新</a></li>
<li><a href="#you-hua-count">优化Count()</a></li>
<li><a href="#guan-lian-cha-xun-you-hua">关联查询优化</a></li>
<li><a href="#group-by-you-hua">Group by优化</a></li>
<li><a href="#you-hua-limit-fen-ye">优化LIMIT分页</a></li>
<li><a href="#ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye">如何知道是否有下一页?分多少页？</a></li>
<li><a href="#you-hua-union">优化UNION</a></li>
<li><a href="#shi-yong-zi-ding-yi-bian-liang-you-hua">使用自定义变量优化</a></li>
<li><a href="#yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua">用特殊关键字控制执行计划</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="cha-xun-wei-shi-me-hui-man">查询为什么会慢？</span><a href="#cha-xun-wei-shi-me-hui-man" class="header-anchor">#</a></h1>
<ul>
<li>查询的生命周期<br>
客户端发送-&gt;服务器接收-&gt;服务器解析sql-&gt;生成执行计划-&gt;执行-&gt;返回结果<br>
其中最耗时的就是执行了。</li>
<li>查询执行时耗费的时间：</li>
</ul>
<ol>
<li>网络</li>
<li>CPU计算</li>
<li>生成统计信息</li>
<li>锁等待</li>
<li>IO操作</li>
</ol>
<h1><span id="ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun">应用逻辑上处理低效查询</span><a href="#ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun" class="header-anchor">#</a></h1>
<h2><span id="ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju">应用层逻辑上，是不是返回了太多会被自己抛弃的数据</span><a href="#ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju" class="header-anchor">#</a></h2>
<p>这个主要和 返回的数据有关</p>
<ul>
<li>sql里写的是返回所有行， 却在代码里只取resultSet的前10行。</li>
<li>sql里写的是返回select *，  代码里却只需要特定几列。</li>
<li>每次查询肯定是相同的结果，却没有做缓存。</li>
</ul>
<h2><span id="mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu">mysql中，是否在扫描额外的记录</span><a href="#mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu" class="header-anchor">#</a></h2>
<p>这个主要和查询的过程有关（返回的数据已经优化到最优了)</p>
<ul>
<li>扫描的行数/返回的行数的比值越小越好</li>
<li>EXPLAIN分析中有几个type，从坏到好分别是</li>
</ul>
<ol>
<li>全表扫描All</li>
<li>索引扫描ref</li>
<li>范围扫描</li>
<li>唯一索引查询</li>
<li>常数引用<br>
EXPLANIN里会显示扫描的行数row， 你可以和返回的行数做对比</li>
</ol>
<ul>
<li>mysql中有3种方式来使用where条件，从好到坏分别是</li>
</ul>
<ol>
<li>在索引中直接做where判断来过滤，然后返回底层数据，这个需要在存储引擎层完成</li>
<li>索引覆盖扫描，直接在索引中返回数据，没有走到底层的数据处，这个在服务器层完成即可，不用走到底层存储引擎</li>
<li>先从存储引擎返回数据， 然后再在服务器层做where判断来过滤</li>
</ol>
<ul>
<li>为了减少扫描的行数，常见优化方式：</li>
</ul>
<ol>
<li>使用索引覆盖扫描</li>
<li>使用汇总表（就是每次做一些操作就会触发更新，不要再去重复查询了）</li>
<li>重写复杂查询(联结等）</li>
</ol>
<h1><span id="chong-gou-cha-xun-yu-ju">重构查询语句</span><a href="#chong-gou-cha-xun-yu-ju" class="header-anchor">#</a></h1>
<h2><span id="limit-qie-fen-cha-xun">limit切分查询</span><a href="#limit-qie-fen-cha-xun" class="header-anchor">#</a></h2>
<ul>
<li>指的是用limit等分页手段来切分，分多次执行</li>
<li>适用于一些可能会锁表的大批量操作。</li>
<li>比如删除某10w条数据， 最好先查询+limit 1w，分10次执行，中间间隔一些时间， 避免长时间的锁表。</li>
</ul>
<h2><span id="guan-lian-cha-xun-join-fen-jie">关联查询（join）分解</span><a href="#guan-lian-cha-xun-join-fen-jie" class="header-anchor">#</a></h2>
<ul>
<li>如果一个语句中join多次， 看下能不能在应用层分3个select依次执行，每次取前一次select的结果加入自己的条件中</li>
<li>好处：</li>
</ul>
<ol>
<li>分解后条件变简单了，就有可能利用mysql的缓存。</li>
<li>也因为条件变简单且是单表，可能会利用上索引</li>
<li>减少锁的竞争</li>
<li>每个表相当于只查询了一次， 减少了重复访问。</li>
</ol>
<h2><span id="you-hua-in-cha-xun">优化In查询</span><a href="#you-hua-in-cha-xun" class="header-anchor">#</a></h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> b <span class="keyword">where</span> b.xx<span class="operator">&lt;</span>y)</span><br></pre></td></tr></table></figure>
<p>注意上面并不是先计算in子表返回的内容，然后作为条件去做检查<br>
而是变成一个关联查询</p>
<p>select * from a where exist(select * from b where b.xx&lt;y and <a target="_blank" rel="noopener" href="http://a.id=b.id">a.id=b.id</a>))</p>
<p>会先对file表做全表扫描，然后再进行条件查询。这这会很慢</p>
<ul>
<li>改进：</li>
</ul>
<ol>
<li>用inner join改写成内联</li>
<li>用GROUP_CONCAT生成一个列表，再提供给IN去使用。<br>
P 224-225</li>
</ol>
<h2><span id="you-hua-union-jia-limit">优化UNION加limit</span><a href="#you-hua-union-jia-limit" class="header-anchor">#</a></h2>
<p>（select …） UNION ALL (select …) limit 20<br>
这句话本质上会把需要联合的表全部取出，做合并之后，再limit，如果表很大，limit相当于没有他本该的作用。<br>
可以改成 在内部都加上一个limit来减少union时的量</p>
<h2><span id="suo-yin-he-bing-you-hua">索引合并优化</span><a href="#suo-yin-he-bing-you-hua" class="header-anchor">#</a></h2>
<h2><span id="deng-zhi-chuan-di">等值传递</span><a href="#deng-zhi-chuan-di" class="header-anchor">#</a></h2>
<p>IN（）列表可能会被复制到关联的各个表中， 列表很大就会导致执行变慢</p>
<h2><span id="bing-xing-zhi-xing">并行执行？</span><a href="#bing-xing-zhi-xing" class="header-anchor">#</a></h2>
<p>mysql都是单线程进行查询</p>
<h2><span id="ha-xi-guan-lian">哈希关联</span><a href="#ha-xi-guan-lian" class="header-anchor">#</a></h2>
<ul>
<li>mysql不支持哈希关联， 关联都是通过 嵌套循环关联的。</li>
<li>除非用之前提过的自定义哈希索引部分（弄一个触发器来生成哈希索引）</li>
</ul>
<h2><span id="song-san-suo-yin-sao-miao">松散索引扫描</span><a href="#song-san-suo-yin-sao-miao" class="header-anchor">#</a></h2>
<p>指没有用到第一列索引，却需要用第二列索引时，按照下面的方式去查：<br>
<img src="/images/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/7276f16be3c71df35198c15d8fdcab0a8032bf14.png" alt="7276f16be3c71df35198c15d8fdcab0a8032bf14"><br>
select * from xxx where B = xxx group by A;<br>
添加 group by 字段后，会先根据 A 索引分组后，会在每个 A 的范围内使用索引进行快速查询定位所需要的 B 列，这就叫做松散索引扫描，比新建一个索引的效率会慢 A 的 distinct 倍，但省去了新索引的消耗</p>
<h2><span id="zui-da-he-zui-xiao-zhi-you-hua">最大和最小值优化</span><a href="#zui-da-he-zui-xiao-zhi-you-hua" class="header-anchor">#</a></h2>
<p>如果你MIN（）的是主键，且where中没有用到索引， 那么MYQL就进行全表顺序扫描。<br>
扫描时按理应当满足第一个可行的值时，就是最小值（主键按顺序排列）<br>
但是mysql不支持。<br>
可以用limit 1来优化，不要用MIN或者MAX， 如果你要统计的是主键的值的话。</p>
<h2><span id="tong-biao-cha-xun-he-geng-xin">同表查询和更新</span><a href="#tong-biao-cha-xun-he-geng-xin" class="header-anchor">#</a></h2>
<p>mysql不允许 在同一张表进行查询和更新<br>
<img src="/images/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/177fdc92efb7933bd40b061f64dc615480e891e7.png" alt="177fdc92efb7933bd40b061f64dc615480e891e7"></p>
<h2><span id="you-hua-count">优化Count()</span><a href="#you-hua-count" class="header-anchor">#</a></h2>
<ul>
<li>count(列或列的表达式) 会过滤掉无值或者null的情况。 而count(*)直接统计所有行数</li>
<li>count(*)的性能好一点， 因为他不用过滤和比较是否为空，可以直接用存储引擎记录的一些信息直接得到。</li>
<li>count(*) 不带where非常快，  如果带了where，就要遍历。</li>
<li>一种优化： 如果统计where id&gt;5， 而id&gt;5很多，&lt;5却很少，可以反向求接，改成<br>
select (select count(<em>) from city) - count(</em>) from t where id &lt; 5。<br>
毕竟不带where的是很快的。</li>
<li>如果对计数要求不是那么精确， 可以用汇总表去处理总和的问题，每隔一段时间更新一次。</li>
<li>注意这种用法<br>
select count(color=‘blue’ OR NULL) AS bule, count(color=‘red’ OR NULL) as red from items;<br>
可以求红色和蓝色的个数并展示在同一行中，无需分组。</li>
</ul>
<h2><span id="guan-lian-cha-xun-you-hua">关联查询优化</span><a href="#guan-lian-cha-xun-you-hua" class="header-anchor">#</a></h2>
<ul>
<li>确保ON或者USING的列上有索引</li>
<li>如果B join A， 那么A上有索引足够了。因为联结是是遍历B的每一行，拿B的joinKey 去A里面搜索，所以真正用到的是A的索引（除非执行计划做了优化）</li>
<li>优化GROUP BY 或者DISTINCT</li>
</ul>
<h2><span id="group-by-you-hua">Group by优化</span><a href="#group-by-you-hua" class="header-anchor">#</a></h2>
<ul>
<li>分组时，要么利用文件要么利用内存做临时表，你可以用优化器的提示去控制用内存还是文件</li>
<li>join后再分组， 分组里的列尽量用join的key，  比如你虽然是要按名字分组并栈式的，但名字和id是一一对应的，所以按id分组并展示名字是ok的</li>
<li>不要用分组去展示非分组列（即不是聚合结果也不是分组列）</li>
<li>分组时，会自动对分组后的结果按分组列排序，消耗一定时间。  如果不希望排序，可以加一个ORDER BY NULL</li>
</ul>
<h2><span id="you-hua-limit-fen-ye">优化LIMIT分页</span><a href="#you-hua-limit-fen-ye" class="header-anchor">#</a></h2>
<ul>
<li>对于“LIMIT 100000,10”     里面存在100000的偏移，而偏移本质上得扫描掉前面的100020条记录。</li>
<li>有3种优化方式：</li>
</ul>
<ol>
<li>构造一个联结临时表，临时表里做索引覆盖查询+limit（即select的只有limit列），然后再拿得到的id做联结，获取你需要的列。</li>
<li>如果确定是某个limit的范围，且为索引，则用where 索引范围来代替</li>
<li>或者where xx&lt;100020 ORDER BY XX DESC LIMIT 20来反向求。</li>
</ol>
<h2><span id="ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye">如何知道是否有下一页?分多少页？</span><a href="#ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye" class="header-anchor">#</a></h2>
<ol>
<li>LIMIT的时候加上SQL_CALC_FOUND_ROWS。这样会返回除去LIMIT之外的其他行数，相当于剩下还需要的行数。</li>
<li>每次LIMIT X+1， 应用层只拿X行， 如果有多一行，说明还有下一页</li>
<li>每次LIMIT 10X， 然后10X作为缓存，应用层每次取X作为一页展示。</li>
</ol>
<h2><span id="you-hua-union">优化UNION</span><a href="#you-hua-union" class="header-anchor">#</a></h2>
<ul>
<li>UNION的本质是创建并填充临时表</li>
<li>用UNION ALL， 否则会默认加上DISTINCT关键字进行唯一性检查，消耗性能</li>
</ul>
<h2><span id="shi-yong-zi-ding-yi-bian-liang-you-hua">使用自定义变量优化</span><a href="#shi-yong-zi-ding-yi-bian-liang-you-hua" class="header-anchor">#</a></h2>
<p>见6.4自定义变量</p>
<h2><span id="yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua">用特殊关键字控制执行计划</span><a href="#yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua" class="header-anchor">#</a></h2>
<ul>
<li>High_Priority/low_priority<br>
多个语句同时操作一个表时， 可以用这个来控制语句的优先级。</li>
<li>Delayed<br>
对插入和更新操作而言， 他会直接返回响应给客户端，然后把数据缓存下来，等服务器空闲了再去插</li>
<li>Straight_join<br>
可以用这个关键字控制 join顺序，而不是用优化器的join顺序</li>
<li>SQL_small_result<br>
告诉优化器 结果集很小，你可以搞个内存临时表做排序</li>
<li>SQL_big_result<br>
告诉优化器 结果集很大， 可以提早准备磁盘排序而不是等发现不够了采用磁盘。</li>
<li>SQL_CACHE<br>
结果集是否应该缓存。</li>
<li>SQL_CALC_FOUND_ROWS<br>
让返回的结果集包含更多信息（例如limit 10,结果集里却有个总数信息）</li>
<li>For update / Lock in share ode<br>
提示优化器加行锁</li>
<li>Use/ignore/force Index</li>
<li>告诉优化器要不要用索引，如果是force，即使where里没有索引，也会去用索引。 如果是ignore，则就是不用，傲娇</li>
<li>optimizer_search_depth<br>
dfs搜索计划时的最大深度</li>
<li>optimizer_prune_level<br>
根据扫描的行数来决定是否跳过执行计划？</li>
<li>optimizer_switch<br>
选择是否关闭某些优化器特性</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">MYSQL执行和内部优化原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 23:47:49" itemprop="dateCreated datePublished" datetime="2022-08-22T23:47:49+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 00:26:48" itemprop="dateModified" datetime="2022-08-23T00:26:48+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#mysql-zhi-xing-cha-xun-de-guo-cheng">mysql执行查询的过程</a>
<ul>
<li><a href="#yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li">一、客户端发查询请求到服务端之间的原理</a></li>
<li><a href="#er-you-xian-cha-xun-huan-cun">二、优先查询缓存</a></li>
<li><a href="#san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li">三、查询前做语句优化处理</a>
<ul>
<li><a href="#1-yu-fa-jie-xi-qi-he-yu-chu-li">1.语法解析器和预处理</a></li>
<li><a href="#2-cha-xun-you-hua-qi-chong-dian">2.查询优化器(重点）</a>
<ul>
<li><a href="#mysql-de-you-hua-lei-xing">mysql的优化类型</a></li>
</ul>
</li>
<li><a href="#3-shu-ju-he-suo-yin-de-tong-ji-xin-xi">3.数据和索引的统计信息</a></li>
<li><a href="#4-mysql-dui-guan-lian-cha-xun-de-zhi-xing">4.MYSQL对关联查询的执行</a></li>
<li><a href="#5-zhi-xing-shu-you-hua">5. 执行树优化</a></li>
<li><a href="#6-guan-lian-cha-xun-you-hua-qi">6. 关联查询优化器</a></li>
<li><a href="#7-pai-xu-you-hua">7.排序优化</a></li>
</ul>
</li>
<li><a href="#si-zhen-zheng-zhi-xing-cha-xun-ji-hua">四、真正执行查询计划</a></li>
<li><a href="#wu-fan-hui-jie-guo-gei-ke-hu-duan">五、返回结果给客户端</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="mysql-zhi-xing-cha-xun-de-guo-cheng">mysql执行查询的过程</span><a href="#mysql-zhi-xing-cha-xun-de-guo-cheng" class="header-anchor">#</a></h1>
<p><img src="/images/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/d07d12af7b4cd173bb9275fd8ef0e6e6ea2a8aca.png" alt="d07d12af7b4cd173bb9275fd8ef0e6e6ea2a8aca"></p>
<ol>
<li>客户端先发送查询语句给服务器</li>
<li>服务器检查缓存，如果存在则返回</li>
<li>进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划</li>
<li>根据执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端。</li>
</ol>
<p>下面是详解</p>
<h2><span id="yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li">一、客户端发查询请求到服务端之间的原理</span><a href="#yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li" class="header-anchor">#</a></h2>
<ul>
<li>客户端和服务端之间是半双工的， 即一个通道内只能一个在发一个接收， 不能同时互相发互相接收</li>
<li>客户端只会发送一个数据包给服务端，并不会在应用层拆成2个数据包去发（max_allowed_packet可以设置数据包最大长）， 这关系到sql语句不能太长。</li>
<li>服务端返回给客户端可以有多个数据包， 但是客户端必须完整接收，不能接到一半停掉连接或用连接去做其他事（UI界面可以操作，不同的线程）</li>
<li>例如java，如果没设置fetchSize，那么都是一次性把结果读进内存。当你使用resultSet的时候，其实已经全部进来了，而不是一条条从服务端获取。————使用fetch Size边读边处理的坏处： 服务端占用的资源时间变久了。</li>
</ul>
<p><strong>查询mysql服务此时的状态：</strong></p>
<p>使用 <em><strong>show full processlist</strong></em> 命令可以查看mysql服务端某些线程的状态</p>
<ul>
<li>Sleep  正在等待客户端发送新的请求</li>
<li>Query 正在执行查询， 或者发结果发给客户端</li>
<li>Locked  正在等待表锁（注意表锁是服务器层的， 而行锁是存储引擎层的，行锁时状态为query）</li>
<li>Analyzing and statistics  正在生成查询的计划或者收集统计信息</li>
<li>copying to tmp table  临时表操作，一般是正在做group by等操作</li>
<li>sorting result  正在对结果集做排序</li>
<li>sending data 正在服务器线程之间传数据</li>
</ul>
<h2><span id="er-you-xian-cha-xun-huan-cun">二、优先查询缓存</span><a href="#er-you-xian-cha-xun-huan-cun" class="header-anchor">#</a></h2>
<ul>
<li>缓存的查询在sql解析之前进行。</li>
<li>缓存的查找通过一个 对大小写敏感的哈希表实现，即直接比对sql字符串。</li>
<li>因此只要有一个字节不同，都不会匹配中。（毕竟还没开始解析，大小写什么的他也不知道要不要区分）</li>
<li>第7章中有更详细的查询缓存。</li>
</ul>
<h2><span id="san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li">三、查询前做语句优化处理</span><a href="#san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li" class="header-anchor">#</a></h2>
<h3><span id="1-yu-fa-jie-xi-qi-he-yu-chu-li">1.语法解析器和预处理</span><a href="#1-yu-fa-jie-xi-qi-he-yu-chu-li" class="header-anchor">#</a></h3>
<ul>
<li>这里就是把sql做解析， 变成一个解析树。解析时会做mysql语法规则验证。</li>
<li>语法解析器: 检查关键字错误、关键字顺序、引号匹配</li>
<li>预处理：和元数据关联校验， 检查数据表和列是否存在，解析名字和别名。</li>
<li>权限校验</li>
</ul>
<h3><span id="2-cha-xun-you-hua-qi-chong-dian">2.查询优化器(重点）</span><a href="#2-cha-xun-you-hua-qi-chong-dian" class="header-anchor">#</a></h3>
<ul>
<li>mysql可能会生成多种计划， 他会分别计算一个预测成本值，然后选一个成本最小的计划</li>
<li>计算信息来自于 表的页面个数、索引分布、长度、个数、数据行长度</li>
<li>因为多种原因，可能不会选择到最优的计划，有偏差</li>
<li>静态优化和动态优化的区别：<br>
静态优化类似“编译期优化”，只和语句结构有关，和具体值无关<br>
动态优化是在运行中去优化的，需要依赖索引行数、where取值，执行次数可能比静态优化要多。</li>
</ul>
<h4><span id="mysql-de-you-hua-lei-xing">mysql的优化类型</span><a href="#mysql-de-you-hua-lei-xing" class="header-anchor">#</a></h4>
<ul>
<li>关联表（join）的顺序可能会变</li>
<li>outer join可能会变成内连接</li>
<li>优化条件表达式， 例如 5=5 AND a&gt;5被简化成a&gt;5</li>
<li>优化MAX\MIN， 如果是MAX(索引），那么直接拿B+树的第一条或者最后一条即可。</li>
<li>当发现某个查询或者表达式的结果是可以提前计算出来的时候，就会优化成常数</li>
<li>索引覆盖，如果只要返回索引列，就不会走到最底层去。</li>
<li>子查询优化</li>
<li>提前终止查询（例如LIMIT）</li>
<li>等值传播： join中可能把左表的where 拿给右表一起用</li>
<li>IN(1,2,3,4,5,6)这个条件， 并不是简单遍历判断， 会先排序，然后用二分去判断是否存在。</li>
</ul>
<h3><span id="3-shu-ju-he-suo-yin-de-tong-ji-xin-xi">3.数据和索引的统计信息</span><a href="#3-shu-ju-he-suo-yin-de-tong-ji-xin-xi" class="header-anchor">#</a></h3>
<ul>
<li>统计信息是存储引擎去计算的，不同的存储引擎有不同的统计信息</li>
<li>服务器层生成查询计划时，会向存储引擎获取这些信息。</li>
</ul>
<h3><span id="4-mysql-dui-guan-lian-cha-xun-de-zhi-xing">4.MYSQL对关联查询的执行</span><a href="#4-mysql-dui-guan-lian-cha-xun-de-zhi-xing" class="header-anchor">#</a></h3>
<ul>
<li>join查询的本质其实是读取临时表做关联</li>
<li>例如a inner join b on <a target="_blank" rel="noopener" href="http://a.id=b.id">a.id=b.id</a> where a.xx=y</li>
</ul>
<ol>
<li>遍历a的每一行（此时a表本质上是 select * from a where a.xx=y）</li>
<li>在那行中a的id被定下来， 那么就会去获取一个临时表，临时表为（select * from b where <a target="_blank" rel="noopener" href="http://a.id">a.id</a> = id）</li>
<li>接着用这个临时表和a那一行拼接，输出多行。</li>
<li>然后再用这里的结果作为临时表，给更上层的关联去用（嵌套查询的含义）。</li>
</ol>
<ul>
<li>如果是left join，则就是临时表如果为空，则给a那一行拼接一个null。</li>
</ul>
<h3><span id="5-zhi-xing-shu-you-hua">5. 执行树优化</span><a href="#5-zhi-xing-shu-you-hua" class="header-anchor">#</a></h3>
<p><img src="/images/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/d8e575f3226ca6bd15ed537fc2af07a297ce5c7a.png" alt="d8e575f3226ca6bd15ed537fc2af07a297ce5c7a"></p>
<h3><span id="6-guan-lian-cha-xun-you-hua-qi">6. 关联查询优化器</span><a href="#6-guan-lian-cha-xun-you-hua-qi" class="header-anchor">#</a></h3>
<ul>
<li>join实际执行的顺序会关系到性能</li>
<li>例如a\b\c三个表关联， 可能先让a和b关联得到的临时表里的记录只有10条， 而如果让a和c先关联，会有10000条， 那么后面的效率就会截然不同</li>
<li>EXPLAIN EXTENDED可以展示关联的顺序</li>
<li>STRAIGHT_JOIN可以手动指定关联顺序</li>
<li>mysql自己会评估搜索一个最优的顺序， 但如果join表太多，则无法搜完所有结果（O(n!))， 那时候就会采用贪心。  是否使用贪心算法的边界值可以根据optimizer_seartch_depth去指定。</li>
</ul>
<h3><span id="7-pai-xu-you-hua">7.排序优化</span><a href="#7-pai-xu-you-hua" class="header-anchor">#</a></h3>
<ul>
<li>如果排序的量小，就用内存快速排序；如果排序的量大，就用文件排序</li>
<li>mysql有2种取排序数据的方式：</li>
</ul>
<ol>
<li>两次传输排序：  先取要排序的字段加行序号，按照字段排序好之后，再根据行索引一条条取读<br>
优点: 排序时占用内存小。<br>
缺点: 排序之后读的过程会很慢，根据行序号取读不是很方便</li>
<li>单次传输排序： 直接把行读出来（行里只有需要用的列，不一定是整行） ，然后排序<br>
优点: 把全部行读出来相当于顺序IO，读取速度快<br>
缺点: 可能会很大导致需要文件排序</li>
</ol>
<ul>
<li>关联查询order by的注意事项<br>
如果order by的列 <em><strong>都</strong></em> 来自关联的 <em><strong>第一张</strong></em>  表，则直接第一张表join的时候就排序了。<br>
除此之外！！ 都是全部join完，再排序！ 就算用了limit，也是全部join+排序后， 再limit的！</li>
</ul>
<h2><span id="si-zhen-zheng-zhi-xing-cha-xun-ji-hua">四、真正执行查询计划</span><a href="#si-zhen-zheng-zhi-xing-cha-xun-ji-hua" class="header-anchor">#</a></h2>
<ul>
<li>执行计划是一个数据结构</li>
</ul>
<h2><span id="wu-fan-hui-jie-guo-gei-ke-hu-duan">五、返回结果给客户端</span><a href="#wu-fan-hui-jie-guo-gei-ke-hu-duan" class="header-anchor">#</a></h2>
<ul>
<li>用tcp封包并逐步传送，而不是全部准备好再发送。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="post-title-link" itemprop="url">数据库分库分表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 23:46:49" itemprop="dateCreated datePublished" datetime="2022-08-22T23:46:49+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 00:22:02" itemprop="dateModified" datetime="2022-08-23T00:22:02+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#chui-zhi-fen-biao">垂直分表</a>
<ul>
<li><a href="#q-shi-me-shi-chui-zhi-fen-biao-yi-ban-zen-me-fen-de">Q： 什么是垂直分表？ 一般怎么分的？</a></li>
<li><a href="#q-shi-me-qing-kuang-xia-xu-yao-fen-biao-ti-sheng-shi-shi-me">Q: 什么情况下需要分表， 提升是什么？</a></li>
<li><a href="#q-wei-shi-me-da-zi-duan-de-xiao-lu-di-ni">Q ： 为什么大字段的效率低呢？</a></li>
</ul>
</li>
<li><a href="#shui-ping-fen-biao">水平分表</a>
<ul>
<li><a href="#q-chui-zhi-fen-biao-he-shui-ping-fen-biao-de-qu-bie">Q: 垂直分表和水平分表的区别？</a></li>
<li><a href="#q-shui-ping-fen-biao-de-hao-chu">Q: 水平分表的好处？</a></li>
</ul>
</li>
<li><a href="#chui-zhi-fen-ku">垂直分库</a>
<ul>
<li><a href="#q-yi-jing-zuo-liao-chui-zhi-fen-biao-liao-wei-shi-me-huan-yao-chui-zhi-fen-ku">Q: 已经做了垂直分表了，为什么还要垂直分库？</a></li>
<li><a href="#q-chui-zhi-fen-ku-de-hao-chu">Q: 垂直分库的好处</a></li>
</ul>
</li>
<li><a href="#shui-ping-fen-ku">水平分库</a>
<ul>
<li><a href="#q-ru-guo-shui-ping-fen-ku-hou-you-bu-gou-yong-liao-shu-ju-yao-zuo-qian-yi-ma-ji-zen-me-zuo-ping-hua-kuo-zhan">Q: 如果水平分库后，又不够用了，数据要做迁移吗？即怎么做平滑扩展</a></li>
<li><a href="#q-cong-ku-qian-yi-zhong-cong-ku-zhong-you-zhi-qian-bei-fen-de-shu-ju-zen-me-ban">Q: 从库迁移中， 从库中有之前备份的数据，怎么办？</a></li>
<li><a href="#q-yi-zhi-xing-ha-xi-you-liao-jie-ma-he-shui-ping-fen-ku-you-shi-me-guan-xi">Q: 一致性哈希有了解吗？ 和水平分库有什么关系？</a></li>
</ul>
</li>
<li><a href="#fen-ku-fen-biao-she-ji-wen-ti">分库分表设计问题</a>
<ul>
<li><a href="#q-fen-ku-fen-biao-hui-dai-lai-shi-me-fu-mian-ying-xiang">Q: 分库分表会带来什么负面影响？</a></li>
<li><a href="#q-na-ni-de-chan-pin-yao-yin-ru-fen-ku-fen-biao-de-hua-zen-me-shi-xian-zi-ji-xie-dai-ma-ma">Q: 那你的产品要引入分库分表的话， 怎么实现？ 自己写代码吗？</a></li>
<li><a href="#q-fen-ku-fen-biao-zhi-hou-quan-ju-qie-lian-xu-de-wei-yi-id-ru-he-sheng-cheng">Q: 分库分表之后，   全局且连续的唯一id如何生成？</a></li>
<li><a href="#q-fen-ku-fen-biao-zhi-hou-ke-neng-yi-ge-biao-bei-chai-cheng-duo-ge-biao-dan-shi-yuan-xian-mou-ge-ye-wu-cha-xun-sql-she-ji-liao-qi-zhong-de-duo-ge-tiao-jian-sou-suo-bian-de-fei-chang-man-ying-gai-zen-me-chu-li">Q: 分库分表之后， 可能一个表被拆成多个表， 但是原先某个业务查询sql涉及了其中的多个条件， 搜索变得非常慢，应该怎么处理？</a></li>
<li><a href="#q-chui-zhi-fen-biao-hou-ke-neng-hui-chan-sheng-rong-yu-biao-ji-fen-cheng-mai-jia-biao-he-mai-jia-biao-hou-ta-men-biao-li-du-xu-yao-ding-dan-xin-xi-yin-ci-ding-dan-xin-xi-xu-yao-tong-bu-2-ci-gei-2-ge-biao-zhe-ge-guo-cheng-ni-hui-ru-he-she-ji">Q: 垂直分表后， 可能会产生 冗余表，  即分成卖家表和买家表后，  他们表里都需要订单信息， 因此订单信息需要同步2次给2个表。  这个过程你会如何设计？</a></li>
<li><a href="#q-da-biao-zen-me-fen-ye-cha-xun">Q: 大表怎么分页查询？</a></li>
<li><a href="#q-fen-ku-fen-biao-hou-zen-me-zuo-fen-ye-cha-xun">Q: 分库分表后，怎么做分页查询？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="chui-zhi-fen-biao">垂直分表</span><a href="#chui-zhi-fen-biao" class="header-anchor">#</a></h1>
<h2><span id="q-shi-me-shi-chui-zhi-fen-biao-yi-ban-zen-me-fen-de">Q： 什么是垂直分表？ 一般怎么分的？</span><a href="#q-shi-me-shi-chui-zhi-fen-biao-yi-ban-zen-me-fen-de" class="header-anchor">#</a></h2>
<p>A:<br>
将一个表按照字段分成多表，每个表存储其中一部分字段。<br>
垂直分表原则：</p>
<ul>
<li>把不常用的字段单独放在一张表;</li>
<li>把text，blob等大字段拆分出来放在附表中;</li>
<li>经常组合查询的列放在一张表中;</li>
</ul>
<hr>
<h2><span id="q-shi-me-qing-kuang-xia-xu-yao-fen-biao-ti-sheng-shi-shi-me">Q: 什么情况下需要分表， 提升是什么？</span><a href="#q-shi-me-qing-kuang-xia-xu-yao-fen-biao-ti-sheng-shi-shi-me" class="header-anchor">#</a></h2>
<p>当有些字段内容比较大，且访问频次比较低时， 可能会导致表的大小非常大，但是用途很小。<br>
例如 商品信息表里， 商品详情表可能字段更多文字也更多，倾向于将详情表单独拆一个出来。 这样业务层可以在真正需要用到详情表的时候，再根据商品id去查就行了。</p>
<p>提升：<br>
1.为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响<br>
2.充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。</p>
<hr>
<h2><span id="q-wei-shi-me-da-zi-duan-de-xiao-lu-di-ni">Q ： 为什么大字段的效率低呢？</span><a href="#q-wei-shi-me-da-zi-duan-de-xiao-lu-di-ni" class="header-anchor">#</a></h2>
<p>A：</p>
<ol>
<li>由于数据量本身大，读取整行记录需要更长的读取时间；</li>
<li>跨页，页是数据库存储单位，很多查找及定位操作都是以页为单位，单页内的数据行越多数据库整体性能越好。而大字段占用空间大，单页内存储行数少，因此IO效率较低。</li>
<li>数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</li>
</ol>
<h1><span id="shui-ping-fen-biao">水平分表</span><a href="#shui-ping-fen-biao" class="header-anchor">#</a></h1>
<p><strong>水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</strong>	<br>
以商品表为例：<br>
商品信息及商品描述被分成了两套表。</p>
<ul>
<li>如果商品ID为双数，将此操作映射至商品信息1表；</li>
<li>如果商品ID为单数，将操作映射至商品信息2表。此操作要访问表名称的表达式为商品信息[商品ID%2 + 1]</li>
</ul>
<hr>
<h2><span id="q-chui-zhi-fen-biao-he-shui-ping-fen-biao-de-qu-bie">Q: 垂直分表和水平分表的区别？</span><a href="#q-chui-zhi-fen-biao-he-shui-ping-fen-biao-de-qu-bie" class="header-anchor">#</a></h2>
<p>A:<br>
垂直分表，是对字段列做划分。   而水平分表，是对数据行做划分。<br>
其实可以把表成下面这种结构，就明白垂直和水平的区别了<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/6b23dd1e12e6caf0d30c041053c2394121985e64.png" alt="6b23dd1e12e6caf0d30c041053c2394121985e64"><br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/5068231bca3cd42e8adcada6089c94b6aff2e510.png" alt="5068231bca3cd42e8adcada6089c94b6aff2e510"></p>
<hr>
<h2><span id="q-shui-ping-fen-biao-de-hao-chu">Q: 水平分表的好处？</span><a href="#q-shui-ping-fen-biao-de-hao-chu" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>优化单一表数据量过大而产生的性能问题</li>
<li>避免IO争抢并减少锁表的几率</li>
</ul>
<p>库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能。</p>
<hr>
<h1><span id="chui-zhi-fen-ku">垂直分库</span><a href="#chui-zhi-fen-ku" class="header-anchor">#</a></h1>
<p>和垂直分表类似， 只不过根据业务类型，将不同业务的表放到的不同的数据库<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/fdff28f7d2056a9764cd57d685fe3a5a2dced46f.png" alt="fdff28f7d2056a9764cd57d685fe3a5a2dced46f"></p>
<p><strong>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用</strong></p>
<hr>
<h2><span id="q-yi-jing-zuo-liao-chui-zhi-fen-biao-liao-wei-shi-me-huan-yao-chui-zhi-fen-ku">Q: 已经做了垂直分表了，为什么还要垂直分库？</span><a href="#q-yi-jing-zuo-liao-chui-zhi-fen-biao-liao-wei-shi-me-huan-yao-chui-zhi-fen-ku" class="header-anchor">#</a></h2>
<p>A:<br>
通过垂直分表性能得到了一定程度的提升，但是还没有达到要求， 当两类表的数据量持续增加时，磁盘空间肯定会不够，毕竟数据还是始终限制在一台服务器（例如用户和商品持续增长）。</p>
<p>即库内垂直分表只解决了单一表数据量过大的问题，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。</p>
<hr>
<h2><span id="q-chui-zhi-fen-ku-de-hao-chu">Q: 垂直分库的好处</span><a href="#q-chui-zhi-fen-ku-de-hao-chu" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>解决业务层面的耦合，业务清晰</li>
<li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</li>
<li>垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题。</li>
</ul>
<h1><span id="shui-ping-fen-ku">水平分库</span><a href="#shui-ping-fen-ku" class="header-anchor">#</a></h1>
<p>当业务上无法再进行垂直拆分时，但是库的容量不够时，就只能水平分库了。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/9c58b49fc2e06dcdee8de126e164e9729bac18ec.png" alt="9c58b49fc2e06dcdee8de126e164e9729bac18ec"><br>
<strong>水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上，但是不影响表结构</strong></p>
<hr>
<ul>
<li>例子：<br>
操作某条数据，先分析这条数据所属的店铺ID。如果店铺ID为双数，将此操作映射至RRODUCT_DB1(商品库1)；如果店铺ID为单数，将操作映射至RRODUCT_DB2(商品库2)。此操作要访问数据库名称的表达式为RRODUCT_DB[店铺ID%2 + 1]</li>
</ul>
<hr>
<p>好处：</p>
<ul>
<li>解决了单库大数据，高并发的性能瓶颈。</li>
<li>提高了系统的稳定性及可用性。</li>
</ul>
<hr>
<h2><span id="q-ru-guo-shui-ping-fen-ku-hou-you-bu-gou-yong-liao-shu-ju-yao-zuo-qian-yi-ma-ji-zen-me-zuo-ping-hua-kuo-zhan">Q:  如果水平分库后，又不够用了，数据要做迁移吗？即怎么做平滑扩展</span><a href="#q-ru-guo-shui-ping-fen-ku-hou-you-bu-gou-yong-liao-shu-ju-yao-zuo-qian-yi-ma-ji-zen-me-zuo-ping-hua-kuo-zhan" class="header-anchor">#</a></h2>
<p>A:<br>
<a target="_blank" rel="noopener" href="https://my.oschina.net/u/1859679/blog/1577049">水平分库如何做到平滑扩展</a></p>
<ol>
<li>停服迁移。<br>
适用于特定时间段用户几乎无法登录或者操作的产品，或者有权限控制用户不允许使用的。</li>
<li>从库升级。<br>
可以理解为原本作为容灾的从库， 直接升级为可以被哈希映射的主库， 加入到水平分库的哈希映射中。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/2a8096dba7c51d1d0346b0c6719af6c6b8f7592a.png" alt="2a8096dba7c51d1d0346b0c6719af6c6b8f7592a"></li>
<li>双写迁移<br>
用于未设置从库，或者必须新增更多的库时（从库一次只能*2）。</li>
</ol>
<ol>
<li>设置新的分片库，要求库内为空。 同时记录一下当前时间或者当前记录号。</li>
<li>业务层增加逻辑，将相同哈希的数据多写一份到新库（注意此时新库只能被写，但是不能被读）</li>
<li>将老记录通过工具迁移到新库，尽量全部迁移</li>
<li>迁移完成后，校验，确保两边已经完全一致(其实类似于生成了一个从库）</li>
<li>开放新的分片规则。 去除冗余数据。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%AE%B9/efb650d32882f059b32735a5142c68c14f0a8231.png" alt="efb650d32882f059b32735a5142c68c14f0a8231"></li>
</ol>
<hr>
<h2><span id="q-cong-ku-qian-yi-zhong-cong-ku-zhong-you-zhi-qian-bei-fen-de-shu-ju-zen-me-ban">Q: 从库迁移中， 从库中有之前备份的数据，怎么办？</span><a href="#q-cong-ku-qian-yi-zhong-cong-ku-zhong-you-zhi-qian-bei-fen-de-shu-ju-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
备份数据不影响使用，只要哈希正确，冗余数据不会干扰。<br>
但可以安排一个特定时间进行冗余数据清理， 且清理过程不会影响自己所映射的数据一致性。</p>
<hr>
<h2><span id="q-yi-zhi-xing-ha-xi-you-liao-jie-ma-he-shui-ping-fen-ku-you-shi-me-guan-xi">Q:  一致性哈希有了解吗？ 和水平分库有什么关系？</span><a href="#q-yi-zhi-xing-ha-xi-you-liao-jie-ma-he-shui-ping-fen-ku-you-shi-me-guan-xi" class="header-anchor">#</a></h2>
<p>A:<br>
如果是简单哈希， 上面提到的扩容中，可能一次变动就要所有的库都涉及迁移。<br>
但我可能只想增加一台呢？ 也要全部都变动吗？</p>
<p>为了尽可能少迁移，只迁移1-2个库，引入一致性哈希。 这样只要改动哈希空间中相邻的即可<br>
具体原理这里有提到<a target="_blank" rel="noopener" href="http://doc.minidown.cn/gmoqrq/">服务缓存设计</a></p>
<hr>
<h1><span id="fen-ku-fen-biao-she-ji-wen-ti">分库分表设计问题</span><a href="#fen-ku-fen-biao-she-ji-wen-ti" class="header-anchor">#</a></h1>
<h2><span id="q-fen-ku-fen-biao-hui-dai-lai-shi-me-fu-mian-ying-xiang">Q: 分库分表会带来什么负面影响？</span><a href="#q-fen-ku-fen-biao-hui-dai-lai-shi-me-fu-mian-ying-xiang" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>无法使用部分外键约束</li>
<li>多表join连接的sql查询，可能需要改造成多次单表查询（注意，分库分表场景下，尽量都用多次单表查询，可读性提高， 牺牲少数性能而已）</li>
<li>无法继续使用数据库自身提供的方法生成全局唯一id。</li>
</ul>
<hr>
<h2><span id="q-na-ni-de-chan-pin-yao-yin-ru-fen-ku-fen-biao-de-hua-zen-me-shi-xian-zi-ji-xie-dai-ma-ma">Q: 那你的产品要引入分库分表的话， 怎么实现？ 自己写代码吗？</span><a href="#q-na-ni-de-chan-pin-yao-yin-ru-fen-ku-fen-biao-de-hua-zen-me-shi-xian-zi-ji-xie-dai-ma-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不需要，有完善的分库分表中间件。<br>
Shark、mycat、tddl。</p>
<p>以shark为例 ，  shark依赖于spring，  只需要通过依赖注入方式配置shark的各种属性、分库分表路由算法，即可使用<br>
业务层调用dao的代码不需要任何变化。<br>
基于AOP拦截jdbcTemplate中除了batch()方法以外的所有读/写方法<br>
利用druid的sqlparse完成sql语句的解析工作。</p>
<hr>
<h2><span id="q-fen-ku-fen-biao-zhi-hou-quan-ju-qie-lian-xu-de-wei-yi-id-ru-he-sheng-cheng">Q:  分库分表之后，   全局且连续的唯一id如何生成？</span><a href="#q-fen-ku-fen-biao-zhi-hou-quan-ju-qie-lian-xu-de-wei-yi-id-ru-he-sheng-cheng" class="header-anchor">#</a></h2>
<p>A:<br>
如果不考虑连续，  则生成时结合uuid、机器ip、时间戳等多个维度因素生成即可。<br>
如果要考虑连续，有两种方式</p>
<ol>
<li>利用分表中间件的id生成器， 例如shark，可以配置一个单点id数据库，  需要id时， 应用里的shark会去这个id数据库申请一批id， 缓存在本地。<br>
利用了行锁保证了并发环境下的数据一致性。</li>
<li>建立一个id生成服务，  需要的时候走这个单点服务去申请（单点服务自身有个mysql），代价比较大。</li>
</ol>
<hr>
<h2><span id="q-fen-ku-fen-biao-zhi-hou-ke-neng-yi-ge-biao-bei-chai-cheng-duo-ge-biao-dan-shi-yuan-xian-mou-ge-ye-wu-cha-xun-sql-she-ji-liao-qi-zhong-de-duo-ge-tiao-jian-sou-suo-bian-de-fei-chang-man-ying-gai-zen-me-chu-li">Q: 分库分表之后， 可能一个表被拆成多个表， 但是原先某个业务查询sql涉及了其中的多个条件， 搜索变得非常慢，应该怎么处理？</span><a href="#q-fen-ku-fen-biao-zhi-hou-ke-neng-yi-ge-biao-bei-chai-cheng-duo-ge-biao-dan-shi-yuan-xian-mou-ge-ye-wu-cha-xun-sql-she-ji-liao-qi-zhong-de-duo-ge-tiao-jian-sou-suo-bian-de-fei-chang-man-ying-gai-zen-me-chu-li" class="header-anchor">#</a></h2>
<p>A:<br>
可以把数据导入到solr中， 让solr进行分词搜索。<br>
另外如果有比较耗时的like查询，也可以导入给solr让solr做like模糊查询。</p>
<hr>
<h2><span id="q-chui-zhi-fen-biao-hou-ke-neng-hui-chan-sheng-rong-yu-biao-ji-fen-cheng-mai-jia-biao-he-mai-jia-biao-hou-ta-men-biao-li-du-xu-yao-ding-dan-xin-xi-yin-ci-ding-dan-xin-xi-xu-yao-tong-bu-2-ci-gei-2-ge-biao-zhe-ge-guo-cheng-ni-hui-ru-he-she-ji">Q:   垂直分表后， 可能会产生 冗余表，  即分成卖家表和买家表后，  他们表里都需要订单信息， 因此订单信息需要同步2次给2个表。  这个过程你会如何设计？</span><a href="#q-chui-zhi-fen-biao-hou-ke-neng-hui-chan-sheng-rong-yu-biao-ji-fen-cheng-mai-jia-biao-he-mai-jia-biao-hou-ta-men-biao-li-du-xu-yao-ding-dan-xin-xi-yin-ci-ding-dan-xin-xi-xu-yao-tong-bu-2-ci-gei-2-ge-biao-zhe-ge-guo-cheng-ni-hui-ru-he-she-ji" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>
<p>自己在业务层实现双写逻辑。  订单服务写入买家表之前， 把卖家表的请求扔给异步消息队列， 这样就是一边异步一边同步，加快速度。<br>
而卖家表如果插入成功了， 就再发一个响应消息给消息队列， 订单服务消费到这个响应后，才能确认写入成功，短时间内收不到则就进行数据补偿类似于重发。 （也叫线上检测补偿）</p>
</li>
<li>
<p>借助某些已经实现的中间件做mysql数据库的binlog增量同步。（阿里的canal）。<br>
它会伪装salve节点，向master节点索要binlog， 然后解析binlog后，完成冗余表的数据增量同步，就不需要业务层写代码了，配置canal中间件即可。</p>
</li>
</ol>
<hr>
<h2><span id="q-da-biao-zen-me-fen-ye-cha-xun">Q: 大表怎么分页查询？</span><a href="#q-da-biao-zen-me-fen-ye-cha-xun" class="header-anchor">#</a></h2>
<p>A:<br>
给时间加索引，然后利用offset+limit即可<br>
select * from t_msg order by time offset 200 limit 100</p>
<hr>
<h2><span id="q-fen-ku-fen-biao-hou-zen-me-zuo-fen-ye-cha-xun">Q: 分库分表后，怎么做分页查询？</span><a href="#q-fen-ku-fen-biao-hou-zen-me-zuo-fen-ye-cha-xun" class="header-anchor">#</a></h2>
<p>以offset 900 limit 60，  3个库为例<br>
A:<br>
4种方法。</p>
<ol>
<li>
<p>全局视野法<br>
用于数据量不大的情况<br>
每次直接取limit 960， 然后在服务端进行排序后手动算出offset 900的位置。</p>
</li>
<li>
<p>禁止跳页。<br>
只提供下一页。这也可以用全局视野拿到第一页后， 记录此时选到的时间。<br>
下一页的时候， 用3个库里记录的那个时间做排序再去取第二页即可。</p>
</li>
<li>
<p>模糊查询<br>
当数据获取要求的精确度不高，且数据确定是均匀分布的<br>
则直接按offset 300 limit 20去取3份合成一页即可。</p>
</li>
<li>
<p>二次查询法<br>
比较复杂。</p>
</li>
</ol>
<ul>
<li>① 先分别offset 300 limit 60， 得到3份数据。</li>
<li>② 得到3份数据中的最小时间tmin， 这个时间的前面300份是可以被“肯定的”</li>
<li>③ 记录另外2个库（就是没取到最小时间的那2个）的时间最大值tmax1, tmax2</li>
<li>④ 按  time&gt;tmin and time &lt; tmax1   和   time&gt;tmin and time&lt;tmax2  的where索引查询再取2份数据。</li>
<li>⑤ 这也就能知道tmin 在3个库里的相对位置是多少了，  例如在库1里排300名，在库2里排250名， 在库3里排270名。</li>
<li>⑥ timin排820名，而刚才取的数据合并起来后，再取个80条，就能找到limit 900的位置了。<br>
也有缺点， 就是极端情况下还是不太好用，例如库2和库3的分布机器不均匀。<br>
<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/architectroad/architectroad-cross-database-paging.html">业界难题-“跨库分页”的四种方案</a></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44062339/article/details/100491744">彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">数据库三种日志原理详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 23:46:49" itemprop="dateCreated datePublished" datetime="2022-08-22T23:46:49+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 00:16:10" itemprop="dateModified" datetime="2022-08-23T00:16:10+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#shu-ju-ku-ri-zhi-fen-lei">数据库日志分类</a>
<ul>
<li><a href="#q-shu-ju-ku-you-na-san-chong-log">Q: 数据库有哪三种log？</a></li>
<li><a href="#q-binlog-he-relog-du-you-na-xie-qu-bie-ni">Q: binlog和relog都有哪些区别呢？</a></li>
</ul>
</li>
<li><a href="#relog">relog</a>
<ul>
<li><a href="#q-relog-shua-ri-zhi-dao-ci-pan-you-na-ji-chong-fang-shi">Q: relog刷日志到磁盘有哪几种方式？</a></li>
<li><a href="#q-relog-ri-zhi-kuai-de-ge-shi-shi-zen-me-yang-de">Q: relog日志块的格式是怎么样的？</a></li>
</ul>
</li>
<li><a href="#binlog">binlog</a>
<ul>
<li><a href="#q-binlog-de-ge-shi-you-shi-zen-me-yang-de">Q: binlog的格式又是怎么样的？</a></li>
</ul>
</li>
<li><a href="#undolog">undolog</a>
<ul>
<li><a href="#q-undolog-de-ri-zhi-ge-shi">Q: undolog的日志格式？</a></li>
<li><a href="#q-checkpoint-shi-zuo-shi-me-de">Q: checkpoint是做什么的？</a></li>
<li><a href="#q-lsn-cheng-wei-ri-zhi-de-luo-ji-xu-lie-hao-ju-ti-shi-zen-me-sheng-xiao-de">Q: LSN称为日志的逻辑序列号, 具体是怎么生效的？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="shu-ju-ku-ri-zhi-fen-lei">数据库日志分类</span><a href="#shu-ju-ku-ri-zhi-fen-lei" class="header-anchor">#</a></h1>
<h2><span id="q-shu-ju-ku-you-na-san-chong-log">Q: 数据库有哪三种log？</span><a href="#q-shu-ju-ku-you-na-san-chong-log" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>
<p>redo log<br>
和大多数关系型数据库一样，InnoDB记录了对数据文件的物理更改，并保证总是<strong>日志先行</strong>，也就是所谓的WAL<br>
即在持久化数据文件前，保证之前的redo日志已经写到磁盘。<br>
mysql重新启动时会检查redo log的日志，把由于mysql异常退出导致没有刷新到磁盘的数据页从redo log中恢复。<br>
innodb_log_group_home_dir表示redo log的目录；innodb_log_file_size表示redo log文件的大小；innodb_log_files_in_group表示redo log文件个数。<br>
redo log文件以ib_logfile[number]命名。</p>
</li>
<li>
<p>undo log<br>
为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方就是undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用undo Log中的备份将数据恢复到事务开始之前的状态。<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/p/9010872.html">详细分析MySQL事务日志(redo log和undo log)</a></p>
</li>
<li>
<p>bin log(二进制日志）<br>
记录sql语句，可用于主从复制。<br>
二进制日志只在事务提交的时候一次性写入(基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入<br>
[查询日志、二进制日志详解](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/p/9001061.html">https://www.cnblogs.com/f-ck-need-u/p/9001061.html</a></p>
</li>
</ul>
<hr>
<h2><span id="q-binlog-he-relog-du-you-na-xie-qu-bie-ni">Q: binlog和relog都有哪些区别呢？</span><a href="#q-binlog-he-relog-du-you-na-xie-qu-bie-ni" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>层次不同。<br>
bin二进制日志是在存储引擎的上层产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改</li>
<li>记录的东西不同。<br>
二进制日志记录操作的方法是逻辑性的语句。本质也还是逻辑的SQL设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中具体到每个页的修改。</li>
<li>写日志的时机不同。<br>
二进制日志只在每次事务提交的时候一次性写入缓存中的日志&quot;文件&quot;(对于非事务表的操作，则是每次执行语句成功后就直接写入)。<br>
而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作</li>
<li>一次事务生成的日志记录数不同。<br>
二进制日志一次提交对应一次记录。<br>
而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。</li>
</ol>
<blockquote>
<p>例如事务T1，可能在redo log中记录了 T1-1,T1-2,T1-3，T1* 共4个操作，其中 T1* 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1* 对应的操作结果</p>
</blockquote>
<ol start="5">
<li>幂等性不同<br>
二进制日志不具有幂等性。重复执行多次会造成数据错误。<br>
redolog具有幂等性， 因为始终是对页做覆盖，不会出错</li>
</ol>
<hr>
<h1><span id="relog">relog</span><a href="#relog" class="header-anchor">#</a></h1>
<p>relog刷磁盘时，存在应用层logBuffer、 操作系统层面的buffer、日志文件。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/408b231580c2619c1e253d461789312de00d6bd5.png" alt="408b231580c2619c1e253d461789312de00d6bd5"></p>
<h2><span id="q-relog-shua-ri-zhi-dao-ci-pan-you-na-ji-chong-fang-shi">Q: relog刷日志到磁盘有哪几种方式？</span><a href="#q-relog-shua-ri-zhi-dao-ci-pan-you-na-ji-chong-fang-shi" class="header-anchor">#</a></h2>
<p>A:<br>
MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1</p>
<ul>
<li>当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。。</li>
<li>当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</li>
<li>当设置为2的时候，每次提交都写入到os buffer，并且是每秒调用fsync()将os buffer中的日志写入到log file on disk。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/47fae1c3b36b7192457b99d4a8ea432bf05b7117.png" alt="47fae1c3b36b7192457b99d4a8ea432bf05b7117"></li>
</ul>
<hr>
<h2><span id="q-relog-ri-zhi-kuai-de-ge-shi-shi-zen-me-yang-de">Q: relog日志块的格式是怎么样的？</span><a href="#q-relog-ri-zhi-kuai-de-ge-shi-shi-zen-me-yang-de" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>redo log以块为单位进行存储的，每个块占512字节，这称为redo log block。（不管是log buffer中还是os buffer中以及redo log file on disk中，都是这样以512字节的块存储的）</li>
<li>组成部分：</li>
</ul>
<ol>
<li>日志块头（包含buffer中的位置id、已记录log大小、涉及分拆日志块时的偏移位置、检查点信息）</li>
<li>日志块尾</li>
<li>日志主体<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/c1feeeef68511ecef418c32a6113910de4bbb137.png" alt="c1feeeef68511ecef418c32a6113910de4bbb137"></li>
</ol>
<blockquote>
<blockquote>
<p>有时候一个数据页产生的日志量超出了一个日志块，这是需要用多个日志块来记录该页的相关日志。例如，某一数据页产生了552字节的日志量，那么需要占用两个日志块，第一个日志块占用492字节，第二个日志块需要占用60个字节，那么对于第二个日志块来说，它的第一个log的开始位置就是73字节(60+12)</p>
</blockquote>
</blockquote>
<hr>
<h1><span id="binlog">binlog</span><a href="#binlog" class="header-anchor">#</a></h1>
<h2><span id="q-binlog-de-ge-shi-you-shi-zen-me-yang-de">Q: binlog的格式又是怎么样的？</span><a href="#q-binlog-de-ge-shi-you-shi-zen-me-yang-de" class="header-anchor">#</a></h2>
<p>A:<br>
mysql binlog日志有三种格式，分别为Statement,MiXED,以及ROW！<br>
可以用命令查看自己的mysql用的是什么模式。</p>
<ul>
<li>
<p>statement  只记录更新的sql语句<br>
缺点：<br>
像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题</p>
</li>
<li>
<p>Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改，仅需要记录那一条记录被修改成什么了。<br>
一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大</p>
</li>
<li>
<p>Mixedlevel：以上两种level的混合使用。MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种</p>
</li>
</ul>
<p>Mysql默认是使用Statement日志格式，推荐使用MIXED.</p>
<hr>
<h1><span id="undolog">undolog</span><a href="#undolog" class="header-anchor">#</a></h1>
<h2><span id="q-undolog-de-ri-zhi-ge-shi">Q: undolog的日志格式？</span><a href="#q-undolog-de-ri-zhi-ge-shi" class="header-anchor">#</a></h2>
<p>A:<br>
对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型<br>
一种是 INSERT_UNDO（INSERT操作），记录插入的唯一键值；<br>
一种是 UPDATE_UNDO（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。<br>
因此update/delete操作的undolog数据会比insert操作的数据多<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/c1a931eb22c5bddff24bac883b757d7f04b76e12.png" alt="c1a931eb22c5bddff24bac883b757d7f04b76e12"></p>
<hr>
<h2><span id="q-checkpoint-shi-zuo-shi-me-de">Q:  checkpoint是做什么的？</span><a href="#q-checkpoint-shi-zuo-shi-me-de" class="header-anchor">#</a></h2>
<p>A:<br>
“检查点”会创建一个已知的正常点，在意外关闭或崩溃后进行恢复的过程中， SQL Server 数据库引擎 可以从该点开始应用日志中所包含的更改。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaobluesky/article/details/50285775">检查点（Checkpoint）的本质</a></p>
<hr>
<h2><span id="q-lsn-cheng-wei-ri-zhi-de-luo-ji-xu-lie-hao-ju-ti-shi-zen-me-sheng-xiao-de">Q: LSN称为日志的逻辑序列号, 具体是怎么生效的？</span><a href="#q-lsn-cheng-wei-ri-zhi-de-luo-ji-xu-lie-hao-ju-ti-shi-zen-me-sheng-xiao-de" class="header-anchor">#</a></h2>
<p>A:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/22/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-22/" class="post-title-link" itemprop="url">2022-0822</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 23:12:42" itemprop="dateCreated datePublished" datetime="2022-08-22T23:12:42+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 00:12:00" itemprop="dateModified" datetime="2022-08-23T00:12:00+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">刷题日记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022%E5%B9%B48%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2022年8月</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/22/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-22/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/22/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-22/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#di-yi-ti-zhan-de-ying-yong">第一题:栈的应用</a></li>
<li><a href="#di-er-ti-bfs">第二题:bfs</a></li>
<li><a href="#di-san-ti-ha-xi-biao-yi-ji-shu-ju-fan-wei-que-ren-xi-guan">第三题:哈希表以及数据范围确认习惯</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="di-yi-ti-zhan-de-ying-yong">第一题:栈的应用</span><a href="#di-yi-ti-zhan-de-ying-yong" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks-lcci/submissions/">面试题 03.04. 化栈为队 - 力扣（LeetCode）</a></p>
<p><img src="/images/2022-08-22/1661184354147.png" alt="1661184354147"></p>
<p>要出队或者要用到队头的时候，移动到另一个栈里，就能反向取了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty()) &#123;</span><br><span class="line">            q2.push(q1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> q2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty()) &#123;</span><br><span class="line">            q2.push(q1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() &amp;&amp; q2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1><span id="di-er-ti-bfs">第二题:bfs</span><a href="#di-er-ti-bfs" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染 - 力扣（LeetCode）</a></p>
<p><img src="/images/2022-08-22/1661184446769.png" alt="1661184446769"></p>
<p>一个简单题，我用bfs写了半天，确实累，是不是应该搞点bfs的模板了？下次比赛直接用上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] floodFill(<span class="type">int</span>[][] image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color) &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ylen</span> <span class="operator">=</span> image.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xlen</span> <span class="operator">=</span> image[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[ylen][xlen];</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;sr,sc&#125;);</span><br><span class="line">        vis[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startColor</span> <span class="operator">=</span> image[sr][sc];</span><br><span class="line">        image[sr][sc] = color;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] p = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> p[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> dir[<span class="number">0</span>] + y;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> dir[<span class="number">1</span>] + x;</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= xlen || ny &gt;= ylen || vis[ny][nx]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (startColor != image[ny][nx]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[ny][nx]= <span class="literal">true</span>;</span><br><span class="line">                image[ny][nx] = color;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ny, nx&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="di-san-ti-ha-xi-biao-yi-ji-shu-ju-fan-wei-que-ren-xi-guan">第三题:哈希表以及数据范围确认习惯</span><a href="#di-san-ti-ha-xi-biao-yi-ji-shu-ju-fan-wei-que-ren-xi-guan" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-unique-lcci/">面试题 01.01. 判定字符是否唯一 - 力扣（LeetCode）</a></p>
<p><img src="/images/2022-08-22/1661184586227.png" alt="1661184586227"></p>
<p>看起来很简单，直接一个数组搞定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnique</span><span class="params">(String astr)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: astr.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[c-<span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[c-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这题究竟想考察什么呢？ 看一下下面这段话：</p>
<blockquote>
<p>如果我是面试官，会考虑主要考察什么，就我的工作经验看，大多数主要是招聘工程师的，面试者如果什么问题都没有，直接写个二重循环搞定，会首先给个50分，如果能写点判断字符串是否为null的，60分。</p>
<p>直接上手什么bitset，什么位运算的，我会先问他，题目中有没有交代字符串的字符一定是26个英文字母？如果是unicode环境，你是不是要准备2^16/8个字节的空间？在实际项目中，风险可控，结果可期更重要，绝大多数时候不在乎那点时间和资源。</p>
<p>所以我期望面试者不要急于解答，我希望他先问我问题：</p>
<ol>
<li>字符串的字符范围，如果我告诉他，26个小写英文字母，那可能一开头直接判断如果字符长度&gt;26, 直接返回False，做到这一点的，80分</li>
<li>如果我告诉他ascii字符集，然后他的代码里有边界检查，并且针对不同的范围有不同的侧重点，比如说ascii字符集，那也就是128个可能性，16个字节的位运算比较好</li>
<li>如果我告诉他是unicode，没有字符范围，老老实实排序再判断是比较符合我对工程师的要求的，因为算法性能稳定，没有额外资源要求，一眼看出没什么不可预见的风险，100分。</li>
</ol>
<p>就是说，有些东西，没想到或者一时没想到根本不是问题，日常工作中稍微提示一下即可，但是缜密的思维对于程序员来说更重要。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/22/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BB%84%E5%90%88%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BB%84%E5%90%88%E6%95%B0/" class="post-title-link" itemprop="url">组合数（排列组合）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 23:12:42" itemprop="dateCreated datePublished" datetime="2022-08-22T23:12:42+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 00:03:49" itemprop="dateModified" datetime="2022-08-23T00:03:49+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/22/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BB%84%E5%90%88%E6%95%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/22/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%BB%84%E5%90%88%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>705</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#c-k-n-de-o-min-k-n-k-jie-fa">C（k,n)的O(Min(k,n-k)）解法：</a></li>
<li><a href="#yang-hui-san-jiao-da-biao-fa">杨辉三角打表法：</a>
<ul>
<li><a href="#ru-guo-yong-o-n-de-fu-za-du-o-1-de-kong-jian-qiu-jie-c-n-m">如果用O(N)的复杂度，O（1）的空间求解C(n,m)?</a></li>
</ul>
</li>
<li><a href="#chao-da-zu-he-shu-she-ji-qu-yu">超大组合数（涉及取余）</a></li>
<li><a href="#xiang-guan-ti-mu">相关题目</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="c-k-n-de-o-min-k-n-k-jie-fa">C（k,n)的O(Min(k,n-k)）解法：</span><a href="#c-k-n-de-o-min-k-n-k-jie-fa" class="header-anchor">#</a></h1>
<p>快速回想组合数解法：<br>
C(8,3) = 8 * 7 * 6 /(321) = 6 / 1 * 7 / 2 * 8 / 3<br>
即分子和分母的个数是一样的<br>
然后你要从小的开始逐步做乘和除的操作，就能求出来了，且一定能保证整除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// y/x * (y+1)/(x+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> k+<span class="number">1</span>, x= <span class="number">1</span>;y&lt;=n &amp;&amp; x&lt;=k;y++,x++) &#123;</span><br><span class="line">        <span class="comment">// (result*y)一定能被x整除</span></span><br><span class="line">        result = (result * y) / x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="yang-hui-san-jiao-da-biao-fa">杨辉三角打表法：</span><a href="#yang-hui-san-jiao-da-biao-fa" class="header-anchor">#</a></h1>
<p>如果空间没要求， 但是要求每次快速获取，则可以用杨辉三角提前打表<br>
<img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/5f59a1dcf0b46aa3f87ac7f2be142b73b028938a.png" alt="5f59a1dcf0b46aa3f87ac7f2be142b73b028938a"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">		c[i][j]=(c[i-<span class="number">1</span>][j]+c[i-<span class="number">1</span>][j-<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>``</p>
<h2><span id="ru-guo-yong-o-n-de-fu-za-du-o-1-de-kong-jian-qiu-jie-c-n-m">如果用O(N)的复杂度，O（1）的空间求解C(n,m)?</span><a href="#ru-guo-yong-o-n-de-fu-za-du-o-1-de-kong-jian-qiu-jie-c-n-m" class="header-anchor">#</a></h2>
<p>杨辉三角里，某行某列的值等同于C(n,m)<br>
<img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/bfd6af87785723cdb1ec6016b0af14e01ccc863a.png" alt="bfd6af87785723cdb1ec6016b0af14e01ccc863a"><br>
<img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/8fb6b5d2b9e4533c76fab309ba111ce6762fab7b.png" alt="8fb6b5d2b9e4533c76fab309ba111ce6762fab7b"></p>
<p>因此可以很短的复杂度得到值<br>
也可以缓存<br>
<img src="/images/%E7%BB%84%E5%90%88%E6%95%B0/38d0ada716a6c8ab7289296c68d19f3c264c86db.png" alt="38d0ada716a6c8ab7289296c68d19f3c264c86db"></p>
<h1><span id="chao-da-zu-he-shu-she-ji-qu-yu">超大组合数（涉及取余）</span><a href="#chao-da-zu-he-shu-she-ji-qu-yu" class="header-anchor">#</a></h1>
<p>超纲题</p>
<ul>
<li>乘法逆元+快速幂+阶乘</li>
<li>Lucas定理</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45404210/article/details/96422543">总结组合数的几种求法（模板）</a></p>
<hr>
<h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径 需要空间为1时，必须用组合数</a><br>
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II O(1)空间求某行某列，用组合数性质</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">数据库索引详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-21 23:46:49 / 修改时间：23:56:11" itemprop="dateCreated datePublished" datetime="2022-08-21T23:46:49+08:00">2022-08-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#suo-yin-de-ji-ben-gai-nian">索引的基本概念</a>
<ul>
<li><a href="#suo-yin-de-you-dian">索引的优点</a></li>
<li><a href="#suo-yin-lei-xing">索引类型</a>
<ul>
<li><a href="#ha-xi-suo-yin">哈希索引</a>
<ul>
<li><a href="#zi-ding-yi-ha-xi-suo-yin">自定义哈希索引</a></li>
</ul>
</li>
<li><a href="#kong-jian-shu-ju-suo-yin-r-tree">空间数据索引（R-Tree)</a></li>
<li><a href="#quan-wen-suo-yin">全文索引</a></li>
</ul>
</li>
<li><a href="#san-xing-suo-yin-de-ping-jie">三星索引的评价</a></li>
</ul>
</li>
<li><a href="#suo-yin-yuan-li">索引原理</a>
<ul>
<li><a href="#b-tree-shi-xian">B+ tree实现</a></li>
<li><a href="#q-wei-shi-me-bu-xuan-ze-shi-yong-b-shu-er-shi-shi-yong-b-shu">Q: 为什么不选择使用B树， 而是使用B+树？</a></li>
<li><a href="#q-na-wei-shi-me-bu-xuan-yong-hong-hei-shu">Q: 那为什么不选用红黑树？</a></li>
<li><a href="#q-na-wei-shi-me-bu-yong-ha-xi-biao">Q: 那为什么不用哈希表？</a></li>
</ul>
</li>
<li><a href="#gao-xing-neng-de-suo-yin-ce-lue">高性能的索引策略</a>
<ul>
<li><a href="#du-li-de-lie-de-wen-ti">独立的列的问题</a></li>
<li><a href="#qian-zhui-suo-yin-you-hua">前缀索引优化</a>
<ul>
<li><a href="#qian-zhui-suo-yin-de-chuang-jian">前缀索引的创建</a></li>
<li><a href="#que-ding-qian-zhui-chang-du">确定前缀长度</a></li>
<li><a href="#ru-he-zuo-hou-zhui-suo-yin">如何做后缀索引？</a></li>
</ul>
</li>
<li><a href="#duo-lie-suo-yin">多列索引</a></li>
<li><a href="#ru-he-que-ding-suo-yin-lie-shun-xu">如何确定索引列顺序</a></li>
</ul>
</li>
<li><a href="#ju-cu-suo-yin">聚簇索引</a>
<ul>
<li><a href="#ju-cu-he-fei-ju-cu-de-qu-bie">聚簇和非聚簇的区别</a></li>
<li><a href="#ju-cu-de-you-dian">聚簇的优点</a></li>
<li><a href="#ju-cu-de-que-dian">聚簇的缺点</a></li>
<li><a href="#ju-cu-he-fei-ju-cu-de-dui-bi">聚簇和非聚簇的对比</a></li>
<li><a href="#q-shi-me-shi-hui-biao">Q: 什么是回表？</a></li>
<li><a href="#q-na-me-dang-fa-sheng-hui-biao-shi-zen-me-bi-mian-ni">Q: 那么当发生回表时，怎么避免呢？</a></li>
<li><a href="#q-fei-zhu-jian-suo-yin-a-zuo-where-a-3-shi-neng-chong-fen-li-yong-suo-yin-zuo-jian-dan-de-fan-wei-du-qu-me">Q: 非主键索引a， 做where a&gt;3时， 能充分利用索引做简单的范围读取么？</a></li>
<li><a href="#er-ji-suo-yin-he-zhu-jian">二级索引和主键</a></li>
<li><a href="#q-zhu-jian-suo-yin-he-wei-yi-suo-yin-you-shi-me-qu-bie-ni">Q: 主键索引和唯一索引有什么区别呢？</a></li>
<li><a href="#q-que-ding-bu-neng-you-duo-ge-zhu-jian-suo-yin-ma-na-fan-shi-li-ti-dao-de-duo-ge-zhu-jian-shi-zen-me-hui-shi-ni">Q: 确定不能有多个主键索引吗？那泛式里提到的多个主键是怎么回事呢？</a></li>
</ul>
</li>
<li><a href="#suo-yin-de-cha-ru">索引的插入</a>
<ul>
<li><a href="#suo-yin-cha-ru-de-gui-fan">索引插入的规范</a></li>
<li><a href="#q-wei-shi-me-zi-zeng-id-ke-neng-hui-chu-xian-bu-lian-xu-de-qing-kuang">Q: 为什么自增id可能会出现不连续的情况？</a></li>
<li><a href="#q-wei-shi-me-zi-zeng-id-bu-neng-hui-gun-ni">Q: 为什么自增id不能回滚呢？</a></li>
</ul>
</li>
<li><a href="#qi-ta-suo-yin">其他索引</a>
<ul>
<li><a href="#fu-gai-suo-yin">覆盖索引</a></li>
<li><a href="#yong-suo-yin-zuo-pai-xu">用索引做排序</a></li>
<li><a href="#ya-suo-qian-zhui-suo-yin">压缩（前缀索引）</a></li>
<li><a href="#chong-fu-suo-yin">重复索引</a></li>
<li><a href="#rong-yu-suo-yin">冗余索引</a></li>
<li><a href="#wei-shi-yong-de-suo-yin">未使用的索引</a></li>
<li><a href="#suo-yin-he-suo">索引和锁</a></li>
</ul>
</li>
<li><a href="#suo-yin-ying-yong">索引应用</a>
<ul>
<li><a href="#duo-chong-guo-lu-tiao-jian-you-hua">多种过滤条件优化</a></li>
<li><a href="#bi-mian-duo-ge-fan-wei-tiao-jian">避免多个范围条件</a></li>
<li><a href="#q-xie-ru-biao-de-shi-hou-wei-shi-me-yi-ban-jian-yi-zi-zeng-de-zhu-jian-id-lai-xie-ru">Q: 写入表的时候， 为什么一般建议自增的主键id来写入？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="suo-yin-de-ji-ben-gai-nian">索引的基本概念</span><a href="#suo-yin-de-ji-ben-gai-nian" class="header-anchor">#</a></h1>
<h2><span id="suo-yin-de-you-dian">索引的优点</span><a href="#suo-yin-de-you-dian" class="header-anchor">#</a></h2>
<ol>
<li>大大减少服务器需要扫描的数据量（本来O(n)的扫描，在B-Tree或者哈希索引的帮助下， 变成O(logn)或者O(1)）</li>
<li>避免了不必要的排序或者临时表（order by和排序需要先弄一个临时存储的表）</li>
<li>把随机IO改成为了顺序IO，IO速度加快</li>
</ol>
<h2><span id="suo-yin-lei-xing">索引类型</span><a href="#suo-yin-lei-xing" class="header-anchor">#</a></h2>
<hr>
<ul>
<li>支持的类型</li>
</ul>
<ol>
<li>全值匹配——key中所有索引列全部匹配中，单个的</li>
<li>匹配最左索引——匹配key中的第一个索引值</li>
<li>匹配列前缀——可以只匹配某个索引的前缀（适用于字符串的情况）</li>
<li>可以匹配最左索引+列前缀——可以只匹配  索引1、索引2加上索引3的前缀。</li>
</ol>
<ul>
<li>注意上面的匹配，都是从左往右的匹配， 因此不支持只匹配中间那个索引的情况。</li>
<li>如果有一列索引用了范围， 那么后面的列都不能再用来匹配了。</li>
<li>B-Tree也可用于排序或者group by key，会加快速度，毕竟默认都是排好序的了。</li>
</ul>
<h3><span id="ha-xi-suo-yin">哈希索引</span><a href="#ha-xi-suo-yin" class="header-anchor">#</a></h3>
<ul>
<li>指的是把 索引列计算出一个哈希值， 存到一个哈希表中， key是哈希值，val是行指针。</li>
<li>只有Memory引擎支持（key using hash(索引值） ）， inndb不支持。</li>
<li>因为不是按照顺序存的， 所以不可用于优化排序， 只能优化查询。</li>
<li>不支持部分索引匹配， 因为哈希值是根据全索引计算的。</li>
<li>也不支持范围。</li>
<li>如果有哈希冲突，且很多，就可能造成性能变慢，</li>
</ul>
<h4><span id="zi-ding-yi-ha-xi-suo-yin">自定义哈希索引</span><a href="#zi-ding-yi-ha-xi-suo-yin" class="header-anchor">#</a></h4>
<ul>
<li>可以利用B-tree弄一个自定义的哈希索引</li>
<li>例如想哈希的列是url， 于是我弄了一个hash_url的列,  里面的值是url经过CRC32(url）后的值， 然后把hash_url这一列作为索引。</li>
<li>然后select语句的时候，  where url = ‘xx’ and hash_url=CRC32(‘xx’)  ，即可 快速定位。</li>
<li>hash_url的值可以通过insert触发器，每次插入url的时候进行更新</li>
<li>查询时必须带上哈希前原本的值（就是上面的url = ‘xxx’)，否则可能会因为哈希冲突返回多行。</li>
<li>不可用SHA1和MDK做哈希函数。</li>
</ul>
<h3><span id="kong-jian-shu-ju-suo-yin-r-tree">空间数据索引（R-Tree)</span><a href="#kong-jian-shu-ju-suo-yin-r-tree" class="header-anchor">#</a></h3>
<ul>
<li>只有MyISAM才支持</li>
<li>从所有维度来索引数据，用于地理信息存储之类的</li>
</ul>
<h3><span id="quan-wen-suo-yin">全文索引</span><a href="#quan-wen-suo-yin" class="header-anchor">#</a></h3>
<ul>
<li>查找文本中的关键词</li>
<li>可以同时创建全文索引和基于值的B-Tree索引</li>
</ul>
<h2><span id="san-xing-suo-yin-de-ping-jie">三星索引的评价</span><a href="#san-xing-suo-yin-de-ping-jie" class="header-anchor">#</a></h2>
<ul>
<li>一星：需要拿的记录都放到同一行（即不用再关联其他表）</li>
<li>二星：索引数据顺序和查找顺序一致</li>
<li>三星: 索引的列包含了查询中需要的全部的列（即不用去返回行中所有顺序，直接返回key就好了）</li>
</ul>
<h1><span id="suo-yin-yuan-li">索引原理</span><a href="#suo-yin-yuan-li" class="header-anchor">#</a></h1>
<h2><span id="b-tree-shi-xian">B+ tree实现</span><a href="#b-tree-shi-xian" class="header-anchor">#</a></h2>
<ul>
<li>如果没有指明类型，基本上都是用的B+ tree索引</li>
<li>B+ tree结构</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/6969d29b8468739b7480fa2315ed0478c0ad46d3.png" alt="6969d29b8468739b7480fa2315ed0478c0ad46d3"><br>
里面的key就是 你选定的索引值<br>
然后按照范围，指向后面其他的范围，直到定位到具体的叶子节点即行所对应的值。<br>
同时因为最后叶子都是按照顺序连起来的，所以也很适合按照范围返回数据。</p>
<ul>
<li>B+tree里的key可以包含多个列的值， 并且这些列匹配时有顺序关系，按照定义key时的优先级来排序。（就是说可以多个key组成一个节点，里面自定义了对应的判定顺序）<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/0856365975e56e39b87ec59c6e52c6c2260027e1.png" alt="0856365975e56e39b87ec59c6e52c6c2260027e1"></li>
</ul>
<hr>
<h2><span id="q-wei-shi-me-bu-xuan-ze-shi-yong-b-shu-er-shi-shi-yong-b-shu">Q: 为什么不选择使用B树， 而是使用B+树？</span><a href="#q-wei-shi-me-bu-xuan-ze-shi-yong-b-shu-er-shi-shi-yong-b-shu" class="header-anchor">#</a></h2>
<p>A:<br>
数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题<br>
正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历<br>
在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作，或者说效率太低。</p>
<p>另外B树的索引节点上也存了数据，导致搜索过程种读了很多不必要的数据，加大了磁盘IO时间</p>
<hr>
<h2><span id="q-na-wei-shi-me-bu-xuan-yong-hong-hei-shu">Q: 那为什么不选用红黑树？</span><a href="#q-na-wei-shi-me-bu-xuan-yong-hong-hei-shu" class="header-anchor">#</a></h2>
<p>A:<br>
红黑树往往出现由于树的深度过大。<br>
磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写</p>
<hr>
<h2><span id="q-na-wei-shi-me-bu-yong-ha-xi-biao">Q: 那为什么不用哈希表？</span><a href="#q-na-wei-shi-me-bu-yong-ha-xi-biao" class="header-anchor">#</a></h2>
<p>A:<br>
哈希表没法做范围查询以及前缀索引匹配查询。</p>
<hr>
<h1><span id="gao-xing-neng-de-suo-yin-ce-lue">高性能的索引策略</span><a href="#gao-xing-neng-de-suo-yin-ce-lue" class="header-anchor">#</a></h1>
<h2><span id="du-li-de-lie-de-wen-ti">独立的列的问题</span><a href="#du-li-de-lie-de-wen-ti" class="header-anchor">#</a></h2>
<ul>
<li>索引列不可以作为表达式的一部分， 必须是独立的<br>
例如 where id+1=5 或者 where Func(id) &lt; 5 都是错误的<br>
应该改成<br>
where id = 5-1 或者  where id &lt; uFunc(5)</li>
</ul>
<h2><span id="qian-zhui-suo-yin-you-hua">前缀索引优化</span><a href="#qian-zhui-suo-yin-you-hua" class="header-anchor">#</a></h2>
<ul>
<li>索引列如果是text之类特别长的，必须使用前缀索引， 不可以用完整长度去做索引，mysql不支持。</li>
</ul>
<h4><span id="qian-zhui-suo-yin-de-chuang-jian">前缀索引的创建</span><a href="#qian-zhui-suo-yin-de-chuang-jian" class="header-anchor">#</a></h4>
<p>… KEY(city(7)),   那么你按照city去where时，就会用city的前缀去索引了。</p>
<h4><span id="que-ding-qian-zhui-chang-du">确定前缀长度</span><a href="#que-ding-qian-zhui-chang-du" class="header-anchor">#</a></h4>
<ul>
<li>前缀索引的选择性 =   不重复的个数/记录总数</li>
<li>如何确定较优的前缀长度？</li>
</ul>
<p>全列选择性：</p>
<p>SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;</p>
<p>某一长度前缀的选择性：</p>
<p>SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;</p>
<p>当你不断调整prefix_length，让前缀的选择性越接近全列选择性的时候，索引效果越好。如果发现继续增加prefi_length，变动幅度不大了，则选取那个值</p>
<ul>
<li>也要注意前缀最大值， 例如该长度n下，平均选择性不高，但是有1-2个前缀数量特别大，也不行。</li>
</ul>
<h4><span id="ru-he-zuo-hou-zhui-suo-yin">如何做后缀索引？</span><a href="#ru-he-zuo-hou-zhui-suo-yin" class="header-anchor">#</a></h4>
<p>存储的时候把字符串 <em><strong>翻转</strong></em> 存进表里，然后再做前缀索引</p>
<h2><span id="duo-lie-suo-yin">多列索引</span><a href="#duo-lie-suo-yin" class="header-anchor">#</a></h2>
<ul>
<li>多列索引指的是 多个独立的索引。就是给表定义了Key(a), key(b) ， 而不是Key(a,b)</li>
<li>如果在多列索引的情况下，要where a=1 or b= 2， 且要性能好， 需要改成  union(a,b) 即查询union的形式。 mysql5.0之后都会优化成union， 简称 <em><strong>索引合并</strong></em></li>
<li>上述默认优化的缺点:  联合操作会耗费大量的CPU和内存。 可是统计时间时又不会统计进来，导致低估时间成本。</li>
<li>可以通过explanin sql语句， 查看extra中是否有using union(a,b)来判断是否有索引合并的情况</li>
</ul>
<h2><span id="ru-he-que-ding-suo-yin-lie-shun-xu">如何确定索引列顺序</span><a href="#ru-he-que-ding-suo-yin-lie-shun-xu" class="header-anchor">#</a></h2>
<ul>
<li>这里指的是如何确定key(a,b,c)里abc的顺序</li>
<li>通用法则：把选择性最高的那个列放前面</li>
<li>选择性计算：  distinct(列)/count(*)  越大，选择性越好。</li>
<li>因为这样的话，可以减少在叶子节点上的遍历。</li>
<li>特殊情况：  某场景下突然表里的username都变成了一样的用户名， 然后对username索引做查询时， 就很慢， 因为相当于在叶子节点上遍历去查了，O(n)的复杂度。</li>
<li>对于特殊场景，要尽量在数据输入避免， 或者查询避免（例如避免在那个时间段去查询那个统一的username）</li>
</ul>
<hr>
<h1><span id="ju-cu-suo-yin">聚簇索引</span><a href="#ju-cu-suo-yin" class="header-anchor">#</a></h1>
<ul>
<li>聚簇索引是一种存储结构，而不是索引类型。</li>
<li>InnoDb默认使用主键列做聚簇索引</li>
<li>如果没有主键，则用第一个非空not NULL unique的索引作为聚簇索引</li>
<li>如果没主键没索引，则会创建一个隐藏的行id作为聚簇索引（毕竟他总要搞一个B+树)</li>
</ul>
<h2><span id="ju-cu-he-fei-ju-cu-de-qu-bie">聚簇和非聚簇的区别</span><a href="#ju-cu-he-fei-ju-cu-de-qu-bie" class="header-anchor">#</a></h2>
<ul>
<li>聚簇索引其实就是指，当你搜索到B+树的叶子之后， 叶子里存的就是数据行了，因此叶子的左右都是与自己索引值相邻的数据行，可以串起来直接一起获取。</li>
<li>而非聚簇索引时， 当你搜到叶子时， 叶子里依然只有索引值， 而后面的指针才指向真正的位置， 这意味着数据行的存放是不连续的， 没有办法用一根线串起来。</li>
</ul>
<h2><span id="ju-cu-de-you-dian">聚簇的优点</span><a href="#ju-cu-de-you-dian" class="header-anchor">#</a></h2>
<ol>
<li>可以一次性读取到 某主键范围的所有行，减少磁盘IO</li>
<li>相比非聚簇，少跑一层（就是最后一层）。</li>
</ol>
<h2><span id="ju-cu-de-que-dian">聚簇的缺点</span><a href="#ju-cu-de-que-dian" class="header-anchor">#</a></h2>
<ol>
<li>如果数据都放在内存中，就没优势了，毕竟非聚簇通过指针一样很快。</li>
<li>更新聚簇索引会很慢，因为会重新组织B+树重新移动。</li>
<li>B+树插入新行时，可能导致叶子节点的页出现分裂，导致更多的空间。（聚簇索引的叶子非常大！）<br>
非聚簇的话都是指针，数据不放在叶子中，也就不会出现那种大叶子的分裂。</li>
</ol>
<h2><span id="ju-cu-he-fei-ju-cu-de-dui-bi">聚簇和非聚簇的对比</span><a href="#ju-cu-he-fei-ju-cu-de-dui-bi" class="header-anchor">#</a></h2>
<p>Innodb都是聚簇索引，叶子节点一般就是数据，数据按顺序存储了。<br>
MyIsam都是非聚簇索引， 叶子节点还是索引，凌乱指向存储位置。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/c29493c31974255e9ce7dbb32c788130b5de1b76.png" alt="c29493c31974255e9ce7dbb32c788130b5de1b76"></p>
<hr>
<h2><span id="q-shi-me-shi-hui-biao">Q:  什么是回表？</span><a href="#q-shi-me-shi-hui-biao" class="header-anchor">#</a></h2>
<p>A:<br>
非聚簇索引查询时， 因为最终只查到的是主键值，最终还需要经过聚簇索引找到数据行<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/93d013b61925f7f744e0aad9bdb1062b32874881.png" alt="93d013b61925f7f744e0aad9bdb1062b32874881"><br>
如粉红色路径，需要扫码两遍索引树：</p>
<ol>
<li>先通过普通索引定位到主键值id=5；</li>
<li>在通过聚集索引定位到行记录；<br>
这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低</li>
</ol>
<hr>
<h2><span id="q-na-me-dang-fa-sheng-hui-biao-shi-zen-me-bi-mian-ni">Q: 那么当发生回表时，怎么避免呢？</span><a href="#q-na-me-dang-fa-sheng-hui-biao-shi-zen-me-bi-mian-ni" class="header-anchor">#</a></h2>
<p>A:<br>
把普通索引列升级到联合主键中。<br>
例如将单列索引(name)升级为联合索引(name, sex)，即可避免回表(代价是name要放到第一个，或者sex in ‘男，女’）</p>
<hr>
<h2><span id="q-fei-zhu-jian-suo-yin-a-zuo-where-a-gt-3-shi-neng-chong-fen-li-yong-suo-yin-zuo-jian-dan-de-fan-wei-du-qu-me">Q: 非主键索引a， 做where a&gt;3时， 能充分利用索引做简单的范围读取么？</span><a href="#q-fei-zhu-jian-suo-yin-a-zuo-where-a-gt-3-shi-neng-chong-fen-li-yong-suo-yin-zuo-jian-dan-de-fan-wei-du-qu-me" class="header-anchor">#</a></h2>
<p>A:<br>
不能。<br>
因为非主键索引最终还是要做回表， 到主键（聚簇）索引树中进行查询。此时a&gt;3是无法直接取出一堆数据的。</p>
<p>mysql5.5之前， 是每个a&gt;3的记录都进行随机回表读取数据。<br>
mysql5.5之后，做了一个MR2优化</p>
<ol>
<li>当a&gt;3的记录不是很多时， 会读取到内存中</li>
<li>接着按照主键id（聚簇索引）进行排序</li>
<li>然后根据id排序后的情况进行回表， 如果有一堆id都是挤在一起的，就对这一批id进行范围查询。</li>
</ol>
<hr>
<h2><span id="er-ji-suo-yin-he-zhu-jian">二级索引和主键</span><a href="#er-ji-suo-yin-he-zhu-jian" class="header-anchor">#</a></h2>
<ul>
<li>注意， 如果有1个key(xx)加一个primKey(yy)，  相当于有2个索引（主键默认索引）<br>
而这2个索引的意思是指：<br>
<em><strong>建立了2个B+树！！</strong></em><br>
对于主键的B+树， 数据就放在叶子<br>
而对于另一个索引的B+树， 叶子节点是主键+索引，  后面才是指向数据</li>
<li>即对于聚簇索引，如果存在主键和二级索引，则选择主键做聚簇， 二级索引和非聚簇索引的B+树没两样。</li>
</ul>
<hr>
<h2><span id="q-zhu-jian-suo-yin-he-wei-yi-suo-yin-you-shi-me-qu-bie-ni">Q:  主键索引和唯一索引有什么区别呢？</span><a href="#q-zhu-jian-suo-yin-he-wei-yi-suo-yin-you-shi-me-qu-bie-ni" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>主键索引一定是唯一索引， 但唯一索引不一定是主键。</li>
<li>主键索引列默认不支持空值，  而唯一索引本身没有这个限制。</li>
<li>主键产生唯一的聚集索引（即聚集索引和主键相关），非主键唯一索引产生唯一的非聚集索引</li>
<li>唯一索引可以有多个， 但是主键只能有一个。</li>
</ol>
<hr>
<h2><span id="q-que-ding-bu-neng-you-duo-ge-zhu-jian-suo-yin-ma-na-fan-shi-li-ti-dao-de-duo-ge-zhu-jian-shi-zen-me-hui-shi-ni">Q:  确定不能有多个主键索引吗？那泛式里提到的多个主键是怎么回事呢？</span><a href="#q-que-ding-bu-neng-you-duo-ge-zhu-jian-suo-yin-ma-na-fan-shi-li-ti-dao-de-duo-ge-zhu-jian-shi-zen-me-hui-shi-ni" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>
<p>数据库的每张表只能有一个主键，不可能有多个主键。</p>
</li>
<li>
<p>所谓的一张表多个主键，我们称之为联合主键。</p>
</li>
</ol>
<p>注：联合主键：就是用多个字段一起作为一张表的主键。</p>
<ol start="3">
<li>主键的主键的作用是保证数据的唯一性和完整性，同时通过主键检索表能够增加检索速度。</li>
</ol>
<hr>
<h1><span id="suo-yin-de-cha-ru">索引的插入</span><a href="#suo-yin-de-cha-ru" class="header-anchor">#</a></h1>
<h2><span id="suo-yin-cha-ru-de-gui-fan">索引插入的规范</span><a href="#suo-yin-cha-ru-de-gui-fan" class="header-anchor">#</a></h2>
<ul>
<li>尽量保证在插入时是按索引的顺序插入的</li>
<li>如果没按顺序插入，会导致经常性的中间分页，移动数据。性能可以差距四倍以上。</li>
<li>所以尽量选用自增的id做索引，尽量不要用随机的UUID做大批量插入的操作。</li>
<li>如果用了UUID做插入，插入之后还要要用一个命令<br>
Optimize Table 表名<br>
来重建表并优化页的填充</li>
<li>什么时候顺序主键的插入是不好的？<br>
同一时刻并发插入（非单线程插入）的情况<br>
这会导致在 数据表末尾发生激烈的竞争冲突（如果是随机的反而可以避免这个情况） P171</li>
</ul>
<hr>
<h2><span id="q-wei-shi-me-zi-zeng-id-ke-neng-hui-chu-xian-bu-lian-xu-de-qing-kuang">Q: 为什么自增id可能会出现不连续的情况？</span><a href="#q-wei-shi-me-zi-zeng-id-ke-neng-hui-chu-xian-bu-lian-xu-de-qing-kuang" class="header-anchor">#</a></h2>
<p>A:<br>
插入时，如果insert语句中不包含id，但是id设成了自增<br>
mysql此时就会从某个自增表中申请一个主键，当申请成功之后，就会拿着这个主键+1去做真实的Insert操作。（注意，是先申请，再插入）<br>
如果主键/唯一键冲突，或者事务回滚， <em><strong>这个自增id不会回滚</strong></em>。 下一次会继续主键+1使用。<br>
因此</p>
<hr>
<h2><span id="q-wei-shi-me-zi-zeng-id-bu-neng-hui-gun-ni">Q: 为什么自增id不能回滚呢？</span><a href="#q-wei-shi-me-zi-zeng-id-bu-neng-hui-gun-ni" class="header-anchor">#</a></h2>
<p>A:<br>
为什么不回退，是避免回退导致重复的冲突，也为了避免太大范围的锁</p>
<ul>
<li>避免回退导致多个id同时插入引发重复的冲突，也为了避免太大范围的锁</li>
<li>自增主键比较大的作用是避免页分割，我们只需要数据是递增而无需连续</li>
</ul>
<hr>
<hr>
<h1><span id="qi-ta-suo-yin">其他索引</span><a href="#qi-ta-suo-yin" class="header-anchor">#</a></h1>
<h2><span id="fu-gai-suo-yin">覆盖索引</span><a href="#fu-gai-suo-yin" class="header-anchor">#</a></h2>
<p>指查询语句中 只有索引相关的列。</p>
<ul>
<li>这样的话，可以不需要回表访问聚簇索引树了， 直接拿索引节点里的索引结果返回，效率非常高。</li>
<li>全覆盖的情况比较少见，一般用于<br>
先用覆盖索引的查询语句得到一个小表<br>
再利用这个小表的结果对原表做查询（相当于省去了一些条件里的判断）</li>
<li>Explanin 解析时，如果extra显示 using index，则说明使用了覆盖索引。</li>
</ul>
<h2><span id="yong-suo-yin-zuo-pai-xu">用索引做排序</span><a href="#yong-suo-yin-zuo-pai-xu" class="header-anchor">#</a></h2>
<ul>
<li>索引和排序语句写对的话，可以不需要弄临时表做排序，直接按照顺序取出返回即可。</li>
<li>索引列的顺序， 必须和order by中声明的索引顺序一致</li>
<li>即你的key是(a,b,c)， 那么oder by a b c才行，不能打乱顺序</li>
<li>order by 索引满足 前缀定理，  即必须是  a 或者 a+b或者  a+b前缀</li>
<li>特例： 如果where中定义了a=‘某个常量’，  那么order by中只需要b和c也满足 前缀定义。</li>
<li>如果是范围就不行了</li>
</ul>
<h2><span id="ya-suo-qian-zhui-suo-yin">压缩（前缀索引）</span><a href="#ya-suo-qian-zhui-suo-yin" class="header-anchor">#</a></h2>
<ul>
<li>就是把索引在存储的做压缩，减少字节数</li>
<li>例如第一个索引是perform， 第二个是performance， 那么第二个存储的时候就表示为7,ance</li>
<li>可以在Create Table语句中指定PACK_KEYS来控制索引压缩</li>
<li>压缩索引主要是为了减少磁盘和内存占用量， 但因为压缩了，每次到节点时要先解开压缩再计算（即只有用到才解压），再去查找，会降低性能。</li>
</ul>
<h2><span id="chong-fu-suo-yin">重复索引</span><a href="#chong-fu-suo-yin" class="header-anchor">#</a></h2>
<p>primary key、 unique(key)、 index(key）这3个本质上都会形成索引，很容易有人定义了主键后， 又给主键加个索引， 这就会出现多个相同的B+树。</p>
<h2><span id="rong-yu-suo-yin">冗余索引</span><a href="#rong-yu-suo-yin" class="header-anchor">#</a></h2>
<ul>
<li>创建了索引（A，B）之后， 又创建了（A）， 那么就是冗余， 因为（A，B） 可以实现单独A的索引功能。</li>
<li>所以尽量修改索引，而不是去新增索引， 新增索引容易出现冗余索引。</li>
<li>修改索引的缺陷:  可能导致一些老的查询语句的性能下降。<br>
例如本来是用索引（A） + 主键ID排序做查询，  那个脚本一直在跑很正常， 后来改成了索引（A.B）  + 主键ID排序， 于是原先的脚本性能GG， 因为A和ID被B分开了（只是我们看不到ID放在我们定义的key里）</li>
</ul>
<h2><span id="wei-shi-yong-de-suo-yin">未使用的索引</span><a href="#wei-shi-yong-de-suo-yin" class="header-anchor">#</a></h2>
<ul>
<li>就是定义了但是平时不用的索引！</li>
<li>定位未使用索引的方法：  打开userstates变量， 然后让服务器运行几天之后， 查询INFORMATION_SCHEMA.INDEX_STATISTICS用来查看索引的使用频率。</li>
<li>具体见P188</li>
</ul>
<h2><span id="suo-yin-he-suo">索引和锁</span><a href="#suo-yin-he-suo" class="header-anchor">#</a></h2>
<ul>
<li>索引能够减少访问的行数，从而减少锁的数量</li>
</ul>
<hr>
<h1><span id="suo-yin-ying-yong">索引应用</span><a href="#suo-yin-ying-yong" class="header-anchor">#</a></h1>
<h2><span id="duo-chong-guo-lu-tiao-jian-you-hua">多种过滤条件优化</span><a href="#duo-chong-guo-lu-tiao-jian-you-hua" class="header-anchor">#</a></h2>
<ul>
<li>如果我们的索引是 sex country age， 但是我们的查询里不关心sex，怎么办？ 如果不走sex，索引就失效了<br>
可以在where中加入  sex in (‘m’,‘f’)  这样就能用到sex了</li>
<li>原则1：<br>
枚举少的放前面， 这样可以用in方式来处理</li>
<li>原则2：<br>
经常范围性查询的索引列放后面 ，例如age， 毕竟范围查的话，后面的索引就肯定用不了了。</li>
</ul>
<h2><span id="bi-mian-duo-ge-fan-wei-tiao-jian">避免多个范围条件</span><a href="#bi-mian-duo-ge-fan-wei-tiao-jian" class="header-anchor">#</a></h2>
<ul>
<li>mysql会把in(1,2,3)和 &gt;1 and &lt; 3 都认为是range的type，  不过在索引的使用，  in之后还可以接其他索引，  但是大于1小于3就不行了</li>
<li>如果出现了  lastoneline  &gt; xxx  and age  between x and y<br>
这种2个范围的索引查询，就会导致age索引失效</li>
<li>一种优化的办法：  如果lastoneline &gt; xxx 仅仅是表示 这个用户是否未过期，则可以新增一个经常维护的字段active，来吧lasttime&gt;xxx的这个条件转成true和false这两种值。</li>
<li>那么后面就可以改成lastline = true and age between… 了， 用等值的话，就不会影响后面的索引</li>
</ul>
<hr>
<h2><span id="q-xie-ru-biao-de-shi-hou-wei-shi-me-yi-ban-jian-yi-zi-zeng-de-zhu-jian-id-lai-xie-ru">Q: 写入表的时候， 为什么一般建议自增的主键id来写入？</span><a href="#q-xie-ru-biao-de-shi-hou-wei-shi-me-yi-ban-jian-yi-zi-zeng-de-zhu-jian-id-lai-xie-ru" class="header-anchor">#</a></h2>
<p>A:<br>
因为底层的索引本质上是B+树<br>
有页分裂<br>
如果id随机，则写入时会碎片化，无法做到顺序写</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/21/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/21/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/" class="post-title-link" itemprop="url">第307场周赛-1232名-3题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-21 22:12:42 / 修改时间：15:42:55" itemprop="dateCreated datePublished" datetime="2022-08-21T22:12:42+08:00">2022-08-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/21/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/21/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661066854478.png" alt="1661066854478"></p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>N种东西组成最大字典序回文时，先把成双的都处理掉，每组留下1个或者0个， 最后再考虑怎么拼接这些</li>
<li>子序列和第K个，可以考虑从最小数字开始， 每次保留当前数字，选下一个数字， 或者废弃当前数字，选下一个数字，  并都放入堆中， 这样每次可更新得到最小的子序列。</li>
</ol>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/">6152. 赢得比赛需要的最少训练时长 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661066882187.png" alt="1661066882187"></p>
<p>最开始有点事情，解决完之后发现脑子很乱，这题目其实很简答</p>
<p>对于精力，可以提前算出需要的精力， 而经验可以在每次对战时判断是否要再增加。</p>
<p>但这题就是条件容易看漏，导致错了2次：</p>
<p><strong>需要在经验和精力上都</strong> <strong>严格超过对手才能击败他们</strong></p>
<p>严格超过意味着不能等于，导致很多地方得+1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, <span class="type">int</span>[] energy, <span class="type">int</span>[] experience)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> initialExperience;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(energy).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, sum + <span class="number">1</span> - initialEnergy);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; experience.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exp &lt;  experience[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                res += experience[i] - exp + <span class="number">1</span>;</span><br><span class="line">                exp = experience[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exp += experience[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-palindromic-number/">6166. 最大回文数字 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661067068832.png" alt="1661067068832"></p>
<p>这题也搞晕了，实际上很简单。</p>
<p>一堆已知数量的字母要组成回文数， 记住你先把所有成双成对的单独都按拿出来， 剩下的都是1个或者0个字母</p>
<p>然后成双的按大小顺序从外向内组成回文 ，  最后最里面那个单字母的用最大的。</p>
<p>我最开始直接把奇数个数的字母当整体去思考了，其实应该先剔除奇数个数字母中成双的部分，只留下单个的， 最后再去考虑他</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestPalindromic</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] charCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">            charCounts[c-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小的字母且是奇数个数的选择放最后</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">endUseChar</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] oneChar = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>; i &gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            oneChar[i] = (charCounts[i] %<span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line">            charCounts[i] /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == endUseChar) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> charCounts[i];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; sb1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sb1.append(c);</span><br><span class="line">                sb2.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oneChar[i]) &#123;</span><br><span class="line">                sb1.append((<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sb1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb1.append(sb2.reverse()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/">6154. 感染二叉树需要的总时间 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC307%E5%9C%BA%E5%91%A8%E8%B5%9B-1232%E5%90%8D-3%E9%A2%98/1661067234487.png" alt="1661067234487"></p>
<p>很容易想到bfs， 先dfs一遍，把每个点的父节点也得到。</p>
<p>然后做bfs即可</p>
<p>另外二叉树的题目中如果涉及map或者set，最好还是直接用引用做key，不容易写错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        Map&lt;TreeNode,TreeNode&gt; parents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    TreeNode startNode;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">amountOfTime</span><span class="params">(TreeNode root, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        find(root, <span class="literal">null</span>, start);</span><br><span class="line">        queue.offer(startNode);</span><br><span class="line">        Set&lt;TreeNode&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        vis.add(startNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 全部出队</span></span><br><span class="line">            res++;</span><br><span class="line">            List&lt;TreeNode&gt; nowNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queue);</span><br><span class="line">            queue.clear();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : nowNodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; !vis.contains(node.left)) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    vis.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span> &amp;&amp; !vis.contains(node.right)) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    vis.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (parents.get(node) != <span class="literal">null</span> &amp;&amp; !vis.contains(parents.get(node))) &#123;</span><br><span class="line">                    queue.offer(parents.get(node));</span><br><span class="line">                    vis.add(parents.get(node));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode node, TreeNode parent, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parents.put(node, parent);</span><br><span class="line">        <span class="keyword">if</span> (node.val == start) &#123;</span><br><span class="line">            startNode = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find(node.left, node, start);</span><br><span class="line">        find(node.right, node, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">6155. 找出数组的第 K 大和 - 力扣（LeetCode）</a></p>
<p>这题好难，其实知道套路就可以了</p>
<p>我是已经想到先得到 正数的和sum， 然后以这个sum不断减去其他的值，这个减去的就是子序列而且要尽可能小， 同时负数要转整数， 到底是加还是减不需要我们关心。</p>
<p>但是怎么得到第K小的子序列和呢？</p>
<p>答案是用最小堆</p>
<p>先按从小到大排序</p>
<p>然后第0个数字肯定是最小的子序列</p>
<p>接着有2个选择：</p>
<p>① 保留第0个数字， 并继续选取第1个数字</p>
<p>② 废弃第0个数字， 并继续选取第1个数字</p>
<p>这样又得到2个子序列， 最小序列肯定在者2个里面</p>
<p>你会奇怪，者肯定是第②个最小啊？</p>
<p>但是继续走下去</p>
<p>当对于“废弃第0个数字， 并继续选取第1个数字”这个位置，你想废弃第1个数字，选第2个数字时，前面的“保留第0个数字， 并继续选取第1个数字”是可能比它小的， 所以要用堆进行保存，且这样的操作处理时不用考虑任何回溯或者重复的情况！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">kSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).filter(num -&gt; num &gt; <span class="number">0</span>).mapToLong(num -&gt; Long.valueOf(num)).sum();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length;i++) &#123;</span><br><span class="line">            nums[i] = Math.abs(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// [0]是选择剔除的子序列的和，[1]是当前这个子序列的最右边索引</span></span><br><span class="line">        <span class="comment">// 每次选最小的出来</span></span><br><span class="line">        Queue&lt;<span class="type">long</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] ? <span class="number">1</span> : -<span class="number">1</span>));</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, <span class="number">0L</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">subSum</span> <span class="operator">=</span> queue.peek()[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)queue.poll()[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (sum - subSum);</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= nums.length) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;subSum + nums[index], index+<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index -<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;subSum - nums[index - <span class="number">1</span>] + nums[index], index + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">网络威胁分析和应对方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-21 00:30:12 / 修改时间：00:57:04" itemprop="dateCreated datePublished" datetime="2022-08-21T00:30:12+08:00">2022-08-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#spoofing-fang-mou-ren-zheng">Spoofing 仿冒—&gt;认证</a></li>
<li><a href="#tampering-cuan-gai-wan-zheng-xing">Tampering 篡改—&gt;完整性</a></li>
<li><a href="#repudiation-di-lai-fou-ren-zuo-guo-de-shi-fang-di-lai">Repudiation 抵赖，否认做过的事—&gt;防抵赖</a></li>
<li><a href="#imformation-disclosure-xin-xi-xie-lu-ji-mi-xing">Imformation Disclosure 信息泄露—&gt;机密性</a></li>
<li><a href="#denial-of-service-ju-jue-fu-wu-ke-yong-xing">Denial of Service 拒绝服务—&gt;可用性</a></li>
<li><a href="#elevation-of-privilege-quan-xian-ti-sheng-shou-quan">Elevation of privilege 权限提升—&gt;授权</a></li>
<li><a href="#privacy-yin-si-tuo-min">Privacy隐私—&gt;脱敏</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="spoofing-fang-mou-gt-ren-zheng">Spoofing 仿冒—&gt;认证</span><a href="#spoofing-fang-mou-gt-ren-zheng" class="header-anchor">#</a></h1>
<p>搞一个克隆的手机号， 接入到公用wifi中看违反视频干违法之事，然后另一个人背锅了 （ 外部交互方）—— 手机短信验证码接入， 或者ssl证书双向认证</p>
<p>公用wifi被我替换成了仿冒的同名假wifi， 其他手机就误接进来了，我就能偷偷知道谁在下小黄片了 （处理过程）， 或者是搞了个假的淘宝，让别人点进来—— ssl双向认证</p>
<h1><span id="tampering-cuan-gai-gt-wan-zheng-xing">Tampering 篡改—&gt;完整性</span><a href="#tampering-cuan-gai-gt-wan-zheng-xing" class="header-anchor">#</a></h1>
<p>服务器的监听特性被纂改?（处理过程）—— 校验端口正确，配置文件mac对比，mac存到服务端</p>
<p>直接再数据库里修改你的个人信息或者金钱（存储）——acl权限控制</p>
<p>某app偷偷修改你的host，把你想发给华为的数据发送到黑客的服务器上了。（数据流) —— acl权限认证，host不可更改，或者文件mac对比</p>
<h1><span id="repudiation-di-lai-fou-ren-zuo-guo-de-shi-gt-fang-di-lai">Repudiation 抵赖，否认做过的事—&gt;防抵赖</span><a href="#repudiation-di-lai-fou-ren-zuo-guo-de-shi-gt-fang-di-lai" class="header-anchor">#</a></h1>
<p>有人用root登录后干了rm -rf 这事， 却说自己没做过，你查不到我（外部交互方) ——审计日志</p>
<p>修改日志记录函数（例如替换jar包之类的）， 日志故意不记录自己的名字 （ 处理过程）——认证</p>
<p>直接去存储的地方修改日志信息（存储过程， 只有日志会存盘才有可能）——认证</p>
<h1><span id="imformation-disclosure-xin-xi-xie-lu-gt-ji-mi-xing">Imformation Disclosure 信息泄露—&gt;机密性</span><a href="#imformation-disclosure-xin-xi-xie-lu-gt-ji-mi-xing" class="header-anchor">#</a></h1>
<p>从app的应用启动目录找到一个二进制文件，可以解密处密钥（处理过程）——加密</p>
<p>入侵数据库里。可以找到明文口令（存储过程）——加密</p>
<p>明文口令直接加在http中， 然后被人直接抓包拿到口令了（数据流）——加密</p>
<h1><span id="denial-of-service-ju-jue-fu-wu-gt-ke-yong-xing">Denial of Service 拒绝服务—&gt;可用性</span><a href="#denial-of-service-ju-jue-fu-wu-gt-ke-yong-xing" class="header-anchor">#</a></h1>
<p>服务器承载不住请求量，内存不足或者cpu爆满（处理过程） ——负载均衡</p>
<p>疯狂执行写操作，然后磁盘满了（存储过程）——缓存</p>
<p>故意拦截中间链路，导致数据流中断（数据流）——过滤</p>
<h1><span id="elevation-of-privilege-quan-xian-ti-sheng-gt-shou-quan">Elevation of privilege 权限提升—&gt;授权</span><a href="#elevation-of-privilege-quan-xian-ti-sheng-gt-shou-quan" class="header-anchor">#</a></h1>
<p>在处理过程中， 用户权限比实际的高（处理过程）——权限最小化\沙箱</p>
<h1><span id="privacy-yin-si-gt-tuo-min">Privacy隐私—&gt;脱敏</span><a href="#privacy-yin-si-gt-tuo-min" class="header-anchor">#</a></h1>
<p>外部交互方： 没有经过用户同意，就收集隐私—— 应该加勾选项告知用户</p>
<p>数据存储： 直接把用户数据存盘却没有加密或者脱敏—— 数据脱敏、匿名化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-20 23:12:42" itemprop="dateCreated datePublished" datetime="2022-08-20T23:12:42+08:00">2022-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-21 00:50:12" itemprop="dateModified" datetime="2022-08-21T00:50:12+08:00">2022-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%B9%B6%E6%9F%A5%E9%9B%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%B9%B6%E6%9F%A5%E9%9B%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>686</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#gai-nian">概念</a></li>
<li><a href="#he-xin-si-lu">核心思路：</a></li>
<li><a href="#dai-ma-mo-ban">代码模板</a></li>
<li><a href="#xiang-guan-ti-mu">相关题目</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor">#</a></h1>
<ul>
<li>
<p>谁和谁相互关联， 问你最终每个集体或者最多集体有多少人， 或者有多少个集体，用并查集即可。</p>
</li>
<li>
<p>区间合并问题直接上并查集，别整更新左区间，更新右区间这种玩意，很容易错。</p>
</li>
</ul>
<h1><span id="he-xin-si-lu">核心思路：</span><a href="#he-xin-si-lu" class="header-anchor">#</a></h1>
<ol>
<li>partent[k] 指k的父亲节点是什么</li>
<li>每次getParent(k)时， 要通过递归， 将其父节点更新成最上面的父节点，实现并查集的压缩，大大减少了复杂度</li>
<li>union时， 则随意选一方进行连接</li>
<li>如何涉及集合中的数量问题，尽量别在union中更新，容易写错，  建议最后全部遍历一边，得到集合中的数量或者价值总数。</li>
<li>如果一定要union更新，注意顺序，p[p1]] = p2的话，说明p1的父亲变成了p2，那么应该是p2作为被加方，即sum[p2] += sum[p1]，反过来了。且注意在getParent中不需要更新val</li>
</ol>
<h1><span id="dai-ma-mo-ban">代码模板</span><a href="#dai-ma-mo-ban" class="header-anchor">#</a></h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">long</span>[] sums;</span><br><span class="line">   <span class="type">int</span>[] parent;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getParent(n1);</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getParent(n2);</span><br><span class="line">       parent[p1] = p2;</span><br><span class="line">       sums[p2] += sums[p1];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> parent[num];</span><br><span class="line">       <span class="keyword">if</span> (p == num) &#123;</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           p = getParent(p);</span><br><span class="line">       &#125;</span><br><span class="line">       parent[num] = p;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-segment-sum-after-removals/">6159. 删除操作后的最大子段和 - 力扣（LeetCode）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/home/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/7/">7</a><a class="extend next" rel="next" href="/home/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共153.9k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
