<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[toc]         刷题日记 😉   😢 😆 😋 [2022-05-09]  给一个图，找入度为n、出度为0的唯一点，最少可以通过3n次查找，从0到n通过遍历a-&gt;b，逐步排除不可能的选项，最终只剩1个，然后再通过2次n确认入度和出度。  😄   2022-05-02  s.indexOf(i, “}”) 可以快速得到下一个  2022-04-09  要求ty通过反复减tx">
<meta property="og:type" content="article">
<meta property="og:title" content="21年10月-22年5月">
<meta property="og:url" content="http://breakdawncoder.com/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="[toc]         刷题日记 😉   😢 😆 😋 [2022-05-09]  给一个图，找入度为n、出度为0的唯一点，最少可以通过3n次查找，从0到n通过遍历a-&gt;b，逐步排除不可能的选项，最终只剩1个，然后再通过2次n确认入度和出度。  😄   2022-05-02  s.indexOf(i, “}”) 可以快速得到下一个  2022-04-09  要求ty通过反复减tx">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/7897843fc21e6aee738cf9853605db09378a0ef0.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/8b5ec292b0898702f3d8c0c1eb08127488982cb7.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/a8eac0b3823f887071474d90e16e46f2475973e5.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/9fc32c38f70bff95f29aa46ba21db777a3362488.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/fd9f505ce39b64eaebad16f0e4445fe305526913.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/b126300997a64998cce44f429188d3f512dbbed6.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/9c00e5b295a063c590a4e969521709d8d673cdb4.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/d987e1f51885cc3c4a0c5d2b059a8e2ca5633145.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/3c84111fe71f4a886bab0bd1b28816389c78b017.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/e0d7714912cb467741ce63ebb6430b7300a96e1e.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/4cb1e2e718d8888408ecc5093f3ba79375869d08.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/5f3365c64c94fd12501c5136b52bfca74ad582f6.png">
<meta property="og:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/e0f19882380cf45d20ff05564b14a013cde11b8e.png">
<meta property="og:image" content="http://breakdawncoder.com/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/69541d637f6c32d66f7415fe3ea1026572937dd6.png">
<meta property="article:published_time" content="2021-10-07T14:12:42.000Z">
<meta property="article:modified_time" content="2022-08-18T16:27:34.585Z">
<meta property="article:author" content="breakDawn">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://breakdawncoder.com/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/7897843fc21e6aee738cf9853605db09378a0ef0.png">

<link rel="canonical" href="http://breakdawncoder.com/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>21年10月-22年5月 | 破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          21年10月-22年5月
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-07 22:12:42" itemprop="dateCreated datePublished" datetime="2021-10-07T22:12:42+08:00">2021-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 00:27:34" itemprop="dateModified" datetime="2022-08-19T00:27:34+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">刷题日记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022%E5%B9%B47%E6%9C%88%E5%8F%8A%E4%BB%A5%E5%89%8D/" itemprop="url" rel="index"><span itemprop="name">2022年7月及以前</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[toc]</p>
  <div class="toc">
<!-- toc -->
<!-- tocstop -->
</div>  
<p>刷题日记</p>
<p>😉   😢 😆 😋</p>
<p>[2022-05-09]</p>
<ul>
<li>给一个图，找入度为n、出度为0的唯一点，最少可以通过3n次查找，从0到n通过遍历a-&gt;b，逐步排除不可能的选项，最终只剩1个，然后再通过2次n确认入度和出度。  😄</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/guinvg">2022-05-02</a></p>
<ul>
<li>s.indexOf(i, “}”) 可以快速得到下一个</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/scvmoj">2022-04-09</a></p>
<ul>
<li>要求ty通过反复减tx，要减到小于等于tx的话 那么就是ty%tx的值</li>
<li>对于自己推导中间过程比较麻烦的题目，就直接写个sout打印中间能很快观察到问题所在</li>
</ul>
<ol>
<li>先写个超时的答案</li>
<li>打印中间结果，看下哪里浪费了</li>
<li>对浪费的步骤做优化</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/jnxyjz">2022-0405-0406</a></p>
<ul>
<li>求1个数字N是否为质数的一个简单方式： 只遍历i=2到i=根号(n)，然后确认能否被整除即可。</li>
<li>优化1： 求二进制1的个数，没必要手动求解， 直接用Integer.bitCount()即可</li>
<li>优化2：质数如果总数比较小，可以直接手动大表，这题里最大数字范围为19 ，那么质数可以直接打表得到</li>
<li>找到一个最小高度的树的根节点，可以用拓扑排序，从最外围往内部逼近</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ctpdxv/">2022-04-01</a></p>
<ul>
<li>n如果是整数，可能直接越界，需要提前强转</li>
<li>如果状态条件种要求不能连续的问题， 考虑状态是否多加一个,这题的状态方程就是,dp[当前位置][颜色][上一个点是否是该颜色]</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/fgsvki/">2022-0329-0330</a></p>
<ul>
<li>知道很多点的大小关系，求整个的大小关系，可用拓扑排序</li>
<li>Stringbuilder.reverse() 会导致自身翻转，所以切忌不要对搜索变量stringbuidler做翻转，要么记得转回来</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/nnjuyg/">2022-03-28</a></p>
<ul>
<li>如果二进制a都是0、1交替的，那么a ^ (a&gt;&gt;1) 则会变成除前置0外，全是1</li>
<li>如何判断某个二进制a全是1组成？a&amp;(a+1)==0， 则说明全是1</li>
<li>多个字符串编码成1个字符串，可以用非ascii码的字符做分隔符(char)257</li>
<li>涉及次数问题的题目，且题目次数一定小于某个总数，则可以考虑计数排序</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/unaalu/">2022-03-27</a></p>
<ul>
<li>涉及数字出现次数，求里面某几个特别的次数的数字时，记得使用分类，即想办法把他们分成不同的组，再分别做异或即可。</li>
<li>x&amp;（-x）是x=110100变000100,  x&amp;(x-1)是x=110100变111000</li>
<li>如何判断一个图是否是1课树？<br>
方法1：首先保证边数=节点数-1,然后用bfs保证所有点相连<br>
方法2：并查集，合并过程不能出现2个根节点相同（说明树内循环连接了），合并完成要求只有1个根节点</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/uwghjd">2022-03-26</a></p>
<ul>
<li>一个数组，如何求去掉每个位置时的数组中的最小值<br>
维护最小值和第二小的值即可<br>
注意，当更新最小值的时候，同时需要更新第二小的值！</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/mjkleh/">2022-03-24</a></p>
<ul>
<li>自定义迭代器注意点：迭代器特点，无论是hasNext还是next,都需要先找到下一个有效的点, 再去判断，而且是通过while循环查找。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/jrogiy">2022-03-23</a></p>
<ul>
<li>int[] 截断成list，可以先转list，再用subList截断.<br>
ret.subList(0, k);</li>
<li>寻找num在list中的位置：Collections.binarySearch(list, x);</li>
<li>用常量空间判断数组是否是二叉搜索树的先序？<br>
遍历每个点，只测试右边方向的正确性</li>
<li></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ymocky">2022-03-21</a></p>
<p>*1个有序数组，求2个数字的和满足target，可以用双指针最左和最右，然后根据大小情况移动左边或者右边。为什么不可能往回走？因为你之前已经走过的点，能确认右边那个位置是无法满足的</p>
<ul>
<li>中序遍历迭代树， 注意走下一个点时，要么右儿子为空往上走，要么走右儿子后，还得往左边一直走到底，才算是下一个点</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/tnetil">2022-03-19</a></p>
<ul>
<li>list[]初始化，直接for循环最简单</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/nweavt">2022-03-18</a></p>
<ul>
<li>一个java-stream的小点： 按照key分组并统计每组key的数量<br>
Map&lt;String, Long&gt; strMap = Arrays.stream(strings)<br>
.collect(Collectors.groupingBy(s -&gt; s, Collectors.counting()));<br>
即groupingBy(key-&gt;key, Collectors.counting())<br>
如果记不起来，马上改成用stream().foreach或者直接循环即可</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/xemgpw">2022-03-17</a></p>
<ul>
<li>2个单词在词典中的最短距离，最好方式是用双指针，如果i1&lt;i2，则i1++，这样子</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/dkceba">2022-03-15</a></p>
<ul>
<li>unicode形式的字符，尽可能用character对象，一个字符可能是多个字节表示，因此不能用数组下标来简单处理这类字符的哈希问题</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/actdba">2022-03-14</a></p>
<ul>
<li>如果求解二叉搜索树的第k个点，要求频繁查询的性能，则事先统计每个子树的节点总数量，即可快速判断在左边还是右边。（如果不平衡则要平衡树）</li>
<li>p、q最近公共祖先问题，可以不一定用父亲数组遍历2次， 而是用 该树是否包含p或者q的布尔值结果，通过先序遍历，找到第一个左右两边都有p\q的情况（也包括自己是p或者q)</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/elprds">2022-03-13</a></p>
<ul>
<li>如果希望使用双端队列而不是栈，请不要用Push和poll了，就用first和last两个语义处理，避免混乱</li>
<li>LinkedList push 施加在list头部. 等同于addFirst。 add 是加在list尾部。</li>
<li>如果一个式子中只有+号和-号，无括号，则直接将-号后的数字取负即可</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/aifjbh">2022-03-09</a></p>
<p>超期优先队列应用</p>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/dapvqa">2022-03-08</a></p>
<ul>
<li>如果题目只需要你返回true或者false，即不需要中间所有结果，则考虑到一些情况可以不用过分担忧，如果有影响，则可能直接返回true了</li>
<li>完全二叉树的节点是否存在，可以用位运算来表示，往left走代表0，往right走代表1.</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/svrgqb">2022-02-20</a></p>
<ul>
<li>回文串最简单的判定s = 翻转(s)， 可以考虑字符串哈希等东西，或者KMP前缀后缀判定优化</li>
<li>字符串哈希，第0位数字不可为0，至少要有数字，因此不需要做s.charAt(i) - 'a’的操作</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/qgdvtd/">2022-02-19</a></p>
<ul>
<li>因此股票买卖，要考虑持有或者不持有，然后通过买入扣钱以及卖出加钱来计算</li>
<li>字典树问题，如果是考虑单词“全匹配”，则必须要在字典树末尾补充isEnd标志。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/cwnymt">2022-02-18</a></p>
<ul>
<li>字符串只有10时，做substring和map.hashcode的时间都是可接受的，可直接用</li>
<li>子序列对应x进制的滑动窗口问题中，你可以先整体右移动，然后截断第一个位，再加上最后一个，即可。</li>
<li>如果窗口大小是的2的倍数，则可以继续用位运算，只不过偏移数量要变化<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/7897843fc21e6aee738cf9853605db09378a0ef0.png" alt="7897843fc21e6aee738cf9853605db09378a0ef0"></li>
<li>对于长度固定的窗口，你可以先预处理窗口剩1个， 然后再开始，避免重复判断<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/8b5ec292b0898702f3d8c0c1eb08127488982cb7.png" alt="8b5ec292b0898702f3d8c0c1eb08127488982cb7"></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/juumpq">2022-02-17</a></p>
<ul>
<li>如何O(h高度）遍历二叉搜索树？ 利用栈，每次把左左左放入，然后出栈时，右儿子放入后继续左左左放入</li>
<li>几个数字怎么排列乘一个数字后最大， 只要满足a+b&gt;b+a，那么a就放在前面即可。</li>
<li>字符串去除前置0的操作：.replaceAll(“^(0+)”, “”)</li>
<li>字符串a+b和b+a做比较觉得不好，可以改成long整数，分别乘高x10位加另一个数字来比较</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ysesry">2022-02-16</a></p>
<ul>
<li>一个节点的祖先和后代节点集合， 一定包含在他父节点的祖先和后代节点集合</li>
<li>可根据各节点的祖先和后代节点数量，确认是否是祖先关系，父亲节点是数量最靠近自己的</li>
<li>后面暂时不做每日一题了，直接按面试高频题进行练习。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/sndbof/">2022-01-27</a></p>
<ul>
<li>注意javaStream.filter中，是满足条件的留下， 而不是剔除。</li>
<li>边界比较麻烦的问题，要自己写一下UT用例，覆盖边界场景，再写代码，这样就算错了，给人留下的印象也会很不错</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/oswnef/">2022-01-26</a></p>
<ul>
<li>快速计算list或者map.values()的最小值方法：Collections.min(collection)</li>
<li>滑动窗口遵循下面的写法最简单：</li>
</ul>
<ol>
<li>只写一个while循环，即只默认循环加right</li>
<li>每次都直接把right放入窗口。</li>
<li>当窗口不满足，则移动左节点直到满足。如果左节点大于右节点，结束左节点的移动。</li>
<li>计算当前窗口结果。左大于右时，要能算为0</li>
<li>right++</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/riagcz">2022-01-24</a></p>
<ul>
<li>求List<integer>的int最大值时，需要先mapToInt， 再求最大值。 如果最大值可能不存在，要用orElse设置默认值</integer></li>
<li>分子/分母的整除对象做哈希键时，需要做4种处理</li>
</ul>
<ol>
<li>分子必须保证为非负数（如果小于0，则上下都乘-1即可）</li>
<li>需要求出gcd进行最小约分</li>
<li>用最大边界来表示这个二维值：（分子/gcd) * 最大边界 + (分母/gcd)</li>
<li>分子为0，那就简化成（0，1）， 分母为0，那就简化成（1，0）</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/bkiugo">2022-01-22</a></p>
<ul>
<li>每次提交代码前，必须看一下中间10^5范围的中间结果是否可能超出int范围。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/qypqat">2022-01-21</a></p>
<ul>
<li>对链表题排序， 注意每次排序完部分链表时， 需要更新最后一个节点的next！</li>
<li>如何对链表做排序，且空间复杂度最小？使用迭代法的归并排序，即自底向上的归并排序。那么就很容易了</li>
<li>怎么划分2个需要合并的列表?提前把尾部设成null</li>
<li>合并两个链表时，可以弄一个局部头节点，这种不算空间复杂度，因为是局部变量， 后面会释放掉。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/vwmdoh/">2022-01-20</a></p>
<ul>
<li>无法搜索的博弈论问题，尝试找规律， 当先手选某一步，之后大概率会陷入某类循环中，直到出现胜负。</li>
<li>不能很快得到公式时，不妨写土方法遍历1下看能否满足循环序列。</li>
<li>短时间想不到的博弈论问题，直接放弃，博弈论还是比较脑减急转弯的</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/dznylj">2022-01-19</a></p>
<ul>
<li>如何避免构建初始滑动窗口的麻烦？可以往右边遍历时，到达某一个边界，才开始删除，就不用构建初始窗口那么麻烦了。</li>
<li>用迭代模拟递归核心原理：</li>
</ul>
<ol>
<li>node局部变量，指代dfs方法中的node入参。</li>
<li>当前node还有用，但需要往下搜索时，把自身入栈，再更新node局部变量。</li>
<li>当stack.pop时，说明已经从dfs(left)或者dfs(right)中走出来了。 则按照递归代码，选择继续走right入栈，还是直接打印自身。</li>
<li>node=null指代什么？指代必须要用stack.pop，即开始回溯了。当你试图回溯时，不可自己做node=node.right的操作， 而是要通过stack.pop处理</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/jngnpk">2022-01-17</a></p>
<ul>
<li>因此动规适用于单个结果，不适用于动规路径或者排列。如果需要求路径组合或者一定条件的排列组合，请使用记忆化搜索而不是动态规划。因为记忆化搜索时，只有成功搜索到底部，才会得到记忆化结果</li>
<li>链表首尾不断相连的解法： 如果涉及从后向前处理的链表，考虑反转链表再操作。 对于中点，使用快慢指针。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/lqhkby">2022-01-16</a></p>
<ul>
<li>感觉不好计算最终数组有几个位置的话，不如直接用list，最后toArrya(new xxx[0])即可<br>
return results.toArray(new String[0]);</li>
<li>问题是分配问题，但是却需要你计算一个某最大长度结果，则可以考虑二分法，固定最大长度，再分配。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-ii/">2022-01-15</a></p>
<ul>
<li>位运算问题，可以考虑“各位的数量&quot;，例如只有1个数字是1个，其他都是3个3个出现，那么可以从每位的1的个数，推断出那个数字（其他肯定要么是1的3倍或者0倍，加起来）</li>
<li>上一个状态集合是[00,01,10,11]，和数字[0,1]碰撞后,得到一个新的状态集合[x,y…]，则可以画出一个卡诺图， 上一个状态集合看作a\b两个门， 数字[0,1]看作c这个门，从而得到a和b的新状态电路情况<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/a8eac0b3823f887071474d90e16e46f2475973e5.png" alt="a8eac0b3823f887071474d90e16e46f2475973e5"></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/mtrveo">2022-01-14</a></p>
<ul>
<li>有时候要求满足复杂规则情况下，求最优结果，则可以考虑拆分成多种规则，取每个位置的最大值或者最小值<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/9fc32c38f70bff95f29aa46ba21db777a3362488.png" alt="9fc32c38f70bff95f29aa46ba21db777a3362488"></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/">2022-01-13</a></p>
<ul>
<li>当从i往右滑动到j时，整个过程要求都满足区间和[i, k]大于等于0时， 一旦有[i,j]不满足， 则[i,j]中的任一点都无法作为起点， 因为[i,i]肯定满足&gt;=0，则[i+1,j]肯定变得更小了，以此类推（或者说[i,xxx]这个前缀和肯定都大于0，得到中间任一位置都无法满足）</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ooypni">2022-01-11</a></p>
<ul>
<li>根据障碍数n，计算出一个能围住的最大格数max，如果a能bfs搜到的点大于max，说明没围住。 如果小于，则肯定围住了。<br>
网格中，障碍个数n能围住的最大格子个数max= n*(n-1)/2</li>
<li>x=1000000，y=1000000, x<em>y不会超Long， 但是(x+1)</em>(y+1)可能会超</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/cgojnt">2022-01-10</a></p>
<ul>
<li>差距某个字母才算相邻的单词相邻问题，可以使用虚拟节点求解。（同理可以作用到数组相邻问题上）<br>
例如abc可以和bc、ac、ab*这三个虚拟节点相邻。<br>
其他一样处理， 这样就可以直接连起来<br>
还要维护id到单词、单词到id的2个映射map。</li>
<li>双向bfs可以降低空间消耗，但是不能降低过多的时间复杂度</li>
<li>力扣不支持bigInteger。如果在35位范围内，可以尝试使用Double表示大整数。如果长达几百上千位，就只能自己写string大整数加法了。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/pspxgi">2022-01-08</a></p>
<ul>
<li>力扣竞赛，示例的正确答案在右边，不要看错了</li>
<li>可以先写一些用例，在跑，减少罚分，养成习惯</li>
<li>给你一堆固定长宽矩形的左上顶点， 让你判断某个点是否被任一矩形包含，则 可以反向前缀和， 求这个点的左上矩形区间内是否包含矩形顶点即可</li>
<li>前缀和别写错，注意要-1的都是左上角顶点坐标<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/fd9f505ce39b64eaebad16f0e4445fe305526913.png" alt="fd9f505ce39b64eaebad16f0e4445fe305526913"></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii/">2022-01-06</a></p>
<ul>
<li>组合数C(n,m)可以用杨辉三角求， 杨辉三角的n行m列等同于C(n,m)</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/swqraj">2022-01-05</a></p>
<ul>
<li>遍历小写字母， 用for(c = ‘a’;c&lt;=‘z’;c++)而不是for (j = 0; j &lt; 26; j++) { （char）(j+‘a’)}</li>
<li>能用spilt分割就用spilt，别自己分割,容易搞错</li>
<li>当给树添加新的指针，让你做常见遍历，却要你用常数空间时，一定是利用新指针当作线索来做遍历，避免了用栈或者队列。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/xjzpvn">2022-01-04</a></p>
<ul>
<li>树的搜索， 用迭代替代递归的关键点：</li>
</ul>
<ol>
<li>node局部变量等同于dfs(Node node)里的node入参</li>
<li>while(node = node.left) 等同于走dfs(node.left)</li>
<li>取栈顶， 等同于if(node==null) return的这个边界</li>
<li>node.right 入栈， node = node.right 等同于dfs(node.right)</li>
</ol>
<ul>
<li>要求空间复杂度为1的树中序遍历， 考虑利用左子树的最右节点的right空闲指针，指向自己，来快速跳转</li>
<li>二叉搜索树寻找问题节点， 直接遍历得到list，然后排序，就能找到问题节点了。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/odfefu">2022-01-03</a></p>
<ul>
<li>矩阵最大面积问题，提前想到单调栈，固定自身高度h，左右扩展。</li>
<li>计算星期几、日期相关题目， 统一用减去1970年12月31日的方式，拿到时隔多少天， 用天数去判断</li>
<li>子集问题，直接dfs，不要想着骚操作搞for循环，太容易写错了。避免重复，就是那个原则“必须连着选相同的，不能跨着选相同的”</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ddyvlk">2022-01-01</a></p>
<ul>
<li>如果是单调栈的题目，最终肯定只需要使用栈头的元素。 如果你发现需要遍历栈中所有元素，导致高度和宽度全在变化导致无法计算， 可以看一下是不是改变计算思路，固定自身为某个高度，而不是去寻找前面的某个高度。</li>
<li>把上一组n阶的格雷码集合 都在头部加一个1， 然后倒序加进来即可。（可以理解为先头部加个1跳进去，然后反向走一遍，就肯定能保证走回去了）</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/cxdaku">2021-12-30</a></p>
<ul>
<li>不要看到总数为n，分组长度最大为n，就认为自己的双重for循环可能有O(n^2)的复杂度。<br>
对于会提前结束/退出判断的情况来说， 双重for可能最多就O(n)，循环就会结束了</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/uynbou">2021-12-29</a></p>
<ul>
<li>a+b+c=d的等式问题， 可以转化为a+b=d-c问题</li>
<li>4个点的复杂滑动窗口问题， 可以只滑动中间点， 左边当区间复用历史结果， 右边做遍历。</li>
<li>从某序列变成某序列的“最短编辑距离”问题， 可以考虑动态规划， 判断从子序列A变成子序列B时，能通过做哪些动作实现部分匹配，再判断剩下子序列a和子序列b的最短距离即可。<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/b126300997a64998cce44f429188d3f512dbbed6.png" alt="b126300997a64998cce44f429188d3f512dbbed6"></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/btbzyn">2021-12-28</a></p>
<ul>
<li>List&lt;int[]&gt; result如何转int[][]?      result.toArray(new int[0][0]);</li>
<li>问你某某走法的数量，却要求空间限制，无法动态规则，则考虑组合数。</li>
<li>组合数快速解法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(<span class="number">8</span>,<span class="number">3</span>) = <span class="number">8</span> * <span class="number">7</span> * <span class="number">6</span> /(<span class="number">3</span> * <span class="number">2</span>* <span class="number">1</span>) =( ((((<span class="number">6</span> / <span class="number">1</span>) * <span class="number">7</span>) / <span class="number">2</span>) * <span class="number">8</span>) / <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">2021-12-27</a></p>
<ul>
<li>当数量很大，但是数值范围很小，却要你做二分、排序或者区间统计时，优先考虑直接用数组做计数排序/计数前缀和。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/agaioj/">2021-12-26</a></p>
<ul>
<li>快速只保留末尾的1，其他全置0： b &amp;(-b)</li>
<li>快速剔除末尾的1： b &amp;(b-1)</li>
<li>全排列问题， 直接搜索每个位置能放谁，从0开始遍历+vis数组</li>
<li>重复问题的剪枝：只能连续插入重复的数字，不能跳跃着放重复数字。因为跳跃了的话，前面完全可以搜过一样的情况</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-duplicate-substring/">2021-12-23</a></p>
<ul>
<li>遇到特定长度的<strong>子串/子数组</strong>是否<strong>重复/已存在</strong>的问题，可以考虑用字符串哈希</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/heaters/">2021-12-20</a></p>
<ul>
<li>二分的最大right记得想清楚，不确定的话直接Integer.MAX_Value就行</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/pdosib">2021-12-19</a></p>
<ul>
<li>问你最少替换几个数字， 可以变成递增序列， 其实 可以变成“求出最长递增子序列后， 剩下的就是要变的数字”。 或者说替换几个东西，可以变成xxxx， 是否可以改成求 最长的xxxxx，然后剩下的就是要改变的东西</li>
<li>如果设计key-value的value二分， 不要试图用treeMap，因为treeMap是基于key排序的。 做更新操作会恶心死自己，不如直接基于key二分，然后判断value</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">2021-12-14</a></p>
<ul>
<li>数独判断的问题记得先写针对区间的check函数，再判断，会简化很多操作。<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/9c00e5b295a063c590a4e969521709d8d673cdb4.png" alt="9c00e5b295a063c590a4e969521709d8d673cdb4"></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/tlehxw">2021-12-13</a></p>
<ul>
<li>旋转数组二分问题，每次找有序的那段，再去判断</li>
<li>旋转数组如果有重复数字，提前处理左右边界都相等的情况，都+1和-1，这样就省了很多复杂场景了</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/">2021-12-12</a></p>
<ul>
<li>滑动窗口求最大值问题时，不要忘记求初始窗口时的最大值更新。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/dzqyun">2021-12-11</a></p>
<ul>
<li>排序过程如果涉及索引，可以考虑弄一个索引i的数组，对i做排序，不需要带着索引弄个二维数组很麻烦</li>
<li>Arrays.sort如果要对int[]数组自定义排序， 应该使用Integer[]而不是int[]数组。</li>
<li>如果滑动窗口如果发现删除点的操作比较麻烦，可以尝试事先利用数组特性预计算一些前缀和等数据，提前算好那个区间的值，而不需要去考虑移动时点的更新。</li>
<li>bfs时，一定要记得第一个入队的点需要设置vis[x] = true，这个很容易漏！</li>
</ul>
<hr>
<p>这下面的是从旧往前， 而最新的都改成了新的放上面</p>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/waggvn">2021-10-07</a></p>
<ul>
<li>复杂字符串解析问题， 尽可能避免边解析边计算，可以分成2步来做，先解析成N个字符串，再依次判断和计算。</li>
<li>并查集问题，涉及边界相连的情况，可以将边界认为是一种集合。</li>
<li>二维点问题，尽可能用index = getIndex(y,x) 获取二维索引， 避免大量二维数组操作， 用InArea(y,x)方法减少判断代码。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/nfzhwn">2021-10-08</a></p>
<ul>
<li>相连、成环问题，都要想到可能和并查集有关</li>
<li>对于复杂的模拟过程题目，一定要自己在纸上把几种情况列出来，切忌脑测然后想出一个完全不合理的解决思路。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/jnvvwv">2021-10-09</a></p>
<ul>
<li>字典树的使用和查询过程，切忌偷懒，不要漏了走到null节点结束查询的情况。</li>
<li>迷宫理论：  总共n种位置，走了2n步，则一定是死循环，无法走出（在博弈题里即平局）</li>
<li>动态规划，记得步长或者回合数是可以当状态的， 不要漏了这个，不要死脑筋只想着做状态压缩</li>
<li>位图状态压缩，力扣题几乎都是16位情况的压缩， 几乎不会出现32位以上的，超过这些，则考虑是否可以不需要记录走过的点之类的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/fatqmp">2021-10-10</a></p>
<ul>
<li>一组数字，如果只能加和减任意x，且要求最终相等， 他们必定互相之间的差值是x的倍数</li>
<li>求和问题、绝对值问题，注意最好先自己用数学公式推导一下，更容易快速理解思路，切忌胡思乱想</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/kvplxk">2021-10-11</a></p>
<ul>
<li>交替复制的问题，可以使用双指针来做</li>
<li>优先队列：a是上面的点，b是下面的点（儿子节点），(a,b)返回大于0的时候，则交换</li>
<li>涉及排序变化，由数组A变成数组B的问题， 确定一下是否存在 ”稳定排序“，即不会跨相同数字变动， 能确定的话，就可以确定数组B中每个数字是由哪些位置的数字变化而来， 从而找到突破口</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/giskpp">2021-10-15</a></p>
<ul>
<li>什么情况下Arrays.stream(数组)之后不需要boxed()？ 即不是int[]、long[]这种需要转包装类型才能变成list的情况</li>
<li>记忆一下.collect(Collectors.toList()))</li>
<li>滑动窗口， 建议先用for循环移动右边， 确定右边的位置后，再用while移动左边找到满足条件的左边界， 这样可以简化很多判断<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/d987e1f51885cc3c4a0c5d2b059a8e2ca5633145.png" alt="d987e1f51885cc3c4a0c5d2b059a8e2ca5633145"></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ibmlji">2021-10-16</a></p>
<ul>
<li>数组A和数组B个数相同，B里的每个值要通过+1、-1变成A时，需要的次数为 ”AB分别排序后，每个i位置的Math.abs(a[i] - b[i])总和“</li>
<li>即使心态不好， 也要仔细审题加看例子，不能不理会用例，错过用例很可能就理解错误导致gg</li>
<li>边比较少点比较多的情况时，如果要求最短路径， 则用bfs，不需要djkstra</li>
<li>bfs求最短路径时， 只需要newDis &lt; dis[node],再入队即可，且不需要做很多的vis判断。记住这个bfs求最短路<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/3c84111fe71f4a886bab0bd1b28816389c78b017.png" alt="3c84111fe71f4a886bab0bd1b28816389c78b017"></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/lubjor">2021-10-17</a></p>
<ul>
<li>n个数小于16的时候， 如果题目涉及选或者不选，那么是可以直接暴力枚举出所有的情况的，不需要用dp缓存之类的。<br>
利用下面的代码求某一位怎么用上，不需要vis数组或者while除2啥的很麻烦的那种</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">     <span class="comment">// 说明那个数字做过亦或，不需要vis数组</span></span><br><span class="line">     <span class="keyword">if</span> ( (i &amp; (<span class="number">1</span>&lt;&lt;j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 选中了nums[j]， 拿nums[j]做对应的操作;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>某DAG点如果可以重复走，那么当你走到某个位置时，其最小路径和次小路径已可以在出现后确定，后面的情况斗则可以不用考虑。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/xacmxh/">2021-10-22</a></p>
<ul>
<li>字符串日期天数问题，可以直接取一个基线例如1971年来计算天数。</li>
<li>快速将map的key变成list的方式, 注意记忆.collect(Collectors.toList())：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; keyList = map.keySet().stream().collect(Collectors.toList())</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/rubjpq">2021-10-23</a></p>
<ul>
<li>树的层序遍历打印不一定要用bfs， dfs也行的，就不用存object[]了。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/jmcdff/">2021-10-24</a></p>
<ul>
<li>下次碰到复杂单词校验，如果正则忘记了，则直接上状态机，会简单很多。</li>
<li>状态变化设置不要放在枚举的构造器里做，初始化可能会出现null，如果顺序不对的话。放static块中做</li>
<li>注意Arrays.stream()不支持对char[]操作。</li>
<li>当遇到答案是乘起来或者很多数字加起来的时候， 最好直接改成long做计算，避免溢出。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/dcugfw">2021-10-29</a></p>
<ul>
<li>链表转换题中，注意如果left和right会变化，则你原本想递归的东西可能会变动， 因此要提前缓存</li>
<li>Math.ceil（） 可以实现向上取整， floor向下取整</li>
<li>Math.log可以求 Math.log(a) /Math.log(b) 等同于loga（b）</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/dcugfw">2021-10-30</a></p>
<ul>
<li>教训： 深度搜索时， 主要先确定层级，如果有n个东西必须做某件事，那就拿这东西做层级，中间for循环搜不同情况即可， 东西搜完了就说明符合条件</li>
<li>注意，涉及按时间在图上走的情况，是可以制造一个三维的图（数组），用时间做某一个维度即可避免冲突或者搞乱。</li>
</ul>
<hr>
<p>2021-11-21</p>
<ul>
<li>遇到边界问题很难受，不知道-1还是-0的，自己冷静下来模拟一下</li>
<li>1-9有9个<em>1位， 10-99的有90个</em>2位，   100-999有900个*3位， 问你第1000位是1-∞中的哪个数字。<br>
这时候冷静处理闭上列出来    9个  180个  811个<br>
811个中，分别是  100 101 102 103<br>
让序号从0开始，则811-1 = 810， 然后用除法和取余即可。</li>
<li>注意要用到取余判断某位是什么时，记得序号从0开始</li>
</ul>
<hr>
<p>2021-11-22</p>
<ul>
<li>洗牌算法： 数组0-n，每次对n随机取余后，将对应位置的数字交换到最后一位，然后减少n，继续操作。</li>
<li>rand.nextInt()的范围是负无穷到正无穷， 如果rand.nextInt()%M， 则范围为-M 到M。 因此应该改成rand.nextInt(M)， 则范围为0-M-1</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/bsrxpi">2021-11-24</a></p>
<ul>
<li>stream中join的用法：.collect(Collectors.joining(“,”))，    而不是直接join</li>
<li>环形数组如果要求避免头尾相碰，  可以选择去掉头或者去掉尾，做2次， 就能不考虑环的问题了</li>
<li>动规、个数问题，优先考虑 dp[从i到末尾][某条件]  而非用区间去判断</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/boundary-of-binary-tree/submissions/">2021-11-25</a></p>
<ul>
<li>树的左边界、叶子、右边界问题，  如果时间紧急，用3次遍历解决即可。  如果追求代码精致， 则用2个标记，不断往下传递，根据情况变化，需要自己考虑好边界条件，慎用。<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/e0d7714912cb467741ce63ebb6430b7300a96e1e.png" alt="e0d7714912cb467741ce63ebb6430b7300a96e1e"></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/random-flip-matrix/">2021-11-26</a></p>
<ul>
<li>如果要求在10000*10000的数字中进行多次不重复的随机选取， 内存不够的情况下， 可以利用map映射，将已被选的数字和末尾数组数字进行映射。<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/4cb1e2e718d8888408ecc5093f3ba79375869d08.png" alt="4cb1e2e718d8888408ecc5093f3ba79375869d08"></li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/kiarwh">2021-11-28</a></p>
<ul>
<li>最大最小值问题，一定要注意如果最大最小是同一个值的情况</li>
<li>Math.abs(a-b)-1 误写成了 Math.abs(a-b-1)， 绝对值计算一定要注意-1是不是写错位置了</li>
<li>带条件的并查集（即满足条件才能相连）， 应当按时间顺序做尝试性连接， 连完后发现不符合条件，则要重置该节点的parent，避免后面连错。</li>
<li>并查集结果返回时，返回前的判断应该是 findParent(node) 是否满足而非parent[node]是否满足， 因为可能还没做压缩。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/lkizjq">2021-11-29</a></p>
<ul>
<li>迭代法前序遍历树： 往栈里放儿子时，直接倒序放入即可。</li>
<li>如果前面的信息可以利用，则考虑用滑动窗口，减少空间占用。（删掉一个元素以后全为 1 的最长子数组）</li>
<li>原地矩阵置0问题， 考虑用第一行和第一列来做临时存储，然后用标记变量判断第一列和第一行是否需要置0。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/vbvqcg/">2021-11-30</a></p>
<ul>
<li>数字不相邻排列问题，按数量从大到小插入，插入时先偶数位插入，再奇数位插入，则一定保证题目要求</li>
<li>统计子串中的唯一字串。碰到某些问x唯一的情况， 想办法从x的角度出发找唯一的串或者子序列。</li>
<li>想不到的时候，试着换一个维度去，原本是从a推b， 看下能否从b推a</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-enclaves/">2021-12-01</a></p>
<ul>
<li>String自身按照字段序重新组合方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = str.toCharArray();</span><br><span class="line">Arrays.sort(cs);</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(cs).toString();</span><br></pre></td></tr></table></figure>
<ul>
<li>bfs题，注意y\x\ny\ny不要写错，每次写完检查一下<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/5f3365c64c94fd12501c5136b52bfca74ad582f6.png" alt="5f3365c64c94fd12501c5136b52bfca74ad582f6"></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/zwqvwy">2021-12-02</a></p>
<ul>
<li>求最长回文子串， 注意  i和前面某中心的对称节点j， 则j的回文长度信息是可以进行利用的。</li>
<li>全排列不一定要用dfs去搜索。因为 第4位时，它的可能性就是前面3位的可能性总和再拼上第四位。因此一直记录当前result全集， 然后走到第x位时，让第x位和result全集拼接，再生成一个新的result集合</li>
<li>k的子变量不要用kk， 同理不要用ii作为i的自变量， 很容易写错， 应该是indexK之类的，做到第一位不同，否则很容易写错。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/mvulve/">2021-12-04</a></p>
<ul>
<li>如果本来是可以利用哈希表，但要求原地算法的题目， 则可以考虑用数组本身作为哈希表</li>
<li>数组迭代期间不要试图取更新数组值，因为更新的话迭代的nums是会变的，并不是不变的。</li>
<li>涉及运算符的题目， 用switch+string的特性即可， 不用搞OP枚举，太容易错了</li>
<li>二维场景加？：表达式很容易漏加括号<br>
<img src="/D:/%25E6%259D%258E%25E7%25BB%258D%25E6%2599%2593%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%259D%25E5%2585%25B8/%25E7%25AE%2597%25E6%25B3%2595/%25E7%25BC%2596%25E7%25A8%258B%25E9%25A2%2598/e0f19882380cf45d20ff05564b14a013cde11b8e.png" alt="e0f19882380cf45d20ff05564b14a013cde11b8e"></li>
<li>二维场景如果不想加边界判断， 可以用这种扩充边界思路， counts设置成 counts[m+2][n+2]， 然后坐标从1，1开始即可。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/nhyavd">2021-12-05</a></p>
<ul>
<li>简单题如果发现要很麻烦的dfs时，直接看下数据范围，确认能否从全集上去直接计算结果，而非从搜索去推导结果。</li>
<li>求公共祖先或者树点到树点路径， 除了向上求祖先之类的外， 还可以用前缀法， 即求出根到2个点的路径，去除相同前缀即可。</li>
<li>给一堆边，让你把他连成一条线（一笔画问题），且题目保证有借， 则考虑这是欧拉问题。 起点和终点是能明确的，直接用Hierholzer算法求。 具体见<a href>欧拉路径</a></li>
<li>即需要边搜索边删除’边’的情况， 可考虑存储边的迭代器引用后，再进行搜索</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/cksuqu">2021-12-07</a></p>
<ul>
<li>括号的全排列问题， 可以用 (a)b的形式去利用a、b缓存逐步求解，不需要dfs</li>
<li>treeMap的floor 和celling总是记不清， floor——浮——水——    要找的值在水上，但是只有下面的水key</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ltmjvy">2021-12-09</a></p>
<ul>
<li>KMP算法的本质是[前缀-后缀]匹配算法， 后缀不匹配时，快速找到之前匹配部分的前缀位置。</li>
<li>是否可按线性跳跃到某点的问题，如果发现从后往前不好判断，会超时，则试着从前往后，根据当前最远到达位置判断， 有点类似于bfs。</li>
<li>a+b&gt;c时如果a+b可能溢出，则改成减法 a&gt;b-c</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/ppidmj/">2021-12-10</a></p>
<ul>
<li>不要做这种map.get()==map.get()的操作，高危操作。 Integer的==是引用。 要用equals。</li>
<li>滑动窗口中的个数匹配问题，用下面这种if-else去判断是+1还是-1。<br>
<img src="69541d637f6c32d66f7415fe3ea1026572937dd6.png" alt="69541d637f6c32d66f7415fe3ea1026572937dd6"></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>breakDawn
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://breakdawncoder.com/2021/10/07/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/21%E5%B9%B410%E6%9C%88-22%E5%B9%B45%E6%9C%88/" title="21年10月-22年5月">http://breakdawncoder.com/2021/10/07/编程/日常刷题日记/21年10月-22年5月/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/05/02/home/" rel="next" title="首页">
      首页 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共216.1k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
