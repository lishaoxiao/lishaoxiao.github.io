<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="冲破黎明前的黑暗">
<meta property="og:url" content="http://example.com/home/index.html">
<meta property="og:site_name" content="冲破黎明前的黑暗">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/home/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>冲破黎明前的黑暗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冲破黎明前的黑暗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-knowledge">

    <a href="/knowledge/" rel="section"><i class="fa fa-university fa-fw"></i>知识库</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book/" rel="section"><i class="fa fa-book fa-fw"></i>读书笔记</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/java-object-in-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/java-object-in-heap/" class="post-title-link" itemprop="url">java堆中分配对象的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-03 23:07:31 / 修改时间：23:39:15" itemprop="dateCreated datePublished" datetime="2022-05-03T23:07:31+08:00">2022-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java对象在堆中的分配原理"><a href="#Java对象在堆中的分配原理" class="headerlink" title="Java对象在堆中的分配原理"></a>Java对象在堆中的分配原理</h1><p>java对象new的一个过程<br> <img src="/images/java-object-in-heap/7499e987f62965de977d2434a2587a1bcf9b3149.png" alt="7499e987f62965de977d2434a2587a1bcf9b3149"> </p>
<hr>
<p>Q: 什么是TLAB?<br>A:<br>TLAB ——Thread Local Allocation Buffer<br>线程本地分配缓冲区</p>
<p>如果没有启用 TLAB，多个并发执行的线程需要创建对象、申请分配内存的时候，有可能在 Java 堆的同一个位置申请，这时就需要对拟分配的内存区域进行加锁或者采用 CAS 等操作，保证这个区域只能分配给一个线程。冲突概率很大</p>
<p>启用了 TLAB 之后(-XX:+UseTLAB, 默认是开启的)，JVM 会针对每一个线程在 Java 堆中预留一个内存区域<br>一旦某个区域确定划分给某个线程，之后该线程需要分配内存的时候，会优先在这片区域中申请。这个区域针对分配内存这个动作而言是该线程私有的，因此在分配的时候不用进行加锁等保护性的操作</p>
<hr>
<p>Q: TLAB给线程预分配空间的时候，如果多个线程竞争同一个预留空间冲突了怎么办？<br>A:<br>在预留这个动作发生的时候，需要进行加锁或者采用 CAS 等操作进行保护，避免多个线程预留同一个区域</p>
<hr>
<p>Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？<br>A:<br>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<p>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。<br>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</p>
<hr>
<p>java对象在内存上的分配：<br> <img src="/images/java-object-in-heap/9624dbbc45d4b10ae636df5b0766b5cc5bcfbe25.png" alt="9624dbbc45d4b10ae636df5b0766b5cc5bcfbe25"> </p>
<hr>
<p>Q: 对象的hashcode确定是创建对象的时候生成的？<br>A:<br>不对。采用延迟加载技术</p>
<hr>
<p>Q: 如何计算一个java对象大小？<br>例如下面的person？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Xiaoming&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">married</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">birthday</span> <span class="operator">=</span> <span class="number">128902093242L</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sallary</span> <span class="operator">=</span> <span class="number">1200.00d</span>;</span><br><span class="line">	<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>这里假设使用64位机器，采用指针压缩，则对象头的大小为：8(_mark)+4(_klass) = 12（如果没开启，k_class即对象引用地址占8个字节）</p>
<p>然后实例数据的大小为： 4(age)+4(name) + 8(birthday) + 8(sallary) + 2(tag) +  4(引用，开启指针压缩) +  1或4(married)  = 31 or 34</p>
<p>因此最终的对象本身大小为：12+31+5(padding) = 48 或者 12+ 34 + 2(padding) = 48</p>
<blockquote>
<p>PS1: 注意布尔值可能是1或者4，根据虚拟机规范不同有不同，4字节的话好处是CPU</p>
</blockquote>
<blockquote>
<p> PS2: 注意，指针压缩不仅仅影响对象头，还影响了对象内的引用大小。</p>
</blockquote>
<p>更详细的见<a target="_blank" rel="noopener" href="https://blog.csdn.net/yunqiinsight/article/details/80431831">如何计算Java对象所占内存的大小</a></p>
<hr>
<p>Q: 对象头里的markword到底是啥？<br>A:<br>markword根据锁标记的状态，里面存储的了不同的内容。<br> <img src="/images/java-object-in-heap/ba9578e95096512cbd024da4b88b117e4a14e449.png" alt="ba9578e95096512cbd024da4b88b117e4a14e449"><br> <img src="/images/java-object-in-heap/ff1ad3a49021dba3739e0c3cb66c2dd636ec242a.png" alt="ff1ad3a49021dba3739e0c3cb66c2dd636ec242a"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26542493/article/details/90938070">java对象头 MarkWord</a></p>
<hr>
<p>Q: 哈希code 有锁的时候，hashcode又去哪了？<br>A:<br>identity_hashcode：31位的对象标识hashCode，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。</p>
<hr>
<p>Q: 对象内存字节为什么要按8字节对齐？<br>A:<br>对齐填充是底层CPU数据总线读取内存数据时的要求<br>例如，通常CPU按照字单位读取，如果一个完整的数据体不需要对齐，那么在内存中存储时，其地址有极大可能横跨两个字<br>例如某数据块地址未对齐，存储为1-4，而cpu按字读取，需要把0-3字块读取出来，再把4-7字块读出来，最后合并舍弃掉多余的部分。这种操作会很多很多，且很频繁<br>但如果进行了对齐，则一次性即可取出目标数据，将会大大节省CPU资源。</p>
<p>另一种说法：</p>
<blockquote>
<blockquote>
<p>Scott oaks在书上给出的理由是：<br>其实在JVM中（不管是32位的还是64位的），对象已经按8字节边界对齐了;对于大部分处理器，这种对齐方案都是最优的。所以使用压缩的oop并不会损失什么。如果JVM<br>中的第一个对象保存到位置0，占用57字节，那下一个对象就要保存到位置64，浪费了7<br>字节，无法再分配。<strong>这种内存取舍是值得的（而且不管是否使用压缩的oop，都是这样），因为在8字节对齐的位置，对象可以更快地访问</strong>。 </p>
<p>不过这也是为什么JVM没有尝试模仿36位引用（可以访问64GB的内存）的原因。在那种情况下，对象就要在16字节的边界上对齐，在堆中保存压缩指针所节约的成本，就被为对齐对象而浪费的内存抵消了。<br>** 8字节对齐，是为了效率的提升，以空间换时间的一种方案**。当然你还可以16字节对齐。但是8字节是最优选择。</p>
</blockquote>
</blockquote>
<hr>
<p>Q: jvm的指针压缩原理是什么？<br>A:<br>我们都知道java中的对象都是8字节对齐的，8字节对齐有一个特点就是总是加上1 000。 发现了吗， 所有对象的指针后三位总是0。这就是指针压缩的点。</p>
<p>压缩原理就是两句话：<br>1：存储的时候，后三位抹除0.<br>就变成：test1=00，test2=10<br>2：使用的时候，后三位补0.</p>
<p>它的指针不再表示对象在内存中的精确位置，而是表示 偏移量 。这意味着 32 位的指针可以引用 40 亿个 对象 ， 而不是 40 亿个字节。最终， 也就是说堆内存增长到 32 GB 的物理内存，也可以用 32 位的指针表示。（4字节指针地址原先只能表示4个G的大小）</p>
<hr>
<p>Q: 指针压缩什么时候会失效？<br>A:<br>因为寄存器中2的32次方只能寻址到32g左右(不是准确的32g，有可能在31g就发生指压缩失效)<br>所以当你的内存超过32g时，jvm就默认停用压缩指针，用64位寻址来操作，这样可以保证能寻址到你的所有内存，但这样所有的对象都会变大，实际上未开启开启后的比较，40g的对象存储个数比不上30g的存储个数</p>
<hr>
<p>Q: 为什么对象头里的kclass也会受指针压缩的影响？class实例不是存储在方法区里么？<br>A:<br>JDK1.6中Class实例在方法区<br>JDK1.8之后， class实例本身就是一个对象，分配在java堆中。而class字节码加载后的各种细节内容则存储在永久代中。</p>
<p>HotSpot并不把永久代中的instanceKlass暴露给Java<br>而会另外创建对应的class对象instanceOopDesc来表示java.lang.Class对象（即这个对象里不会包含class细节字节码的内容），并将后者称为前者的“Java镜像”， 对象头里的klass就是持有指向类oopDesc引用(_java_mirror便是该instanceKlass对Class对象的引用)；</p>
<hr>
<p>Q: 在方法栈中执行代码时，如何通过引用定位到堆里的对象？<br>A:<br>两种方式，通过句柄池，或者通过指针。如下图所示<br><img src="/images/java-object-in-heap/5d0f1b24e4b024123de4f669.png" alt="引用对象"></p>
<hr>
<p>Q: 句柄和指针的区别是什么？<br>A:<br>句柄池， 引用中的句柄地址不会发生改变引用变动时，只会变动句柄中数据指针的内存<br>可以理解为，句柄池方式， 创建新对象后，句柄位置就定下来了。后面如果频繁修改引用， 只会修改句柄里的指针，但是本地变量表里寻找的位置都不会变化，因此不用经常跳到各种本地变量表去修改。</p>
<ul>
<li>频繁gc、修改引用的，用句柄池引用</li>
<li>频繁访问固定对象的，用指针引用</li>
</ul>
<hr>
<p>Q: 怎么确认用的是句柄引用还是指针引用？<br>A:<br>sun HotSpot用的指针引用，速度快<br>访问方式，取决于虚拟机的实现。</p>
<hr>
<p>Q： 方法里创建基本类型的局部变量时， 为什么不把基本类型放堆中呢？<br>A:<br>因为其占用的空间一般是 1~8 个字节——需要空间比较少，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的。</p>
<p>可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据</p>
<hr>
<p>Q: 那我new出来的对象， 一定都在堆中吗？<br>A:<br>HotSpot虚拟机引入了JIT优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>
<hr>
<p>Q: 刚才new对象的过程，可能存在重排序吗？<br>A:<br>存在。<br>①「JVM」为对象分配一块内存M。<br>②在内存M上为对象进行初始化。<br>③将内存M的地址复制给singleton变量。<br>可以是「①②③」或者「①③②」。 这也导致了双重检查锁时，为什么有了sync还要加volatile。</p>
<p>但是另一种说法，是JDK高版本之后， 将这个new语句看成一个大号的volatile写，因此这个大号volatile写前后会有内存屏障，与volatile读隔离开来，因此虽然volatile读不知道大号volatile写的内部顺序，但是知道它的结果一定是执行完那三步的。<br>因此重排序仍然存在，但是会特地限制其他对该对象的new的过程是有屏障的。</p>
<hr>
<p>Q: 上面的过程的指令码是什么样的？<br>A:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: new           #16 // class jvm/fenixsoft/DynamicDispath$Man</span><br><span class="line">    3: dup   // 将栈顶复制一份再推进栈</span><br><span class="line">    4: invokespecial #18 // Method jvm/fenixsoft/DynamicDispach$Man.&quot;&lt;init&gt;&quot;:()V   调用初始化方法</span><br><span class="line">    7: astore_1  // 将引用赋值到局部变量表里</span><br></pre></td></tr></table></figure>
<p>那么为什么要进行备份呢？</p>
<p>一开始是new指令在堆上分配了内存并向操作数栈压入了指向这段内存的引用<br>之后dup指令又备份了一份，那么操作数栈顶就有两个<br>再后是调用invokespecial #18指令进行初始化，此时会消耗一个引用作为传给构造器的“this”参数， 注意这个指令会将栈顶的引用拿走，因此dup指令都是用于这种场景的，即栈顶的引用存在消耗。</p>
<p>那么还剩下一个引用，会被astore_1指令存储到局部变量表中，后面调用的代码会用到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/why-study-java-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/why-study-java-stack/" class="post-title-link" itemprop="url">【反八股系列】为什么我们要学习java虚拟机栈的原理？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-03 19:15:36 / 修改时间：23:06:07" itemprop="dateCreated datePublished" datetime="2022-05-03T19:15:36+08:00">2022-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>反八股系列的2大宗旨：</p>
<p>拒绝死记硬背</p>
<p>拒绝浅尝则止</p>
<hr>
<p>对于jvm的虚拟机内存结构，大家应该都能背会有“2个堆”、“2个栈”、“1个计数器” 这种内容，就像下面这张图一样。  其中java的栈是虚拟机指令执行的关键。</p>
<p>那么，为什么我们要学习背后的这个虚拟机栈呢？ 我的代码能跑起来不就了可以吗？</p>
<p>哦，是面试要用么？然而个人不希望这些内容成为新一代的“科技八股文”。</p>
<p>因此本系列希望先从为什么学习入手，再深入到更深层次的东西，，希望能带来的是长久的收获，而非短暂的记忆。</p>
<hr>
<p>首先回答第一个问题， 为什么要学习背后的虚拟机栈。</p>
<p>首先，你debug的时候，你都不知道这个是什么东西，瞎猜可不行，你要知道暂停时现在是个请什么情况， IDE上的东西到底是什么，他们对程序运行又有什么影响</p>
<p>[debug图片]</p>
<p>其次，这有部分内容是垃圾收集的前置知识点， 栈帧有关， JIT优化和栈有关，如果你不知道，遇到线管知识点，只会产生“这是啥”“这又是啥”，背吧背吧， 然后陷入背诵八股文的折磨中。</p>
<p>[知识点图谱]</p>
<p>最后，java虚拟机栈为我们生动展示了 一个小心的迷你的CPU执行逻辑。  </p>
<p>[cpu图]</p>
<p>[CSAPP图]</p>
<p>对于很多没有学习过计算机底层原理（例如CSAPP这本书） 的人来说， 是完全不知道计算机是如何执行机器码指令的。 而java虚拟机栈可以更好理解 指令是如何运行的， 虽然这个指令不是真正的机器码执行， 而是jvm字节码指令。  但是通过字节码指令， 我们可以快速对应到java中常见的各种操作。</p>
<p>这对于很多入门时直奔删减改查的同学来说， 是不可多得的学习底层的机会。</p>
<p>另外数据结构里学习的栈的知识也会在这里得以应用。</p>
<hr>
<p>清楚了上述好处后，我们开始深入了解虚拟机栈背后的东西。</p>
<p>首先，栈帧是什么？</p>
<p>当我们每进入一个方法，就生成了一个栈帧， 此刻只有栈顶在运行， 而前面的方法全部暂定（咋瓦鲁多）</p>
<p>对于栈帧， 经典4个词：</p>
<p>局部变量表</p>
<p>操作数栈</p>
<p>动态链接</p>
<p>方法返回地址</p>
<p>其实与之配合的还有个“程序计数器”，共同实现了jvm指令的执行。</p>
<p>首先拿局部变量表而言， 为什么要有这个东西？</p>
<p>这个可能好理解</p>
<p>我们声明的变量， 直接放到局部变量表中。</p>
<p>但是，变量表有多大呢？</p>
<p>编译时指定定死了</p>
<p>为什么能定死？</p>
<p>因为编译器很聪明，通过分析代码，他就能知道到底这个方法要用几个变量。</p>
<p>那我在一个for循环里反复生成一个变量，这个不会很大吗？</p>
<p>所以会支持变量表的复用，  编译器会知道你在重复声明变量，在实际字节码指令中写下“这个变量继续放到第8个槽”， 这样就会覆盖了之前使用的槽了。 </p>
<p>你问我怎么分析的？ 请阅读《编译原理》</p>
<p>然后操作数栈又是干什么的？ 如果要做a+b,我直接从变量表上取a的值和b的值，加起来不就好了？</p>
<p>直接让CPU取a和b的值拿去算完回来，不就好了？</p>
<p>那我如果是 a + b*c呢</p>
<p>b*c的值放哪里？</p>
<p>如果是a+b*(c+d)呢？</p>
<p>这时候如果你学习过数据结构里栈的应用 ，就会知道 模拟一个计算器，往往需要一个栈。</p>
<p>而操作数栈就是这个作用。</p>
<p>当你学习jvm指令时，就会看到有专门的指令就是取栈顶或者把值推送到栈顶的指令。</p>
<p>这样做加法的时候，也就不用关心变量的地址了，只要你把栈顶的值存好，我直接拿去加就行。</p>
<p>那么动态链接又是个什么玩意？ </p>
<p>就这么说， 你怎么知道这个方法此时要做哪些动作？</p>
<p>肯定有一段代码区（即jvm指令），让我一条条执行对吧？</p>
<p>那么这个代码区放哪呢？我总需要知道一个地址， 因此，动态链接，就是这个方法代码的位置。</p>
<p>那干嘛叫动态链接这么抽象啊？</p>
<p>因为有的方法往往是等运行的时候才知道地址， 所以统一就叫做动态链接了，这就是未来会提到的java多态的核心本质而。</p>
<p>那么返回地址比较好理解，方法执行完成， 返回上一层方法执行的位置。</p>
<p>等等，这个地址是实际的地址吗？例如0x2313212这种？</p>
<p>应该是把，不然怎么叫地址？</p>
<p>但是我已经有动态链接标记的方法指令的起始位置了，你为什么还要整这么长？</p>
<p>哦，那就用偏移值就可以了！</p>
<p>那现在再看，程序计数器，代表的是什么</p>
<p>很显然和方法返回地址一样， 也是指令偏移值，  这样通过动态链接 + 计数器， 就能知道这个方法当前执行到什么位置了， 即使发生了线程切换或者方法返回， 都不用担心了~！ </p>
<p>那么再深度扩展一下，根据以上理解，是否能清楚下面这个的原因代码的原因</p>
<p>当你知道远离后，你就不需要记忆这种情况，而是一想背后的实现，就能明白这么写是不对的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">   System.out.println(<span class="string">&quot;value : &quot;</span> + getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        i++; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 就是在执行 finally 语句块之前，try 或者 catch 语句块会保留其返回值到本地变量表（Local Variable Table）中。待 subroutine 执行完毕之后，再恢复保留的返回值到操作数栈中，然后通过 return 或者 throw 语句将其返回给该方法的调用者（invoker） </p>
<p>因为你要处理finally块时， 操作数栈要腾出来给finally使用， 因此返回值不能放在这，所以整了个局部变量ret放进去， 执行完成返回来。</p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/74771.htm">https://www.jb51.net/article/74771.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/java-high-level/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/java-high-level/" class="post-title-link" itemprop="url">java高阶知识点进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-03 16:03:55 / 修改时间：23:43:19" itemprop="dateCreated datePublished" datetime="2022-05-03T16:03:55+08:00">2022-05-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java原理进阶"><a href="#Java原理进阶" class="headerlink" title="Java原理进阶"></a>Java原理进阶</h1><h3 id="jvm内存区域结构-栈、方法区、计数器"><a href="#jvm内存区域结构-栈、方法区、计数器" class="headerlink" title="jvm内存区域结构(栈、方法区、计数器)"></a><a target="_blank" rel="noopener" href="http://breakdawncoder.com/2022/05/03/java-jvm-memory/">jvm内存区域结构(栈、方法区、计数器)</a></h3><h3 id="jvm堆分配对象原理"><a href="#jvm堆分配对象原理" class="headerlink" title="jvm堆分配对象原理"></a><a target="_blank" rel="noopener" href="http://breakdawncoder.com/2022/05/03/java-object-in-heap/">jvm堆分配对象原理</a></h3><h1 id="Java应用进阶"><a href="#Java应用进阶" class="headerlink" title="Java应用进阶"></a>Java应用进阶</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/java-jvm-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/java-jvm-memory/" class="post-title-link" itemprop="url">jvm内存区域知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-03 15:47:55 / 修改时间：16:20:25" itemprop="dateCreated datePublished" datetime="2022-05-03T15:47:55+08:00">2022-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM内存区域详解"><a href="#JVM内存区域详解" class="headerlink" title="JVM内存区域详解"></a>JVM内存区域详解</h1><hr>
<p>Q; Java虚拟机规范将JVM虚拟机所管理的内存分为几部分？如果是多选题，估计会给一些不在里面的，例如直接内存。<br>A：程序计数器、java虚拟机栈、本地方法栈、方法区、堆。</p>
<p> <img src="/images/java-jvm-memory/808b3199e8599896108e1152c52b3f53e7afec93.png" alt="808b3199e8599896108e1152c52b3f53e7afec93"> </p>
<hr>
<p>Q: 有多个线程时，刚才提到的5个区域是怎么分布的？<br>A:<br>每个线程，都有自己独立的虚拟机栈、独立的程序计数器PC<br>方法区和堆是共用的，但是线程分配堆空间时，会先根据TLAB进行独立分配。<br> <img src="/images/java-jvm-memory/c0e260afa9bc603cb1168bd992e3a8a47e5e0ace.png" alt="c0e260afa9bc603cb1168bd992e3a8a47e5e0ace"> </p>
<hr>
<h2 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h2><p>java堆的内容比较多，更多关注于如何分配内存，可以跳转到这篇文章：</p>
<p><a target="_blank" rel="noopener" href="http://doc.minidown.cn/fiqjgy">java堆的对象分配原理</a></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>Q: PC计数器是整个jvm共有的吗？<br>A:<br>不是的，是每个线程各自有一个， 而且是java自己定义的线程PC， 和CPU里的PC寄存器不同。</p>
<hr>
<p>Q: PC计数器有啥用？ 那如果没有PC寄存器呢？ 我不是也能一条条执行，遇到return指令，返回对应地址即可，需要PC寄存器做啥？<br>A: PC寄存器的作用在于多线程切换的时候，能找到每个线程执行的位置，所以它是线程私有的一个寄存器，知道当前运行到哪了。如果没有，一旦随机切换就不知道咋办了。你总需要一个地方存储这个线程当前执行情况，但又要保持独立性，所以不可能存到其他线程的空间里。</p>
<hr>
<p>Q： 为什么native方法的程序计数器为0（undefine）？如果发生线程切换，怎么办？<br>A:<br>注意，jvm内存结构里的PC计数器是jvm自己定义的“字节码指令”执行寄存器。<br>对于native方法，并不在字节码的范围，不指向方法区里的任何指令位置。</p>
<p>因此native方法其实不是由jvm管理的，如果线程切换，他执行到哪边，取决于OS的底层机器码计数器实现。</p>
<blockquote>
<blockquote>
<p>以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。</p>
</blockquote>
</blockquote>
<hr>
<p>Q: PC计数器里存的到底是啥？是指令地址吗？<br>A:<br>错误！ 存的不是地址，而是这个方法的字节码偏移。例如0、1、5、6这种。<br> <img src="http://doc.minidown.cn/usfgdf/1841394cac82851fa43e67815f0e8b125c5667c7.png" alt="1841394cac82851fa43e67815f0e8b125c5667c7"> </p>
<hr>
<p>Q: 那么怎么知道实际的字节码位置？<br>A: 这个就要结合后面提到的栈帧中的动态链接了。</p>
<h2 id="虚拟机栈区域"><a href="#虚拟机栈区域" class="headerlink" title="虚拟机栈区域"></a>虚拟机栈区域</h2><hr>
<p>Q： 什么是栈帧？<br>A： 每个线程有一个自己的栈帧，然后运行到每个方法时，每个方法中都会可以理解为是摄影里的一帧。<br><img src="/images/java-jvm-memory/1636712286586008263.png" alt="image.png"></p>
<hr>
<p>Q： 栈帧里包含什么？<br>A：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法返回地址</li>
</ul>
<hr>
<p>Q： 什么是操作数栈<br>A：<br>可以理解为jvm做计算时，需要一个临时的寄存器，把需要计算的数据或者传方法的参数放到栈中，然后做计算。<br><img src="/images/java-jvm-memory/1636712274277007826.png" alt="image.png"></p>
<hr>
<hr>
<p>Q: 栈帧的大小什么时候确定？<br>A：<br>在编译程序代码的时候.<br>注意， 图例提到的栈大小，并不是指线程堆栈的最大深度，<br>而是指“操作数栈”的最大深度。（注意这个深度存在类文件字节码中对应方法的属性表中）<br> <img src="/images/java-jvm-memory/3f45dad50b4c1bd88754054097032e9d4e791965.png" alt="3f45dad50b4c1bd88754054097032e9d4e791965"><br>即jvm能够通过分析代码中可能存在多少个变量以及计算空间，来确定局部变量表和最大操作数栈的一个深度。<br> <img src="/images/java-jvm-memory/9ecc7dd1b5b084cb1558e8fdabfe1cb8d3dcc33a.png" alt="9ecc7dd1b5b084cb1558e8fdabfe1cb8d3dcc33a"> </p>
<hr>
<p>Q: 什么是局部变量表？<br>A：<br>每个线程所在栈帧都会有一个自己的局部变量表，里面存储方法中使用到的局部变量。<br><img src="/images/java-jvm-memory/1636712313442094087.png" alt="image.png"></p>
<hr>
<p>Q： 实例方法（就是某new出来的对象调用的某个方法）局部变量表的第一个变量是什么？<br>A：<br>是this引用。<br>因此在实例方法（即非静态方法）中调用f()时， 实际上调用的是this.f()， 而这个this就来自局部变量表。<br><img src="/images/java-jvm-memory/1636712332915079509.png" alt="image.png"></p>
<hr>
<p>Q: 局部变量的槽又是什么？<br>A:</p>
<ul>
<li>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</li>
<li>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）</li>
<li>slot的长度可以随着处理器、操作系统的不同而变化， 不是绝对的32位。<br>jvm概念中说的是”slot一定能存放下1个boolean\byte\int\引用地址\返回地址returnAddress“等不包括long在内的内容。</li>
<li>如果要访问long，需要做2次局部变量slot的读取，读取n和n+1，不允许单独访问，如果有问题会在字节码校验中报错。</li>
</ul>
<hr>
<p>Q: 局部变量表里的returnAddress和栈帧里的返回地址returnAddress有啥区别？<br>A:<br>局部变量表里的的returnAddress，是老版本jvm用于处理异常跳转的（jsr\jsr_w\ret指令，新版本基本都用code里的异常表来代替），而栈帧里的返回地址，是返回到上一层栈帧的代码调用位置，更新PC计数器用的。</p>
<hr>
<p>Q: 局部变量表的slot可以被覆盖吗？这个设计有什么好处<br>A:</p>
<ul>
<li>可以减少局部变量表的空间，通过分析每个局部变量的使用生命周期，在某变量不再被使用后，让其他变量可以覆盖这个槽的位置。</li>
<li>另一方面，覆盖的机制，可以将一些局部变量上已经不使用的大对象解除引用，例如对一些大的变量做=null的操作，那么可以尽早进行垃圾回收（因为栈帧的局部变量表里的每个slot都是一个gcRoot）</li>
</ul>
<hr>
<p>Q: 设置null值，就一定会覆盖slot吗？<br>A:<br>不一定，有时候JIT编译优化，可能会处理掉这个无用的=null的操作，且能正确处理slot中已经不被使用的变量。<br>按照书里的说法，正好有大对象，然后还停留在局部变量表里的概率是比较低的。不建议那么做了</p>
<hr>
<hr>
<p>Q:为什么java中局部变量没有默认初始？<br>A:<br>我的理解，局部变量在局部变量表中，而局部变量表是运行时生成的， 而非在堆上生成，因此不会有堆对象创建时的那个默认值赋值操作。 即jvm定义上， 就是局部变量没有初始化前的’准备‘这个阶段的，也就不存在默认赋值的指令行为。</p>
<p>如果硬要说为什么，如果每个局部变量都复制，肯定会影响执行效率，因此不如不赋值。，所以必须通过赋值指令在运行时给他赋值。（没找到很好的解释，有更好理解的可以帮忙回答一下，其实就是）</p>
<p>另外如果每个局部变量都有，那可能指令数量就会变多，因为你需要放入很多赋值指令？</p>
<p>阅读JMM内存模型时的另一个解释：</p>
<blockquote>
<blockquote>
<p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性.<br>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来<br>对于全局变量（类对象成员），必须有默认初始化，为了满足多线程环境下的最小安全性。<br>但对于局部变量，不存在被多线程使用，因此一定后面可以拼接一个指令，所以不需要默认初始化的动作。</p>
</blockquote>
</blockquote>
<hr>
<p>Q: 执行多次方法，一个栈上有多个栈帧，每个栈帧都有各自的局部变量表和操作数栈，上下的栈帧之间可能存在共享的情况吗？<br>A:<br>可能存在。即上下两个栈帧之间， 可能有操作数栈可以直接操作另一个栈帧局部变量的情况。这样可以避免额外的参数复制传递。<br>什么时候触发？不清楚</p>
<hr>
<p>Q：某个方法中执行return a时， 操作数栈和局部变量表会如何变化？<br>A：<br>a的值会被放到操作数栈的栈顶，再去进行finally操作里的行为。（不过不存就漏了）<br>后面取返回值时，就从这里取（即jvm总得知道返回值放哪，而return肯定是方法的最后一步操作，于是默认栈顶）<br><img src="/images/java-jvm-memory/1636712341543022349.png" alt="image.png"></p>
<hr>
<hr>
<p>Q：在return  a之后， 如果在finally操作又对a执行a=2+b， 操作数栈和局部变量表又会如何变化？<br>A:<br>原先准备返回的值会被作为局部变量存起来， 接着为了做计算，会取出a和b放到操作数栈中做计算<br><img src="/images/java-jvm-memory/1636712368299052397.png" alt="image.png"></p>
<p>而在finally计算结束后，之前存的返回值会被放回栈顶。<br><img src="/images/java-jvm-memory/1636712375048087932.png" alt="image.png"></p>
<p>因此，finally里对返回变量的修改，无法修改真正的返回值。<br>除非在finally里再执行return操作，这时候就会更改返回值。<br><img src="/images/java-jvm-memory/1636712386489020408.png" alt="image.png"></p>
<hr>
<p>Q : 栈帧里的动态链接又是啥？<br>A:<br>首先明确一点， 每一个栈帧，不一定是”动态”链接，但一定会有一个指向常量池中方法的引用。</p>
<p>为什么栈帧里需要存这个指向方法的引用？</p>
<p>首先，当你进入一个方法，准备生成一个栈帧，放到线程上时，你需要知道你这个代码执行的是什么代码，才能进行后面的操作。<br>如果是构造方法、final方法，则会编译器进行静态链接。<br>如果是虚方法，则会进行动态链接，运行期只是从类对象中，拿到了一个符号引用，但是这个引用指向哪个方法？则通过下面的过程进行定位和寻找，把符号引用转成实际方法的直接引用。<br> <img src="/images/java-jvm-memory/7ab56e50a81591f99ec990727c5fe677d0c58e3e.png" alt="7ab56e50a81591f99ec990727c5fe677d0c58e3e"><br> <img src="/images/java-jvm-memory/4b750641ecdcfc58a5efb5387dd32f57be1b9278.png" alt="4b750641ecdcfc58a5efb5387dd32f57be1b9278"><br>因此要提供一个引用，指向常量池里的方法。指向后，就能知道程序位置。<br>然后<strong>字节码实际引用位置 + PC计数器偏移</strong>，就能知道当前线程执行到哪个方法的哪一步指令上了。</p>
<p>而因为“动态分派”的存在，你这个方法位置是不确定的，和实际对象+方法名有关， 所以称为动态链接。</p>
<hr>
<p>Q: 既然有PC寄存器，栈帧里的返回地址的作用是什么？<br>A:<br>方法A调用方法B的时候，PC寄存器会跟着移动到B方法去。当B执行完后，要能返回A继续执行，就需要A当时执行到的那条指令的地址。所以，在B的栈帧中保存A当时的指令地址（当时PC寄存器的值），当B执行完后，根据此返回地址跳回A。通过返回地址，从而知道当前线程的上一级应该从PC的第几行偏移开始。</p>
<p>另外除了正常通过ret指令退出，还可能是出现异常时，如果没有在异常表里被捕捉并处理，也会通过异常完成出口， 使用返回地址返回到上一层。</p>
<hr>
<p>Q: 栈帧中的方法退出时，会触发哪些动作？<br>A:</p>
<ol>
<li>当前栈帧出栈</li>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>如果有返回值，把返回值压入操作数栈的栈顶（因为马上就要被调用了）</li>
<li>调整这个线程栈的PC计数器，改成returnAddress对应的那个指令位置地址，然后继续往下调用执行。</li>
</ol>
<hr>
<p>Q: 栈帧除了上面提到的几个，还有其他的信息吗？<br>A:<br>有些支持调试的虚拟机，可能会补充很多调试相关的信息。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>Q: 方法区里存的是class字节码吗？<br>A:<br>不是。经过类的加载、链接、初始化之后， class字节码对于进程来说就没用了<br> <img src="/images/java-jvm-memory/4e44533ba56f9e7e406e157403048f66004bfcec.png" alt="4e44533ba56f9e7e406e157403048f66004bfcec"><br>存了以下内容：</p>
<ul>
<li>每个类的类型信息：类名、父类类名、修饰符、接口</li>
<li>字段信息field（域信息）：字段名、字段类型、字段修饰符</li>
<li>方法信息，包括方法名、类型、参数、修饰符、字节码、一场表<br>如下：</li>
<li>类的静态变量</li>
<li>常量池，存储常量<br>注意，符号引用、类引用、实际类名等信息等都是放在常量池中的。</li>
</ul>
<hr>
<p>Q:  java7和java8在方法区上有变化，能讲一讲吗？java8改动的好处是什么<br>A:<br>永久代和元空间，元空间的好处<br>方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p>
<p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap</p>
<p><strong>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小</strong><br>-XX:MetaspaceSize和-XX:MaxMetaspaceSize<br>替换永久代的其他原因：</p>
<ol>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ol>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jklixin/p/13457936.html">jvm方法区详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/02/home/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/02/home/" class="post-title-link" itemprop="url">首页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-02 22:07:43 / 修改时间：22:11:05" itemprop="dateCreated datePublished" datetime="2022-05-02T22:07:43+08:00">2022-05-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>哈喽，我是破晓。<br>本博客主要有以下目的：</p>
<ol>
<li>整理自己历史以往学习过的所有知识点，温故知新</li>
<li>发布一些高质量的知识分享文章</li>
<li>记录一些只给部分人观看的个人生活记录</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
