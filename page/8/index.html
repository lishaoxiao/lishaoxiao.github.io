<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="破晓的知识屋">
<meta property="og:url" content="http://breakdawncoder.com/page/8/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">java流程控制语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 00:05:08" itemprop="dateCreated datePublished" datetime="2022-08-12T00:05:08+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-15 23:43:06" itemprop="dateModified" datetime="2022-08-15T23:43:06+08:00">2022-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/java%E5%88%9D%E7%BA%A7%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">java初级语法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-break-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: break后面加一个label标签是做什么的？像下面这样：</a></li>
<li><a href="#q-continue-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: continue后面加一个label标签是做什么的？像下面这样：</a></li>
<li><a href="#q-switch-de-default-xian-jing-1-yi-xia-shu-chu-shi-me">Q: switch的default陷阱1，以下输出什么</a></li>
<li><a href="#q-case-hou-mian-ke-yi-gen-bian-liang-ma">Q:case后面可以跟变量吗？</a></li>
<li><a href="#q-switch-de-default-xian-jing-2-yi-xia-shu-chu-shi-me">Q: switch的default陷阱2，以下输出什么</a></li>
<li><a href="#q-switch-neng-shi-bie-na-xie-lei-xing">Q: switch(） 能识别哪些类型？</a></li>
<li><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1： finally能通过修改变量，来更新return的变量值吗</a></li>
<li><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</a></li>
<li><a href="#q-for-each-he-for-index-na-ge-kuai-jiu-shi-for-num-nums-he-for-int-i-0-i-n-i">Q： for-each和for-index 哪个快？（就是for(num:nums)和for(int i=0;i&lt;n;i++)）</a></li>
<li><a href="#q-shi-me-shi-hou-mei-fa-yong-for-each-dai-ti-for-index">Q： 什么时候没法用for-each代替for-index？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h2><span id="q-break-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: break后面加一个label标签是做什么的？像下面这样：</span><a href="#q-break-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABC：</span><br><span class="line"><span class="keyword">while</span>(t++&lt;<span class="number">5</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">   	 <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">break</span> ABC;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A: break+label标签 是用于从内部退出多层循环的， 上面的例子就是直接从for内部直接退出到while的外面了。</p>
<hr>
<h2><span id="q-continue-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang">Q: continue后面加一个label标签是做什么的？像下面这样：</span><a href="#q-continue-hou-mian-jia-yi-ge-label-biao-qian-shi-zuo-shi-me-de-xiang-xia-mian-zhe-yang" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABC：</span><br><span class="line"><span class="keyword">while</span>(t++&lt;<span class="number">5</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">   	 <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">continue</span> ABC;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A: 直接contine到ABC的后面，即用于contine到最外层循环， 即走到while(t++&lt;5)那边继续走</p>
<hr>
<h2><span id="q-switch-de-default-xian-jing-1-yi-xia-shu-chu-shi-me">Q: switch的default陷阱1，以下输出什么</span><a href="#q-switch-de-default-xian-jing-1-yi-xia-shu-chu-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： 输出&quot;0 1&quot;， default都是最后再匹配的。</p>
<hr>
<h2><span id="q-case-hou-mian-ke-yi-gen-bian-liang-ma">Q:case后面可以跟变量吗？</span><a href="#q-case-hou-mian-ke-yi-gen-bian-liang-ma" class="header-anchor">#</a></h2>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> a:</span><br><span class="line"><span class="keyword">case</span> b:</span><br></pre></td></tr></table></figure>
<p>这样子<br>
A：<br>
不可以，case后面只能跟常量。</p>
<hr>
<h2><span id="q-switch-de-default-xian-jing-2-yi-xia-shu-chu-shi-me">Q: switch的default陷阱2，以下输出什么</span><a href="#q-switch-de-default-xian-jing-2-yi-xia-shu-chu-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： 输出&quot;default 0 1&quot;， 匹配到default之后，如果没有break还是会一直往下走。</p>
<hr>
<h2><span id="q-switch-neng-shi-bie-na-xie-lei-xing">Q: switch(） 能识别哪些类型？</span><a href="#q-switch-neng-shi-bie-na-xie-lei-xing" class="header-anchor">#</a></h2>
<p>A：<br>
JDK1.0-1.4 数据类型接受 byte short int char<br>
JDK1.5 ? ? ? 数据类型接受 byte short int char enum(枚举)<br>
JDK1.7 ? ? ? 数据类型接受?byte short int char enum(枚举)，String 六种类型<br>
PS： 上面提到的基本类型的包装类型也是支持的。</p>
<hr>
<h2><span id="q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1： finally能通过修改变量，来更新return的变量值吗</span><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      a=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A: 不能， f返回1。<br>
（PS：注意下如果是a引用的话，不能改变返回的a的引用， 但是可以改变a的引用里的属性）<br>
原理见：流程控制语句知识点里的java原理</p>
<hr>
<h2><span id="q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</span><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：返回finally里的，返回2。</p>
<hr>
<h2><span id="q-for-each-he-for-index-na-ge-kuai-jiu-shi-for-num-nums-he-for-int-i-0-i-lt-n-i">Q： for-each和for-index 哪个快？（就是for(num:nums)和for(int i=0;i&lt;n;i++)）</span><a href="#q-for-each-he-for-index-na-ge-kuai-jiu-shi-for-num-nums-he-for-int-i-0-i-lt-n-i" class="header-anchor">#</a></h2>
<p>A： 和场景有关。引用评论区2个小伙伴给的信息：</p>
<p>若实现了RandomAccess接口，那么使用for-index是优于for-each的吧</p>
<p>for-each 比 for-index 快，是不是可以这样考虑：<br>
for-each 是通过内部的迭代器进行遍历的，类似于索引；<br>
for-index 是通过 index 计算偏移量的方式遍历。<br>
—— 这样一来：<br>
对 ArrayList 这样的连续结构来说，for-each 和 for-index 的效率应该不相上下；<br>
而对 LinkedList 这样的链式列表，for-each 的索引优势就体现出来了。</p>
<hr>
<h2><span id="q-shi-me-shi-hou-mei-fa-yong-for-each-dai-ti-for-index">Q： 什么时候没法用for-each代替for-index？</span><a href="#q-shi-me-shi-hou-mei-fa-yong-for-each-dai-ti-for-index" class="header-anchor">#</a></h2>
<p>A: 需要往迭代器中插入元素或者删除元素时。（这会破坏迭代器结构）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">java基础数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-10 23:58:42" itemprop="dateCreated datePublished" datetime="2022-08-10T23:58:42+08:00">2022-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-15 23:42:57" itemprop="dateModified" datetime="2022-08-15T23:42:57+08:00">2022-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/java%E5%88%9D%E7%BA%A7%E8%AF%AD%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">java初级语法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#shu-ju-lei-xing">数据类型</a>
<ul>
<li><a href="#q-java-zhong-shu-ju-lei-xing-da-xiao-hui-he-ping-tai-shi-32-wei-64-wei-xiang-guan-ma">Q：java中数据类型大小会和平台是32位、64位相关吗？</a></li>
<li><a href="#q-java-zhong-jie-xi-shu-ju-shi-xu-yao-kao-lu-chu-li-qi-de-da-xiao-duan-wen-ti-ma-ji-0x1234-de-12-shi-fang-zai-gao-di-zhi-huan-shi-di-di-zhi">Q：java中解析数据时，需要考虑处理器的大小端问题吗？（即0x1234的12是放在高地址还是低地址）</a></li>
<li><a href="#q-java-zhong-short-int-long-de-zi-jie-fen-bie-shi-duo-shao">Q：java中short、int 、long的字节分别是多少？</a></li>
<li><a href="#q-float-double-shi-duo-shao-zi-jie">Q： float、double是多少字节？</a></li>
<li><a href="#q-java-zhong-byte-char-shi-duo-shao-zi-jie-c-zhong-char-shi-duo-shao-zi-jie">Q: java中byte、char是多少字节？C++中char是多少字节？</a></li>
<li><a href="#q-java-zhong-boolean-lei-xing-de-da-xiao">Q： java中boolean类型的大小？</a></li>
<li><a href="#q-bu-ke-bian-lei-xing-you-na-ji-chong">Q： 不可变类型有哪几种？</a></li>
<li><a href="#q-lei-li-de-cheng-yuan-ru-guo-shi-ji-ben-shu-ju-lei-xing-na-me-hui-zi-dong-chu-shi-hua-ma-chu-shi-hua-cheng-shi-me">Q：类里的成员如果是基本数据类型， 那么会自动初始化吗？初始化成什么？</a></li>
<li><a href="#q-java-zhong-ju-bu-bian-liang-mei-chu-shi-hua-hui-bao-cuo-ma">Q： java中局部变量没初始化，会报错吗？</a></li>
<li><a href="#q-bu-er-lei-xing-ke-yi-qiang-zhi-zhuan-hua-cheng-qi-ta-lei-xing-ma">Q： 布尔类型可以强制转化成其他类型吗？</a></li>
<li><a href="#q-shi-me-shi-hou-bu-neng-yin-shi-zhuan-hua">Q： 什么时候不能隐式转化？</a></li>
<li><a href="#q-8-chong-yuan-shi-shu-ju-lei-xing-de-lei-xing-you-xian-ji-pai-xu-shi">Q: 8种原始数据类型的类型优先级排序是？</a></li>
<li><a href="#q-xia-mian-na-ge-shi-cuo-wu-de">Q:下面哪个是错误的？</a></li>
<li><a href="#q-float-f-1-1-you-cuo-ma">Q：float f = 1.1;有错吗？</a></li>
<li><a href="#q-bu-er-lei-xing-ke-yi-zuo-jia-jian-cheng-chu-ma">Q： 布尔类型可以做加减乘除吗？</a></li>
<li><a href="#q-zheng-xing-bao-zhuang-lei-xing-de-bi-jiao-xia-mian-shu-chu-sha">Q：整型包装类型的比较，下面输出啥？</a></li>
<li><a href="#q-java-zhong-na-2-ge-lei-ke-yi-zhi-chi-ren-yi-jing-du-de-zheng-shu-he-ren-yi-jing-du-de-fu-dian-shu">Q： java中哪2个类可以支持任意精度的整数 和任意精度的浮点数?</a></li>
<li><a href="#q-java-de-shu-zu-yi-ding-xu-yao-wo-men-shou-dong-chu-shi-hua-ma">Q: java的数组一定需要我们手动初始化吗？</a></li>
<li><a href="#q-java-zhi-chi-c-li-de-yun-suan-fu-chong-zai-ma">Q：java支持C++里的运算符重载吗？</a></li>
<li><a href="#q-if-a-b-ke-yi-ma">Q： if(a=b) 可以吗？</a></li>
<li><a href="#q-fu-dian-shu-xiang-deng-de-bi-jiao-fang-shi">Q： 浮点数相等的比较方式</a></li>
<li><a href="#q-shang-mian-zhe-xian-xiang-de-yuan-yin-ni-liao-jie-ma-cong-fu-dian-shu-de-yuan-li-jiang-yi-xia-shi-shi">Q： 上面这现象的原因，你了解吗，从浮点数的原理讲一下试试</a></li>
<li><a href="#q-xia-mian-de-shu-zu-sheng-ming-na-ji-ge-shi-dui-de">Q:下面的数组声明哪几个是对的？</a></li>
</ul>
</li>
<li><a href="#zi-fu-chuan">字符串</a>
<ul>
<li><a href="#q-stringbuffer-he-stringbuilder-de-qu-bie">Q： StringBuffer和StringBuilder的区别：</a></li>
<li><a href="#q-string-s-123-456-789-dui-yu-zhe-chong-jing-tai-de-pin-jie-yong-stringbuffer-qu-pin-jie-bi-yong-string-qu-pin-jie-yao-kuai-dui-ma">Q：String s = “123”+“456”+“789”;对于这种静态的拼接，用StringBuffer去拼接比用String去拼接要快，对吗？</a></li>
<li><a href="#q-xia-mian-9-chong-zi-fu-chuan-pin-jie-xiang-deng-de-bi-jiao-shu-chu-shi-me-jie-guo-wei-shi-me">Q：下面9种字符串拼接相等的比较，输出什么结果？为什么？</a></li>
</ul>
</li>
<li><a href="#ke-bian-can-shu">可变参数</a>
<ul>
<li><a href="#q-fang-fa-chong-zai-shi-ru-he-xuan-ze-ke-bian-can-shu-he-gu-ding-can-shu-xiang-xia-mian-shu-chu-sha">Q： 方法重载时，如何选择可变参数和固定参数？像下面输出啥：</a></li>
<li><a href="#can-kao-zi-liao">参考资料：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="shu-ju-lei-xing">数据类型</span><a href="#shu-ju-lei-xing" class="header-anchor">#</a></h1>
<h2><span id="q-java-zhong-shu-ju-lei-xing-da-xiao-hui-he-ping-tai-shi-32-wei-64-wei-xiang-guan-ma">Q：java中数据类型大小会和平台是32位、64位相关吗？</span><a href="#q-java-zhong-shu-ju-lei-xing-da-xiao-hui-he-ping-tai-shi-32-wei-64-wei-xiang-guan-ma" class="header-anchor">#</a></h2>
<p>A：不相关，虚拟机原因平台兼容</p>
<hr>
<h2><span id="q-java-zhong-jie-xi-shu-ju-shi-xu-yao-kao-lu-chu-li-qi-de-da-xiao-duan-wen-ti-ma-ji-0x1234-de-12-shi-fang-zai-gao-di-zhi-huan-shi-di-di-zhi">Q：java中解析数据时，需要考虑处理器的大小端问题吗？（即0x1234的12是放在高地址还是低地址）</span><a href="#q-java-zhong-jie-xi-shu-ju-shi-xu-yao-kao-lu-chu-li-qi-de-da-xiao-duan-wen-ti-ma-ji-0x1234-de-12-shi-fang-zai-gao-di-zhi-huan-shi-di-di-zhi" class="header-anchor">#</a></h2>
<p>A：不需要。java由于虚拟机的关系,屏蔽了大小端问题,需要知道的话可用 ByteOrder.nativeOrder() 查询。在操作ByteBuffer中，也可以使用 ByteBuffer.order() 进行设置：。</p>
<hr>
<h2><span id="q-java-zhong-short-int-long-de-zi-jie-fen-bie-shi-duo-shao">Q：java中short、int 、long的字节分别是多少？</span><a href="#q-java-zhong-short-int-long-de-zi-jie-fen-bie-shi-duo-shao" class="header-anchor">#</a></h2>
<p>A：2、4、8</p>
<hr>
<h2><span id="q-float-double-shi-duo-shao-zi-jie">Q： float、double是多少字节？</span><a href="#q-float-double-shi-duo-shao-zi-jie" class="header-anchor">#</a></h2>
<p>A：4、8</p>
<hr>
<h2><span id="q-java-zhong-byte-char-shi-duo-shao-zi-jie-c-zhong-char-shi-duo-shao-zi-jie">Q: java中byte、char是多少字节？C++中char是多少字节？</span><a href="#q-java-zhong-byte-char-shi-duo-shao-zi-jie-c-zhong-char-shi-duo-shao-zi-jie" class="header-anchor">#</a></h2>
<p>A : java中是1和2， C++中char是1</p>
<hr>
<h2><span id="q-java-zhong-boolean-lei-xing-de-da-xiao">Q： java中boolean类型的大小？</span><a href="#q-java-zhong-boolean-lei-xing-de-da-xiao" class="header-anchor">#</a></h2>
<p>A： bool类型无空间大小（来自java编程思想）<br>
根据http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html官方文档的描述：</p>
<p>boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.</p>
<p>布尔类型：布尔数据类型只有两个可能的值：真和假。使用此数据类型为跟踪真/假条件的简单标记。这种数据类型就表示这一点信息，但是它的“大小”并不是精确定义的。</p>
<p>贴一下书中关于布尔数据类型的描述：<br>
<img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1613726452952078147.png" alt="img"></p>
<hr>
<h2><span id="q-bu-ke-bian-lei-xing-you-na-ji-chong">Q： 不可变类型有哪几种？</span><a href="#q-bu-ke-bian-lei-xing-you-na-ji-chong" class="header-anchor">#</a></h2>
<p>A： short、int、long、float、double、byte、char、boolean的?包装类型， 以及String，这9种属于不可变类型。（这只是部分，还有其他的不可变类）</p>
<p>不可变类型概念：里面的值的内容变了，对应的内存地址也会变化。</p>
<hr>
<h2><span id="q-lei-li-de-cheng-yuan-ru-guo-shi-ji-ben-shu-ju-lei-xing-na-me-hui-zi-dong-chu-shi-hua-ma-chu-shi-hua-cheng-shi-me">Q：类里的成员如果是基本数据类型， 那么会自动初始化吗？初始化成什么？</span><a href="#q-lei-li-de-cheng-yuan-ru-guo-shi-ji-ben-shu-ju-lei-xing-na-me-hui-zi-dong-chu-shi-hua-ma-chu-shi-hua-cheng-shi-me" class="header-anchor">#</a></h2>
<p>A： 会， 初始化为0或者false。</p>
<hr>
<h2><span id="q-java-zhong-ju-bu-bian-liang-mei-chu-shi-hua-hui-bao-cuo-ma">Q： java中局部变量没初始化，会报错吗？</span><a href="#q-java-zhong-ju-bu-bian-liang-mei-chu-shi-hua-hui-bao-cuo-ma" class="header-anchor">#</a></h2>
<p>A： 会</p>
<hr>
<h2><span id="q-bu-er-lei-xing-ke-yi-qiang-zhi-zhuan-hua-cheng-qi-ta-lei-xing-ma">Q： 布尔类型可以强制转化成其他类型吗？</span><a href="#q-bu-er-lei-xing-ke-yi-qiang-zhi-zhuan-hua-cheng-qi-ta-lei-xing-ma" class="header-anchor">#</a></h2>
<p>A ： 不能。 boolean b = 1或者boolean b = “true” 是不可以的</p>
<hr>
<h2><span id="q-shi-me-shi-hou-bu-neng-yin-shi-zhuan-hua">Q： 什么时候不能隐式转化？</span><a href="#q-shi-me-shi-hou-bu-neng-yin-shi-zhuan-hua" class="header-anchor">#</a></h2>
<p>A： 如果会丢失精度，则不能隐式转化，比如long转int或者double转long这种。 编译器会强制我们使用强制转化</p>
<hr>
<h2><span id="q-8-chong-yuan-shi-shu-ju-lei-xing-de-lei-xing-you-xian-ji-pai-xu-shi">Q: 8种原始数据类型的类型优先级排序是？</span><a href="#q-8-chong-yuan-shi-shu-ju-lei-xing-de-lei-xing-you-xian-ji-pai-xu-shi" class="header-anchor">#</a></h2>
<p>A：<br>
（byte/short/char)&lt;int&lt;long&lt;float&lt;double<br>
即隐式转换都是从低往高转。</p>
<hr>
<h2><span id="q-xia-mian-na-ge-shi-cuo-wu-de">Q:下面哪个是错误的？</span><a href="#q-xia-mian-na-ge-shi-cuo-wu-de" class="header-anchor">#</a></h2>
<p><img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1613726121049038816.png" alt="img"><br>
A：<br>
B选项是错误的。<br>
因为2个byte类型变量相加的时候，会自动转换成int类型，右边的int类型赋值给short类型便会报错。（好冷的知识）</p>
<hr>
<h2><span id="q-float-f-1-1-you-cuo-ma">Q：float f = 1.1;有错吗？</span><a href="#q-float-f-1-1-you-cuo-ma" class="header-anchor">#</a></h2>
<p>A：<br>
float浮点后面要加f。加f就代表是float类型，否则就是double类型浮点。</p>
<p>float f = 1.1f;<br>
double d1 = 1.1;</p>
<hr>
<h2><span id="q-bu-er-lei-xing-ke-yi-zuo-jia-jian-cheng-chu-ma">Q： 布尔类型可以做加减乘除吗？</span><a href="#q-bu-er-lei-xing-ke-yi-zuo-jia-jian-cheng-chu-ma" class="header-anchor">#</a></h2>
<p>A ： 不能</p>
<p>Q： Integer N = 0; int n = N; 这时候会发生什么？<br>
A： 自动拆包</p>
<hr>
<h2><span id="q-zheng-xing-bao-zhuang-lei-xing-de-bi-jiao-xia-mian-shu-chu-sha">Q：整型包装类型的比较，下面输出啥？</span><a href="#q-zheng-xing-bao-zhuang-lei-xing-de-bi-jiao-xia-mian-shu-chu-sha" class="header-anchor">#</a></h2>
<p>Integer num1 = 128,num2 = 128;<br>
System.out.println(num1==num2);</p>
<p>A：<br>
输出false。<br>
值的范围在-128~127的时候Integer可以直接用==比较大小，但是超出这个范围时，==就不管用了，要用equals。<br>
大致原因是在那个范围，Integer的对象会直接用缓存对象，所以地址都相同。<br>
不在那个范围，Integer对象会新生成1个对象，所以地址不同。</p>
<p>另一个注意点： “==” 对于对象来说，比较的是地址。</p>
<hr>
<h2><span id="q-java-zhong-na-2-ge-lei-ke-yi-zhi-chi-ren-yi-jing-du-de-zheng-shu-he-ren-yi-jing-du-de-fu-dian-shu">Q： java中哪2个类可以支持任意精度的整数 和任意精度的浮点数?</span><a href="#q-java-zhong-na-2-ge-lei-ke-yi-zhi-chi-ren-yi-jing-du-de-zheng-shu-he-ren-yi-jing-du-de-fu-dian-shu" class="header-anchor">#</a></h2>
<p>A: BigInteger和BigDecimal</p>
<p>这2个也属于不可变类。</p>
<hr>
<h2><span id="q-java-de-shu-zu-yi-ding-xu-yao-wo-men-shou-dong-chu-shi-hua-ma">Q: java的数组一定需要我们手动初始化吗？</span><a href="#q-java-de-shu-zu-yi-ding-xu-yao-wo-men-shou-dong-chu-shi-hua-ma" class="header-anchor">#</a></h2>
<p>A： 不需要，数组元素会自动初始化为null或者0或者false。</p>
<hr>
<h2><span id="q-java-zhi-chi-c-li-de-yun-suan-fu-chong-zai-ma">Q：java支持C++里的运算符重载吗？</span><a href="#q-java-zhi-chi-c-li-de-yun-suan-fu-chong-zai-ma" class="header-anchor">#</a></h2>
<p>A： 不支持</p>
<hr>
<h2><span id="q-if-a-b-ke-yi-ma">Q： if(a=b) 可以吗？</span><a href="#q-if-a-b-ke-yi-ma" class="header-anchor">#</a></h2>
<p>A： 不行，不能在条件表达式中放入赋值操作。除非a和b都是boolean类型。</p>
<hr>
<h2><span id="q-fu-dian-shu-xiang-deng-de-bi-jiao-fang-shi">Q： 浮点数相等的比较方式</span><a href="#q-fu-dian-shu-xiang-deng-de-bi-jiao-fang-shi" class="header-anchor">#</a></h2>
<p>A：<br>
相等的话要像下面这样</p>
<p>if(Math.abs(a-b))&lt;1E-6F)</p>
<p>如果用浮点的a==b或者a!=b做while循环退出判断，可能会导致死循环</p>
<hr>
<h2><span id="q-shang-mian-zhe-xian-xiang-de-yuan-yin-ni-liao-jie-ma-cong-fu-dian-shu-de-yuan-li-jiang-yi-xia-shi-shi">Q： 上面这现象的原因，你了解吗，从浮点数的原理讲一下试试</span><a href="#q-shang-mian-zhe-xian-xiang-de-yuan-yin-ni-liao-jie-ma-cong-fu-dian-shu-de-yuan-li-jiang-yi-xia-shi-shi" class="header-anchor">#</a></h2>
<p>A:<br>
<img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3744d5b86b6e1010d046ea4b423e635c5bdc330f.png" alt="3744d5b86b6e1010d046ea4b423e635c5bdc330f"></p>
<ul>
<li>1.1用二进制表示为：1.000110…xxxx…(后面表示省略)<br>
0.1 = 02(-1)+0<em>2(-2)+02(-3)+1</em>2(-4)+…</li>
<li>而double类型表示小数部分只有52位，当向后计算 52位后基数还不为0，那后面的部分只能舍弃，从这里可以看出float、double并不能准确表示每一位小数，对于有的小数只能无限趋向它。</li>
<li>在计算机 中加减成除运算实际上最后都要在计算机中转换成二进制的加运算，由此，当计算机运行System.out.println(2.00-1.10);<br>
时会拿他们在计算机内存中的二进制表示计算，而1.10的二进制表示本身就不准确，所以会出现0.8999999999999999的结果。</li>
</ul>
<hr>
<h2><span id="q-xia-mian-de-shu-zu-sheng-ming-na-ji-ge-shi-dui-de">Q:下面的数组声明哪几个是对的？</span><a href="#q-xia-mian-de-shu-zu-sheng-ming-na-ji-ge-shi-dui-de" class="header-anchor">#</a></h2>
<p>A. char[] chr1 = new char[]{‘A’,‘B’,‘C’};<br>
B. char[] chr2 = new char[3]{‘A’,‘B’,‘C’};<br>
C. char[][] chr3 = new char[][10];<br>
D. char[][] chr4 = new char[10][];<br>
E. char[] chr5 = new char[3];</p>
<p>A：<br>
ADE是对的。</p>
<h1><span id="zi-fu-chuan">字符串</span><a href="#zi-fu-chuan" class="header-anchor">#</a></h1>
<hr>
<h2><span id="q-stringbuffer-he-stringbuilder-de-qu-bie">Q： StringBuffer和StringBuilder的区别：</span><a href="#q-stringbuffer-he-stringbuilder-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
StringBuffer是线程安全的，但是慢<br>
StringBuilder是线程不安全的（即可以多个线程同时读取他的内容），但是快。</p>
<hr>
<h2><span id="q-string-s-123-456-789-dui-yu-zhe-chong-jing-tai-de-pin-jie-yong-stringbuffer-qu-pin-jie-bi-yong-string-qu-pin-jie-yao-kuai-dui-ma">Q：String s = “123”+“456”+“789”;对于这种静态的拼接，用StringBuffer去拼接比用String去拼接要快，对吗？</span><a href="#q-string-s-123-456-789-dui-yu-zhe-chong-jing-tai-de-pin-jie-yong-stringbuffer-qu-pin-jie-bi-yong-string-qu-pin-jie-yao-kuai-dui-ma" class="header-anchor">#</a></h2>
<p>A：<br>
错，反编译代码后，我们发现代码是<br>
String s = “123456789”;<br>
因为对于静态字符串的连接操作，Java在编译时会进行彻底的优化，将多个连接操作的字符串在编译时合成一个单独的长字符串。<br>
因此要注意StringBuffer/Builder的适用场合： for循环中大量拼接字符串。<br>
如果是静态的编译器就能感知到的拼接，不要盲目地去使用StirngBuffer/Builder<br>
PS：</p>
<p>如果是字符串变量相加，会优化成StringBuilder做append<br>
如果是常量字符串相加， 则会直接拼接<br>
具体可以查看这篇博文，里面有展示这2 种情况的字节码。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34405557/article/details/89630362?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/weixin_34405557/article/details/89630362?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
<hr>
<h2><span id="q-xia-mian-9-chong-zi-fu-chuan-pin-jie-xiang-deng-de-bi-jiao-shu-chu-shi-me-jie-guo-wei-shi-me">Q：下面9种字符串拼接相等的比较，输出什么结果？为什么？</span><a href="#q-xia-mian-9-chong-zi-fu-chuan-pin-jie-xiang-deng-de-bi-jiao-shu-chu-shi-me-jie-guo-wei-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;Hel&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s5.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;H&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;ello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> s7 + s8;</span><br><span class="line"> </span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s4);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s6);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s9);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<p>A：<br>
println(s1 == s2)输出 true<br>
println(s1 == s3)输出 true<br>
println(s1 == s4)输出 false<br>
println(s4 == s5)输出 false<br>
println(s1 == s6)输出 true<br>
println(s1 == s9)输出 false</p>
<p>字符串的==操作比较的是引用地址。<br>
如果是直接写死在代码里的常量字符串，则地址是固定的，都在常量池中。<br>
写死的常量字符串拼接，依旧会作为常量放入常量池中。（常量池就是指，程序编译的时候，就已经知道了这个字符串）<br>
如果是String类型的，则引用地址是堆中的string对象地址，而非常量池中地址。（因为程序编译的时候，string里的内容不一定是确定的，因此不可能会放到常量池中）<br>
因此涉及string拼接的，都是和原先常量不等。s7和s8已经属于string对象，所以二者不属于常量拼接。<br>
intern会试图把字符串放入常量池。</p>
<p>具体原因可见<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/syp172654682/p/8082625.html">https://www.cnblogs.com/syp172654682/p/8082625.html</a></p>
<p>关于常量池，更多可以见：<br>
原始数据类型强化学习之常量池</p>
<h1><span id="ke-bian-can-shu">可变参数</span><a href="#ke-bian-can-shu" class="header-anchor">#</a></h1>
<hr>
<h2><span id="q-fang-fa-chong-zai-shi-ru-he-xuan-ze-ke-bian-can-shu-he-gu-ding-can-shu-xiang-xia-mian-shu-chu-sha">Q： 方法重载时，如何选择可变参数和固定参数？像下面输出啥：</span><a href="#q-fang-fa-chong-zai-shi-ru-he-xuan-ze-ke-bian-can-shu-he-gu-ding-can-shu-xiang-xia-mian-shu-chu-sha" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> ...a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可变参数方法：&quot;</span>+Arrays.toString(a));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;固定长度 参数方法：&quot;</span>+a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
输出固定长度参数方法。<br>
原则:<br>
如果重载方法中，固定参数方法能满足，优先用固定参数方法，不满足时再去选择可变参数方法。</p>
<hr>
<p><img src="/images/java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/662027daa06620610256ebc9a89705952ca01b0e.png" alt="662027daa06620610256ebc9a89705952ca01b0e"></p>
<h2><span id="can-kao-zi-liao">参考资料：</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/syp172654682/p/8082625.html">https://www.cnblogs.com/syp172654682/p/8082625.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java线程高级应用和原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-10 00:35:00 / 修改时间：23:56:19" itemprop="dateCreated datePublished" datetime="2022-08-10T00:35:00+08:00">2022-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/10/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#executor-xian-cheng-chi-ying-yong-xiang-jie">Executor线程池应用详解</a>
<ul>
<li><a href="#corepoolsize-he-maximumpoolsize-can-shu-you-shi-me-qu-bie">corePoolSize和maximumPoolSize参数有什么区别？</a></li>
<li><a href="#keepalive-can-shu-shi-gan-ma-de">keepalive参数是干嘛的？</a></li>
<li><a href="#he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">核心线程可以被回收吗？（线程池没有被回收的情况下）</a></li>
<li><a href="#he-xin-xian-cheng-shu-she-zhi-duo-shao-zen-me-kao-lu">核心线程数设置多少，怎么考虑？</a></li>
<li><a href="#xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">线程池有哪三种队列策略？</a></li>
<li><a href="#xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</a></li>
<li><a href="#xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">线程池为什么需要阻塞队列？</a></li>
<li><a href="#wu-chong-chang-jian-de-executor-zi-dai-xian-cheng-chi">五种常见的Executor自带线程池</a>
<ul>
<li><a href="#newcachedthreadpool-huan-cun-xian-cheng-chi">newCachedThreadPool： 缓存线程池</a></li>
<li><a href="#newfixedthreadpool-ding-chang-xian-cheng-chi">newFixedThreadPool ：定长线程池</a></li>
<li><a href="#newscheduledthreadpool-ding-shi-qi-xian-cheng-chi">newScheduledThreadPool :定时器线程池</a></li>
<li><a href="#newsinglethreadexecutor-dan-xian-cheng-chi">newSingleThreadExecutor : 单线程池</a></li>
<li><a href="#newworkstealingpool-ji-cheng-zi-forkjoinpool-gong-zuo-mi-qu-xian-cheng-chi">newWorkStealingPool（继承自ForkJoinPool ）： 工作密取线程池</a></li>
</ul>
</li>
<li><a href="#submit-he-execute-fang-fa-qu-bie-shi-shi-me">submit和execute方法区别是什么？</a>
<ul>
<li><a href="#xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">线程池中， shutdown、 shutdownNow、awaitTermination的区别？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#forkjoin-xian-cheng-chi">ForkJoin线程池</a>
<ul>
<li><a href="#forkjoin-he-xin-gai-nian">forkJoin核心概念</a></li>
<li><a href="#forkjoin-zhong-ge-ge-xian-cheng-shi-ru-he-huo-qu-na-xie-xiao-ren-wu-de-ni">forkJoin中各个线程是如何获取那些小任务的呢？</a></li>
<li><a href="#fork-shi-ju-ti-fa-sheng-liao-shi-me">fork时具体发生了什么？</a></li>
<li><a href="#join-shi-shi-me-han-yi-shi-me-shi-hou-zuo-de">join是什么含义？什么时候做的？</a></li>
<li><a href="#join-zhe-ge-zu-sai-guo-cheng-shi-zen-me-zuo-de-ru-guo-ba-xian-cheng-gua-qi-na-zhe-ge-xian-cheng-qi-bu-shi-wu-fa-gong-zuo-liao">join这个阻塞过程是怎么做的？如果把线程挂起，那这个线程岂不是无法工作了？</a></li>
<li><a href="#forkjoin-cun-fang-ren-wu-de-shi-hou-zen-me-bao-zheng-bu-hui-chu-xian-bing-fa-wen-ti-bi-ru-tong-shi-wang-dui-wei-cha-ru-de-hua">forkJoin存放任务的时候，怎么保证不会出现并发问题？比如同时往队尾插入的话</a></li>
<li><a href="#forkjoin-ying-yong-zai-na">forkJoin应用在哪？</a></li>
</ul>
</li>
<li><a href="#theadlocal-he-xin-yuan-li">TheadLocal核心原理</a>
<ul>
<li><a href="#threadlocal-de-chang-jian-shi-yong-chang-jing">ThreadLocal的常见使用场景？</a></li>
<li><a href="#threadlocal-he-synchronized-guan-jian-zi-de-qu-bie">ThreadLocal和Synchronized关键字的区别？</a></li>
<li><a href="#theadlocal-zai-mei-ge-xian-cheng-zhong-shi-yi-shi-me-xing-shi-cun-chu-de-yuan-li-shi-shi-me">TheadLocal在每个线程中是以什么形式存储的？ 原理是什么</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="executor-xian-cheng-chi-ying-yong-xiang-jie">Executor线程池应用详解</span><a href="#executor-xian-cheng-chi-ying-yong-xiang-jie" class="header-anchor">#</a></h1>
<h2><span id="corepoolsize-he-maximumpoolsize-can-shu-you-shi-me-qu-bie">corePoolSize和maximumPoolSize参数有什么区别？</span><a href="#corepoolsize-he-maximumpoolsize-can-shu-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
当提交新线程到池中时</p>
<ul>
<li>如果当前线程数 &lt; corePoolSize，则会创建新线程</li>
<li>如果当前线程数=corePoolSize，则新线程被塞进一个队列中等待。</li>
<li>如果队列也被塞满了，那么又会开始新建线程来运行任务，避免任务阻塞或者丢弃</li>
<li>如果队列满了的情况下， 线程总数超过了maxinumPoolSize，那么就抛异常或者阻塞（取决于队列性质）。</li>
</ul>
<hr>
<ul>
<li>调用prestartCoreThread()可提前开启一个空闲的核心线程</li>
<li>调用prestartAllCoreThreads()，可提前创建corePoolSize个核心线程。</li>
</ul>
<hr>
<h2><span id="keepalive-can-shu-shi-gan-ma-de">keepalive参数是干嘛的？</span><a href="#keepalive-can-shu-shi-gan-ma-de" class="header-anchor">#</a></h2>
<p>A：当线程数量在corePoolSize到maxinumPoolSize之间时， 如果有线程已跑完，且空闲时间超过keepalive时，则会被清除（注意只限于corePoolSize到maxinumPoolsize之间的线程）</p>
<hr>
<h2><span id="he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">核心线程可以被回收吗？（线程池没有被回收的情况下）</span><a href="#he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia" class="header-anchor">#</a></h2>
<p>A:<br>
ThreadPoolExecutor有个allowCoreThreadTimeOut(boolean value)方法，可以设置是否在超期后做回收</p>
<hr>
<h2><span id="he-xin-xian-cheng-shu-she-zhi-duo-shao-zen-me-kao-lu">核心线程数设置多少，怎么考虑？</span><a href="#he-xin-xian-cheng-shu-she-zhi-duo-shao-zen-me-kao-lu" class="header-anchor">#</a></h2>
<p>A:<br>
io密集型， 可以设置多一点， 因为多一个线程，他可能也没太占cpu，都是在等待IO。<br>
如果是计算密集型，则要设置少一点，别把cpu搞满载了。</p>
<p>有超线程技术的话， 一般可以设置成2倍CPU数量的线程数</p>
<blockquote>
<blockquote>
<p>超线程技术把多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">线程池有哪三种队列策略？</span><a href="#xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue" class="header-anchor">#</a></h2>
<p>A：</p>
<ol>
<li>握手队列<br>
相当于不排队的队列。可能造成线程数量无限增长直到超过maxinumPoolSize（相当于corePoolSize没什么用了，只以maxinumPoolSize做上限）</li>
<li>无界队列<br>
队列队长无限，即线程数量达到corePoolSize时，后面的线程只会在队列中等待。（相当于maxinumPoolSize没什么用了）<br>
缺陷： 可能造成队列无限增长以至于OOM</li>
<li>有界队列</li>
</ol>
<hr>
<h2><span id="xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</span><a href="#xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>AbortPolicy 默认策略：直接抛出RejectedExecutionException异常</li>
<li>DiscardPolicy 丢弃策略： 直接丢了，什么错误也不报</li>
<li>DiscardOldestPolicy 丢弃队头策略： 即把最先入队的人从队头扔出去，再尝试让该任务进入队尾（队头任务内心：不公平。。。。）</li>
<li>CallerRunsPolicy 调用者处理策略： 交给调用者所在线程自己去跑任务（即谁调用的submit或者execute，他就自己去跑） <strong>注意这个策略会用的比较多</strong></li>
<li>也可以用实现自定义新的RejectedExecutionHandler</li>
</ul>
<hr>
<h2><span id="xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">线程池为什么需要阻塞队列？</span><a href="#xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie" class="header-anchor">#</a></h2>
<p>A:<br>
线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。避免大量线程获取这个创建锁。</p>
<hr>
<h2><span id="wu-chong-chang-jian-de-executor-zi-dai-xian-cheng-chi">五种常见的Executor自带线程池</span><a href="#wu-chong-chang-jian-de-executor-zi-dai-xian-cheng-chi" class="header-anchor">#</a></h2>
<p>有以下五种Executor提供的线程池，注意记忆一下他们的用途，就能理解内部的原理了。</p>
<ul>
<li>
<h3><span id="newcachedthreadpool-huan-cun-xian-cheng-chi">newCachedThreadPool： 缓存线程池</span><a href="#newcachedthreadpool-huan-cun-xian-cheng-chi" class="header-anchor">#</a></h3>
<p>corePoolSize=0, maxinumPoolSize=+∞，队列长度=0 ，<br>
因此线程数量会在corePoolSize到maxinumPoolSize之间一直灵活缓存和变动， 且不存在队列等待的情况，一来任务我就创建，用完了会释放。<br>
<img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1619147438780044960.png" alt="image.png"></p>
</li>
<li>
<h3><span id="newfixedthreadpool-ding-chang-xian-cheng-chi">newFixedThreadPool ：定长线程池</span><a href="#newfixedthreadpool-ding-chang-xian-cheng-chi" class="header-anchor">#</a></h3>
<p>corePoolSize= maxinumPoolSize=构造参数值， 队列长度=+∞。<br>
因此不存在线程不够时扩充的情况</p>
</li>
<li>
<h3><span id="newscheduledthreadpool-ding-shi-qi-xian-cheng-chi">newScheduledThreadPool :定时器线程池</span><a href="#newscheduledthreadpool-ding-shi-qi-xian-cheng-chi" class="header-anchor">#</a></h3>
<p>提交定时任务用的，构造参数里会带定时器的间隔和单位。 其他和FixedThreadPool相同，属于定长线程池。</p>
</li>
<li>
<h3><span id="newsinglethreadexecutor-dan-xian-cheng-chi">newSingleThreadExecutor : 单线程池</span><a href="#newsinglethreadexecutor-dan-xian-cheng-chi" class="header-anchor">#</a></h3>
<p>corePoolSize=maxinumPoolSize=1， 队列长度=+∞<br>
只会跑一个任务， 所以其他的任务都会在队列中等待，因此会严格按照FIFO执行</p>
</li>
<li>
<h3><span id="newworkstealingpool-ji-cheng-zi-forkjoinpool-gong-zuo-mi-qu-xian-cheng-chi">newWorkStealingPool（继承自ForkJoinPool ）： 工作密取线程池</span><a href="#newworkstealingpool-ji-cheng-zi-forkjoinpool-gong-zuo-mi-qu-xian-cheng-chi" class="header-anchor">#</a></h3>
</li>
</ul>
<p>如果你的任务执行时间很长，并且里面的任务运行并行跑的，那么他会把你的线程任务再细分到其他的线程来分治。这种特点在于可以在任务队列的两头取任务</p>
<hr>
<h2><span id="submit-he-execute-fang-fa-qu-bie-shi-shi-me">submit和execute方法区别是什么？</span><a href="#submit-he-execute-fang-fa-qu-bie-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>execute只能接收Runnable类型的任务，而submit除了Runnable，还能接收Callable（Callable类型任务支持返回值）</li>
<li>execute方法返回void，  submit方法返回FutureTask。</li>
<li>异常方面， submit方法因为返回了futureTask对象，而当进行future.get()时，会把线程中的异常抛出，因此调用者可以方便地处理异常。（如果是execute，只能用内部捕捉或者设置catchHandler）</li>
</ul>
<hr>
<h3><span id="xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">线程池中， shutdown、 shutdownNow、awaitTermination的区别？</span><a href="#xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie" class="header-anchor">#</a></h3>
<p>A：</p>
<ul>
<li>shutdown: 停止接收新任务，等待所有池中已存在任务完成（ <em><strong>包括等待队列中的线程</strong></em> ）。异步方法，即调用后马上返回。</li>
<li>shutdownNow: 停止接收新任务，并 <em><strong>停止所有正执行的task</strong></em>，返回还在队列中的task列表 。</li>
<li>awaitTermination： <em><strong>仅仅是一个判断方法</strong></em>，判断当前线程池任务是否全部结束。一般用在shutdown后面，因为shutdown是异步方法，你需要知道什么时候才真正结束。</li>
</ul>
<h1><span id="forkjoin-xian-cheng-chi">ForkJoin线程池</span><a href="#forkjoin-xian-cheng-chi" class="header-anchor">#</a></h1>
<h2><span id="forkjoin-he-xin-gai-nian">forkJoin核心概念</span><a href="#forkjoin-he-xin-gai-nian" class="header-anchor">#</a></h2>
<p>ForkJoin线程池在常规的java书籍里还是提到比较少的，毕竟是java8引入的产物。</p>
<p>首先这里简单解释一下forkJoin的运作原理， 本质上有点像归并计算。</p>
<ol>
<li>他会将提交大任务按照一定规则拆解（fork）成多个小任务</li>
<li>当任务小到一定程度时，就会执行计算</li>
<li>执行完成时会和其他的小任务进行合并（join）， 逐步将所有小结果合成一个大结果。<br>
<img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361412728070823-1660063481962.png" alt="image.png"></li>
</ol>
<p>可以看这个forkJoinTask的实现伪代码，即如果想使用forkJoin并发执行任务，需要自己把任务继承RecursiveTask，作为forkJoin池的submit对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;任务参数&gt; &#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ReckonTask</span><span class="params">(任务参数)</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> File <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(根据任务参数判断任务是否足够小) &#123;</span><br><span class="line">        计算，返回</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	 拆分成子任务<span class="number">1</span>和子任务<span class="number">2</span> </span><br><span class="line">        任务<span class="number">1.</span>fork();</span><br><span class="line">        任务<span class="number">2.</span>fork();</span><br><span class="line">        结果<span class="number">1</span> = 任务<span class="number">1.</span>join();</span><br><span class="line">        结果<span class="number">2</span> = 任务<span class="number">2.</span>join();</span><br><span class="line">        返回结果<span class="number">1</span>+结果<span class="number">2</span>；</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实际上整个forkjoin的细节非常多，这里我通过给自己提好几个问题，来逐步理解forkJoin的原理，</p>
<hr>
<h2><span id="forkjoin-zhong-ge-ge-xian-cheng-shi-ru-he-huo-qu-na-xie-xiao-ren-wu-de-ni">forkJoin中各个线程是如何获取那些小任务的呢？</span><a href="#forkjoin-zhong-ge-ge-xian-cheng-shi-ru-he-huo-qu-na-xie-xiao-ren-wu-de-ni" class="header-anchor">#</a></h2>
<p>A:<br>
他是通过工作密取的方式获取。（java并发那本书里提到过工作密取workSteal，原来是用在这了）</p>
<ul>
<li>假设我们给forkJoin设置3个工作线程，那么就会有3个工作队列， 注意，这个队列是双端队列。</li>
<li>每当执行任务时，如果不满足小任务的条件，他会fork出2个子任务，并push进自己的工作队列中。</li>
<li>每个工作线程不断取自己队头的任务执行。</li>
<li>关键点：如果自己队列里没有数据，则会从其他队列的队尾取数据。</li>
</ul>
<hr>
<h2><span id="fork-shi-ju-ti-fa-sheng-liao-shi-me">fork时具体发生了什么？</span><a href="#fork-shi-ju-ti-fa-sheng-liao-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
是一个异步的操作， 就是向当前线程队列中添加这个fork出来任务，能放进去的话就返回，不会等待。<br>
注意，默认fork出的任务是先默认给自己的。 当自己做不完时，才可能被别人取走！<br>
<img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361429766064686-1660063481975.png" alt="image.png"></p>
<hr>
<h2><span id="join-shi-shi-me-han-yi-shi-me-shi-hou-zuo-de">join是什么含义？什么时候做的？</span><a href="#join-shi-shi-me-han-yi-shi-me-shi-hou-zuo-de" class="header-anchor">#</a></h2>
<p>A:<br>
见实现forkJoin任务接口时的代码：<br>
<img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361436926002588-1660063481980.png" alt="image.png"></p>
<p>可以看到时每次fork完之后， 通过join，来获取子task的结果，获取到之后，再合并计算，返回结果。</p>
<hr>
<h2><span id="join-zhe-ge-zu-sai-guo-cheng-shi-zen-me-zuo-de-ru-guo-ba-xian-cheng-gua-qi-na-zhe-ge-xian-cheng-qi-bu-shi-wu-fa-gong-zuo-liao">join这个阻塞过程是怎么做的？如果把线程挂起，那这个线程岂不是无法工作了？</span><a href="#join-zhe-ge-zu-sai-guo-cheng-shi-zen-me-zuo-de-ru-guo-ba-xian-cheng-gua-qi-na-zhe-ge-xian-cheng-qi-bu-shi-wu-fa-gong-zuo-liao" class="header-anchor">#</a></h2>
<p>A:</p>
<p>首先，之前fork时，新的子任务已经被放入队列了。<br>
每个子任务都有一个任务状态。<br>
当调用该子任务的join时， 会循环判断他的状态</p>
<p>如果这个子任务状态未完成， 则从自身队列或其他人的队列中取出新的任务执行，因此进入了下一层的exec()操作。<br>
如果发现子任务状态更新为了完成（这个更新动作可能是自己线程完成的，也可能是别的线程完成的，反正这个任务的状态实现了同步和可见）， 则将结果返回给上层。<br>
因此join的本质是一个递归的过程， 任务没完成的话，他就取其他任务继续递归往下执行。</p>
<p>更详细的可以看这个链接<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yougewe/p/14943418.html">fork+join过程详细解读</a></p>
<hr>
<h2><span id="forkjoin-cun-fang-ren-wu-de-shi-hou-zen-me-bao-zheng-bu-hui-chu-xian-bing-fa-wen-ti-bi-ru-tong-shi-wang-dui-wei-cha-ru-de-hua">forkJoin存放任务的时候，怎么保证不会出现并发问题？比如同时往队尾插入的话</span><a href="#forkjoin-cun-fang-ren-wu-de-shi-hou-zen-me-bao-zheng-bu-hui-chu-xian-bing-fa-wen-ti-bi-ru-tong-shi-wang-dui-wei-cha-ru-de-hua" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>n个工作线程是通过数组存放的（即有一个工作线程数组）</li>
<li>sun.misc.Unsafe操作类直接基于操作系统控制层在硬件层面上进行原子操作，它是ForkJoinPool高效性能的一大保证，类似的编程思路还体现在java.util.concurrent包中相当规模的类功能实现中。<br>
<img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/1636361445964033773-1660063481982.png" alt="image.png"></li>
</ul>
<hr>
<h2><span id="forkjoin-ying-yong-zai-na">forkJoin应用在哪？</span><a href="#forkjoin-ying-yong-zai-na" class="header-anchor">#</a></h2>
<p>A:<br>
java8 stream的parallel并发功能就是基于forkJoin做的， parallelStream实现的forkJoin拆解任务和执行任务的接口， 默认用机器所有CPU数量的forkJoin线程池。<br>
如果需要限制线程数量，可以用<br>
new forkJoin(线程数).submit(()-&gt;(list.stream().parallel().map()…)); 即可</p>
<p>关于java8和forkJoin究竟是如何配合的，可以看这个链接：<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Dorae/p/7779246.html">源码级别学习java8并行流执行原理</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Dorae/p/7779246.html">https://www.cnblogs.com/Dorae/p/7779246.html</a></p>
<h1><span id="theadlocal-he-xin-yuan-li">TheadLocal核心原理</span><a href="#theadlocal-he-xin-yuan-li" class="header-anchor">#</a></h1>
<hr>
<h2><span id="threadlocal-de-chang-jian-shi-yong-chang-jing">ThreadLocal的常见使用场景？</span><a href="#threadlocal-de-chang-jian-shi-yong-chang-jing" class="header-anchor">#</a></h2>
<p>每个线程中需要维护1个不同的副本， 但这个副本可能是某一个时刻一起塞入每个线程的， 只不过之后该副本的变化 不再受其他线程的影响。</p>
<p>常见场景有连接器管理模块connectorManager， 每个线程持有的connect变量是单独使用的，不会互相影响或者需要加锁。原因就是将其作为副本放入每个线程，当线程启动连接或者关闭时，不影响其他线程里的getConnect方法。</p>
<hr>
<h2><span id="threadlocal-he-synchronized-guan-jian-zi-de-qu-bie">ThreadLocal和Synchronized关键字的区别？</span><a href="#threadlocal-he-synchronized-guan-jian-zi-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
Synchronized是用时间的消耗，来换取数据同步以及互不冲突<br>
ThreadLocal则是用空间的消耗，来换取数据之间互不冲突（不涉及同步）</p>
<hr>
<h2><span id="theadlocal-zai-mei-ge-xian-cheng-zhong-shi-yi-shi-me-xing-shi-cun-chu-de-yuan-li-shi-shi-me">TheadLocal在每个线程中是以什么形式存储的？ 原理是什么</span><a href="#theadlocal-zai-mei-ge-xian-cheng-zhong-shi-yi-shi-me-xing-shi-cun-chu-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h2>
<p>这篇文章讲解ThreadLocal源码讲解的蛮好的：<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920407.html">Java并发编程：深入剖析</a></p>
<p>看完后用我自己的话总结一下就是：</p>
<ol>
<li>
<p>在某个线程中调用 某threadlocal.set(value)时， 其实就是在该线程中新建了1个threalocalMap， 然后把threadLocal作为键，value作为值，放进本线程的threalocalMap中。</p>
</li>
<li>
<p>当在线程中调用threadlocal.get()的时候，就是从线程的threadLocalMap中获取这个threadLocal对应的值<br>
如果get不到，则可以通过自定义initValue方法生成一个threadLocal的默认值</p>
</li>
</ol>
<p>见如下图所示：<br>
<img src="/images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/20210718230858556.png" alt="在这里插入图片描述"></p>
<hr>
<p>下面这个代码会报什么错？（例子改编自上面链接的文章）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">         </span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(stringLocal.get());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">		stringLocal.set(<span class="string">&quot;thread0&quot;</span>)</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Thread1中，会报空指针， 因为调用get之前没有做过set， 此时做get会报错。<br>
一种方式改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	stringLocal.set(<span class="string">&quot;thread1&quot;</span>)</span><br><span class="line">        System.out.println(stringLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种是给stringLocal设置默认值，这种一般用于能直接根据线程推导出初始值的情况：<br>
ThreadLocal<string> stringLocal = new ThreadLocal<string>(){;<br>
protected String initialValue() {<br>
return xxx;<br>
};<br>
};</string></string></p>
<p>正确set之后， 答案就会返回thread0和thread1， 且后续怎么set，两边都不会互相影响各自的threadLocal，<strong>虽然看起来是都用的是同一个Test里的成员。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/07/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/" class="post-title-link" itemprop="url">第305场周赛-264名-22分钟4题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-07 22:12:42 / 修改时间：11:08:28" itemprop="dateCreated datePublished" datetime="2022-08-07T22:12:42+08:00">2022-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/07/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/07/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841108569.png" alt="1659841108569"></p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-qi-zong-jie">本期总结：</a></li>
</ul>
<!-- tocstop -->
</div> 
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>bfs时，必须要记得在对第一个入队节点做vis[start]=true的操作！否则一定会导致WA！</li>
<li></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/number-of-arithmetic-triplets/">算术三元组的数目 - 力扣 (LeetCode) 竞赛</a></p>
<p>直接3个for循环搞定</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/reachable-nodes-with-restrictions/">受限条件下可到达节点的数目 - 力扣 (LeetCode) 竞赛</a></p>
<p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841166952.png" alt="1659841166952"></p>
<p>这么简单的bfs题竟然错了一次（用bfs是因为节点数量很多有10^5个）</p>
<p>因为bfs时忘了对第一个入队节点做vis[起点] = true;的操作， 直接导致错失前200</p>
<p>另外这题甚至不应该思考， 直接开写才对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt;[] edgToNextNodeLists(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] list = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            list[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edg : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> edg[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> edg[<span class="number">1</span>];</span><br><span class="line">            list[s].add(e);</span><br><span class="line">            list[e].add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachableNodes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span>[] restricted)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt;[] nextNodes = edgToNextNodeLists(n, edges);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        Set&lt;Integer&gt; resSet = Arrays.stream(restricted).boxed().collect(Collectors.toSet());</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nextNode : nextNodes[node]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[nextNode] || resSet.contains(nextNode)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(nextNode);</span><br><span class="line">                vis[nextNode] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/check-if-there-is-a-valid-partition-for-the-array/">检查数组是否存在有效划分 - 力扣 (LeetCode) 竞赛</a></p>
<p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841394607.png" alt="1659841394607"></p>
<p>可检查范围最多就3个，如果[4,5,6]如果符合，那我只要检查4前面那个数字是否有符合的划分，划分可以传递，因此直接动态规划即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == num) &#123;</span><br><span class="line">            dp[i] |= (i-<span class="number">2</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">2</span>] : <span class="literal">true</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == num &amp;&amp; nums[i-<span class="number">2</span>] == num) &#123;</span><br><span class="line">            dp[i] |= (i-<span class="number">3</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">3</span>] : <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == num-<span class="number">1</span> &amp;&amp; nums[i-<span class="number">2</span>] == num-<span class="number">2</span>) &#123;</span><br><span class="line">            dp[i] |= (i-<span class="number">3</span>&gt;=<span class="number">0</span>?dp[i-<span class="number">3</span>] : <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/longest-ideal-subsequence/">最长理想子序列 - 力扣 (LeetCode) 竞赛</a></p>
<p><img src="/images/%E7%AC%AC305%E5%9C%BA%E5%91%A8%E8%B5%9B-264%E5%90%8D-22%E5%88%86%E9%92%9F4%E9%A2%98/1659841530495.png" alt="1659841530495"></p>
<p>显然是动态规划，   在[a-z]中找到符合k差值的字母， 根据字母已记录的最长子序列长度，进行+1即可。</p>
<p>最开始想歪了，想成了k是位置距离了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIdealString</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lastc</span> <span class="operator">=</span> c-k;lastc &lt;= c+k;lastc++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastc &lt; <span class="number">0</span> || lastc &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, dp[lastc] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[c] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/06/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/" class="post-title-link" itemprop="url">第85场双周赛-1322-3题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-06 22:12:42" itemprop="dateCreated datePublished" datetime="2022-08-06T22:12:42+08:00">2022-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 01:52:10" itemprop="dateModified" datetime="2022-08-07T01:52:10+08:00">2022-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/06/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/06/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659806489275.png" alt="1659806489275"></p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-qi-zong-jie">本期总结：</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>只记录一下对我而言比较有意义的题目</p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>
<p>遇到类似坐标  <code>j - i == nums[j] - nums[i]</code>的题目，记得直接转移公式以期望得到一个f(x)从而建立基于f(x)做key的hashmap， 不要想着什么从左往右+多少减多少这种绕来绕去的思路。</p>
</li>
<li>
<p>数字num要拆成任意个比Target小的任意数字，且还要拆后的最小值尽可能大，那肯定不是直接基于target去做减法，而是让数字尽可能平均， 切分数量*target正好比num大的话，那么num/切分数量肯定满足比target小</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-84/problems/merge-similar-items/">合并相似的物品 - 力扣 (LeetCode) 竞赛</a></p>
<p>hashmap直接用即可</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-84/problems/count-number-of-bad-pairs/">统计坏数对的数目 - 力扣 (LeetCode) 竞赛</a></p>
<p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659806990621.png" alt="1659806990621"></p>
<p>好数概念： <code>i &lt; j</code> 且 <code>j - i == nums[j] - nums[i]</code>， 求好数的个数</p>
<p>明明对做法有印象但就是理不清楚，每次做每次都头晕</p>
<p>主要没法用很简洁的语言表达和解释这个做法</p>
<p>即使我刚做完，我现在也没法很好地描述，为什么是每次put这个nums[i] - i</p>
<p>啊，等等？公式推导？</p>
<p><code>i &lt; j</code> 且 <code>j - i == nums[j] - nums[i]</code></p>
<p>那不就是</p>
<p>nums[j] - j == nums[i] - i</p>
<p>即</p>
<p>f[j] ==  f[i]</p>
<p>f[x] = nums[x] - x</p>
<p><strong>根本和什么动态规划无关，就是一个数学公式推导啊。。。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countBadPairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">needNum</span> <span class="operator">=</span> nums[i] - i;</span><br><span class="line">        result += map.getOrDefault(needNum, <span class="number">0L</span>);</span><br><span class="line">        map.put(needNum, map.getOrDefault(needNum, <span class="number">0L</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)nums.length * (nums.length-<span class="number">1</span>) /<span class="number">2</span> - result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-84/problems/task-scheduler-ii/">任务调度器 II - 力扣 (LeetCode) 竞赛</a></p>
<p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659807018323.png" alt="1659807018323"></p>
<p>这个还好，每次完成任务后，存一下下一次任务开始时至少的时间即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">taskSchedulerII</span><span class="params">(<span class="type">int</span>[] tasks, <span class="type">int</span> space)</span> &#123;</span><br><span class="line">        <span class="comment">// 存的是下一次任务的至少开始时间</span></span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">task</span> <span class="operator">=</span> tasks[i];</span><br><span class="line">            <span class="type">long</span> <span class="variable">canStartTime</span> <span class="operator">=</span> map.getOrDefault(task, Long.MIN_VALUE);</span><br><span class="line">            <span class="keyword">if</span> (nowTime &lt; canStartTime) &#123;</span><br><span class="line">                nowTime = canStartTime;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(task, nowTime + space + <span class="number">1</span>);</span><br><span class="line">            nowTime++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nowTime - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-84/problems/minimum-replacements-to-sort-the-array/">将数组排序的最少替换次数 - 力扣 (LeetCode) 竞赛</a></p>
<p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659807076595.png" alt="1659807076595"></p>
<p>首先我很快想到必须是从右往左去遍历和替换，</p>
<p>如果当前比右边的都要小，则尽可能不拆</p>
<p>如果当前比右边的最小值要大， 则必须拆，拆的时候要保证最小值尽可能大</p>
<p>这题就演变成了</p>
<p>数字x要拆成k个比t小的任意数字，且最小值尽可能小（y)</p>
<p>我固执己见以为是一直按t去减，最后剩余的数字求个平均，就能保证最小值尽可能小了</p>
<p>却没考虑剩余数字可能因为我错误的选择了t导致特别小</p>
<p>实际上应该是拆分后的数字尽可能平均</p>
<p>以100 22为例</p>
<p>5个22正好比100大（4个22比100小）</p>
<p>那么100/5得到的均值肯定比22小</p>
<p>公式上即满足</p>
<p><img src="/images/%E7%AC%AC85%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-1322-3%E9%A2%98/1659807407709.png" alt="1659807407709"></p>
<p>简单点的话就是  k&gt;=x/y的最小整数，即向上取整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumReplacement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>  <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; last) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// k=【num[i] / last】向上取整</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i] / last;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % last != <span class="number">0</span>) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                last = nums[i] / k;</span><br><span class="line">                result += k-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">第二阶段心理成长感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-01 23:35:22" itemprop="dateCreated datePublished" datetime="2022-08-01T23:35:22+08:00">2022-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:58:06" itemprop="dateModified" datetime="2022-08-10T00:58:06+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>72</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me">思考追求工作高绩效的价值是什么</a></li>
</ul>
<!-- tocstop -->
</div> 
<h1><span id="si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me">思考追求工作高绩效的价值是什么</span><a href="#si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me" class="header-anchor">#</a></h1>
<p>我是觉得在某个大公司做工作，就是有意义的吗？</p>
<p>做的项目影响的人数越多，我就越有价值吗？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/" class="post-title-link" itemprop="url">第304场周赛-897-4题（心态重要）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-01 22:12:42" itemprop="dateCreated datePublished" datetime="2022-08-01T22:12:42+08:00">2022-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-31 22:58:44" itemprop="dateModified" datetime="2022-07-31T22:58:44+08:00">2022-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659277621782.png" alt="1659277621782"></p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-qi-zong-jie">本期总结：</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>只记录一下对我而言比较有意义的题目</p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>永远保持冷静，不要激动，下次可以录屏，记录自己的心态和过程</li>
<li>图里有环的判断并不是走回自己，而是走到了重复走过的点</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">6132. 使数组中所有元素都等于零 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278338228.png" alt="1659278338228"></p>
<p>这题花了七分钟，不应该。</p>
<p>题目没看懂</p>
<p>**选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 **最小的 <strong>非零</strong> 元素</p>
<p>又要求最少操作数，那么只能是每次选nums中的最小即可,这里想复杂了，以为是选某个区间范围内的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(nums);</span><br><span class="line">        <span class="keyword">if</span> (min == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] -= min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            min = Math.min(nums[i], min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/">6133. 分组的最大数量 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278765664.png" alt="1659278765664"></p>
<p>脑筋急转弯啊这是</p>
<p>跟grades根本没关系</p>
<p>直接排序后，每次取1个、2个、3个即可</p>
<p>拿就是看这样增加到什么时候为止结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGroups</span><span class="params">(<span class="type">int</span>[] grades)</span> &#123;</span><br><span class="line">        <span class="comment">//Arrays.sort(grades);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> grades.length;</span><br><span class="line">        <span class="keyword">while</span> (len - (k+<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = len - (k+<span class="number">1</span>);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/">6134. 找到离给定两个节点最近的节点 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278866526.png" alt="1659278866526"></p>
<p>这题思路其实也容易想：</p>
<p>先从node1一直往下遍历，直到遇到尽头或者环，记录每个点的距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dis[node1] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> edges[node1];</span><br><span class="line"><span class="keyword">while</span> (node != -<span class="number">1</span> &amp;&amp; dis[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">    dis[node] = d++;</span><br><span class="line">    node = edges[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后node2也一直往下走，遇到node1走过的点（通过dis是否为-1判断）则计算最小值和要选择的点。同时也要判断环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="number">0</span>;</span><br><span class="line">node = node2;</span><br><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[edges.length];</span><br><span class="line"><span class="keyword">while</span> (node!=-<span class="number">1</span> &amp;&amp; !vis[node]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[node] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.max(d, dis[node]) &lt; result) &#123;</span><br><span class="line">            result = Math.max(d, dis[node]);</span><br><span class="line">            select = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d++;</span><br><span class="line">    vis[node] = <span class="literal">true</span>;</span><br><span class="line">    node = edges[node];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是自己提前想漏了很多点</p>
<p>遗漏点1：环的判断并不是走回自己啊，而是走到了重复走过的点！</p>
<p>遗漏点2：要注意节点距离相同的情况，要选节点编号最小！</p>
<p>遗漏点3：冷静冷静，不要妄自生气，你及时没进200，也拿到了每日3题的积分了！</p>
<p>这种easy题做了40分钟还错了2次很不应该！</p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279307738.png" alt="1659279307738"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-cycle-in-a-graph/">6135. 图中的最长环 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279326269.png" alt="1659279326269"></p>
<p>大放水，欸，知道每个点不需要重复走， 这个思路就能处理了</p>
<p>但是要注意  ”碰到自己走过的点即成环了“ 和”碰到别人走过的点，不用再走“是有区别的，不能一起判断</p>
<p>所以我用了一个root来判断</p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279449222.png" alt="1659279449222"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88%EF%BC%880730-0817%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88%EF%BC%880730-0817%EF%BC%89/" class="post-title-link" itemprop="url">22年8月刷题日记（0730-0817）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 22:12:42" itemprop="dateCreated datePublished" datetime="2022-07-29T22:12:42+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 00:28:00" itemprop="dateModified" datetime="2022-08-19T00:28:00+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">刷题日记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022%E5%B9%B48%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2022年8月</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88%EF%BC%880730-0817%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88%EF%BC%880730-0817%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="22-nian-8-yue-shua-ti-ri-ji-0730-0817">22年8月刷题日记（0730-0817）</span><a href="#22-nian-8-yue-shua-ti-ri-ji-0730-0817" class="header-anchor">#</a></h1>
<p>[toc]</p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#2022-07-30">2022-07-30</a></li>
<li><a href="#2022-07-29">2022-07-29</a></li>
<li><a href="#2022-08-01">2022-08-01</a></li>
<li><a href="#2022-08-03">2022-08-03</a></li>
<li><a href="#2022-08-04">2022-08-04</a></li>
<li><a href="#2022-08-05">2022-08-05</a></li>
<li><a href="#2022-08-07">2022-08-07</a></li>
<li><a href="#2022-08-08">2022-08-08</a></li>
<li><a href="#2022-08-09">2022-08-09</a></li>
<li><a href="#2022-08-10">2022-08-10</a></li>
<li><a href="#2022-08-11">2022-08-11</a></li>
<li><a href="#2022-08-12">2022-08-12</a></li>
<li><a href="#2022-08-13">2022-08-13</a></li>
<li><a href="#2022-08-15">2022-08-15</a></li>
<li><a href="#2022-08-16">2022-08-16</a></li>
<li><a href="#2022-08-17">2022-08-17</a></li>
</ul>
<!-- tocstop -->
</div> 
<hr>
<h1><span id="2022-07-30">2022-07-30</span><a href="#2022-07-30" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列 - 力扣（LeetCode）</a></p>
<p>简单，题意理解了就好， 排列组合的数学应用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串 - 力扣（LeetCode）</a></p>
<p>简单，推导出贪心规律，从左到右只要符合平衡，就一定可以从更大的平衡串中拆掉</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数 - 力扣（LeetCode）</a></p>
<p>“111011011”这种二进制字符串如何快速转int整数？</p>
<p>可以用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(&quot;111011011&quot;, 2) </span><br></pre></td></tr></table></figure>
<p>2指代二进制</p>
<h1><span id="2022-07-29">2022-07-29</span><a href="#2022-07-29" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-square/">593. 有效的正方形 - 力扣（LeetCode）</a></p>
<p><strong>如何用4个点判断是否是一个正方形？</strong></p>
<ul>
<li>
<p>方法1： 设置顺时针点为1-&gt;2-&gt;3-&gt;4，然后根据边长相同、22边平行、勾股定理3者判断是否为正方形。</p>
<p>1-&gt;2-&gt;3-&gt;4点的判定先根据横坐标最小，再根据纵坐标最小。</p>
</li>
<li>
<p>方法二：正方形的任意3个点都是等边直角三角形，判断4次即可，注意额外加一个三角形中边的判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validSquare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c, <span class="type">int</span>[] d)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calc(a, b, c) &amp;&amp; calc(a, b, d) &amp;&amp; calc(a, c, d) &amp;&amp; calc(b, c, d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/furthest-building-you-can-reach/">1642. 可以到达的最远建筑 - 力扣（LeetCode）</a></p>
<p>简单贪心题。</p>
<p>注意PriorityQueue默认小顶堆</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/">1285. 找到连续区间的开始和结束数字 - 力扣（LeetCode）</a></p>
<ul>
<li>
<p>row_number() over() 指每一行在整个表分区中的序号</p>
</li>
<li>
<p>over()是窗口函数，不会做汇聚动作，因此行数不会发生变化。只会给出每一行所处分区的某个特定值（例如各分区的和 sum over(PARTITION  by xxx)）</p>
</li>
<li>
<p>id - <strong>row_number() over()</strong> diff   外层套一个group by diff可以用来求解连续区间的问题</p>
</li>
</ul>
<hr>
<h1><span id="2022-08-01">2022-08-01</span><a href="#2022-08-01" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合 - 力扣（LeetCode）</a></p>
<ul>
<li>dfs全排列搜索问题且要求不能重复，关键语句就是”预处理排序。选的时候前一位相同，则必须是连续选的情况，不可以前面的相同数字还没选，却选了自己“</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == nums[i] &amp;&amp; lastIndex != i-<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>list.remove(int) 就是按索引移除。  list.remove(object)是针对非int对象的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-plus-sign/">764. 最大加号标志 - 力扣（LeetCode）</a></p>
<ul>
<li>
<p>写了4个2重循环好麻烦，就是提前预处理好每个点的上下左右到最近0的距离即可</p>
</li>
<li>
<p>for (int y = 0, dis=0; y &lt; n;y++)    此时int等同于声明了dis，外层不可再声明dis了</p>
</li>
</ul>
<hr>
<h1><span id="2022-08-03">2022-08-03</span><a href="#2022-08-03" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">2265. 统计值等于子树平均值的节点数 - 力扣（LeetCode）</a></p>
<p>直接后序遍历即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p>
<p>翻转问题还是写一个reverse的简单方法会比较快，用stringBuilder不一定快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distribute-candies/">575. 分糖果 - 力扣（LeetCode）</a></p>
<p>集合应用，没啥好说的</p>
<h1><span id="2022-08-04">2022-08-04</span><a href="#2022-08-04" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/">1403. 非递增顺序的最小子序列 - 力扣（LeetCode）</a></p>
<p>排序即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计 - 力扣（LeetCode）</a></p>
<p>将出点和入点放入数组中，出点位置+seats， 入点位置-seats即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/print-foobar-alternately/">1115. 交替打印 FooBar - 力扣（LeetCode）</a></p>
<p>第一次做多线程的题目，还蛮有意思的</p>
<p>要求交替打印n次foo和bat</p>
<p>其实可以用资源的角度来理解</p>
<p>即需要打印foo时，说明生产了一个foo令牌，才可以打印</p>
<p>如果要打印bar，则要求有bar令牌才可以。</p>
<p>那么就很容易想到用2个阻塞队列或者2个信号量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; fooSync = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; barSync = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fooSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fooSync.take();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            barSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            barSync.take();</span><br><span class="line">            printBar.run();</span><br><span class="line">            fooSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以用一个boolean布尔值来表示此时打印foo还是打印bar，然后利用等待-唤醒机制。</p>
<p>如果用java自带语法，可以是wait和notify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">2</span>*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                 printFoo.run();</span><br><span class="line">                 count--;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                count--;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用JUC，则用Condition即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="2022-08-05">2022-08-05</span><a href="#2022-08-05" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-way-to-form-string/">1055. 形成字符串的最短路径 - 力扣（LeetCode）</a></p>
<p>2个字符串长度最多1000，双指针即可，没啥难的</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cyJERH/">剑指 Offer II 092. 翻转字符 - 力扣（LeetCode）</a></p>
<p>提前预处理往左看的1的个数和往右看的0的个数</p>
<p>然后再遍历一次，每次把左边翻0，右边翻1，因为预处理过了所以可以马上得到答案</p>
<p>但是这个做法比较消耗2个O(n)的空间</p>
<p>用动态规划可以节省很多空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFlipsMonoIncr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// dp0代表位置为i时变成000..00所需翻转的数量</span></span><br><span class="line">    <span class="comment">// dp1代表位置为i时变成0001111所需翻转的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>, dp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last0</span> <span class="operator">=</span> dp0;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last1</span> <span class="operator">=</span> dp1;</span><br><span class="line">        dp0 = last0 + (c==<span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        dp1 = (c==<span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>) + Math.min(last0, last1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp0, dp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindrome/">409. 最长回文串 - 力扣（LeetCode）</a></p>
<p>就是数量统计题而已</p>
<hr>
<h1><span id="2022-08-07">2022-08-07</span><a href="#2022-08-07" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/exclusive-time-of-functions/submissions/">636. 函数的独占时间 - 力扣（LeetCode）</a></p>
<p>栈的应用题，start和end等同于左括号和右括号</p>
<p>注意用int[]数组来简化新类的定义操作，注意每次end出栈后，要把这段程序占用的总时间加到栈顶</p>
<hr>
<h1><span id="2022-08-08">2022-08-08</span><a href="#2022-08-08" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-gold/">1219. 黄金矿工 - 力扣（LeetCode）</a></p>
<p>提示dfs最大深度为25，则认为可以直接做带vis访问标记的dfs且不需要做记忆化结果。</p>
<p>另外dfs时也不要忘记对初始点的vis处理</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/submissions/">1365. 有多少小于当前数字的数字 - 力扣（LeetCode）</a></p>
<p>虽然是简单题，数量级别只有500，但还是考虑写了一下最快性能，直接按值做键处理，就能知道比每个值小的数量了，然后再分别设置。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/special-binary-string/">761. 特殊的二进制序列 - 力扣（LeetCode）</a></p>
<p>这题没做出来，直接看答案了</p>
<p>0和1的数量相等  +  任意前缀1数量大于0，  类似于括号匹配</p>
<p>要我们调整括号对使得字典序尽可能大</p>
<p>这样就很容易想到递归了，即最外层括号可以不管， 然后只对内层做处理， 内层找到每一个括号对，然后按字典序排序。</p>
<ul>
<li>
<p>字符串list快速拼接：list.stream().collect(Collectors.joining());</p>
</li>
<li>
<p>s.subString(a,b)中b是开区间</p>
</li>
</ul>
<h1><span id="2022-08-09">2022-08-09</span><a href="#2022-08-09" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/">1413. 逐步求和得到正数的最小值 - 力扣（LeetCode）</a></p>
<p>遍历求和，求中间sum距离1的最大差值即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-in-binary-tree/">1367. 二叉树中的列表 - 力扣（LeetCode）</a></p>
<p>O(二叉树节点*链表节点)的复杂度符合要求</p>
<p>遍历每个点为起点，然后往下搜索判断能否找到即可，还是挺有意思的递归应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        nodes.add(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, List&lt;Integer&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkToDown(node, nodes, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(node.left, nodes)  ||   dfs(node.right, nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">checkToDown</span><span class="params">(TreeNode node, List&lt;Integer&gt; nodes, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nodes.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val != nodes.get(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> checkToDown(node.left, nodes, index+<span class="number">1</span>) || checkToDown(node.right, nodes, index+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7WHec2/">剑指 Offer II 077. 链表排序 - 力扣（LeetCode）</a></p>
<p>要求在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序</p>
<p>那所有排序方法里，只有递归排序可以实现了</p>
<p>而且得是从下往上递归</p>
<p>先11合并，再22合并，再44合并。</p>
<p>链表归并排序处理的几个坑：</p>
<ol>
<li>头节点可能变更的话，最好提前创建一个dummy头节点，这样dummy头节点.next就是新节点了</li>
<li>注意记录下一个排序序列的起始节点，用于确认是否第二个序列到末尾结束了。</li>
<li>还要记录上次排序序列的末尾节点， 用于排序后更新  上次末尾节点.next</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">listLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            listLen++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要总是改变头节点的情况下，最好定义一个空头节点用来更新头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">emptyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        emptyHead.next = head;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; listLen) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> emptyHead;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> emptyHead.next;</span><br><span class="line">            <span class="keyword">while</span>(head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> head1;</span><br><span class="line">                <span class="comment">// 走过len步，找到第二个比较序列的头部</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; head2 != <span class="literal">null</span>;i++) &#123;</span><br><span class="line">                    head2 = head2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找不到第二个序列头部了，则不用比较直接结束这次排序</span></span><br><span class="line">                <span class="keyword">if</span> (head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找一下下一次排序序列的开始节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">nextSortStartNode</span> <span class="operator">=</span> head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; nextSortStartNode != <span class="literal">null</span>;i++) &#123;</span><br><span class="line">                    nextSortStartNode = nextSortStartNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 合并，并更新新合并序列的末尾节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">newSortHead</span> <span class="operator">=</span> sortBatch(head1, head2, nextSortStartNode);</span><br><span class="line">                <span class="comment">// 更新头节点</span></span><br><span class="line">                preNode.next = newSortHead;</span><br><span class="line">                <span class="comment">// 定位末尾节点</span></span><br><span class="line">                <span class="keyword">while</span>(preNode.next != nextSortStartNode) &#123;</span><br><span class="line">                    preNode = preNode.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                head1 = nextSortStartNode;</span><br><span class="line">            &#125;</span><br><span class="line">            len*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emptyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode <span class="title function_">sortBatch</span><span class="params">(ListNode head1, ListNode head2, ListNode nextNode)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> head3;</span><br><span class="line">        <span class="keyword">while</span>(node1 != head2 || node2 != nextNode) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> node1 != head2 ? node1.val : Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> node2 != nextNode ? node2.val : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">                node3.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node3.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node3 = node3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node3.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> head3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1><span id="2022-08-10">2022-08-10</span><a href="#2022-08-10" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">1253. 重构 2 行二进制矩阵 - 力扣（LeetCode）</a></p>
<p>还是蛮容易推导的一个数组题，先处理掉所有0和2的情况</p>
<p>再处理1的情况，先把1都分配给上边，上边不够之后再分配给下边，最后检查是否清零即可。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-minimum-value/">1102. 得分最高的路径 - 力扣（LeetCode）</a></p>
<p>很有意思的搜索题，我想到了bfs，且这个bfs是支持刷新点的bfs。先优先按最大的走</p>
<p>如果发现当前点被人走过，但是自己是比他优（不能相等），则可以刷新对方自己继续走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已经有人走过，且自己不能刷新最好记录，则没必要走了，别人已经在走了</span></span><br><span class="line"><span class="keyword">if</span> (gMin[ny][nx] != Integer.MIN_VALUE &amp;&amp; gMin[ny][nx] &gt;= Math.min(grid[ny][nx], lastMin)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">gMin[ny][nx] = Math.min(grid[ny][nx], lastMin);</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ny, nx, gMin[ny][nx]&#125;);</span><br></pre></td></tr></table></figure>
<p>当然看答案还有dfs+二分， 即确定目标最小值之后， dfs搜索最多10000次。</p>
<p>复杂度O(10000 * (log2(10^9)))</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/UHnkqh/">剑指 Offer II 024. 反转链表 - 力扣（LeetCode）</a></p>
<p>用递归做比较有趣</p>
<hr>
<h1><span id="2022-08-11">2022-08-11</span><a href="#2022-08-11" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-the-lonely-nodes/">1469. 寻找所有的独生节点</a></p>
<p>直接递归判断，简单</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sparse-array-search-lcci/">面试题 10.05. 稀疏数组搜索 - 力扣（LeetCode）</a></p>
<p>二分搜索，但我还是遍历了一遍先过滤空字符串了。导致性能是1ms</p>
<p>但差距不大是因为那些人也要定位后在0上去走，消耗不会差别太大。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串 - 力扣（LeetCode）</a></p>
<p>很简单的滑动窗口</p>
<ol>
<li>第一波做出来性能20ms，不是最佳。因为用了Stream去判断是否有重复</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">int</span>[] counts)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(counts).noneMatch(c -&gt; c &gt;= <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>去掉Stream改用简单for循环，性能就到 5 ms 了</p>
</li>
<li>
<p>去掉k&gt;26的判断，提升到4ms</p>
</li>
<li>
<p>避免每次26次判断，用repeatCount值来记录，这样每次最多判断2次，结果还是4ms</p>
<p><img src="/images/22%E5%B9%B48%E6%9C%88/1660233587305.png" alt="1660233587305"></p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reformat-the-string/">1417. 重新格式化字符串</a></p>
<p>一般那种要你交叉放数字的，都可能有一种改进点是看你能否空间复杂度为O(1)（不包含结果输出空间）</p>
<p>这就需要原地算法，双指针进行交换</p>
<hr>
<h1><span id="2022-08-12">2022-08-12</span><a href="#2022-08-12" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/">1282. 用户分组 - 力扣（LeetCode）</a></p>
<p>按数量建哈希表，每个数量对应一个列表，列表满了就放入结果中并重置，很简单</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数 - 力扣（LeetCode）</a></p>
<p>只能取左右两边，那么等同于滑动窗口，只不过是反着求中间的滑动窗口最小值</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或 - 力扣（LeetCode）</a></p>
<p>很有意思，要求 <code>nums[i] XOR nums[j]</code> 的最大运算 结果</p>
<p>想了半天终于想起来有一个字典树这玩意，一开始觉得麻烦，后来还是写了 ，答案也有这个思路，很棒</p>
<p>只不过自己得记住，要先在字典树中试图求解最大运算结果，  求解完成后，才能把自己再插入字典树中</p>
<hr>
<h1><span id="2022-08-13">2022-08-13</span><a href="#2022-08-13" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/goal-parser-interpretation/">1678. 设计 Goal 解析器 - 力扣（LeetCode）</a></p>
<p>直接取临时字符串然后判断即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/">1874. 两个数组的最小乘积和 - 力扣（LeetCode）</a></p>
<p>直接排序后第一个数组的最大乘第二个数组的最小，依次处理即可，很简单，虽然我不知道怎么证明 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II - 力扣（LeetCode）</a></p>
<p>一次就AC了， 想到了动态规划</p>
<p>每次求出左边的最大值</p>
<p>然后看一下自己当前位置往左边遍历时，选取那个左边位置作为一块，能否满足要求，能满足要求则就看判断当前最大分割块即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (左边最大值 小于 我当前位置从右往左遍历时的最小值， 说明可以分割)&#123;</span><br><span class="line">    dp[当前位置] = Math.max(dp[左边界-<span class="number">1</span>] + <span class="number">1</span>  , dp[当前位置]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1><span id="2022-08-15">2022-08-15</span><a href="#2022-08-15" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列 - 力扣（LeetCode）</a></p>
<p>循环双端队列，其实关键在于循环队列的定义，双端的话很容易处理的。</p>
<p>这题肯定是要用数组来做比较有意义</p>
<p>循环队列数组概念硬记忆：</p>
<ul>
<li>front指向已存储的队头元素， rear指向已存储的队尾元素的下一个位置（即空位置）</li>
</ul>
<ul>
<li>队满： (Q.rear+1)%M = Q.front，  即队尾的下一个位置已经有了</li>
<li>队空： Q.front = Q.rear    即队头存储的是一个空的</li>
<li>队长： (rear-front+M)%M</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组 - 力扣（LeetCode）</a></p>
<p>很简单， 直接计算左边前缀乘积， 计算右边前缀乘积即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/comments/">1015. 可被 K 整除的最小整数 - 力扣（LeetCode）</a></p>
<ul>
<li>
<p>数字末尾是1的情况下，肯定不能被2和5整除</p>
</li>
<li>
<p>通过公式推导：</p>
<blockquote>
<blockquote></blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">设n=p*K+q</span><br><span class="line">则n*<span class="number">10</span>+<span class="number">1</span>= <span class="number">10</span>*p*K + q*<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">对两边都取k取余</span><br><span class="line">有(n*<span class="number">10</span>+<span class="number">1</span>)%K=(<span class="number">10</span>*p*K+q*<span class="number">10</span>+<span class="number">1</span>)%K</span><br><span class="line">又因为n%k=q</span><br><span class="line">则右边(<span class="number">10</span>*p*K+q*<span class="number">10</span>+<span class="number">1</span>)%K = (q*<span class="number">10</span>+<span class="number">1</span>)%K = (n%k*<span class="number">10</span> + <span class="number">1</span>) %K</span><br><span class="line">推断出：(n*<span class="number">10</span>+<span class="number">1</span>)%K = ((n%K)*<span class="number">10</span>+<span class="number">1</span>)%K</span><br><span class="line">因此(n*<span class="number">10</span>+<span class="number">1</span>)如果能被k整除，等同于 (n%k)*<span class="number">10</span>+<span class="number">1</span>被k整除</span><br><span class="line">所以只要n做增加时先取余即可</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>不含2和5的质因子的数必定在K之内有解，直接用其mod循环即可，避免了大数之间的除法</p>
<hr>
<h1><span id="2022-08-16">2022-08-16</span><a href="#2022-08-16" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-an-ordered-stream/">1656. 设计有序流 - 力扣（LeetCode）</a></p>
<p>用String[]做数组，当前点之前是空，现在要插入，则可以尝试往后遍历直到遇到空</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/percentage-of-letter-in-string/">2278. 字母在字符串中的百分比 - 力扣（LeetCode）</a></p>
<p>没看懂有啥用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-three/">326. 3 的幂 - 力扣（LeetCode）</a></p>
<p>直接按3取余，不断除3，直到为1说明就是3的幂</p>
<p>题解有个超简单方法：</p>
<p>根据数值范围，找到最大的3幂的值 1162261467  ，然后直接看 1162261467  能否被询问的这个值整除即可</p>
<p>这提示我们如果以后遇到这种需求，可以直接定义一个最大范围值取判断，而不用自己重复去循环计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="2022-08-17">2022-08-17</span><a href="#2022-08-17" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/">914. 卡牌分组 - 力扣（LeetCode）</a></p>
<p>记住gcd公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">x</span> <span class="operator">=</span>= <span class="number">0</span> ? y : gcd(y % x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这题里因为题目必须要求分成每组X个，所以总数必须要能被X整除，这就过滤掉很多了</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接 - 力扣（LeetCode）</a></p>
<p>一个树，加上一个边构成带环的图，问怎么找到应该去掉的那条边，重新变回树</p>
<p>我最初的思路：每次去掉一个边，然后做bfs看是否重新碰到自己的点，但是要考虑很多判断，很麻烦</p>
<p>这题最佳是用并查集， 当拼接的时候，如果发现左右两个点属于同一个集合，则一定会出现环</p>
<p>即是否图中成环的判断可以用这个方式：</p>
<p><strong>通过边连接2个点的时候，如果2个点属于同一个并查集，则一定存在环</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-people-to-teach/">1733. 需要教语言的最少人数 - 力扣（LeetCode）</a></p>
<p>最开始以为我的思路需要500乘500乘500</p>
<p>后来发现其实好友关系的总数只有500，即边只有500个</p>
<p>则遍历次数少了500倍</p>
<p>那可以直接遍历每种语言，判断能否加</p>
<p>注意需要提前处理掉那些不需要新学语言的人（即他和他的所有好友都有共同语言）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">数据库锁、事务、隔离级别超详细原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-28 23:01:11" itemprop="dateCreated datePublished" datetime="2022-07-28T23:01:11+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-21 23:56:06" itemprop="dateModified" datetime="2022-08-21T23:56:06+08:00">2022-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#zang-du-he-zang-du-guo-cheng-zhong-she-ji-de-suo">脏读和脏读过程中涉及的锁</a>
<ul>
<li><a href="#q-tong-shi-zhi-xing-jia-qian-he-kou-qian-cao-zuo-yi-fang-hui-gun-dao-zhi-shu-ju-chu-cuo-de-du-guo-cheng-jiao-shi-me"><strong>Q:同时执行加钱和扣钱操作，一方回滚导致数据出错的读过程叫什么？</strong></a></li>
<li><a href="#q-zai-bu-xiu-gai-shu-ju-ku-ge-chi-ji-bie-de-qing-kuang-xia-wo-men-ke-yi-ru-he-yong-sql-yu-ju-shou-dong-jie-jue-zhe-ge-zang-du">Q: 在不修改数据库隔离级别的情况下， 我们可以如何用sql语句手动解决这个脏读？</a></li>
<li><a href="#q-gang-cai-kan-dao-suo-zhu-li-si-zhe-yi-xing-na-me-zhe-ge-jiu-jiao-xing-ji-suo-shi-me-qing-kuang-xia-hui-bian-cheng-suo-zhu-zheng-ge-biao"><strong>Q: 刚才看到”锁住李四这一行“， 那么这个就叫行级锁。什么情况下会变成锁住整个表？</strong></a></li>
<li><a href="#q-ru-guo-yi-ge-shi-wu-a-shen-qing-liao-xing-suo-suo-zhu-mou-yi-xing-ling-yi-ge-shi-wu-b-shen-qing-liao-biao-suo-na-b-hui-bei-zu-sai-ma"><strong>Q: 如果一个事务A申请了行锁，锁住某一行， 另一个事务B申请了表锁，那B会被阻塞吗？</strong></a></li>
<li><a href="#pai-ta-suo-gai-nian">排他锁概念</a></li>
<li><a href="#gong-xiang-suo-gai-nian">共享锁概念</a></li>
<li><a href="#q-na-me-shi-me-shi-hou-shi-yong-gong-xiang-suo-bi-pai-ta-suo-yao-hao-ni"><strong>Q: 那么什么时候使用共享锁比排他锁要好呢？</strong></a></li>
<li><a href="#q-na-wo-jia-de-gong-xiang-suo-s-suo-he-pai-ta-suo-x-shi-me-shi-hou-shi-fang-ni-shi-mei-ci-zhi-xing-wan-update-ma-shang-shi-fang-ma"><strong>Q: 那我加的共享锁（S锁）和排他锁（X)什么时候释放呢？是每次执行完update马上释放吗？</strong></a></li>
<li><a href="#q-liang-jie-duan-suo-xie-yi-ke-yi-bi-mian-si-suo-ma"><strong>Q: 两阶段锁协议可以避免死锁吗？</strong></a></li>
</ul>
</li>
<li><a href="#ge-chi-ji-bie-he-mvcc-yuan-li">隔离级别和MVCC原理</a>
<ul>
<li><a href="#q-xian-lai-ge-xiao-wen-ti-ru-ji-bie-mei-you-ren-he-suo-dui-ma"><strong>Q: 先来个小问题，RU级别没有任何锁，对吗？</strong></a></li>
<li><a href="#q-dang-wo-men-de-shu-ju-ku-bei-she-zhi-cheng-rc-ji-bie-read-commited-shi-ke-yi-jie-jue-zang-du-na-me-bei-hou-shi-zen-me-jie-jue-de-ni"><strong>Q: 当我们的数据库被设置成RC级别（Read commited）时， 可以解决脏读， 那么背后是怎么解决的呢？</strong></a></li>
<li><a href="#q-mvcc-jiu-jing-shi-zen-me-zuo-de-ni"><strong>Q: MVCC究竟是怎么做的呢？</strong></a></li>
<li><a href="#q-mvcc-ji-zhi-xia-shi-me-shi-kuai-zhao-du-shi-me-shi-dang-qian-du"><strong>Q: MVCC机制下， 什么是快照读，什么是当前读？</strong></a></li>
<li><a href="#q-na-me-hui-dao-gang-cai-de-zang-du-wen-ti-mvcc-jiu-jing-shi-zen-me-zai-du-bu-jia-suo-de-qing-kuang-xia-jie-jue-zang-du-de"><strong>Q: 那么回到刚才的脏读问题，  MVCC究竟是怎么在读不加锁的情况下， 解决脏读的？</strong></a></li>
<li><a href="#q-ru-guo-shi-wu-b-zhong-bu-zuo-yu-e-pan-duan-zhi-chi-zhi-jie-she-zhang-kou-fei-na-shi-bu-shi-hui-dao-zhi-xian-kou-fei-ran-hou-hui-gun-cheng-0-zhe-yang-de-qing-kuang"><strong>Q: 如果事务B中不做余额判断，支持直接赊账+扣费， 那是不是会导致先扣费，然后回滚成0这样的情况？</strong></a></li>
<li><a href="#q-shang-mian-zhe-ge-guo-cheng-you-shi-me-yin-huan"><strong>Q: 上面这个过程有什么隐患</strong></a></li>
<li><a href="#q-rr-ke-chong-fu-du-repeat-read-de-ge-chi-ji-bie-you-shi-zen-me-jie-jue-shang-mian-zhe-ge-wen-ti-de"><strong>Q: RR（可重复读，Repeat Read)的隔离级别又是怎么解决上面这个问题的？</strong></a></li>
<li><a href="#q-na-du-wen-ti-zhong-de-huan-du-you-shi-shi-me"><strong>Q: 那读问题中的幻读又是什么？</strong></a></li>
<li><a href="#q-rr-ge-chi-ji-bie-zhong-de-mvcc-ji-zhi-ke-yi-jie-jue-shang-mian-de-wen-ti-ma"><strong>Q: RR隔离级别中的MVCC机制可以解决上面的问题吗？</strong></a></li>
<li><a href="#q-na-ru-guo-xiang-xia-mian-zhe-yang-shi-wu-a-lian-xu-zuo-liang-ci-geng-xin-ni-dan-chun-kao-mvcc-neng-bi-mian-geng-xin-cao-zuo-de-huan-du-me"><strong>Q: 那如果像下面这样， 事务A连续做两次更新呢，单纯靠MVCC能避免更新操作的幻读么？</strong></a></li>
<li><a href="#q-na-shu-ju-ku-zen-me-chu-li-zhe-chong-2-ci-updete-zhong-jian-zuo-insert-de-huan-du-qing-kuang-ni"><strong>Q: 那数据库怎么处理这种2次updete中间做insert的幻读情况呢？</strong></a></li>
<li><a href="#q-na-xing-suo-jian-xi-suo-next-key-suo-shi-shi-me-qu-bie"><strong>Q: 那行锁、间隙锁、next-key锁是什么区别？</strong></a></li>
<li><a href="#q-ru-guo-name-zhe-ge-zi-duan-bu-shi-suo-yin-er-shi-pu-tong-zi-duan-na-jian-xi-suo-hui-zen-me-jia"><strong>Q: 如果name这个字段不是索引，而是普通字段，那间隙锁会怎么加？</strong></a></li>
<li><a href="#q-na-shi-bu-shi-zhi-yao-name-shi-suo-yin-jiu-bu-hui-gei-zheng-ge-biao-quan-jia-jian-xi-suo-liao"><strong>Q: 那是不是只要name是索引，就不会给整个表全加间隙锁了？</strong></a></li>
<li><a href="#q-gang-cai-kan-dao-shuo-rr-ke-yi-jie-jue-2-ci-select-zhi-jian-de-huan-du-ye-neng-jie-jue-2-ci-update-zhi-jian-de-huan-du-na-wei-shi-me-hen-duo-zi-liao-li-reng-ran-shuo-rr-bu-neng-jie-jue-huan-du"><strong>Q: 刚才看到说RR可以解决2次select之间的幻读， 也能解决2次update之间的幻读， 那为什么很多资料里，仍然说RR不能解决幻读？</strong></a></li>
<li><a href="#q-na-chuan-xing-hua-serializable-ge-chi-ji-bie-wei-shi-me-jiu-neng-bi-mian-huan-du-liao"><strong>Q: 那串行化serializable隔离级别，为什么就能避免幻读了？</strong></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>将下面这些数据库的概念单独拿出来时，相信很多人都有了解或者记忆过，但是将这些概念全部串联在一起时，可能就会很混乱。<br>
我这里举个例子：</p>
<ul>
<li>排他锁、共享锁</li>
<li>行锁、表锁、意向锁、间隙锁、next-key锁</li>
<li>悲观锁、乐观锁</li>
<li>两阶段锁协议</li>
<li>LCBB锁并发控制协议、MVCC多版本控制协议</li>
<li>脏读、不可重复读、幻读</li>
<li>RU\RC\RR\SE隔离级别<br>
然后自己问自己一个问题：</li>
</ul>
<ol>
<li>这一堆锁的关联关系究竟是什么？</li>
<li>各隔离级别究竟是怎么用各种锁+MVCC来解决事务读问题的？</li>
</ol>
<hr>
<h1><span id="zang-du-he-zang-du-guo-cheng-zhong-she-ji-de-suo">脏读和脏读过程中涉及的锁</span><a href="#zang-du-he-zang-du-guo-cheng-zhong-she-ji-de-suo" class="header-anchor">#</a></h1>
<p>首先，我们完全不考虑数据库引擎、隔离级别设置之类的，就当作你用一个超简陋的儿科级别数据库来存放和更新数据。</p>
<p>假设你的商城服务正好在<strong>同时执行</strong>如下的2种事情</p>
<ul>
<li>张三给穷光蛋李四转账100元。</li>
<li>李四尝试下单购买100元的衣服</li>
</ul>
<p>李四在最开始余额只有0元钱。<br>
注意因为是同时执行，在没有做任何保护的情况下，就可能会出现下图这样的情况<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463857433006958-1659020780284.png" alt="image.png"></p>
<p>可以看到李四明明没有钱，却扣费了，变成了很奇怪的-100元。</p>
<hr>
<h2><span id="q-tong-shi-zhi-xing-jia-qian-he-kou-qian-cao-zuo-yi-fang-hui-gun-dao-zhi-shu-ju-chu-cuo-de-du-guo-cheng-jiao-shi-me"><strong>Q:同时执行加钱和扣钱操作，一方回滚导致数据出错的读过程叫什么？</strong></span><a href="#q-tong-shi-zhi-xing-jia-qian-he-kou-qian-cao-zuo-yi-fang-hui-gun-dao-zhi-shu-ju-chu-cuo-de-du-guo-cheng-jiao-shi-me" class="header-anchor">#</a></h2>
<p>A: 这个过程就叫做<strong>脏读</strong>。  即更新回退的时，另一个事务读到了脏数据，判断失误，导致做了错误的处理。<br>
<strong>根本原因是2个事务都是先查后扣，却没有提前保护的形式</strong></p>
<hr>
<h2><span id="q-zai-bu-xiu-gai-shu-ju-ku-ge-chi-ji-bie-de-qing-kuang-xia-wo-men-ke-yi-ru-he-yong-sql-yu-ju-shou-dong-jie-jue-zhe-ge-zang-du">Q: 在不修改数据库隔离级别的情况下， 我们可以如何用sql语句手动解决这个脏读？</span><a href="#q-zai-bu-xiu-gai-shu-ju-ku-ge-chi-ji-bie-de-qing-kuang-xia-wo-men-ke-yi-ru-he-yong-sql-yu-ju-shou-dong-jie-jue-zhe-ge-zang-du" class="header-anchor">#</a></h2>
<p>A: 那很显然就是加锁对事务过程做提前保护， 不让B去判断和扣费。<br>
sql语句里有个 ”for update“ 语法， 会手动锁住李四那一行，在调用commit后释放<br>
具体见下面绿色的标注部分：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463870583057788-1659020780291.png" alt="image.png"></p>
<hr>
<h2><span id="q-gang-cai-kan-dao-suo-zhu-li-si-zhe-yi-xing-na-me-zhe-ge-jiu-jiao-xing-ji-suo-shi-me-qing-kuang-xia-hui-bian-cheng-suo-zhu-zheng-ge-biao"><strong>Q: 刚才看到”锁住李四这一行“， 那么这个就叫行级锁。什么情况下会变成锁住整个表？</strong></span><a href="#q-gang-cai-kan-dao-suo-zhu-li-si-zhe-yi-xing-na-me-zhe-ge-jiu-jiao-xing-ji-suo-shi-me-qing-kuang-xia-hui-bian-cheng-suo-zhu-zheng-ge-biao" class="header-anchor">#</a></h2>
<p>A:<br>
name ='李四’这句话， 如果name是索引列的话，就会加行锁<br>
如果不是索引列， 就会变成表锁。<br>
换言之， <strong>行锁的本质是在索引节点上加锁</strong><br>
如果无法在索引节点上加锁，那就会直接变成整张表的锁，代价就会很大。</p>
<p>另外表锁也可以单独用lock table的语法手动加锁</p>
<hr>
<h2><span id="q-ru-guo-yi-ge-shi-wu-a-shen-qing-liao-xing-suo-suo-zhu-mou-yi-xing-ling-yi-ge-shi-wu-b-shen-qing-liao-biao-suo-na-b-hui-bei-zu-sai-ma"><strong>Q:  如果一个事务A申请了行锁，锁住某一行， 另一个事务B申请了表锁，那B会被阻塞吗？</strong></span><a href="#q-ru-guo-yi-ge-shi-wu-a-shen-qing-liao-xing-suo-suo-zhu-mou-yi-xing-ling-yi-ge-shi-wu-b-shen-qing-liao-biao-suo-na-b-hui-bei-zu-sai-ma" class="header-anchor">#</a></h2>
<p>A:<br>
B事务既然申请表锁，说明可能会用到A中的每一行。<br>
B申请的流程可以是下面这样：</p>
<ol>
<li>判断表是否已被其他事务用表锁锁表</li>
<li>判断表中的每一行是否已被行锁锁住。<br>
但2这一步也太耗时了。<br>
因此A申请行锁前，会优先申请一个意向锁，再申请行锁。<br>
然后B申请时，第2步改成判断意向锁即可，有意向锁就阻塞。</li>
</ol>
<p>简单点说， 意向锁就是行锁操作用来阻塞表锁用的。 但行锁和行锁之间不会互相阻塞，除非行有冲突。</p>
<hr>
<h2><span id="pai-ta-suo-gai-nian">排他锁概念</span><a href="#pai-ta-suo-gai-nian" class="header-anchor">#</a></h2>
<p>刚才看到的for update会限制其他并行事务的所有读写操作，而且是2个事务上都加了”for update“。<br>
那么这个锁就叫做”排他锁“， 属于非常强势的锁， 相当于其他读写操作马上全部拦住了。</p>
<p>这里使用排他锁来解决脏读的原因是因为后面有<strong>查询余额+扣余额</strong>的代码，写这段代码的人必须做提前保护，<strong>以避免自己读到一个可能被修改的数据，导致判断和修改失误</strong>。</p>
<hr>
<h2><span id="gong-xiang-suo-gai-nian">共享锁概念</span><a href="#gong-xiang-suo-gai-nian" class="header-anchor">#</a></h2>
<p>和排他锁对应的是“共享锁”，也就是熟知的读写锁。<br>
可以让多个事务同时读，但是不允许修改 。<br>
手动加共享锁的方式:把for update改成  lock in share mode即可</p>
<h2><span id="q-na-me-shi-me-shi-hou-shi-yong-gong-xiang-suo-bi-pai-ta-suo-yao-hao-ni"><strong>Q: 那么什么时候使用共享锁比排他锁要好呢？</strong></span><a href="#q-na-me-shi-me-shi-hou-shi-yong-gong-xiang-suo-bi-pai-ta-suo-yao-hao-ni" class="header-anchor">#</a></h2>
<p>A:<br>
可以看下面的例子：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463921737079966-1659020780298.png" alt="image.png"></p>
<p>可以看到没有查自身+更新自身的操作， 仅仅是查+更新其他表，表之间也互不关联，对余额的实时性也不是要求太高。</p>
<ul>
<li>如果都加排他锁，各种select操作就会很慢。</li>
<li>但如果不加共享锁， T6这边删除时，就可能产生冗余数据，所以还是得加锁。</li>
</ul>
<hr>
<h2><span id="q-na-wo-jia-de-gong-xiang-suo-s-suo-he-pai-ta-suo-x-shi-me-shi-hou-shi-fang-ni-shi-mei-ci-zhi-xing-wan-update-ma-shang-shi-fang-ma"><strong>Q: 那我加的共享锁（S锁）和排他锁（X)什么时候释放呢？是每次执行完update马上释放吗？</strong></span><a href="#q-na-wo-jia-de-gong-xiang-suo-s-suo-he-pai-ta-suo-x-shi-me-shi-hou-shi-fang-ni-shi-mei-ci-zhi-xing-wan-update-ma-shang-shi-fang-ma" class="header-anchor">#</a></h2>
<p>A:<br>
这里就涉及了“两阶段锁”协议。</p>
<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
<p>说人话， 就是在事务中需要加锁时再加锁， 直到commit完一次性解锁。</p>
<p>为什么要两阶段锁，看到的一句话是<br>
<strong>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</strong></p>
<hr>
<h2><span id="q-liang-jie-duan-suo-xie-yi-ke-yi-bi-mian-si-suo-ma"><strong>Q: 两阶段锁协议可以避免死锁吗？</strong></span><a href="#q-liang-jie-duan-suo-xie-yi-ke-yi-bi-mian-si-suo-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不能避免，但是可以通过死锁检测算法进行事务解除。</p>
<hr>
<p>重新回到张三李四转账+下单的场景上来。<br>
for update这种锁，其实也是一种“悲观锁” ，加锁解锁比较耗时， 默认经常发生竞争。<br>
但如果我的转账和下单过程要求非常快，每次只有几毫秒，那加悲观锁成本就太大了<br>
这时候就可以手动使用乐观锁， 需要你自己在余额表里增加version列，增加后如下所示：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463991504080949-1659020780303.png" alt="image.png"></p>
<p>这样就不需要特地加锁了，每次循环判断即可，前提是冲突发生概率比较低，阻塞时间比较短。</p>
<hr>
<p>刚才一个小小的脏读，就已经解决了下面3个问题</p>
<ul>
<li>排他锁和共享锁的区别：前者是拒绝所有读写 ， 后者是允许并发读拒绝写</li>
<li>行锁和表锁的区别： 前者是对单行加锁 ， 后者是对整表加锁，  区别是 是否涉及索引</li>
<li>悲观锁和乐观锁的区别：  前者主动用数据库自带的锁， 后者自己添加version版本号<br>
外加一个两阶段锁协议</li>
</ul>
<hr>
<h1><span id="ge-chi-ji-bie-he-mvcc-yuan-li">隔离级别和MVCC原理</span><a href="#ge-chi-ji-bie-he-mvcc-yuan-li" class="header-anchor">#</a></h1>
<p>继续回到脏读问题， 前面我们学习的所有概念，都是和数据库自身隔离级别无关，使用数据库的锁语法或者version版本号来避免。</p>
<p>但数据库发展这么强大，怎么可能需要我们频繁自己写这种复杂逻辑，于是数据库诞生了隔离级别设置。</p>
<p>前面会发生脏读的隔离级别， 叫做RU（read uncommited)<br>
即RU级别时， 我可以在别的事务没完全commit好时就读到数据。</p>
<hr>
<h2><span id="q-xian-lai-ge-xiao-wen-ti-ru-ji-bie-mei-you-ren-he-suo-dui-ma"><strong>Q: 先来个小问题，RU级别没有任何锁，对吗？</strong></span><a href="#q-xian-lai-ge-xiao-wen-ti-ru-ji-bie-mei-you-ren-he-suo-dui-ma" class="header-anchor">#</a></h2>
<p>A:<br>
错误， RU级别做update等增删改操作时，仍然会默认在事务更新操作中增加排他锁，避免update冲突。<br>
切记脏读的发生原因，是查询+更新+回滚时没加锁导致其他查询操作出现失误判断。<br>
即查询这块可能读到没提交的数据，导致错误，而不是更新的并发问题。</p>
<hr>
<h2><span id="q-dang-wo-men-de-shu-ju-ku-bei-she-zhi-cheng-rc-ji-bie-read-commited-shi-ke-yi-jie-jue-zang-du-na-me-bei-hou-shi-zen-me-jie-jue-de-ni"><strong>Q: 当我们的数据库被设置成RC级别（Read commited）时， 可以解决脏读， 那么背后是怎么解决的呢？</strong></span><a href="#q-dang-wo-men-de-shu-ju-ku-bei-she-zhi-cheng-rc-ji-bie-read-commited-shi-ke-yi-jie-jue-zang-du-na-me-bei-hou-shi-zen-me-jie-jue-de-ni" class="header-anchor">#</a></h2>
<p>A:<br>
业界有两种方式</p>
<ul>
<li>LBCC基于锁的并发控制（Lock-Based Concurrency Control)）</li>
<li>MVCC基于多版本的并发控制协议(Multi-Version Concurrency Control)</li>
</ul>
<p>LBCC其实就是类似前面手动用悲观锁的方式， 事务操作中查询时默认试图加锁，因此就可能被update的排他锁阻塞住，避免了脏读。</p>
<p>但代价就是效率很低。很多场景下，select的次数是远大于update的。</p>
<p>所以InnoDb 基于乐观锁的概念， 想了一个MVCC，自己在事务的背后实现了一套类似乐观锁的机制来处理这种情况。 确保了尽可能不在读操作上加锁， 排他锁只对更新操作生效。</p>
<hr>
<h2><span id="q-mvcc-jiu-jing-shi-zen-me-zuo-de-ni"><strong>Q: MVCC究竟是怎么做的呢？</strong></span><a href="#q-mvcc-jiu-jing-shi-zen-me-zuo-de-ni" class="header-anchor">#</a></h2>
<p>A:<br>
简单来说，就是默认给每个数据行加了一个版本号列TRX_ID和回滚版本链ROLL_BT，具体可以看《高性能mysql》书里的这段描述：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464034268062917-1659020780312.png" alt="image.png"></p>
<p>简而言之</p>
<ul>
<li>查的时候，只查当前事务之前的记录，或者回滚版本比当前大的已删记录。</li>
<li>增的时候，加新版本的记录</li>
<li>删的时候，把老记录标记上回滚版本</li>
<li>改的时候，本质上是加新记录， 同时把老记录标上回滚版本</li>
</ul>
<hr>
<h2><span id="q-mvcc-ji-zhi-xia-shi-me-shi-kuai-zhao-du-shi-me-shi-dang-qian-du"><strong>Q: MVCC机制下， 什么是快照读，什么是当前读？</strong></span><a href="#q-mvcc-ji-zhi-xia-shi-me-shi-kuai-zhao-du-shi-me-shi-dang-qian-du" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>快照读：对于select读操作，统一默认不加锁，使用历史版本数据。</li>
<li>当前读：对于insert、update、delete操作，仍然需要加X锁，因为涉及了数据变更，必须使用最新数据进行修改</li>
</ul>
<hr>
<h2><span id="q-na-me-hui-dao-gang-cai-de-zang-du-wen-ti-mvcc-jiu-jing-shi-zen-me-zai-du-bu-jia-suo-de-qing-kuang-xia-jie-jue-zang-du-de"><strong>Q: 那么回到刚才的脏读问题，  MVCC究竟是怎么在读不加锁的情况下， 解决脏读的？</strong></span><a href="#q-na-me-hui-dao-gang-cai-de-zang-du-wen-ti-mvcc-jiu-jing-shi-zen-me-zai-du-bu-jia-suo-de-qing-kuang-xia-jie-jue-zang-du-de" class="header-anchor">#</a></h2>
<p>A:<br>
首先，每次select都不用任何锁， 每次都是快照读，不会阻塞，因此会变成下面这样：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464042249047653-1659020780329.png" alt="image.png"></p>
<p>总结这个图，就是</p>
<ol>
<li>每次读时，会生成一个readView，用来记录当前还没提交的事务版本号。</li>
<li>根据自己事务的版本号version，去寻找小于自己当前版本且不在readView集合中的记录。</li>
</ol>
<p>这样的话就保证了读的数据必须是已经完成提交的，是不是很简单？</p>
<hr>
<h2><span id="q-ru-guo-shi-wu-b-zhong-bu-zuo-yu-e-pan-duan-zhi-chi-zhi-jie-she-zhang-kou-fei-na-shi-bu-shi-hui-dao-zhi-xian-kou-fei-ran-hou-hui-gun-cheng-0-zhe-yang-de-qing-kuang"><strong>Q: 如果事务B中不做余额判断，支持直接赊账+扣费， 那是不是会导致先扣费，然后回滚成0这样的情况？</strong></span><a href="#q-ru-guo-shi-wu-b-zhong-bu-zuo-yu-e-pan-duan-zhi-chi-zhi-jie-she-zhang-kou-fei-na-shi-bu-shi-hui-dao-zhi-xian-kou-fei-ran-hou-hui-gun-cheng-0-zhe-yang-de-qing-kuang" class="header-anchor">#</a></h2>
<p>A:<br>
不会。<br>
上面提过， MVCC中更新操作都是“当前读”，仍然需要<strong>加X锁</strong>， 且因为涉及了数据变更，必须使用<strong>最新数据版本</strong>进行修改</p>
<p>换言之， update等操作， 还是会加锁，且用最新版本更新，避免了脏更新的问题，如下：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464053974009576-1659020780335.png" alt="image.png"></p>
<hr>
<h2><span id="q-shang-mian-zhe-ge-guo-cheng-you-shi-me-yin-huan"><strong>Q: 上面这个过程有什么隐患</strong></span><a href="#q-shang-mian-zhe-ge-guo-cheng-you-shi-me-yin-huan" class="header-anchor">#</a></h2>
<p>A:<br>
如果1个事务中连续读2次余额，可能有“不可重复读”的风险，即前后读的数据发生了不一致<br>
如下所示<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464111781086895-1659020780344.png" alt="image.png"></p>
<p>因此RC隔离级别无法解决 “不可重复读的问题”</p>
<hr>
<h2><span id="q-rr-ke-chong-fu-du-repeat-read-de-ge-chi-ji-bie-you-shi-zen-me-jie-jue-shang-mian-zhe-ge-wen-ti-de"><strong>Q: RR（可重复读，Repeat Read)的隔离级别又是怎么解决上面这个问题的？</strong></span><a href="#q-rr-ke-chong-fu-du-repeat-read-de-ge-chi-ji-bie-you-shi-zen-me-jie-jue-shang-mian-zhe-ge-wen-ti-de" class="header-anchor">#</a></h2>
<p>A:<br>
本质上就是readView生成时的区别<br>
上面RC不可重复读的图中可以看到，每次读时，都取了最新的readView。 这可能导致事务A提交后， 事务B观察到的readView集合发生了变化。</p>
<p>因此RR机制改变了readView的生成方式， 每次读时只使用事务B最开始拿到的那个readView，这样永远就只取老的数据了。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464120144079067-1659020780350.png" alt="image.png"></p>
<hr>
<h2><span id="q-na-du-wen-ti-zhong-de-huan-du-you-shi-shi-me"><strong>Q: 那读问题中的幻读又是什么？</strong></span><a href="#q-na-du-wen-ti-zhong-de-huan-du-you-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
刚才的”不可重复读“，是一个事务中查询2次结果，<strong>发现值对不上</strong>。<br>
而”幻读“，是指一个事务中查询2批结果，发现这2批<strong>数量对不上</strong>，就好象发生了幻觉。<br>
就像下图所示展示：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464126365033284-1659020780356.png" alt="image.png"></p>
<hr>
<h2><span id="q-rr-ge-chi-ji-bie-zhong-de-mvcc-ji-zhi-ke-yi-jie-jue-shang-mian-de-wen-ti-ma"><strong>Q: RR隔离级别中的MVCC机制可以解决上面的问题吗？</strong></span><a href="#q-rr-ge-chi-ji-bie-zhong-de-mvcc-ji-zhi-ke-yi-jie-jue-shang-mian-de-wen-ti-ma" class="header-anchor">#</a></h2>
<p>A:<br>
可以解决。<br>
通过查询的快照读，能够保证只查询到同一批数据。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464132401059589-1659020780360.png" alt="image.png"></p>
<hr>
<h2><span id="q-na-ru-guo-xiang-xia-mian-zhe-yang-shi-wu-a-lian-xu-zuo-liang-ci-geng-xin-ni-dan-chun-kao-mvcc-neng-bi-mian-geng-xin-cao-zuo-de-huan-du-me"><strong>Q: 那如果像下面这样， 事务A连续做两次更新呢，单纯靠MVCC能避免更新操作的幻读么？</strong></span><a href="#q-na-ru-guo-xiang-xia-mian-zhe-yang-shi-wu-a-lian-xu-zuo-liang-ci-geng-xin-ni-dan-chun-kao-mvcc-neng-bi-mian-geng-xin-cao-zuo-de-huan-du-me" class="header-anchor">#</a></h2>
<p>A:<br>
如果<strong>只依靠MVCC</strong>，那就无法避免了， 因为update操作是”当前读“，每次取最新版本做更新， 这会导致update中的读操作出现幻读，前后更新的记录数量不一样了。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464140021048467-1659020780364.png" alt="image.png"></p>
<hr>
<h2><span id="q-na-shu-ju-ku-zen-me-chu-li-zhe-chong-2-ci-updete-zhong-jian-zuo-insert-de-huan-du-qing-kuang-ni"><strong>Q: 那数据库怎么处理这种2次updete中间做insert的幻读情况呢？</strong></span><a href="#q-na-shu-ju-ku-zen-me-chu-li-zhe-chong-2-ci-updete-zhong-jian-zuo-insert-de-huan-du-qing-kuang-ni" class="header-anchor">#</a></h2>
<p>A:<br>
之前有了解到， update过程仍然会加锁，</p>
<p>RR级别会启用一个叫”间隙锁“（Gap锁）的玩意，专门来防这样情况。<br>
即调用 update xxx where name ='李四’时， 不仅仅在李四的行上加锁，  更会在中间所有行的间隙、左右边界的两边，加上一个gap间隙锁，就像下面这个图一样：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464152390001303-1659020780369.png" alt="image.png"></p>
<p>可以看到，订单D的插入过程被update过程的间隙锁拦住了，于是无法插入，置到事务结束才会释放。<br>
因此事务中两次update之间的幻读是可以避免的，也能。</p>
<hr>
<h2><span id="q-na-xing-suo-jian-xi-suo-next-key-suo-shi-shi-me-qu-bie"><strong>Q: 那行锁、间隙锁、next-key锁是什么区别？</strong></span><a href="#q-na-xing-suo-jian-xi-suo-next-key-suo-shi-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A:<br>
行锁就是单个行（单个索引节点）加锁<br>
间隙锁就是在行（索引节点之间）加锁<br>
next-key就是“行锁+间隙锁”，一起使用。</p>
<hr>
<h2><span id="q-ru-guo-name-zhe-ge-zi-duan-bu-shi-suo-yin-er-shi-pu-tong-zi-duan-na-jian-xi-suo-hui-zen-me-jia"><strong>Q: 如果name这个字段不是索引，而是普通字段，那间隙锁会怎么加？</strong></span><a href="#q-ru-guo-name-zhe-ge-zi-duan-bu-shi-suo-yin-er-shi-pu-tong-zi-duan-na-jian-xi-suo-hui-zen-me-jia" class="header-anchor">#</a></h2>
<p>A:<br>
那就会给整个表的所有间隙都加上锁！<br>
因为数据库无法确认到底是哪个范围，所以干脆全加上。<br>
这就会导致整表锁住，性能很差。</p>
<hr>
<h2><span id="q-na-shi-bu-shi-zhi-yao-name-shi-suo-yin-jiu-bu-hui-gei-zheng-ge-biao-quan-jia-jian-xi-suo-liao"><strong>Q: 那是不是只要name是索引，就不会给整个表全加间隙锁了？</strong></span><a href="#q-na-shi-bu-shi-zhi-yao-name-shi-suo-yin-jiu-bu-hui-gei-zheng-ge-biao-quan-jia-jian-xi-suo-liao" class="header-anchor">#</a></h2>
<p>A:<br>
不对， 如果where条件写的有问题，不符合最左匹配原则，那也会导致索引失效， 以至于给整个表加锁。</p>
<hr>
<h2><span id="q-gang-cai-kan-dao-shuo-rr-ke-yi-jie-jue-2-ci-select-zhi-jian-de-huan-du-ye-neng-jie-jue-2-ci-update-zhi-jian-de-huan-du-na-wei-shi-me-hen-duo-zi-liao-li-reng-ran-shuo-rr-bu-neng-jie-jue-huan-du"><strong>Q:  刚才看到说RR可以解决2次select之间的幻读， 也能解决2次update之间的幻读， 那为什么很多资料里，仍然说RR不能解决幻读？</strong></span><a href="#q-gang-cai-kan-dao-shuo-rr-ke-yi-jie-jue-2-ci-select-zhi-jian-de-huan-du-ye-neng-jie-jue-2-ci-update-zhi-jian-de-huan-du-na-wei-shi-me-hen-duo-zi-liao-li-reng-ran-shuo-rr-bu-neng-jie-jue-huan-du" class="header-anchor">#</a></h2>
<p>A:<br>
这个问题我也是翻了好多资料， 终于找到了一个合理的解释。<br>
看下面这个场景：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464161376010263-1659020780370.png" alt="image.png"></p>
<p>发现什么区别没，  事务B的insert操作，发生在了事务A的update之前。因此事务B的insert操作没有被间隙锁阻塞。</p>
<p>而update用的是当前读， 于是更新的数量和 最初select的数量匹配不上了。</p>
<p>Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读，所以这个场景下，算出现幻读了。</p>
<p>这也就是下面这个图的来源：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464168471063981-1659020780375.png" alt="image.png"></p>
<hr>
<h2><span id="q-na-chuan-xing-hua-serializable-ge-chi-ji-bie-wei-shi-me-jiu-neng-bi-mian-huan-du-liao"><strong>Q: 那串行化serializable隔离级别，为什么就能避免幻读了？</strong></span><a href="#q-na-chuan-xing-hua-serializable-ge-chi-ji-bie-wei-shi-me-jiu-neng-bi-mian-huan-du-liao" class="header-anchor">#</a></h2>
<p>A:<br>
Se级别时，会从MVCC并发控制退化为基于锁的并发控制（LCBB）。<br>
不区别快照读和当前读<br>
所有的读操作都是当前读，读加读锁(S锁)，写加写锁(X锁)。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</p>
<p>这就是我们文章最开头手动加锁的那个过程了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/" class="post-title-link" itemprop="url">第303场周赛-463名-4题（pair类、var特性、双指针而不是二分）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-24 22:12:42" itemprop="dateCreated datePublished" datetime="2022-07-24T22:12:42+08:00">2022-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 00:22:32" itemprop="dateModified" datetime="2022-07-26T00:22:32+08:00">2022-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-qi-zong-jie">本期总结：</a></li>
<li><a href="#2352-xiang-deng-xing-lie-dui-https-leetcode-cn-problems-equal-row-and-column-pairs">2352. 相等行列对</a></li>
<li><a href="#2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode-https-leetcode-cn-problems-design-a-food-rating-system">2353. 设计食物评分系统 - 力扣（LeetCode）</a></li>
<li><a href="#2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode-https-leetcode-cn-problems-number-of-excellent-pairs">2354. 优质数对的数目 - 力扣（LeetCode）</a></li>
</ul>
<!-- tocstop -->
</div> 
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658763277173.png" alt="1658763277173"></p>
<p>只记录一下对我而言比较有意义的题目</p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>考虑用Pair包装而不是设计class实体类</li>
<li>var特性可以简化变量名的打印</li>
<li>双点有序(&gt;k)等问题，优先考虑用双指针而不是二分， 先确定固定哪个点，再看怎么移动，最多就4种情况。</li>
</ol>
<h2><span id="2352-xiang-deng-xing-lie-dui"></span><a href="#2352-xiang-deng-xing-lie-dui" class="header-anchor">#</a></h2>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658763341991.png" alt="1658763341991"></p>
<p>看着很简单啊，我的想法是直接对每一行搞成一个字符串， 然后做成hasMap，记录这个字符串出现的次数</p>
<p>在拿列去map里匹配即可</p>
<p>结果忘记了数字的范围是1-10^9， 并非0-9，不能直接拼，还得加逗号。痛失五分钟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">equalPairs</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ylen</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xlen</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        String[] rows = <span class="keyword">new</span> <span class="title class_">String</span>[ylen];</span><br><span class="line">        String[] cols = <span class="keyword">new</span> <span class="title class_">String</span>[xlen];</span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">                sb.append(grid[y][x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s)) &#123;</span><br><span class="line">                map.put(s, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(s).add(y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">                sb.append(grid[y][x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">                count += map.get(s).size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外java处理字符串和map问题确实比python要麻烦，如果要冲速度，我是不是得学一下python？</p>
<p>题解里的python，可以快速转数量统计的map</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalPairs</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cnt[col] <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">zip</span>(*grid))</span><br></pre></td></tr></table></figure>
<h2><span id="2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode"></span><a href="#2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode" class="header-anchor">#</a></h2>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764007681.png" alt="1658764007681"></p>
<p>很明显就是一个会更新的优先队列集合</p>
<p>需要用优先队列加一个检查更新的map实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">            String name;</span><br><span class="line">            String cuisines;</span><br><span class="line">            <span class="type">int</span> rate;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String name, String cuisines, <span class="type">int</span> rate)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.cuisines = cuisines;</span><br><span class="line">                <span class="built_in">this</span>.rate = rate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Queue&lt;Food&gt;&gt; queues;</span><br><span class="line">        Map&lt;String, Food&gt; nowFoodMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FoodRatings</span><span class="params">(String[] foods, String[] cuisines, <span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> foods.length;</span><br><span class="line">            queues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">                <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(foods[i], cuisines[i], ratings[i]);</span><br><span class="line">                nowFoodMap.put(foods[i], food);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!queues.containsKey(cuisines[i])) &#123;</span><br><span class="line">                    queues.put(cuisines[i], <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(</span><br><span class="line">                            a.rate != b.rate ? (b.rate - a.rate): (a.name.compareTo(b.name)))));</span><br><span class="line">                &#125;</span><br><span class="line">                queues.get(cuisines[i]).offer(food);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeRating</span><span class="params">(String food, <span class="type">int</span> newRating)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cu</span> <span class="operator">=</span> nowFoodMap.get(food).cuisines;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(food, cu, newRating);</span><br><span class="line">            nowFoodMap.put(food, food1);</span><br><span class="line">            queues.get(cu).offer(food1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">highestRated</span><span class="params">(String cuisine)</span> &#123;</span><br><span class="line">            Queue&lt;Food&gt; queue = queues.get(cuisine);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (food != nowFoodMap.get(food.name)) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> food.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FoodRatings object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);</span></span><br><span class="line"><span class="comment"> * obj.changeRating(food,newRating);</span></span><br><span class="line"><span class="comment"> * String param_2 = obj.highestRated(cuisine);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>但是定义类的时候比较麻烦，后面可以考虑以下的效率优化：</p>
<ol>
<li>
<p>用Pair做二元组，避免定义内部类麻烦</p>
</li>
<li>
<p>用var避免定义变量类型</p>
</li>
</ol>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764157594.png" alt="1658764157594"></p>
<h2><span id="2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode"></span><a href="#2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode" class="header-anchor">#</a></h2>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764316137.png" alt="1658764316137"></p>
<p>其实这个脑筋急转弯通过纸上推演，很快能得到</p>
<p><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的1的个数，等同于num1和num2中1的个数总和</p>
<p>就变成就一个数组中，a[x] + a[y]共有多少对</p>
<p>这个子问题的解法我想复杂了，竟然想到用二分法。。。又因为很久没写了，对二分不熟了，导致浪费了大量时间确认二分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countExcellentPairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = Arrays.stream(nums).mapToObj(Integer::valueOf).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ontCounts = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span>[] newNums = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : set) &#123;</span><br><span class="line">            newNums[t++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = newNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            ontCounts[i] = Integer.bitCount(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ontCounts);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oneCount</span> <span class="operator">=</span> ontCounts[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">needOneCount</span> <span class="operator">=</span> k - oneCount;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  left + (right - left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ontCounts[mid] &lt; needOneCount) &#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ontCounts[mid] &gt;= needOneCount)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> right;</span><br><span class="line">            result += Math.max(<span class="number">0</span>, ontCounts.length - select);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比二分要更快速的可能是用双指针求解这类问题</p>
<p>但是双指针的方向可能要好好想想</p>
<p>即2个指针哪个优先固定， 再移动哪个，哪个方向移动</p>
<p>这题需要left=0, right=length， 固定住left， 让right移动找到一个位置后，right右边的所有点和left想家肯定都满足&gt; k</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ontCounts.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;left&lt;ontCounts.length;left++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt;=<span class="number">0</span> &amp;&amp; ontCounts[left] + ontCounts[right] &gt;= k) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    result += (ontCounts.length - <span class="number">1</span> - right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共205.5k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
