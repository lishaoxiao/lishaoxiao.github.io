<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="破晓的知识屋">
<meta property="og:url" content="http://breakdawncoder.com/page/8/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-20 23:12:42" itemprop="dateCreated datePublished" datetime="2022-09-20T23:12:42+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 00:10:51" itemprop="dateModified" datetime="2022-09-21T00:10:51+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#1-4-de-si-kao-tao-lu">1+4的思考套路</a>
<ul>
<li><a href="#jian-dan-li-zi">简单例子</a>
<ul>
<li><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</a></li>
<li><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</a></li>
<li><a href="#ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</a></li>
<li><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</a></li>
<li><a href="#bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</a></li>
<li><a href="#shi-xian">实现</a></li>
</ul>
</li>
<li><a href="#jin-jie-ban-er-wei-de-dong-tai-gui-hua">进阶版，二维的动态规划</a>
<ul>
<li><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi-1">①在超时的思路上写出一组计算过程的例子</a></li>
<li><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang-1">②在超时例子的基础上，有哪些重复、浪费的地方？</a></li>
<li><a href="#ru-he-ding-yi-dp-shu-zu-1">③如何定义dp数组？</a></li>
<li><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de-1">④状态的变化方向是什么，是怎么变化的</a></li>
<li><a href="#bian-jie-zhuang-tai-shi-shi-me-1">⑤边界状态是什么？</a></li>
<li><a href="#shi-xian-1">实现</a></li>
<li><a href="#nei-cun-yi-chu-chu-li">内存溢出处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#qi-ta-lei-si-ti-mu-lian-xi">其他类似题目练习</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>以后不定期更新一些算法方便自己的思考和总结。</p>
<hr>
<p>平时练习算法题学习算法知识时，经常会发现题解里写着“动态规划”，里面一上来就是一个复杂的dp公式，对于新人来说除了说声<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(144).png" alt="image.png"></p>
<p>剩下就是疑惑，他是怎么想到这个公式的？我能想到吗？这玩意工作中有用吗？<br>
加上“动态规划”这高端的名字，然后就劝退了不少试图去理解他的人。<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(145).png" alt="image.png"></p>
<p>动态规划听起来太吓人，可以换个说法</p>
<p>我在内心更喜欢叫他“状态缓存”<br>
如果是服务开发，相信很熟悉这个词语， 利用缓存来加快一些重复的请求的响应速度。<br>
而这个缓存的特点是 <em><strong>和其他缓存有所关联。</strong></em></p>
<p>比如我们的服务要计算7天内的某金钱总和，计算后要缓存一下。<br>
后来又收到一个请求，要计算8天内的金钱总和<br>
那我们只需要取之前算过的7天内的金钱综合，加上第8天的金钱就行了。</p>
<h1><span id="1-4-de-si-kao-tao-lu">1+4的思考套路</span><a href="#1-4-de-si-kao-tao-lu" class="header-anchor">#</a></h1>
<p>自己针对动态规划总结了一个自己的思考套路，我叫他1组例子4个问题，就叫1+4好了，通过这5个过程，可以站在普通人的角度（就是非acm大佬那种的角度），去理解动态规划是如何被思考出来的</p>
<ul>
<li>在超时的思路上写出一组计算过程的例子</li>
<li>在超时例子的基础上，有哪些重复、浪费的地方？</li>
<li>如何定义dp数组</li>
<li>状态的变化方向是什么，是怎么变化的</li>
<li>边界状态是什么</li>
</ul>
<h2><span id="jian-dan-li-zi">简单例子</span><a href="#jian-dan-li-zi" class="header-anchor">#</a></h2>
<p>以一道简单题为例：<br>
爬楼梯：<br>
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(146).png" alt="image.png"></p>
<p>这时候就要静下心，观察这个解法的例子中是否有重复经历的场景，而这个重复经历的场景就叫状态。<br>
我处理动态规划的题目时， 都会问自己3个问题，一般就能顺利地解决。</p>
<h3><span id="zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</span><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi" class="header-anchor">#</a></h3>
<p>如果我们考虑最简单的解法，  就是从起点开始，每次选择走1步或者走2步，看下能否走到终点，能走到则方法数+1。<br>
但这种方法注定超时（O（n^2)）<br>
但我还是照着这个过程模拟了一下，随便列了几个<br>
1 -&gt;2-&gt; 3-&gt; 4-&gt; 5<br>
1 -&gt;2 -&gt;3-&gt; 5<br>
1-&gt;3-&gt;4-&gt;5<br>
1-&gt;3-&gt;5</p>
<h3><span id="zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</span><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang" class="header-anchor">#</a></h3>
<p>在上面，我发现了重复的地方<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(147).png" alt="image.png"></p>
<p>也就是说<br>
从3到5总共就2种路线，已经在1-&gt;2之后计算过了，我后面从1走到3再往后走时，没必要再去算了。<br>
换言之，当我走到3的时候，其实早就可以知道后面还剩下多少种走法。<br>
发现重复的地方后，就可以开始建立dp公式了。</p>
<h3><span id="ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</span><a href="#ru-he-ding-yi-dp-shu-zu" class="header-anchor">#</a></h3>
<p>定义dp数组，也就是定义上面提到的重复的地方。重新看下之前的那句话<br>
当我走到3的时候，其实早就可以知道后面还剩下多少种走法。<br>
所以dp[3]代表的就是从3往后，有多少种可走的方法。</p>
<h3><span id="zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</span><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de" class="header-anchor">#</a></h3>
<ul>
<li>首先思考状态的变化方向<br>
重新看这句话：</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>当我走到3的时候，其实早就可以知道后面还剩下多少种走法</p>
</blockquote>
</blockquote>
</blockquote>
<p>说明结果取决于往 <em><strong>后面</strong></em> 的状态<br>
因此我们要先计算后面的状态, 即从后往前算</p>
<ul>
<li>接着思考这个后面的状态和当前的状态有什么联系，是怎么变化的</li>
</ul>
<p>这个一般都包含在题目条件中<br>
根据题意，要么走2步，要么走1步，因此每当我走到一层时，下一次就2种状态可以变化。<br>
那么对于第3层而言，他后续有2种走法，走1步或者走2步<br>
那么他的情况就是dp[3] = dp[3+1] + dp{3+2}<br>
如果层数设为i，那么这个变化情况就是<br>
dp[i] = dp[i+1] + dp[i+2]</p>
<h3><span id="bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</span><a href="#bian-jie-zhuang-tai-shi-shi-me" class="header-anchor">#</a></h3>
<p>边界状态就是不需要依赖后面的状态了，直接可以得到结果的状态。<br>
在这里肯定就是最后一层dp[n]， 最后一层默认是一种走法。 dp[n]=1</p>
<h3><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h3>
<p>根据上面的过程，自己便定义了这个状态和变化</p>
<ul>
<li>定义：dp[i] :  代表从第i层往后，有多少种走法</li>
<li>方向和变化：dp[i] =  dp[i+1] + dp[i+2];</li>
<li>边界:  dp[n] = 1<br>
根据这个写代码就很容易了<br>
代码：</li>
</ul>
<pre><code class="language-java">    public int climbStairs(int n) &#123;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n-1] = 1;
        for(int i = n-2; i &gt;=0;i--) &#123;
            dp[i] = dp[i+1] + dp[i+2];
        &#125;
        return dp[0];
    &#125;
</code></pre>
<h2><span id="jin-jie-ban-er-wei-de-dong-tai-gui-hua">进阶版，二维的动态规划</span><a href="#jin-jie-ban-er-wei-de-dong-tai-gui-hua" class="header-anchor">#</a></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/</a></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(148).png" alt="image.png"></p>
<h3><span id="zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</span><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi" class="header-anchor">#</a></h3>
<p>超时的思路肯定是像搜索一样模拟所有的行走过程。<br>
先假设1个steps=5, arrlen=3的情况<br>
随便先列几个。模拟一下不断走的位置。数字指的是当前位置。<br>
0-&gt;1-&gt;2-&gt;1-&gt;0-&gt;0<br>
0-&gt;1-&gt;2-&gt;1-&gt;1-&gt;0<br>
0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0<br>
0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;0<br>
0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0<br>
……</p>
<h3><span id="zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</span><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang" class="header-anchor">#</a></h3>
<p>0-&gt;1-&gt;2-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
0-&gt;1-&gt;2-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;1-&gt;1-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;1-&gt;1-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
0-&gt;0-&gt;1-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;0-&gt;1-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
我发现这部分标粗的部分重复了，<br>
换句话说<br>
当我还剩2步且当前位置为1的时候，后面还有多少种走法，其实早就知道了。</p>
<h3><span id="ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</span><a href="#ru-he-ding-yi-dp-shu-zu" class="header-anchor">#</a></h3>
<p>重新看这句话：</p>
<blockquote>
<blockquote>
<blockquote>
<p>当我还剩2步且当前位置为1的时候，后面还有多少种走法，其实早就知道了。</p>
</blockquote>
</blockquote>
</blockquote>
<p>涉及了2个关键因素: 剩余步数和当前值，所以得用二维数组<br>
因此<br>
dp[realstep][index]<br>
就代表了  剩余步数为step且位置为index时， 后续还剩多少种走法。</p>
<h3><span id="zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</span><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de" class="header-anchor">#</a></h3>
<ul>
<li>先思考变化方向<br>
“当我还剩2步且当前位置为1的时候，<em><strong>后面</strong></em> 还有多少种走法，其实早就知道了。”</li>
</ul>
<p>这个后面是指啥， 后面会怎么变?<br>
后面肯定是步数越来越少的情况， 并且位置会根据规律变化。 所以变化方向是步数变少，位置则按照规定去变。<br>
那么这个固定越来越少的这个“剩余步数”，就是核心的变化方向<br>
我们计算时，可以先计算小的剩余步数的状态， 再去算大的剩余步数。</p>
<ul>
<li>如何变化<br>
根据题意和方向，剩余步数肯定-1，  然后位置有3种选择（减1，不变，加1）， 那么方法就是3种选择的相加<br>
dp[step][index] = dp[step-1][index-1] + dp[step-1][index] + dp[step-1][index+1]</li>
</ul>
<h3><span id="bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</span><a href="#bian-jie-zhuang-tai-shi-shi-me" class="header-anchor">#</a></h3>
<p>剩余步数为0时，只有当前位置为0才是我们最终想要的方案，把值设为1并提供给后面用，其他位置且步数为0时都认为是0。<br>
dp[0][0] = 1；<br>
dp[0][index] = 0；（index&gt;0)</p>
<h3><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h3>
<p>那么最终出来了</p>
<ul>
<li>定义：dp{realstep][index]:    剩余步数为step且位置为index时， 后续还剩多少种走法。</li>
<li>方向和变化：dp[step][index] = dp[step-1][index-1] + dp[step-1][index] + dp[step-1][index+1]</li>
<li>边界:  dp[0][0] = 1；</li>
</ul>
<h3><span id="nei-cun-yi-chu-chu-li">内存溢出处理</span><a href="#nei-cun-yi-chu-chu-li" class="header-anchor">#</a></h3>
<p>不过这题因为是困难题，所以给上面这个公式设立了一个小难度：<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(149).png" alt="image.png"></p>
<p>数组长度非常大，导致如果index的范围我们选择为0~arrLen-1, 那么最大情况dp[500][10^6]注定超时内存范围。<br>
这时候就要去思考index设那么大是不是没必要<br>
一般我们可以自己列这种情况的小例子，例如<br>
step=2, arr=10<br>
然后看下index有没有必要设成0~9，随便走几步<br>
0-&gt;1-&gt;0<br>
0-&gt;1-&gt;0<br>
0-&gt;0-&gt;0<br>
嗯？我发现就3种情况，arr后面那么长不用啦？<br>
于是发现规律：<br>
剩余的步数，必须支撑他返回原点！<br>
也就是说，其实index的最大范围最多就是step/2， 不能再多了，再多肯定回不去了。<br>
于是问题解决。</p>
<h1><span id="qi-ta-lei-si-ti-mu-lian-xi">其他类似题目练习</span><a href="#qi-ta-lei-si-ti-mu-lian-xi" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/">https://leetcode-cn.com/problems/minimum-cost-for-tickets/</a></p>
<hr>
<p>状态压缩的位dp，尽量从0往上更新，往后面看而不是往前面看</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集 - 力扣（LeetCode）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">微服务心跳管理机制设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 23:40:12 / 修改时间：23:25:44" itemprop="dateCreated datePublished" datetime="2022-09-19T23:40:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</a>
<ul>
<li><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</a></li>
<li><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</a></li>
<li><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</a></li>
<li><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</a></li>
</ul>
</li>
<li><a href="#ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</a>
<ul>
<li><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</a></li>
<li><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>笔记来源：<br>
<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/240656">实战：单机如何实现管理百万主机的心跳服务</a></p>
<h1><span id="ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</span><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu" class="header-anchor">#</a></h1>
<h2><span id="1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</span><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi" class="header-anchor">#</a></h2>
<p>全部遍历找超时，O(n)， 百万级别节点消耗非常大，   遍历时可能会因为涉及更新的同步问题， 导致此时无法插入。<br>
如果用单线程，这个过程慢的话会造成阻塞。</p>
<p>实现方式1： LRU+链表+哈希表<br>
① 所有心跳放进一个LRU队列中，保证最新的心跳包在队尾，最老的心跳包在队头。<br>
② 如果某节点有新的心跳包进来， 利用哈希表找到这个节点的链点位置，删除掉，再将新包插入到队尾。<br>
③ 每次心跳检查时， 只要查询队头， 不断将超时的心跳包出队，直到队头的心跳包不超时即可。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/ee76fb4d7bfd65d2190dbadd7760c7f312f74079.png" alt="ee76fb4d7bfd65d2190dbadd7760c7f312f74079"><br>
实现方式2： 时间轮，时间轮的做法见最后</p>
<h2><span id="2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</span><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing" class="header-anchor">#</a></h2>
<p>上面提到的心跳检查都在内存中，  心跳检查节点如果只有1个的话不可靠，而且量级也会很大。<br>
但又不能落盘，这会导致数据库的并发查询压力很大，且数据库自身的可靠性又会成了问题。</p>
<p>解决方式：<br>
分布式处理。<br>
心跳入口网关 根据节点的ip或者节点id做哈希， 确保相同节点的心跳包发往同一个节点。<br>
如果网关发现某个节点挂了，利用哈希一致算法更新发送的节点即可。</p>
<h2><span id="3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</span><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng" class="header-anchor">#</a></h2>
<p>收到心跳后， 涉及心跳的解包，LRU+哈希更新，需要提升处理性能。</p>
<p>①  多线程处理， 同样利用上面的方法做哈希，分配到特定的心跳处理线程，不同线程之间处理的节点信息不会互相干扰。</p>
<blockquote>
<blockquote>
<p>注意点：  缓存队列放到各自的工作线程中。 即push而非pull的方式，尽可能避免N之间的竞争，即只做1+1的竞争。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8.png" alt="68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8"><br>
队列锁采用自旋锁，避免工作线程频繁出现上下文切换（即保证工作线程一直在跑，这个用于高并发场景，高并发场景不能让他停下来的）</p>
</blockquote>
</blockquote>
<p>② 心跳包资源池减少内存释放频率<br>
如果只有10w个节点，那么每次收到心跳请求时，不要反复new新的心跳对象，而是从心跳资源池里取出构造好的对象，把最新时间set进去后再扔给分发线程。</p>
<h2><span id="4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</span><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp" class="header-anchor">#</a></h2>
<p>满足以下条件的话选择UDP:</p>
<ol>
<li>心跳包报文长度内容信息量很少，基本小于MTU， 不需要利用TCP自带的分包机制。</li>
<li>超时判断时间允许偶然一次的不可靠丢包（即偶尔丢一次并不影响）</li>
</ol>
<p>这种情况用UDP在网内发到心跳服务即可。<br>
不需要TCP那样的高消耗。</p>
<h1><span id="ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</span><a href="#ling-yi-ge-fang-shi-shi-jian-lun" class="header-anchor">#</a></h1>
<p>参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0f0fec47a0ad">TimingWheel 时间轮详解</a></p>
<p>时间轮本质：</p>
<ol>
<li>弄一个数组（看起来是一个环，实际上是数组）</li>
<li>数组中中每个节点又存了一个双向链表，用于存放实际的任务（用链表是为了方便插入）</li>
<li>任务具体放数组中的哪个位置？  根据 超期时间取余决定他的实际存放位置。</li>
<li>如果数组的节点中有任务，会把本身的超期时间带着一起扔进一个 队列中</li>
<li>队列每次取队头数据， 如果时间没到队头节点指定的延迟时间，就阻塞，直到时间到达，取出里面的任务逐个执行。</li>
<li>如果任务的定时时间超过整个环的时间？  则新增一个时间轮，时间比这个更长，因此队列里可能会多插入一个节点，节点中会标识我是小时间轮还是大时间轮的。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/2e95b497a970bc8baad42f25d6dee04d0241a079.png" alt="2e95b497a970bc8baad42f25d6dee04d0241a079"></li>
</ol>
<hr>
<p>其他的延时队列怎么做的?<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/woniu211111/article/details/109302412">延时队列实现的几种姿势</a></p>
<hr>
<h2><span id="q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</span><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>有一个优先队列， 放入的任务会根据是否快要超期进行排序， 马上就要超期的会放在队头。</li>
<li>当使用take方法取数据时，看一下队头任务，如果时间到了就返回。</li>
<li>如果时间还没到</li>
</ol>
<ul>
<li>首先看一下是否已经有线程在等待这个任务了，如果是的话，使用锁的condition机制做await等待。</li>
<li>如果没有线程正在等待，就计算还差多少时间， 然后用 LockSupport.parkNanos()让这个调用take方法的线程等待特定时间。</li>
</ul>
<ol start="4">
<li>注意等待期间，会释放锁，因此这期间可以正常offer和take。</li>
<li>当时间到了后，这个线程肯定能取走数据了。  取完后，顺便看一下队列里还有没有数据，如果有， 调用condition.signal()，通知那堆正在等待的线程， 你们可以试着竞争一下取数据了。</li>
<li>另外每当有新的任务offer时，如果发现最新入队的数据就是马上要超期的数据， 也会立刻通知等待的各位马上苏醒竞争（因为之前等待的线程认为自己还要睡一会才会有数据）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/105716205">Java阻塞延迟队列DelayQueue原理及使用</a></p>
<hr>
<h2><span id="q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</span><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A:<br>
java的delayQueue本质上是用堆（优先队列）实现的。<br>
接收任务后， 直接把任务放进优先队列中， 按照超期时间确定堆位置。  每次poll时如果发现堆顶没到时间就阻塞，直到时间到了再poll。<br>
取出来检查后，再加上时间扔回队列。</p>
<p>坏处： 插入和删除的复杂度是O(logn)。</p>
<p>而时间轮并不会把任务扔进 queue中，而是把时间轮的槽扔进queue中。  因此整个延迟队列实际上时针对槽的，不需要堆，按先入先出取数据和插槽即可，O(1)的复杂度。  而后面扔进来的任务，都是往槽里的双向链表塞进去而已。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">服务缓存设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 23:10:12 / 修改时间：23:26:01" itemprop="dateCreated datePublished" datetime="2022-09-19T23:10:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-di-huan-cun">本地缓存</a>
<ul>
<li><a href="#q-shi-me-shi-ben-di-huan-cun">Q: 什么是本地缓存？</a></li>
<li><a href="#q-you-na-xie-ben-di-huan-cun-chan-pin">Q: 有哪些本地缓存产品？</a></li>
<li><a href="#q-ben-di-huan-cun-you-shi-me-que-dian">Q: 本地缓存有什么缺点？</a></li>
<li><a href="#q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi">Q: 本地缓存有哪些更新方式？</a></li>
<li><a href="#q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang">Q: 被动更新本地缓存有什么要注意的地方？</a></li>
<li><a href="#q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu">Q: 什么是off-heap技术？有什么好处</a></li>
<li><a href="#q-zen-me-shi-yong-off-heap">Q: 怎么使用off-heap？</a></li>
<li><a href="#q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma">Q: directByteBuffer的内存什么时候会被释放？ 需要自己写C++代码释放吗？</a></li>
</ul>
</li>
<li><a href="#fen-bu-shi-huan-cun">分布式缓存</a>
<ul>
<li><a href="#q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de">Q: 一致性哈希是做什么的？</a></li>
<li><a href="#q-fen-cao-suan-fa-shi-shi-me">Q: 分槽算法是什么？</a></li>
<li><a href="#q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi">Q: 缓存穿透是什么?解决方式是？</a></li>
<li><a href="#q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng">Q: 要是分布式缓存发生雪崩了怎么办，要怎么防止发生</a></li>
<li><a href="#q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue">Q: 几十万的用户同时访问某个数据，但这个数据正好缓存里没有，导致十几万的请求打到数据库上，这种情况叫做什么？怎么解决？</a></li>
<li><a href="#q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai">Q: 缓存过多时，如何进行筛选和淘汰？</a></li>
</ul>
</li>
<li><a href="#huan-cun-re-dian">缓存热点</a>
<ul>
<li><a href="#q-shi-me-shi-re-dian-key-wen-ti">Q: 什么是热点Key问题？</a></li>
<li><a href="#q-ru-he-fa-xian-re-dian">Q: 如何发现热点？</a></li>
<li><a href="#q-ru-he-jie-jue-re-dian-wen-ti">Q: 如何解决热点问题？</a></li>
<li><a href="#q-ru-he-shan-chu-re-dian">Q: 如何删除热点？</a></li>
<li><a href="#q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong">Q: 如何利用redis 实现秒杀系统？</a></li>
</ul>
</li>
<li><a href="#shu-ju-yi-zhi-xing">数据一致性</a>
<ul>
<li><a href="#q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti">Q: 当需要删除数据时， 如果我先删缓存，再删数据库，可能会有什么问题？</a></li>
<li><a href="#q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me">Q: 网络通信正常、命令正常的情况下， 先删库 ，再删缓存， 还是有可能造成脏数据， 知道为什么么？</a></li>
<li><a href="#q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao">Q: 如果删了库之后， 再删缓存的途中，网络临时不通怎么办？那缓存也有可能一直脏着了。</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="ben-di-huan-cun">本地缓存</span><a href="#ben-di-huan-cun" class="header-anchor">#</a></h1>
<h2><span id="q-shi-me-shi-ben-di-huan-cun">Q:  什么是本地缓存？</span><a href="#q-shi-me-shi-ben-di-huan-cun" class="header-anchor">#</a></h2>
<p>A:<br>
即在客户端、应用端进行本地缓存， 或在jvm中缓存或在程序的堆外缓存。中间没有跨网络的开销</p>
<hr>
<h2><span id="q-you-na-xie-ben-di-huan-cun-chan-pin">Q: 有哪些本地缓存产品？</span><a href="#q-you-na-xie-ben-di-huan-cun-chan-pin" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>Ehcache(Hibernate的二级缓存就用的这个）</li>
<li>GuavaCache（轻量，易用，有丰富的被动更新机制）</li>
<li>MapDb(支持堆外内存）</li>
</ul>
<hr>
<h2><span id="q-ben-di-huan-cun-you-shi-me-que-dian">Q: 本地缓存有什么缺点？</span><a href="#q-ben-di-huan-cun-you-shi-me-que-dian" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>本地缓存会占用jvm有限的内存资源</li>
<li>高潮gc次数过快可能会导致贤者时间（stopworld）的延长。</li>
<li>只在本地缓存， 容易引发数据不同步。</li>
</ul>
<hr>
<h2><span id="q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi">Q: 本地缓存有哪些更新方式？</span><a href="#q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>被动更新<br>
通过自己设置的超时时间， 超期后就自动进行更新，更新就是去重新发请求获取。。</li>
<li>主动更新<br>
数据发生变更，主动通过消息队列的方式同步给订阅的应用（适用于内部服务配置订阅），应用进行更新。</li>
</ul>
<hr>
<h2><span id="q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang">Q: 被动更新本地缓存有什么要注意的地方？</span><a href="#q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang" class="header-anchor">#</a></h2>
<p>A:<br>
如果同时失效的缓存很多，  需要控制更新时的线程必须只有1个， 如果支持同时触发多个线程进行请求更新，可能导致大量请求打到分布式缓存上引发雪崩。<br>
两种方式：</p>
<ol>
<li>expireAfterWrite，   各超期的缓存起线程准备发请求时，需要先抢到锁，抢到了才能发，否则就阻塞（对性能要求不高可以选这个）</li>
<li>refreshAfterWrite，  也是抢锁，区别是如果抢不到，就返回旧值，等下次超期再抢。 （ 数据实时性要求不高的情况下可以选择这个）</li>
</ol>
<hr>
<h2><span id="q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu">Q: 什么是off-heap技术？有什么好处</span><a href="#q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu" class="header-anchor">#</a></h2>
<p>A:<br>
堆外内存技术， 将数据存在jvm外的操作系统内存上，避免和原jvm进程互相干扰，因此也不会参与垃圾收集器gc。<br>
好处：</p>
<ul>
<li>减少gc次数</li>
<li>扩展和使用更大的内存空间</li>
<li>省去了物理内存和heap进程内存之间的数据复制步骤，类似于零拷贝了。</li>
</ul>
<hr>
<h2><span id="q-zen-me-shi-yong-off-heap">Q: 怎么使用off-heap？</span><a href="#q-zen-me-shi-yong-off-heap" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>NIO有个ByteBuffer.allocateDirect(int capacity)方法， 可以生成一个DirectByteBuffer实例</li>
<li>根据参数capacity的值，它会在物理内存中分配一块固定大小的直接字节缓冲区。</li>
<li>本质上是调用sum.misc.unsafe里实现的native方法进行内存分配操作。</li>
<li>可用-XX：MaxDirectMemorySize限制总的最大堆外申请大小，避免申请过多。</li>
</ul>
<hr>
<h2><span id="q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma">Q: directByteBuffer的内存什么时候会被释放？ 需要自己写C++代码释放吗？</span><a href="#q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不需要。   directByteBuffer在jvm中仍然是段引用，只不过buffer数据存到堆外了。 当这个buffer引用被回收了， 那么buffer背后的堆外内存也会被回收。</p>
<h1><span id="fen-bu-shi-huan-cun">分布式缓存</span><a href="#fen-bu-shi-huan-cun" class="header-anchor">#</a></h1>
<hr>
<h2><span id="q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de">Q:  一致性哈希是做什么的？</span><a href="#q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de" class="header-anchor">#</a></h2>
<p>A:<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42046105/article/details/92802476">https://blog.csdn.net/qq_42046105/article/details/92802476</a><br>
普通的哈希表算法一般都是计算出哈希值后，通过取余操作将 key 值映射到不同的服务器上<br>
但是当服务器数量发生变化时，取余操作的除数发生变化，所有 key 所映射的服务器几乎都会改变，这对分布式缓存系统来说是不可以接收的。<br>
一致性哈希算法能尽可能减少了服务器数量变化所导致的缓存迁移。</p>
<p>以分布式缓存场景为例，分析一下一致性哈希算法环的原理。<br>
首先将缓存服务器（ ip + 端口号）进行哈希，映射成环上的一个节点，计算出缓存数据 key 值的 hash key，同样映射到环上，并顺时针选取最近的一个服务器节点作为该缓存应该存储的服务器。具体实现见后续的章节。</p>
<p><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/b64d1b6633bdfe624e578751aadc21f0ea591b65.png" alt="b64d1b6633bdfe624e578751aadc21f0ea591b65"><br>
服务器 B 宕机下线，服务器 B 中存储的缓存数据要进行迁移，但由于一致性哈希环的存在，只需要迁移key 值为1的数据，其他的数据的存储服务器不会发生变化。这也是一致性哈希算法比取余映射算法出色的地方。<br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/9aac123b97d816fed485a1c96c572f008eb025b1.png" alt="9aac123b97d816fed485a1c96c572f008eb025b1"></p>
<p>现实情况下，服务器在一致性哈希环上的位置不可能分布的这么均匀，导致了每个节点实际占据环上的区间大小不一。</p>
<p>这种情况下，可以增加虚节点来解决。通过增加虚节点（即A节点实际对应好几个虚节点），使得每个节点在环上所“管辖”的区域更加均匀。</p>
<p>这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。</p>
<hr>
<h2><span id="q-fen-cao-suan-fa-shi-shi-me">Q: 分槽算法是什么？</span><a href="#q-fen-cao-suan-fa-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
在redis官方给出的集群方案中，数据的分配是按照槽位来进行分配的，每一个数据的键被哈希函数映射到一个槽位，redis-3.0.0规定一共有16384个槽位，当然这个可以根据用户的喜好进行配置。当用户put或者是get一个数据的时候，首先会查找这个数据对应的槽位是多少，然后查找对应的节点，然后才把数据放入这个节点。这样就做到了把数据均匀的分配到集群中的每一个节点上，从而做到了每一个节点的负载均衡，充分发挥了集群的威力。</p>
<p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p>
<ul>
<li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</li>
<li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；<br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/5bf0eef7aafe6e5eeb4da6d74b7ba2fa37bbefa2.png" alt="5bf0eef7aafe6e5eeb4da6d74b7ba2fa37bbefa2"><br>
<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4163916a2a8a">一致性哈希和分槽算法</a></li>
</ul>
<hr>
<h2><span id="q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi">Q: 缓存穿透是什么?解决方式是？</span><a href="#q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi" class="header-anchor">#</a></h2>
<p>A:<br>
大量不存在的请求攻入，反复去查询数据库<br>
对于不存在的数据，可以用布隆过滤器（对1个值做多个不同的哈希，放入不同的位图位置里，  后面计算的时候，看下是否有1个位置没满足，没满足就一定不存在）</p>
<hr>
<p>Q:  缓存中的布隆过滤器是什么？</p>
<p>A:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fouy_yun/article/details/81075432">回答1</a><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38080318/article/details/106207978?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control404&amp;depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control40">回答2</a><br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1663600837395.png" alt="1663600837395"></p>
<hr>
<hr>
<h2><span id="q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng">Q: 要是分布式缓存发生雪崩了怎么办，要怎么防止发生</span><a href="#q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng" class="header-anchor">#</a></h2>
<p>A:<br>
缓存雪崩可能是因为数据未加载到缓存中，或者一大堆缓存在同一时间大面积的失效过期，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</p>
<p>解决方式：</p>
<ul>
<li>
<p>缓存失效可以通过加锁或队列来控制读取数据库的访问的线程数量，比如对某个key值运行一个线程访问数据库，其他线程等待</p>
</li>
<li>
<p>不同的key，设置不同的过期时间，让失效的时间点尽量均匀或者随机，避免一下子大面积失效。</p>
</li>
<li>
<p>做二级缓存，a1失效时候，访问a2，a1失效的时间设置为短期，a2为长期</p>
</li>
</ul>
<hr>
<h2><span id="q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue">Q: 几十万的用户同时访问某个数据，但这个数据正好缓存里没有，导致十几万的请求打到数据库上，这种情况叫做什么？怎么解决？</span><a href="#q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue" class="header-anchor">#</a></h2>
<p>A:<br>
这种情况叫做  ”缓存击穿“。</p>
<ol>
<li>延长热点数据的缓存超期时间。 提前预置热点缓存。</li>
<li>接口限流、降级、队列。</li>
</ol>
<hr>
<h2><span id="q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai">Q: 缓存过多时，如何进行筛选和淘汰？</span><a href="#q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai" class="header-anchor">#</a></h2>
<p>A:</p>
<p>没啥人用的数据占用了很多内存，叫缓存污染</p>
<p>Redis共支持八种淘汰策略。</p>
<ul>
<li>第一类： 不淘汰</li>
</ul>
<ol>
<li>noeviction<br>
如果满了，新的写请求就报错</li>
</ol>
<ul>
<li>第二类：淘汰部分过期数据<br>
当缓存满却收到新的写请求时，从会过期数据中选一个淘汰。</li>
</ul>
<ol start="2">
<li>volatile-random 随机删除过期数据中的某一个</li>
<li>volatile-ttl： 越早过期的数据，越优先被删除</li>
<li>volatile-lru：局部最近最少使用（即过期数据中一直没被用过的，优先删）。<br>
特点是会从集合中随机选N个，从N个里选一个LRU最小的删除。<br>
好处：Redis不用维护一个巨大的链表，也不用操作链表，进而提升性能</li>
<li>volatile-lfu：<br>
增加了访问次数<br>
先在过期集合中判断访问次数，再判断LRU时间、</li>
</ol>
<ul>
<li>第三类：全部数据可能都被淘汰</li>
</ul>
<ol start="6">
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>allkeys-lfu<br>
和volatile的处理一样，区别是 ”所有缓存“ 而非”部分过期缓存“</li>
</ol>
<h1><span id="huan-cun-re-dian">缓存热点</span><a href="#huan-cun-re-dian" class="header-anchor">#</a></h1>
<h2><span id="q-shi-me-shi-re-dian-key-wen-ti">Q: 什么是热点Key问题？</span><a href="#q-shi-me-shi-re-dian-key-wen-ti" class="header-anchor">#</a></h2>
<p>A:<br>
热点问题产生的原因大致有以下两种：</p>
<p>用户消费的数据远大于生产的数据（热卖商品、热点新闻、热点评论、明星直播）。<br>
在日常工作生活中一些突发的的事件，被大量刊发、浏览的热点新闻、热点评论、明星直播等，这些典型的读多写少的场景会产生热点问题。<br>
危害：</p>
<ul>
<li>请求分片集中，超过单Server的性能极限。</li>
<li>在服务端读数据进行访问时，往往会对数据进行分片切分，此过程中会在某一主机Server上对相应的Key进行访问，当访问超过Server极限时，就会导致热点Key问题的产生。</li>
<li>流量集中，达到物理网卡上限。</li>
<li>请求过多，缓存分片服务被打垮。</li>
<li>DB击穿，引起业务雪崩。</li>
</ul>
<hr>
<h2><span id="q-ru-he-fa-xian-re-dian">Q:  如何发现热点？</span><a href="#q-ru-he-fa-xian-re-dian" class="header-anchor">#</a></h2>
<ol>
<li>最简单的方式，是提前配置热点key，需要运营人员提供相关数据。</li>
<li>或者搭建有自身业务特点的热点自动发现平台， 通过分析日志得到热点key，及时更新热点保护。</li>
<li>client-&gt;Proxy-&gt;redis的proxy层做收集上报，其实类似于上面的自动发现收集。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/liu15835467265liu/article/details/103746821/">发现动态热点数据</a><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/cxy_19891109/article/details/87480515">秒杀系统之发现动态热点数据</a></li>
<li>redis自身有个monitor命令， 可以抓取收到的命令，收集上报热点key。</li>
</ol>
<hr>
<h2><span id="q-ru-he-jie-jue-re-dian-wen-ti">Q: 如何解决热点问题？</span><a href="#q-ru-he-jie-jue-re-dian-wen-ti" class="header-anchor">#</a></h2>
<p>识别到热点后就是处理策略了。</p>
<ol>
<li>升级为本地缓存，也就是redis前置服务增加jvm内部缓存，只针对部分热点key。</li>
<li>紧急扩容redis缓存（但是扩容需要过程，还涉及预热同步主节点数据问题）</li>
<li>拆分key分散到更多其它缓存节点避免单节点瓶颈**（redis单节点一般10w qps）**， 即单独对这个热点key添加新的分片算法，分到其他本不属于的redis上。</li>
</ol>
<p>换句话说， 根本解决方式就是及时进行缓存的扩容。 有种办法是重写redis的访问机制，将slave节点也用上，实现读写分离。<br>
redis有个客户端lettuce，可以开启cluster模式下的读写分离， 水平扩容slave节点来无限延申系统容量。<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/11250789.html">热点Key问题的发现与解决</a></p>
<hr>
<h2><span id="q-ru-he-shan-chu-re-dian">Q: 如何删除热点？</span><a href="#q-ru-he-shan-chu-re-dian" class="header-anchor">#</a></h2>
<p>A:<br>
然后就是删除的问题，，保证最终一致性即可，如果是本地缓存可以用MQ广播消息+超时过期的策略，当然还有些极端情况的不一致可以考虑延迟双删和binlog异步刷新</p>
<hr>
<h2><span id="q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong">Q: 如何利用redis 实现秒杀系统？</span><a href="#q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong" class="header-anchor">#</a></h2>
<p>A:<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/11250753.html">使用Redis搭建电商秒杀系统</a></p>
<hr>
<hr>
<hr>
<h1><span id="shu-ju-yi-zhi-xing">数据一致性</span><a href="#shu-ju-yi-zhi-xing" class="header-anchor">#</a></h1>
<h2><span id="q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti">Q: 当需要删除数据时， 如果我先删缓存，再删数据库，可能会有什么问题？</span><a href="#q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti" class="header-anchor">#</a></h2>
<p>A:<br>
删完缓存，业务代码准备去删数据库时， 另一个请求打到redis这，发现不存在，于是另一个处理线程去数据库中取出了数据，并加载到了缓存中。<br>
这导致了缓存删除了个寂寞。</p>
<p>核心原因是因为业务代码的 删库和读-加载操作是支持并发执行的。</p>
<ul>
<li>因此应该先删数据库， 再删缓存，  这样能确保不会把脏数据重新加载到内存中</li>
</ul>
<hr>
<h2><span id="q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me">Q:  网络通信正常、命令正常的情况下， 先删库 ，再删缓存， 还是有可能造成脏数据， 知道为什么么？</span><a href="#q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me" class="header-anchor">#</a></h2>
<p>A:<br>
这种情况一般是”读缓存过期“导致的。</p>
<p>即正好某个key的读缓存过期，被删除。<br>
然后查询请求过来， 决定查库并加载到缓存中。<br>
此时又正好发来一个删除请求， 删库+删缓存，  然后又被上面的请求给重新加载了。</p>
<p>但是一般不考虑， 因为 正好过期+ 正好删除请求 +  ”先删库-&gt;查询缓存-&gt;删缓存-&gt;加载缓存的顺序“    这种概率是非常低的。</p>
<hr>
<h2><span id="q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao">Q: 如果删了库之后， 再删缓存的途中，网络临时不通怎么办？那缓存也有可能一直脏着了。</span><a href="#q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao" class="header-anchor">#</a></h2>
<p>A:<br>
失败的话，放入一个消息队列。 搞一个定时线程定期取消息队列中的消息进行处理。<br>
为了减少业务代码耦合， 弄一个独立的缓存更新程序， 专门从binlog中拿更新消息进行同步。<br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/f94f82af9a27192d3240215b4ce5f13b785f87b1.png" alt="f94f82af9a27192d3240215b4ce5f13b785f87b1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">分布式存储和事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 22:32:12 / 修改时间：23:17:54" itemprop="dateCreated datePublished" datetime="2022-09-19T22:32:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-cap-fen-bie-zhi-shi-me">Q: CAP分别指什么？</a></li>
<li><a href="#q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma">Q: 为什么说CAP无法同时满足？ 能讲清楚3种情况吗？</a></li>
<li><a href="#q-base-jie-jue-fang-an-shi-shi-me">Q: BASE解决方案是什么？</a></li>
<li><a href="#q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me">Q: 分布式事务种的2PC是什么？</a></li>
<li><a href="#q-3pc-you-shi-shi-me">Q: 3PC又是什么？</a></li>
<li><a href="#q-tcc-you-shi-shi-me">Q: TCC又是什么？</a></li>
<li><a href="#q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue">Q:数据库主从复制的延时问题如何解决？</a></li>
<li><a href="#q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian">Q：讲一下分布式锁的实现？</a></li>
<li><a href="#q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo">Q: 详细讲讲如何用数据库实现锁？</a></li>
<li><a href="#q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de">Q: redis的红锁是什么？解决什么问题的？</a></li>
<li><a href="#q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng">Q: 如何实现分布式的负载均衡？</a></li>
<li><a href="#q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan">Q: 主备数据库如何实现主备切换？</a></li>
<li><a href="#q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi">Q： 如何防止上面的主备切换过程中的新数据丢失？</a></li>
<li><a href="#q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao">Q: 如何防止主备切换时的数据不同步？ 和上面的数据丢失不同， 这里指的是master节点已经收到数据， 但是还没有往备节点同步时就挂掉了</a></li>
<li><a href="#q-ru-he-sheng-cheng-fen-bu-shi-id">Q: 如何生成分布式ID？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-cap-fen-bie-zhi-shi-me">Q:  CAP分别指什么？</span><a href="#q-cap-fen-bie-zhi-shi-me" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>C  一致性Consistency ——    多台节点之间数据一致 （响应准确度）</p>
</li>
<li>
<p>A  可用性Availability ——    能快速响应结果，没有延迟或者等待  （响应速度，不需要等待）</p>
</li>
<li>
<p>P   分区容错性PartitionTolerance——  如果有一部分节点挂了， 其他区节点还能提供服务 （ 时刻能响应，不会挂）</p>
</li>
</ul>
<hr>
<h1><span id="q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma">Q: 为什么说CAP无法同时满足？ 能讲清楚3种情况吗？</span><a href="#q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>CA 无P :<br>
不支持分区处理请求，  则仅1个节点， 或者全部是时刻联通， 1个挂了，则认为系统不可用。<br>
意味着分布式系统的意义不存在。无法扩展。违背初衷<br>
传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p>
</li>
<li>
<p>CP 无A：<br>
没有可用性。<br>
意味着我会尽可能保证数据同步，  不同步的话我就不返回。<br>
如果有节点挂了，就用另外正在同步的节点做。<br>
例子： redis、hbase 这类和业务实时性强相关较弱的分布式数据库<br>
他们要保证一致性，但不一定要马上能返回结果，</p>
</li>
<li>
<p>AP 无C<br>
缺失一致性。<br>
就是因为节点同步延迟， 你看到的可能和别人的页面不一样，但是至少会马上给你结果。<br>
一般用于不重要的广告、 网页推送、推荐之类的功能。</p>
</li>
</ul>
<p>举个例子：<br>
<img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/c06e14ad98f2204d0498aa5833018c5d8374a45c.png" alt="c06e14ad98f2204d0498aa5833018c5d8374a45c"><br>
以这个图为例<br>
如果必须满足P<br>
则当DB1和DB0的网络通信断开（需要1分钟才能恢复）<br>
N2仍旧要能够返回结果。<br>
这时候一致性和可用性无法同时满足<br>
如果要求有一致性，则必须等待1分钟才会恢复， 则无法立刻响应结果<br>
如果要求可用性， 则必须立刻返回结果，  那么无法保证DB0和DB1是一致的。</p>
<hr>
<h1><span id="q-base-jie-jue-fang-an-shi-shi-me">Q: BASE解决方案是什么？</span><a href="#q-base-jie-jue-fang-an-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<ul>
<li>基本可用（Basically Available）<br>
指系统故障时，能保障核心功能可用，接口性能适当降低</li>
<li>软状态（Soft state）<br>
允许存在中间状态，例如支付中、同步中， 也就是允许数据延时</li>
<li>最终一致（Eventually Consistent）<br>
经过一段时间后，所有节点数据都将会达到一致。如订单的&quot;支付中&quot;状态，最终会变 为“支付成功”或者&quot;支付失败&quot;，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li>
</ul>
<hr>
<h1><span id="q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me">Q: 分布式事务种的2PC是什么？</span><a href="#q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
2PC（ two-phase commit protocol）<br>
两阶段提交</p>
<ul>
<li>第一阶段：请求/表决阶段（点击放大）<br>
问一下这些参与节点&quot;这件事你们能不能处理成功了&quot;，参与者节点打开本地数据库事务，完成后并不会立马提交数据库本地事务，而是先向Coordinator报告说：“我这边可以处理了/我这边不能处理”</li>
<li>第二阶段：提交/执行阶段（正常流程）<br>
所有参与者节点都向协调者报告说“我这边可以处理”，协调者向所有参与者节点发送“全局提交确认通知（global_commit）”，参与者节点就会完成自身本地数据库事务的提交，并最终将提交结果回复“ack”消息给Coordinator，然后Coordinator就会向调用方返回分布式事务处理完成的结果。</li>
<li>第二阶段：提交/执行阶段（异常流程）<br>
参与者节点向协调者节点反馈“Vote_Abort”的消息。此时分布式事务协调者节点就会向所有的参与者节点发起事务回滚的消息（“global_rollback”），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。<br>
缺点：性能（阻塞等待）、协调者故障、</li>
</ul>
<hr>
<h1><span id="q-3pc-you-shi-shi-me">Q:  3PC又是什么？</span><a href="#q-3pc-you-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
在两阶段提交的基础上增加了CanCommit阶段 并引入了超时机制 ，一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。</p>
<p>第一阶段：CanCommit阶段（确认、检查各节点状态）<br>
第二阶段：PreCommit阶段（事务预提交，有执行节点的超时机制）<br>
第三阶段：DoCommit阶段（同样引入超时）</p>
<hr>
<h1><span id="q-tcc-you-shi-shi-me">Q: TCC又是什么？</span><a href="#q-tcc-you-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:</p>
<p>补偿事务TCC协议 （Try-Confirm-Cancel）<br>
有3个阶段   Try、confirm、cancel</p>
<ul>
<li>Try阶段：主要是对业务系统做检测及资源预留。</li>
<li>Confirm阶段：确认执行业务操作。</li>
<li>Cancel阶段：取消执行业务操作。</li>
</ul>
<blockquote>
<blockquote>
<p>2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p>
</blockquote>
</blockquote>
<p>TCC的不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p>
<hr>
<h1><span id="q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue">Q:数据库主从复制的延时问题如何解决？</span><a href="#q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue" class="header-anchor">#</a></h1>
<p>A:<br>
分情况讨论</p>
<ul>
<li>如果是写操作太多，导致binlog过多，以至于主库写和从库写都很慢——那么可以通过水平扩容的方式，打散写请求。  或者用高版本mysql支持并行binlog复制</li>
<li>过大的事务，导致主从延时——拆分大事务语句到若干小事务中，这样能够进行及时提交，减小主从复制延时</li>
<li>对大表进行alter table操作，导致了表会重新生成并进行迁移。——避免业务高峰执行表修改操作，尽量安排在业务低峰期执行</li>
<li>从库机器规格、配置和主库不一致。 ——从库有时候规格应该比主库配置要高。</li>
<li>数据库的表缺少主键或者合适索引，导致更新时的主从复制延时。  —— 去检查表结构，保证每个表都有显式自增主键，并协助用户建立合适索引</li>
<li>从库的查询请求过多，导致性能下降——增加从库数量，打散从库的查询请求。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92077345">https://zhuanlan.zhihu.com/p/92077345</a></p>
<hr>
<h1><span id="q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian">Q：讲一下分布式锁的实现？</span><a href="#q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian" class="header-anchor">#</a></h1>
<p>A:<br>
分布式锁实现</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhiwei549/article/details/80692278">https://blog.csdn.net/wuzhiwei549/article/details/80692278</a></p>
<ul>
<li>从理解的难易程度角度（从低到高）</li>
</ul>
<p>数据库（最简单） &gt; 缓存 &gt; Zookeeper</p>
<ul>
<li>从实现的复杂性角度（从低到高）</li>
</ul>
<p>Zookeeper &gt;= 缓存 &gt; 数据库</p>
<ul>
<li>从性能角度（从高到低）</li>
</ul>
<p>缓存（最快） &gt; Zookeeper &gt;= 数据库</p>
<ul>
<li>从可靠性角度（从高到低）</li>
</ul>
<p>Zookeeper（最可靠） &gt; 缓存（怕主节点突然挂了，导致锁失效） &gt; 数据库（无失效时间，挂了就gg）</p>
<hr>
<h1><span id="q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo">Q: 详细讲讲如何用数据库实现锁？</span><a href="#q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo" class="header-anchor">#</a></h1>
<p>A:<br>
有个locker表<br>
分别有4个字典</p>
<ul>
<li>锁名</li>
<li>持有锁的机器id</li>
<li>version</li>
<li>超时时间</li>
</ul>
<p>先查出这个锁名所在的行数据<br>
判断这个锁的id是否为空。<br>
如果不为空，且机器id也不是自己，说明被人持有了，返回false。<br>
如果为空， 则会尝试去更新， 使用   update 机器id where lockname=‘xxx’ and  <strong>version = 刚才拿到的version+1</strong><br>
如果update返回的结果不为0，说明更新成功， 返回true，持有锁成功。<br>
如果update结果为0， 说明抢锁失败， 因为version被人改了，导致where条件不成立，没更新任何一条</p>
<p>抢到锁的人完成自己的事务操作后， 释放锁，即把锁id清理即可。<br>
没抢到的人自己选择等一段时间再获取，或者频繁查询。</p>
<p>利用的行锁和MVCC的特性实现。<br>
图片如下：<br>
<img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/0e3326d72b41e735c84aec1ebb1b23f34149834b.png" alt="locker锁表"></p>
<hr>
<h1><span id="q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de">Q: redis的红锁是什么？解决什么问题的？</span><a href="#q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de" class="header-anchor">#</a></h1>
<p>A:<br>
解决的问题：<br>
Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点；master故障，发生故障转移，slave节点升级为master节点，导致锁丢失。</p>
<p>如何解决：</p>
<ol>
<li>获取当前时间（单位是毫秒）。</li>
<li>轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li>
<li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>
<li>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li>
<li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li>
</ol>
<hr>
<h1><span id="q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng">Q: 如何实现分布式的负载均衡？</span><a href="#q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng" class="header-anchor">#</a></h1>
<p>A:</p>
<p>nginx的负载均衡方式<br>
反向代理，作为代理服务器进行请求转发。<br>
轮询： 指定1个服务器ip列表， 依次按顺序分配<br>
weight权重： 根据指定权重， 分配的概率会变高（和服务器不同性能相关）<br>
ip哈希算法：  让特定ip都导向同一个服务器（避免不同服务器频繁获取某个用户信息）<br>
fair响应时间算法：  根据响应时间，动态调整分配优先级<br>
url哈希： 类似ip哈希，根据url哈希，一般是某个服务器会做特定接口缓存的情况。</p>
<hr>
<h1><span id="q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan">Q:  主备数据库如何实现主备切换？</span><a href="#q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan" class="header-anchor">#</a></h1>
<p>A:<br>
两种方式</p>
<ol>
<li>配置中心实现。 当监控系统发现异常后， 运维人员手动修改配置中心的数据源信息。  shark支持了基于zk的配置中心客户端。</li>
<li>给主备节点部署keepalive程序。  需要主备机器配置虚拟ip（类似于浮动ip),支持机器进行ip切换。<br>
运行过程中，  master和slave机器上的keepalived程序会互相发心跳，确认对方是否存货。 一旦master实例出现异常， 主节点的keeplive会自杀， 同时slave节点开始接管这个虚拟ip。</li>
</ol>
<hr>
<h1><span id="q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi">Q： 如何防止上面的主备切换过程中的新数据丢失？</span><a href="#q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi" class="header-anchor">#</a></h1>
<p>A:<br>
数据优先插入到缓存服务，再通过消息队列插入到数据库， 如果主节点挂了，可以通过failover机制重发，当切换成功后，就能插入到更新后的master节点上了（ 前提是failover的总时间大于主备切换的时间）</p>
<hr>
<h1><span id="q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao">Q: 如何防止主备切换时的数据不同步？ 和上面的数据丢失不同， 这里指的是master节点已经收到数据， 但是还没有往备节点同步时就挂掉了</span><a href="#q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>方法1： 如果要求数据强一致， 可以开启半同步复制模式， 即事务提交到master时，master会先发binlog给slave，当slave响应成功后，master才会完成这个事务。 （TPS较高场景不适合该模式）</p>
</li>
<li>
<p>方法2： 就是上面提到的缓存机制，先缓存，再落库。 然后再依靠 GTID（全局事务id）来保证主备数据的最终一致性。</p>
</li>
</ul>
<p>GTID即全局事务ID (global transaction identifier), 其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GTID最初由google实现，官方MySQL在5.6才加入该功能。mysql主从结构在一主一从情况下对于GTID来说就没有优势了，而对于2台主以上的结构优势异常明显，可以在数据不丢失的情况下切换新主<br>
<img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/5e695f9c56a67777bdb1727f6c2f805f16b0140c.png" alt="5e695f9c56a67777bdb1727f6c2f805f16b0140c"><br>
如图, Server1(Master)崩溃，根据从上show slave status获得Master_log_File/Read_Master_Log_Pos的值，Server2(Slave)已经跟上了主，Server3(Slave)没有跟上主。这时要是把Server2提升为主，Server3变成Server2的从。这时在Server3上执行change的时候需要做一些计算。</p>
<p>这个问题在5.6的GTID出现后，就显得非常的简单。由于同一事务的GTID在所有节点上的值一致，那么<strong>根据Server3当前停止点的GTID就能定位到Server2上的GTID</strong>。甚至由于MASTER_AUTO_POSITION功能的出现，我们都不需要知道GTID的具体值，直接使用CHANGE MASTER TO MASTER_HOST=‘xxx’, MASTER_AUTO_POSITION命令就可以直接完成failover的工作。</p>
<hr>
<h1><span id="q-ru-he-sheng-cheng-fen-bu-shi-id">Q: 如何生成分布式ID？</span><a href="#q-ru-he-sheng-cheng-fen-bu-shi-id" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>UUID<br>
UUID.randomUUID()<br>
UUID有5个版本，第一个版本比较好理解<br>
基于时间戳、随机数、机器MAC地址（java中改成ip地址）生成UUID<br>
随机性过强，不连续</li>
<li>数据库自增ID<br>
需要一个单独的MySQL实例用来生成ID，给id字段加上auto_increment关键字，自动id，只不过可能会不连续（可能挂掉）</li>
<li>数据库多主模式<br>
设置两个Mysql实例都能单独的生产自增ID<br>
2个实例的自增大小相同，但是起始值不同，就能保证隔开了<br>
不方便扩容</li>
<li>号段模式<br>
从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存<br>
多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。<br>
主流</li>
<li>Redis<br>
利用redis的 incr命令实现ID的原子性自增<br>
RDB备份可能导致id重复<br>
AOF备份可能导致重启时间过长</li>
<li>雪花算法Snowflake<br>
Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型<br>
序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107939861">9种分布式ID生成方式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">消息队列设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 21:30:12 / 修改时间：23:12:48" itemprop="dateCreated datePublished" datetime="2022-09-19T21:30:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me">Q: 消息队列的作用是什么？</a></li>
<li><a href="#q-xiao-xi-dui-lie-du-you-shi-me-que-dian">Q: 消息队列都有什么缺点？</a></li>
<li><a href="#q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian">Q: Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</a></li>
<li><a href="#q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling">Q: 如何保证消息队列的高可用？不会因为1台消息队列服务挂掉导致服务失灵？</a></li>
<li><a href="#q-zen-me-zhi-dao-leader-diao-xian">Q: 怎么知道leader掉线？</a></li>
<li><a href="#q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei">Q: 如何保证消息不会被重复消费？</a></li>
<li><a href="#q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de">Q: 是如何保证消息消费时一定是幂等的？</a></li>
<li><a href="#q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei">Q: 消息队列 mq 怎么保证顺序消费？</a></li>
<li><a href="#q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi">Q: 如何保证消息的可靠性传输，不会丢失？</a></li>
<li><a href="#q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya">Q:消息队列满了, 发生阻塞积压怎么办？例如突然流量峰值， 几百万消息持续积压？</a></li>
<li><a href="#q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu">Q: 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me">Q: 消息队列的作用是什么？</span><a href="#q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>解耦：<br>
通过一个MQ，发布和订阅模型（Pub/Sub模型），系统A就和其它系统彻底解耦。<br>
需要考虑一下负责的系统中，是否有类似的场景，就是一个系统或者一个模块，调用了多个系统，互相之间的调用很复杂，维护起来很麻烦。（新增、删除接口都是要两边互相适配）<br>
但是其实这个调用是不需要同步调用接口的（不需要等待返回），如果用MQ给他异步化解耦，也是可以的，这个时候可以考虑在自己的项目中，是不是可以运用这个MQ来进行系统的解耦。</p>
</li>
<li>
<p>异步：<br>
加快接口的返回。</p>
</li>
<li>
<p>削峰<br>
就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。</p>
</li>
</ul>
<hr>
<h1><span id="q-xiao-xi-dui-lie-du-you-shi-me-que-dian">Q: 消息队列都有什么缺点？</span><a href="#q-xiao-xi-dui-lie-du-you-shi-me-que-dian" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>系统可用性降低： MQ挂掉的话很危险</li>
<li>系统复杂性提高：要考虑消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性</li>
<li>一致性问题：存在关联的消息，被不同消费者消费，如果另一个消费者执行失败，如何感知和回退？</li>
</ul>
<hr>
<h1><span id="q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian">Q: Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</span><a href="#q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian" class="header-anchor">#</a></h1>
<p>A:<br>
列出一个表格<br>
<img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/63e89c47a42f0a17c97a8a2a303e4aeabd0a6de1.png" alt="63e89c47a42f0a17c97a8a2a303e4aeabd0a6de1"></p>
<p>简单记忆rabitMq和kafka的区别</p>
<ol>
<li>kafka高吞吐，适合大数据量的实时计算、日志采集。 但rabitMq的时延更小。</li>
<li>rabitMq基于主从， kafka则支持分布式（多副本）</li>
<li>rabitQq基于erlang开发， kafka用scala开发。</li>
</ol>
<hr>
<h1><span id="q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling">Q: 如何保证消息队列的高可用？不会因为1台消息队列服务挂掉导致服务失灵？</span><a href="#q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling" class="header-anchor">#</a></h1>
<p>A:<br>
只讲一下kafka的</p>
<p>每个partition属于多台机器。<br>
有一个是leader节点<br>
leader会把数据同步到另外2台机器。<br>
如果leader挂了，则消费者选择读取 这个partition的另外2台机器</p>
<p>假设其中的一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此kafka会自动感知leader已经宕机，同时将其它的follower给选举出来，作为新的leader，并向外提供服务支持。<br>
<img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/45e7b2c323914c2bcc4ed65a2d3d872471f920ed.png" alt="45e7b2c323914c2bcc4ed65a2d3d872471f920ed"></p>
<hr>
<h1><span id="q-zen-me-zhi-dao-leader-diao-xian">Q: 怎么知道leader掉线？</span><a href="#q-zen-me-zhi-dao-leader-diao-xian" class="header-anchor">#</a></h1>
<p>A:<br>
对于Kafka而言，定义一个Broker是否“活着”包含两个条件：</p>
<p>一是它必须维护与ZooKeeper的session（这个通过ZooKeeper的Heartbeat机制来实现）。<br>
二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。<br>
Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除</p>
<p>更详细的解释，包括如何感知掉线（ack、zk-session）、如何选举<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingyunzong/p/9004703.html">Kafka学习之路 （三）Kafka的高可用</a></p>
<hr>
<h1><span id="q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei">Q: 如何保证消息不会被重复消费？</span><a href="#q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei" class="header-anchor">#</a></h1>
<p>A: 需要消息消费者保证幂等性， 同样的消息，消费2次，结果是一样的。</p>
<p>幂等性是什么？通俗点说：幂等性就是一个数据，或者一个请求，以相同的内容和方式给你执行多次，得保证对应的数据不会改变，并且不能出错，这就是幂等性。（这样才能做到发送者搞重试或者多发问题）</p>
<hr>
<h1><span id="q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de">Q: 是如何保证消息消费时一定是幂等的？</span><a href="#q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de" class="header-anchor">#</a></h1>
<p>A:<br>
需要应用服务器消费消息时是幂等的， 注意<strong>消息队列不保证幂等</strong>。<br>
消费中如果是insert相关，且只会insert1次的，通过主键判断，避免重插（消费端）<br>
消费端业可以加一个redis， 以缓存消费过的记录， 重复消费可以通过redis识别，并且redis是临时缓存，不会占用太多资源。</p>
<hr>
<h1><span id="q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei">Q: 消息队列 mq 怎么保证顺序消费？</span><a href="#q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei" class="header-anchor">#</a></h1>
<p>A:<br>
abbitmq 中， 每个消费者对应一个队列<br>
kafka中， 每个消费者对应一个 partition。 partion中是有序的。</p>
<p>即kafka能保证塞入partion时是有序的<br>
因此你要求有序的那堆请求，要有相同的key映射到同一个partion</p>
<p>同时消费者处理的时候，也要按照核心key在内存中分配给不同的线程（内存线程使用加锁队列去获取消息）， 避免多线程处理的时候出现混乱<br>
<img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/e536b0c4b51e6b9230a6f586b3cb7c65fc9f23d9.png" alt="e536b0c4b51e6b9230a6f586b3cb7c65fc9f23d9"></p>
<hr>
<h1><span id="q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi">Q: 如何保证消息的可靠性传输，不会丢失？</span><a href="#q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi" class="header-anchor">#</a></h1>
<p>A:<br>
生产者发送到 MQ的时候丢了： 生产者使用ack机制，如果超时没收到，就回调nack接口做重发</p>
<p>MQ没发给消费者： 消息持久化，如果MQ挂了，还可以从磁盘中恢复重发。（ack应该在存盘后再发给生产者）</p>
<p>消费端没收到数据或者消费者挂了：<br>
关闭MQ的自动ack， 在消费者的代码逻辑里自己实现ack机制，保证是自己处理完成后才发ack，而不是收到了就发ack。<br>
对于kafka来说， 消费者的ack其实就是offset。 offset不能自动发，要自己实现。</p>
<hr>
<h1><span id="q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya">Q:消息队列满了, 发生阻塞积压怎么办？例如突然流量峰值， 几百万消息持续积压？</span><a href="#q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya" class="header-anchor">#</a></h1>
<p>A:<br>
运维根据告警信息， 对queue资源和consumer资源都临时进行紧急进行人工扩容。</p>
<hr>
<h1><span id="q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu">Q: 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</span><a href="#q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>首先MQ得支持可伸缩性<br>
那就需要快速扩容，就可以增加吞吐量和容量，可以设计一个分布式的系统，参考kafka的设计理念，broker - &gt; topic -&gt; partition，每个partition放一台机器，那就存一部分数据，如果现在资源不够了，可以给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多的数据，提高更高的吞吐量</p>
</li>
<li>
<p>其次得考虑一下这个MQ的数据要不要落地磁盘？也就是需不需要保证消息持久化，因为这样可以保证数据的不丢失，那落地盘的时候怎么落？顺序写，这样没有磁盘随机读写的寻址开销，磁盘顺序读的性能是很高的，这就是kafka的思路。</p>
</li>
<li>
<p>其次需要考虑MQ的可用性？这个可以具体到我们上面提到的消息队列保证高可用，提出了多副本 ，leader 和follower模式，当一个leader宕机的时候，马上选取一个follower作为新的leader对外提供服务。</p>
</li>
<li>
<p>需不需要支持数据0丢失？可以参考kafka零丢失方案</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98/" class="post-title-link" itemprop="url">第311场周赛-104名-4题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 12:12:42" itemprop="dateCreated datePublished" datetime="2022-09-18T12:12:42+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-19 23:34:07" itemprop="dateModified" datetime="2022-09-19T23:34:07+08:00">2022-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98%20/1663509817507.png" alt="1663509817507"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-even-multiple/">6180. 最小偶倍数 - 力扣（LeetCode）</a></p>
<p>sb题目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?n:n*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/">6181. 最长的字母序连续子字符串的长度 - 力扣（LeetCode）</a></p>
<p>单指针直接遍历计数就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestContinuousSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">lastC</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != lastC + <span class="number">1</span>) &#123;</span><br><span class="line">                res = Math.max(len, res);</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len++;   </span><br><span class="line">            &#125;</span><br><span class="line">            lastC = c;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(len, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/">6182. 反转二叉树的奇数层 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC311%E5%9C%BA%E5%91%A8%E8%B5%9B-104%E5%90%8D-4%E9%A2%98%20/1663509945954.png" alt="1663509945954"></p>
<p>先后序dfs记录每个点在哪个层，放进一个list</p>
<p>然后按层遍历哪些list，把他们的值返回来重新存放即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reverseOddLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;TreeNode&gt;&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="number">0</span>, nodes);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;TreeNode&gt;&gt; entry : nodes.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            List&lt;TreeNode&gt; list = entry.getValue();</span><br><span class="line">            List&lt;Integer&gt; valus = list.stream().map(tn -&gt; tn.val).collect(Collectors.toList());</span><br><span class="line">            Collections.reverse(valus);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size();i++) &#123;</span><br><span class="line">                list.get(i).val = valus.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> level, Map&lt;Integer, List&lt;TreeNode&gt;&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left, level+<span class="number">1</span>, map);</span><br><span class="line">        dfs(node.right, level+<span class="number">1</span>, map);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(level)) &#123;</span><br><span class="line">            map.put(level, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(level).add(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/">6183. 字符串的前缀分数和 - 力扣（LeetCode）</a></p>
<p>字段树，只有1000的范围，不会超，直接构建完树后直接遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Node[] nextNodes = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sumPrefixScores(String[] words) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>].count++;</span><br><span class="line">                node = node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[words.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sum += node.nextNodes[c - <span class="string">&#x27;a&#x27;</span>].count;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nextNodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[i++] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%8F%A0%E5%8A%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%8F%A0%E5%8A%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">扫描线（叠加区间问题）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 23:12:42 / 修改时间：01:01:59" itemprop="dateCreated datePublished" datetime="2022-09-17T23:12:42+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%8F%A0%E5%8A%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%8F%A0%E5%8A%A0%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>366</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#sao-miao-xian-gai-nian">扫描线概念</a></li>
<li><a href="#bu-zou">步骤</a></li>
<li><a href="#xiang-guan-ti-mu">相关题目</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="sao-miao-xian-gai-nian">扫描线概念</span><a href="#sao-miao-xian-gai-nian" class="header-anchor">#</a></h1>
<p>多个连续区间，计算叠加部分要去掉或者叠加某个价值，这种题常见于那种任务流</p>
<p>区间的坐标很大（一般是10^9）导致无法遍历坐标值， 但你可以遍历起点和终点坐标。</p>
<p>则可以将这些起点和终点作为纳入扫描点，逐个按从左到右的顺序扫描,并更新所谓的“高度&quot;&quot;，每次做宽度 乘 高度的计算</p>
<h1><span id="bu-zou">步骤</span><a href="#bu-zou" class="header-anchor">#</a></h1>
<ol>
<li>将终点和起点都放入数组排序， 并注意保留是起点还是终点的信息（有可能起点和终点相同，如果没保留这个标志可能导致出错）</li>
<li>从左到右扫描各点</li>
<li>扫描到某点时， 先不着急更新<strong>高度</strong>，  而是先计算&quot;当前高度乘上（当前位置减去上一个位置）&quot;。注意这个过程不需要区分是起点还是终点，都可以直接算。</li>
<li>计算完成后， 根据是起点还是终点，来更新所谓的高度</li>
<li>更新上一个位置</li>
</ol>
<hr>
<h1><span id="xiang-guan-ti-mu">相关题目</span><a href="#xiang-guan-ti-mu" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rectangle-area-ii/">850. 矩形面积 II - 力扣（LeetCode）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/" class="post-title-link" itemprop="url">算法题常见情况应对思路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-16 23:12:42" itemprop="dateCreated datePublished" datetime="2022-09-16T23:12:42+08:00">2022-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-17 01:08:35" itemprop="dateModified" datetime="2022-09-17T01:08:35+08:00">2022-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>340</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#jie-da-cuo-wu">解答错误</a>
<ul>
<li><a href="#pai-cha-yi-shu-zhi-yi-chu">排查一：数值溢出</a></li>
</ul>
</li>
<li><a href="#pai-cha-er-er-fen-fa-xun-zhao-guan-jian-yong-li">排查二： 二分法寻找关键用例</a></li>
<li><a href="#chao-shi">超时</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="jie-da-cuo-wu">解答错误</span><a href="#jie-da-cuo-wu" class="header-anchor">#</a></h1>
<h2><span id="pai-cha-yi-shu-zhi-yi-chu">排查一：数值溢出</span><a href="#pai-cha-yi-shu-zhi-yi-chu" class="header-anchor">#</a></h2>
<p>排查是否存在数值溢出， int要改成用long， 或者根据题意在某个可能溢出的部分没有mod(10^9+7)</p>
<h1><span id="pai-cha-er-er-fen-fa-xun-zhao-guan-jian-yong-li">排查二： 二分法寻找关键用例</span><a href="#pai-cha-er-er-fen-fa-xun-zhao-guan-jian-yong-li" class="header-anchor">#</a></h1>
<p>如果给出了用例， 但是用例里的值或者数组特别多，也不存在溢出问题，说明是题意理解有错，且肯定和某个关键值有关（如果不是某个关键值，那么简单用例就该出错了）</p>
<p>例如：</p>
<p><img src="/images/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF/1663347973949.png" alt="1663347973949"></p>
<p>则你应对不断二分删除里面的数据， 对比结果，直到缩小用例范围，便可以调试或者打印信息来确认问题原因了。</p>
<p>上面这边最后可以定位到这样小的范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">166</span>,<span class="number">0</span>,<span class="number">166</span>,<span class="number">808</span>],[<span class="number">441</span>,<span class="number">0</span>,<span class="number">644</span>,<span class="number">435</span>]]</span><br></pre></td></tr></table></figure>
<p>从而发现是[166,0,166,808]这个数据，明明题目说是矩形，却可以允许x1和x2相等。。</p>
<h1><span id="chao-shi">超时</span><a href="#chao-shi" class="header-anchor">#</a></h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">epoll原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-15 23:47:49 / 修改时间：23:31:22" itemprop="dateCreated datePublished" datetime="2022-09-15T23:47:49+08:00">2022-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">linux-unix原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-select-poll-de-que-dian">Q: select/poll的缺点？</a></li>
<li><a href="#epoll-de-she-ji-yao-dian">epoll的设计要点</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>来源：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/wxy941011/article/details/80274233">Redis IO多路复用技术以及epoll实现原理</a><br>
<a target="_blank" rel="noopener" href="https://www.sohu.com/a/343216187_120104204">精通Redis！epoll?IO的同/异步、阻塞/非阻塞？都懂了吗?</a></p>
<hr>
<h1><span id="q-select-poll-de-que-dian">Q:  select/poll的缺点？</span><a href="#q-select-poll-de-que-dian" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>select的本质是采用32个整数的32位，即32<em>32= 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE的大小。这个时候就可以标识32</em>max值范围的fd。</li>
<li>poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</li>
<li>select/poll的几大缺点：</li>
</ul>
<ol>
<li>每次调用select/poll，都需要把<strong>fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></li>
<li>同时每次调用select/poll都需要在<strong>内核遍历</strong>传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>针对select支持的文件描述符数量<strong>太小了</strong>，默认是1024</li>
<li>select返回的是含有整个句柄的数组，<strong>应用程序需要遍历</strong>整个数组才能发现哪些句柄发生了事件；</li>
<li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li>
<li>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制 ，但其他三个缺点依然存在。</li>
</ol>
<p>而用了epoll，上面select的缺点都不复存在了。<br>
他们三者的对比如下：<br>
<img src="/images/epoll%E5%8E%9F%E7%90%86/af606199b857d67784fc708b01ad193a0ae5b2ab.png" alt="af606199b857d67784fc708b01ad193a0ae5b2ab"></p>
<hr>
<h1><span id="epoll-de-she-ji-yao-dian">epoll的设计要点</span><a href="#epoll-de-she-ji-yao-dian" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>首选Epoll在Linux内核中构建了一个文件系统，该文件系统<strong>采用红黑树</strong>来构建，红黑树在查询、新增、删除的效率极高，保障了在存在大量活跃连接的情况下的性能。 即新连接通过红黑树方式插入和更新</p>
</li>
<li>
<p>其次Epoll红黑树上采用事件异步唤醒，内核监听I/O，<strong>事件发生后内核搜索红黑树并将对应节点数据放入异步唤醒的事件队列中</strong>。这就避免了无差别的轮询，不会因为连接数增加而导致性能的快速下降。</p>
</li>
<li>
<p>最后Epoll的数据从用户空间到内核空间采用mmap存储I/O映射来加速。该方法是目前Linux进程间通信中传递最快,消耗最小,传递数据过程不涉及系统调用的方法。这点大大提升了存在大量FD时数据拷贝的消耗</p>
</li>
</ol>
<blockquote>
<blockquote>
<p>详细解释：epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象</p>
</blockquote>
</blockquote>
<p><img src="/images/epoll%E5%8E%9F%E7%90%86/398cc1e5fdaa0abf90cd8e577fd826ade07c3ecf.png" alt="398cc1e5fdaa0abf90cd8e577fd826ade07c3ecf"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">linux-unix原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-15 23:23:59" itemprop="dateCreated datePublished" datetime="2022-09-15T23:23:59+08:00">2022-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-08 16:59:19" itemprop="dateModified" datetime="2023-01-08T16:59:19+08:00">2023-01-08</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>47</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/epoll%E5%8E%9F%E7%90%86/" title="epoll原理">epoll原理</a><br>
<a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E5%91%BD%E4%BB%A4/" title="linux命令">linux命令</a><br>
<a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" title="linux系统启动过程">linux系统启动过程</a><br>
<a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/" title="linux零拷贝">linux零拷贝</a><br>
<a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/linux-unix%E5%8E%9F%E7%90%86/unix%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/" title="unix高级编程思维导图笔记">unix高级编程思维导图笔记</a><br>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">239</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共318.6k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://breakdawncoder.com/page/8/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
