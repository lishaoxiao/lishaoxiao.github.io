<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="冲破黎明前的黑暗">
<meta property="og:url" content="http://breakdawncoder.com/home/index.html">
<meta property="og:site_name" content="冲破黎明前的黑暗">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/home/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>冲破黎明前的黑暗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冲破黎明前的黑暗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/" class="post-title-link" itemprop="url">原神旅游日记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 00:07:32 / 修改时间：00:14:35" itemprop="dateCreated datePublished" datetime="2022-08-15T00:07:32+08:00">2022-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">游戏</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/15/%E9%9A%8F%E7%AC%94/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<!-- tocstop -->
</div> 
<p><img src="/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" alt="1660493655011"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java-IO%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java-IO%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java-IO基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 23:50:15 / 修改时间：23:53:19" itemprop="dateCreated datePublished" datetime="2022-08-14T23:50:15+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java-IO%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java-IO%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#wen-jian-api">文件API</a>
<ul>
<li><a href="#q-file-lei-ke-yi-yong-lai-zuo-mu-lu-cao-zuo-ma">Q: File类可以用来做目录操作吗？</a></li>
<li><a href="#q-zhi-jie-diao-yong-file-delete-ke-yi-shan-chu-mu-lu-ma">Q：直接调用file.delete()可以删除目录吗？</a></li>
<li><a href="#q-you-na-xie-fang-fa-pan-duan-gei-ding-lu-jing-xia-wen-jian-shi-fou-cun-zai">Q： 有哪些方法判断给定路径下文件是否存在？</a></li>
</ul>
</li>
<li><a href="#zi-jie-shu-ru-liu-inputstream">字节输入流InputStream</a>
<ul>
<li><a href="#shuo-yi-xia-yi-xia-zhe-xie-te-dian-dui-ying-na-xie-inputstream-lei">说一下以下这些特点对应哪些InputStream类</a></li>
<li><a href="#q-filterinputstream-shi-shi-me">Q： FilterInputStream是什么？</a></li>
</ul>
</li>
<li><a href="#zi-jie-shu-chu-liu-outputstream">字节输出流OutputStream</a>
<ul>
<li><a href="#q-outputstream-bao-han-na-xie-shi-xian">Q: OutputStream包含哪些实现？</a></li>
<li><a href="#q-new-fileoutputstream-name-true-zhe-ge-gou-zao-li-de-true-can-shu-shi-zuo-shi-me-yong-de">Q：new FileOutputStream(name, true)，这个构造里的true参数是做什么用的？</a></li>
<li><a href="#q-bufferoutputstream-xiang-guan-gai-nian-qi-shi-shi-kao-huan-chong-qu-shi-fou-xu-yao-shua-xin-zhi-lei-de-wen-ti">Q：BufferOutputStream相关概念（其实是考缓冲区是否需要刷新之类的问题）</a></li>
</ul>
</li>
<li><a href="#reader-he-writer">Reader和Writer</a>
<ul>
<li><a href="#q-reader-writer-he-inputstream-outputstream-de-qu-bie">Q: Reader/Writer和InputStream/OutputStream的区别？</a></li>
<li><a href="#ru-he-she-zhi-she-zhi-bian-ma">如何设置设置编码：</a></li>
</ul>
</li>
<li><a href="#xu-lie-hua-wen-ti">序列化问题</a>
<ul>
<li><a href="#q-java-de-xu-lie-hua-yi-ban-shi-zuo-shi-me-de">Q: java的序列化一般是做什么的？</a></li>
<li><a href="#q-dui-mou-dui-xiang-jin-xing-xu-lie-hua-shi-ru-he-rang-li-mian-mou-ge-min-gan-cheng-yuan-bu-bei-xu-lie-hua">Q： 对某对象进行序列化时， 如何让里面某个敏感成员不被序列化？</a></li>
<li><a href="#q-externalizable-he-serializable-na-ge-kuai-yuan-yin-shi-shi-me">Q： Externalizable和Serializable哪个快？ 原因是什么？</a></li>
<li><a href="#q-externalizable-xu-yao-chan-sheng-xu-lie-hua-id-ma">Q： Externalizable需要产生序列化ID吗？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="wen-jian-api">文件API</span><a href="#wen-jian-api" class="header-anchor">#</a></h1>
<h2><span id="q-file-lei-ke-yi-yong-lai-zuo-mu-lu-cao-zuo-ma">Q: File类可以用来做目录操作吗？</span><a href="#q-file-lei-ke-yi-yong-lai-zuo-mu-lu-cao-zuo-ma" class="header-anchor">#</a></h2>
<p>A：<br>
可以。<br>
File对象本身可以是目录。<br>
调用file.mkdirs()即可创建目录。</p>
<hr>
<h2><span id="q-zhi-jie-diao-yong-file-delete-ke-yi-shan-chu-mu-lu-ma">Q：直接调用file.delete()可以删除目录吗？</span><a href="#q-zhi-jie-diao-yong-file-delete-ke-yi-shan-chu-mu-lu-ma" class="header-anchor">#</a></h2>
<p>A：<br>
如果是文件或者空目录，可以直接删除。<br>
但如果目录中有文件或者子目录，则必须递归删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">    String[] children = dir.list();</span><br><span class="line">　　　　　　　<span class="comment">//递归删除目录中的子目录下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;children.length; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> deleteDir(<span class="keyword">new</span> <span class="title class_">File</span>(dir, children[i]));</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 目录此时为空，可以删除</span></span><br><span class="line">   <span class="keyword">return</span> dir.delete();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="q-you-na-xie-fang-fa-pan-duan-gei-ding-lu-jing-xia-wen-jian-shi-fou-cun-zai">Q： 有哪些方法判断给定路径下文件是否存在？</span><a href="#q-you-na-xie-fang-fa-pan-duan-gei-ding-lu-jing-xia-wen-jian-shi-fou-cun-zai" class="header-anchor">#</a></h2>
<p>A：</p>
<ol>
<li>File类的exists方法： ? file.exist(string)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">testFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(testFilePath);</span><br><span class="line"><span class="keyword">if</span>(!testFile .exists()) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>File类的静态exist方法, File.exist(Path path)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> Paths.get(testFilePath);</span><br><span class="line"><span class="keyword">if</span> (Files.exists(filePath) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>注意静态方法和非静态方法的区别</p>
<h1><span id="zi-jie-shu-ru-liu-inputstream">字节输入流InputStream</span><a href="#zi-jie-shu-ru-liu-inputstream" class="header-anchor">#</a></h1>
<h2><span id="shuo-yi-xia-yi-xia-zhe-xie-te-dian-dui-ying-na-xie-inputstream-lei">说一下以下这些特点对应哪些InputStream类</span><a href="#shuo-yi-xia-yi-xia-zhe-xie-te-dian-dui-ying-na-xie-inputstream-lei" class="header-anchor">#</a></h2>
<ul>
<li>字节数组char[] 作为输入源的InputStream类是————ByteArrayInputStream</li>
<li>用文件作为输入源的InputStream类是？————FileInputStream</li>
<li>用字符串作为输入源的是？————StringBufferInputStream</li>
<li>用于多线程之间管道通信的输入源是————PipeInputStream ?</li>
</ul>
<hr>
<h2><span id="q-filterinputstream-shi-shi-me">Q： FilterInputStream是什么？</span><a href="#q-filterinputstream-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： 用于装饰上面这些输入流的，可以叠加，每装饰一层就相当于增加了1个功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInputStream</span>(InputStream)</span><br></pre></td></tr></table></figure>
<p>–<br>
以下这些特点分别对应哪些FilterInputStream？</p>
<ul>
<li>装饰后，不仅可读字符串，还可读取例如int、long等java基本类型的是————DataInputStream<br>
DataInputStream里面会支持readInt、readLong等方法。</li>
<li>装饰后，支持分批缓冲读取读取的是————BufferedInputStream<br>
创建BufferedInputStream时，我们会通过它的构造函数指定某个输入流为参数。BufferedInputStream会将该输入流数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从输入流中读取下一部分的数据。</li>
<li>其他：<br>
PushbackInputStream： 具有1个能回退上一个字节的缓冲区<br>
ObjectInputStream ： 一般用于反序列化读入<br>
LineNumberInputStream： 可跟踪输入流中的行号</li>
</ul>
<hr>
<h1><span id="zi-jie-shu-chu-liu-outputstream">字节输出流OutputStream</span><a href="#zi-jie-shu-chu-liu-outputstream" class="header-anchor">#</a></h1>
<h2><span id="q-outputstream-bao-han-na-xie-shi-xian">Q: OutputStream包含哪些实现？</span><a href="#q-outputstream-bao-han-na-xie-shi-xian" class="header-anchor">#</a></h2>
<p>ByteArrayOutputStream ?输出到缓冲区?<br>
FileOutputStream ? 写到文件<br>
PipedOutputStream ?写入管道<br>
FilterOutputStream ?</p>
<p>而FilterOutputStream 包含</p>
<ul>
<li>DataOutputStream ?（可以out.writexxx各种类型的数据，writeDouble， writeUTF， ?reader也一样，可以读想要的数据类型）、</li>
<li>PringtStream （输出到文件用这个， 该类.println(str)即可写入文件）</li>
<li>BufferOutputString</li>
</ul>
<hr>
<p>FileOutputStream相关</p>
<h2><span id="q-new-fileoutputstream-name-true-zhe-ge-gou-zao-li-de-true-can-shu-shi-zuo-shi-me-yong-de">Q：new FileOutputStream(name, true)，这个构造里的true参数是做什么用的？</span><a href="#q-new-fileoutputstream-name-true-zhe-ge-gou-zao-li-de-true-can-shu-shi-zuo-shi-me-yong-de" class="header-anchor">#</a></h2>
<p>A：<br>
是否支持在文件末追加的意思。<br>
<img src="/images/Java-IO%E5%9F%BA%E7%A1%80/1618921889243064567.png" alt="image.png"></p>
<p>默认是false，指的是覆盖整个文本。<br>
如果设置成true，会在要写入的文件后面追加本次写入的内容。</p>
<hr>
<h2><span id="q-bufferoutputstream-xiang-guan-gai-nian-qi-shi-shi-kao-huan-chong-qu-shi-fou-xu-yao-shua-xin-zhi-lei-de-wen-ti">Q：BufferOutputStream相关概念（其实是考缓冲区是否需要刷新之类的问题）</span><a href="#q-bufferoutputstream-xiang-guan-gai-nian-qi-shi-shi-kao-huan-chong-qu-shi-fou-xu-yao-shua-xin-zhi-lei-de-wen-ti" class="header-anchor">#</a></h2>
<ul>
<li>BufferOutputStream里的flush()方法是做什么的？</li>
<li>BufferOutputStream调用close后，会触发flush()来刷新缓冲区吗？</li>
<li>BufferOutputStream调用close可能会丢数据吗？</li>
<li>BufferOutputStream多次调用close会报错吗？</li>
</ul>
<p>A：</p>
<ul>
<li>
<p>flush把缓冲区里的数据写入文件，并刷新缓冲区<br>
<img src="/images/Java-IO%E5%9F%BA%E7%A1%80/1618921900764052010.png" alt="image.png"></p>
</li>
<li>
<p>close关闭此输出流并释放与此相关联的任何系统资源， 会调用flush，除了flushBuffer，还会调用父类的flush。</p>
</li>
<li>
<p>不会丢数据，因为上面这条原因。</p>
</li>
<li>
<p>多次调用不会报错。<br>
*?<br>
<img src="/images/Java-IO%E5%9F%BA%E7%A1%80/1618921909192091711.png" alt="image.png"></p>
</li>
</ul>
<h1><span id="reader-he-writer">Reader和Writer</span><a href="#reader-he-writer" class="header-anchor">#</a></h1>
<h2><span id="q-reader-writer-he-inputstream-outputstream-de-qu-bie">Q: Reader/Writer和InputStream/OutputStream的区别？</span><a href="#q-reader-writer-he-inputstream-outputstream-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>InputStream是表示 <em><strong>字节输入流</strong></em> 的所有类的超类<br>
Reader是用于读取 <em><strong>字符流</strong></em> 的抽象类<br>
InputStream提供的是字节流的读取，而非文本读取，这是和Reader类的根本区别。<br>
即用Reader读取出来的是char数组或者String ，使用InputStream读取出来的是byte数组。</li>
<li>Reader/Writer提供兼容Unicode、面向字符的IO功能，为了国际化</li>
</ul>
<hr>
<ul>
<li>用reader读取标准输入：<br>
BufferedReader bufr = new BufferedReader(new InputStreamReader(<a target="_blank" rel="noopener" href="http://System.in">System.in</a>));</li>
<li>用Writer进行标准输出：<br>
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</li>
</ul>
<hr>
<h2><span id="ru-he-she-zhi-she-zhi-bian-ma">如何设置设置编码：</span><a href="#ru-he-she-zhi-she-zhi-bian-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file), <span class="string">&quot;UTF-8&quot;</span>); ?</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr); ?</span><br></pre></td></tr></table></figure>
<h1><span id="xu-lie-hua-wen-ti">序列化问题</span><a href="#xu-lie-hua-wen-ti" class="header-anchor">#</a></h1>
<h2><span id="q-java-de-xu-lie-hua-yi-ban-shi-zuo-shi-me-de">Q: java的序列化一般是做什么的？</span><a href="#q-java-de-xu-lie-hua-yi-ban-shi-zuo-shi-me-de" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>永久的保存对象数据(将对象数据保存在文件当中,或者是磁盘中</li>
<li>通过序列化操作将对象数据在网络上进行传输(由于网络传输是以字节流的方式对数据进行传输的.因此序列化的目的是将对象数据转换成字节流的形式)</li>
<li>将对象数据在进程之间进行传递(Activity之间传递对象数据时,需要在当前的Activity中对对象数据进行序列化操作.在另一个Activity中需要进行反序列化操作讲数据取出)</li>
<li>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长（即每个对象都在JVM中）但在现实应用中，就可能要停止JVM运行，但有要保存某些指定的对象，并在将来重新读取被保存的对象。这是Java对象序列化就能够实现该功能。（可选择入数据库、或文件的形式保存）</li>
<li>序列化对象的时候只是针对变量进行序列化,不针对方法进行序列化.</li>
<li>在Intent之间,基本的数据类型直接进行相关传递即可,但是一旦数据类型比较复杂的时候,就需要进行序列化操作了.</li>
</ol>
<hr>
<h2><span id="q-dui-mou-dui-xiang-jin-xing-xu-lie-hua-shi-ru-he-rang-li-mian-mou-ge-min-gan-cheng-yuan-bu-bei-xu-lie-hua">Q： 对某对象进行序列化时， 如何让里面某个敏感成员不被序列化？</span><a href="#q-dui-mou-dui-xiang-jin-xing-xu-lie-hua-shi-ru-he-rang-li-mian-mou-ge-min-gan-cheng-yuan-bu-bei-xu-lie-hua" class="header-anchor">#</a></h2>
<p>A:?</p>
<ul>
<li>方法一：可使用transient关键字处理那个敏感成员</li>
<li>方法二：可以通过覆盖Serializable接口的writeObject和readObject来实现序列化， ?但是方法签名必须是private void writeObject(ObjetOutputStream stream) throw IOException;</li>
<li>方法三： 实现Externalizable接口，可自定义实现writeExternal以及readExternal方法</li>
</ul>
<hr>
<h2><span id="q-externalizable-he-serializable-na-ge-kuai-yuan-yin-shi-shi-me">Q： Externalizable和Serializable哪个快？ 原因是什么？</span><a href="#q-externalizable-he-serializable-na-ge-kuai-yuan-yin-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： Externalizable更快。<br>
原因：</p>
<ul>
<li>
<p>Java序列化写入不仅是完整的类名，也包含整个类的定义，包含所有被引用的类。<br>
类定义可以是相当大的，也许构成了性能和效率的问题，当然这是编写一个单一的对象。如果您正在编写了大量相同的类的对象，这时类定义的开销通常不是一个大问题。另一件事情是，如果你的对象有一类的引用（如元数据对象），那么Java序列化将写入整个类的定义，不只是类的名称，因此，使用Java序列化写出元数据（meta-data）是非常昂贵的</p>
</li>
<li>
<p>通过实现Externalizable接口，这是可能优化Java序列化的。实现此接口，避免写出整个类定义，只是类名被写入</p>
</li>
</ul>
<hr>
<h2><span id="q-externalizable-xu-yao-chan-sheng-xu-lie-hua-id-ma">Q： Externalizable需要产生序列化ID吗？</span><a href="#q-externalizable-xu-yao-chan-sheng-xu-lie-hua-id-ma" class="header-anchor">#</a></h2>
<p>A： 采用Externalizable无需产生序列化ID（serialVersionUID）~而Serializable接口则需要</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java多线程基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 23:41:55 / 修改时间：23:48:05" itemprop="dateCreated datePublished" datetime="2022-08-14T23:41:55+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#thread-lei-ji-chu">Thread类基础</a>
<ul>
<li><a href="#q-thread-de-deprecated-guo-qi-fang-fa-shi-na-3-ge-zuo-yong-shi-sha">Q： Thread的deprecated过期方法是哪3个？作用是啥</a></li>
<li><a href="#q-fei-qi-stop-de-yuan-yin-shi-sha">Q： 废弃stop的原因是啥？</a></li>
<li><a href="#q-stop-de-ti-dai-fang-fa-shi-shi-me">Q： stop的替代方法是什么？</a></li>
<li><a href="#q-suspend-resume-de-fei-qi-yuan-yin-shi-shi-me">Q： suspend/resume的废弃原因是什么？</a></li>
<li><a href="#q-shang-ti-de-suspend-he-resume-ke-yi-zen-me-ti-huan-lai-jie-jue-si-suo-wen-ti">Q： 上题的suspend和resume可以怎么替换，来解决死锁问题？</a></li>
<li><a href="#q-xia-mian-zhe-li-zi-wei-shi-me-hui-yun-xing-yi-chang-pao-chu-illegalmonitorstateexception-cuo-wu">Q： 下面这例子为什么会运行异常，抛出IllegalMonitorStateException错误？</a></li>
<li><a href="#q-wei-shi-me-wait-bi-xu-chi-you-suo-de-shi-hou-cai-neng-diao-yong">Q: 为什么wait必须持有锁的时候才能调用？</a></li>
<li><a href="#q-thread-sleep-he-object-wait-de-qu-bie">Q： Thread.sleep()和Object.wait()的区别</a></li>
<li><a href="#q-ru-guo-you-3-ge-xian-cheng-tong-shi-qiang-zhan-liao-zhe-ge-suo-qie-du-zai-wait-wo-xi-wang-zhi-notify-huan-xing-mou-ge-xian-cheng-zen-me-ban">Q: 如果有3个线程同时抢占了这个锁且都在wait，我希望只notify唤醒某个线程，怎么办？</a></li>
<li><a href="#q-locksupport-xiang-bi-notify-wait-you-shi-me-you-dian">Q: LockSupport相比notify/wait有什么优点？</a></li>
<li><a href="#q-runnable-jie-kou-he-callable-de-qu-bie">Q：Runnable接口和Callable的区别。</a></li>
<li><a href="#q-thread-alive-biao-shi-xian-cheng-dang-qian-shi-fou-chu-yu-huo-yue-ke-yong-zhuang-tai-thread-start-hou-shi-fou-alive-yi-ding-fan-hui-true">Q：thread.alive()表示线程当前是否处于活跃/可用状态。thread.start()后，是否alive()一定返回true？</a></li>
<li><a href="#q-xian-cheng-a-ru-xia-ba-xian-cheng-a-zuo-wei-gou-zao-can-shu-chuan-gei-xian-cheng-b-ci-shi-dui-b-xian-cheng-da-yin-this-isalive-hui-xian-shi-shi-me">Q: 线程A如下，把线程A作为构造参数，传给线程B，此时对B线程打印this.isAlive会显示什么？：</a></li>
<li><a href="#q-ba-futuretask-fang-jin-thread-zhong-bing-start-hou-hui-zheng-chang-zhi-xing-callable-li-de-nei-rong-ma">Q：把FutureTask放进Thread中，并start后，会正常执行callable里的内容吗？</a></li>
</ul>
</li>
<li><a href="#synchronized-guan-jian-zi">synchronized关键字</a>
<ul>
<li><a href="#q-diao-yong-xia-mian-de-f-shi-hui-chu-xian-si-suo-ma">Q： 调用下面的f()时，会出现死锁吗？</a></li>
<li><a href="#q-2-ge-xian-cheng-tong-shi-diao-yong-f1-he-f2-hui-chan-sheng-tong-bu-ma">Q:2个线程同时调用f1和f2会产生同步吗？</a></li>
</ul>
</li>
<li><a href="#qi-ta-de-tong-bu-gong-ju">其他的同步工具</a>
<ul>
<li><a href="#countdownlatch">CountDownLatch</a>
<ul>
<li><a href="#q-countdownlatch-de-nei-bu-ji-shu-zhi-neng-bei-chong-zhi-ma">Q： countDownLatch的内部计数值能被重置吗？</a></li>
</ul>
</li>
<li><a href="#futuretask">FutureTask</a>
<ul>
<li><a href="#q-diao-yong-futruetask-get-shi-zhe-ge-shi-zu-sai-fang-fa-ma-ru-guo-shi-zu-sai-shi-me-shi-hou-hui-jie-shu">Q：调用futrueTask.get()时，这个是阻塞方法吗？如果是阻塞，什么时候会结束？</a></li>
</ul>
</li>
<li><a href="#semaphore">Semaphore</a>
<ul>
<li><a href="#xin-hao-liang-gai-nian">信号量概念</a></li>
<li><a href="#q-xin-hao-liang-zhong-gong-ping-mo-shi-he-fei-gong-ping-mo-shi-de-qu-bie-xia-mian-she-cheng-true-jiu-shi-gong-ping-mo-shi">Q： 信号量中，公平模式和非公平模式的区别？下面设成true就是公平模式</a></li>
</ul>
</li>
<li><a href="#cyclicbarrier-zha-lan">CyclicBarrier （栅栏）</a></li>
<li><a href="#exchanger-jiao-huan-zha-lan">Exchanger （交换栅栏）</a></li>
<li><a href="#yuan-zi-lei-atomicxxx">原子类AtomicXXX</a>
<ul>
<li><a href="#q-xia-mian-shu-chu-shi-me-kao-cha-getandadd-de-yong-fa">Q：下面输出什么？（考察getAndAdd的用法）</a></li>
<li><a href="#q-atomicreference-he-atomicinteger-de-qu-bie">Q：AtomicReference和AtomicInteger的区别？</a></li>
<li><a href="#java-zhong-yi-shi-xian-de-quan-bu-yuan-zi-lei">java中已实现的全部原子类：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#xian-cheng-chi">线程池</a>
<ul>
<li><a href="#q-threadpoolexecutor-xian-cheng-chi-gou-zao-can-shu-zhong-corepoolsize-he-maximumpoolsize-you-shi-me-qu-bie">Q: ThreadPoolExecutor线程池构造参数中，corePoolSize和maximumPoolSize有什么区别？</a></li>
<li><a href="#q-xian-cheng-chi-de-keepalive-can-shu-shi-gan-ma-de">Q： 线程池的keepalive参数是干嘛的？</a></li>
<li><a href="#q-he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">Q: 核心线程可以被回收吗？（线程池没有被回收的情况下）</a></li>
<li><a href="#q-na-zhe-ge-xian-cheng-shu-she-zhi-duo-shao-ni-shi-zen-me-kao-lu-de-ni">Q: 那这个线程数设置多少，你是怎么考虑的呢？</a></li>
<li><a href="#q-xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">Q： 线程池有哪三种队列策略？</a></li>
<li><a href="#q-xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">Q： 线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</a></li>
<li><a href="#q-xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">Q: 线程池为什么需要阻塞队列？</a></li>
<li><a href="#q-you-yi-xia-wu-chong-executor-ti-gong-de-xian-cheng-chi-zhu-yi-ji-yi-yi-xia-ta-men-de-yong-tu-jiu-neng-li-jie-nei-bu-de-yuan-li-liao">Q：有以下五种Executor提供的线程池，注意记忆一下他们的用途，就能理解内部的原理了。</a></li>
<li><a href="#q-submit-he-execute-de-qu-bie-shi-shi-me">Q： submit和execute的区别是什么？</a></li>
<li><a href="#q-xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">Q：线程池中， shutdown、 shutdownNow、awaitTermination的区别？</a></li>
</ul>
</li>
<li><a href="#thread-zhuang-tai-zhuan-huan">Thread状态转换</a>
<ul>
<li><a href="#q-xian-cheng-de-6-chong-zhuang-tai-shi">Q： 线程的6种状态是：</a></li>
<li><a href="#q-java-xian-cheng-shi-me-shi-hou-hui-jin-ru-zu-sai-ke-neng-an-duo-xuan-ti-kao">Q： java线程什么时候会进入阻塞（可能按多选题考）：</a></li>
</ul>
</li>
<li><a href="#volatile">Volatile</a>
<ul>
<li><a href="#q-bu-yong-volatile-xiu-shi-cheng-yuan-bian-liang-shi-wei-shi-me-qi-ta-xian-cheng-hui-wu-fa-li-ji-kan-dao-gai-bian">Q： 不用volatile修饰成员变量时， 为什么其他线程会无法立即看到改变？</a></li>
<li><a href="#q-yong-liao-volatile-shi-bu-shi-jiu-ke-yi-bu-yong-jia-suo-la">Q： 用了volatile是不是就可以不用加锁啦？</a></li>
<li><a href="#q-zhan-shi-yi-duan-java-bing-fa-bian-cheng-shi-zhan-shu-li-de-yi-ge-jing-dian-li-zi-wei-shi-me-xia-mian-zhe-ge-li-zi-ke-neng-hui-si-xun-huan-huo-zhe-shu-chu-0">Q:展示一段《Java并发编程实战》书里的一个经典例子，为什么下面这个例子可能会死循环，或者输出0？</a></li>
<li><a href="#q-volatile-bian-liang-ru-guo-ding-yi-de-tai-duo-hui-fa-sheng-shi-me">Q: volatile变量如果定义的太多会发生什么？</a></li>
</ul>
</li>
<li><a href="#xian-cheng-qun-zu">线程群组</a>
<ul>
<li><a href="#q-zai-xian-cheng-a-zhong-chuang-jian-xian-cheng-b-ta-men-shu-yu-tong-yi-ge-xian-cheng-zu-ma">Q：在线程A中创建线程B， 他们属于同一个线程组吗</a></li>
<li><a href="#q-na-wo-gai-cheng-gou-zao-guan-xi-shang-de-fu-zi-guan-xi-xia-mian-shu-chu-shi-me">Q： 那我改成构造关系上的父子关系，下面输出什么？</a></li>
<li><a href="#q-ru-guo-wo-rang-zi-ji-zuo-set-bu-zhuo-qi-de-cao-zuo-ni-na-xia-mian-zhe-ge-shu-chu-shi-me">Q：如果我让自己做set捕捉器的操作呢？那下面这个输出什么？</a></li>
<li><a href="#xiu-gai-yi-xia-zhi-qian-de-zong-jie-yi-xia-xian-cheng-de-shi-ji-yi-chang-pao-chu-pan-duan-luo-ji">修改一下之前的总结一下线程的实际异常抛出判断逻辑：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="thread-lei-ji-chu">Thread类基础</span><a href="#thread-lei-ji-chu" class="header-anchor">#</a></h1>
<h2><span id="q-thread-de-deprecated-guo-qi-fang-fa-shi-na-3-ge-zuo-yong-shi-sha">Q： Thread的deprecated过期方法是哪3个？作用是啥</span><a href="#q-thread-de-deprecated-guo-qi-fang-fa-shi-na-3-ge-zuo-yong-shi-sha" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>stop()， 终止线程的执行。</li>
<li>suspend()， 暂停线程执行。</li>
<li>resume()， 恢复线程执行。</li>
</ul>
<hr>
<h2><span id="q-fei-qi-stop-de-yuan-yin-shi-sha">Q： 废弃stop的原因是啥？</span><a href="#q-fei-qi-stop-de-yuan-yin-shi-sha" class="header-anchor">#</a></h2>
<p>A：<br>
调用stop时，会直接终止线程并释放线程上已锁定的锁，线程内部无法感知，<em><strong>并且不会做线程内的catch操作</strong></em>！<br>
即线程内部不会处理stop后的烂摊子。如果其他线程等在等着上面的锁去取数据， 那么拿到的可能是1个半成品。<br>
变成题目的话应该是下面这样，问会输出什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">        <span class="comment">// thread.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//处理烂摊子,清理资源</span></span><br><span class="line">            System.out.println(<span class="string">&quot;clear resource!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是输出 start和run，但是不会输出clear resource</p>
<hr>
<h2><span id="q-stop-de-ti-dai-fang-fa-shi-shi-me">Q： stop的替代方法是什么？</span><a href="#q-stop-de-ti-dai-fang-fa-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： interrupt()。<br>
调用thread.interrupt()终止时，  不会直接释放锁，可通过调用interrupt()或者捕捉sleep产生的中断异常，来判断是否被终止，并处理烂摊子。<br>
上题把thread.stop()改成thread.interrupt()，在Thread.sleep()过程中就会抛出interrupException（注意，InterrupExcetpion是sleep抛出的）<br>
因此就会输出clear resource。<br>
如果没有做sleep操作， 可以用isInterrupted()来判断自己这个线程是否被终止了，来做清理。<br>
另外注意一下interrupt和isInterrupted的区别：<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147310174077755.png" alt="image.png"></p>
<hr>
<h2><span id="q-suspend-resume-de-fei-qi-yuan-yin-shi-shi-me">Q： suspend/resume的废弃原因是什么？</span><a href="#q-suspend-resume-de-fei-qi-yuan-yin-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： ：调用suspend不会释放锁。<br>
如果线程A暂停后，他的resume是由线程B来调用的，但是线程B又依赖A里的某个锁，那么就死锁了。<br>
例如下面这个例子，就要知道会引发死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程试图占用lockObject锁资源&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">            <span class="comment">// 用Test.lockObject做一些事</span></span><br><span class="line">            System.out.println(<span class="string">&quot;做一些事&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复&quot;</span>);</span><br><span class="line">        thread.resume();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;占用Test.lockObject&quot;</span>);</span><br><span class="line">                suspend();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread释放TestlockObject锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案输出<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147342840021209.png" alt="image.png"></p>
<p>MyThread内部暂停后，外部的main因为没法拿到锁，所以无法执行后面的resume操作。</p>
<hr>
<h2><span id="q-shang-ti-de-suspend-he-resume-ke-yi-zen-me-ti-huan-lai-jie-jue-si-suo-wen-ti">Q： 上题的suspend和resume可以怎么替换，来解决死锁问题？</span><a href="#q-shang-ti-de-suspend-he-resume-ke-yi-zen-me-ti-huan-lai-jie-jue-si-suo-wen-ti" class="header-anchor">#</a></h2>
<p>A： 可以用wait和noitfy来处理（不过尽量不要这样设计，一般都是用run内部带1个while循环的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//拿来做临时锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程试图占用lockObject锁资源&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">            <span class="comment">// 用Test.lockObject做一些事</span></span><br><span class="line">            System.out.println(<span class="string">&quot;做一些事&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">            Test.lockObject.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.lockObject) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;占用Test.lockObject&quot;</span>);</span><br><span class="line">                Test.lockObject.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread释放TestlockObject锁资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如此执行，结果正常：<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147354886034832.png" alt="image.png"></p>
<hr>
<h2><span id="q-xia-mian-zhe-li-zi-wei-shi-me-hui-yun-xing-yi-chang-pao-chu-illegalmonitorstateexception-cuo-wu">Q： 下面这例子为什么会运行异常，抛出IllegalMonitorStateException错误？</span><a href="#q-xia-mian-zhe-li-zi-wei-shi-me-hui-yun-xing-yi-chang-pao-chu-illegalmonitorstateexception-cuo-wu" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： notify和wait的使用前提是必须持有这个对象的锁， 即main代码块 需要先持有thread对象的锁，才能使用notify去唤醒（wait同理）。<br>
改成下面就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">    thread.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="q-wei-shi-me-wait-bi-xu-chi-you-suo-de-shi-hou-cai-neng-diao-yong">Q: 为什么wait必须持有锁的时候才能调用？</span><a href="#q-wei-shi-me-wait-bi-xu-chi-you-suo-de-shi-hou-cai-neng-diao-yong" class="header-anchor">#</a></h2>
<p>A:<br>
因为wait和notify是组合使用的。</p>
<ul>
<li>一般是到了一定条件例如缺少资源、缺乏某个前置动作时，才会进入wait。</li>
<li>这时候生产资源的那个线程生产了新资源后，就会调用notify方法，告诉另一个线程，我做好了，你可以动身了。</li>
<li>但如果我们不先加同步块， 就可能导致 wait之前的判断条件有问题，即先判断缺资源， 然后切到另一个线程 做了资源生产并notify， 这时候再wait已经没有意义了, 永远收不到notify。  ”即如果不在同步块中，则wait的判断条件或者wait时机可能是有问题的！“<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/set-cookie/p/8686218.html">为什么WAIT必须在同步块中</a></li>
</ul>
<hr>
<h2><span id="q-thread-sleep-he-object-wait-de-qu-bie">Q： Thread.sleep()和Object.wait()的区别</span><a href="#q-thread-sleep-he-object-wait-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
sleep不会释放对象锁， 而wait会释放对象锁。</p>
<hr>
<h2><span id="q-ru-guo-you-3-ge-xian-cheng-tong-shi-qiang-zhan-liao-zhe-ge-suo-qie-du-zai-wait-wo-xi-wang-zhi-notify-huan-xing-mou-ge-xian-cheng-zen-me-ban">Q: 如果有3个线程同时抢占了这个锁且都在wait，我希望只notify唤醒某个线程，怎么办？</span><a href="#q-ru-guo-you-3-ge-xian-cheng-tong-shi-qiang-zhan-liao-zhe-ge-suo-qie-du-zai-wait-wo-xi-wang-zhi-notify-huan-xing-mou-ge-xian-cheng-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>使用LockSupport,  可以unPark指定的线程。<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/0904c96f81872d9d57deb7cc7cf5e9afb0601039.png" alt="0904c96f81872d9d57deb7cc7cf5e9afb0601039"></li>
<li>使用Lock + Condition 实现唤醒指定的部分线程。即锁是同一个，但是可以针对锁生成的特定condition做唤醒<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/799b48eaf23750316d096f97237b0cca42e2332f.png" alt="799b48eaf23750316d096f97237b0cca42e2332f"><br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/3ad4a174c3b5b160dc51501502f57c2fe62cdcb5.png" alt="3ad4a174c3b5b160dc51501502f57c2fe62cdcb5"></li>
</ol>
<hr>
<h2><span id="q-locksupport-xiang-bi-notify-wait-you-shi-me-you-dian">Q: LockSupport相比notify/wait有什么优点？</span><a href="#q-locksupport-xiang-bi-notify-wait-you-shi-me-you-dian" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>LockSupport不需要在同步代码块里 。所以线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦。</li>
<li>unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序。</li>
</ol>
<hr>
<h2><span id="q-runnable-jie-kou-he-callable-de-qu-bie">Q：Runnable接口和Callable的区别。</span><a href="#q-runnable-jie-kou-he-callable-de-qu-bie" class="header-anchor">#</a></h2>
<p>A： Callable可以和Futrue配合，并且启动线程时用的时call，能够拿到线程结束后的返回值，call方法还能抛出异常。</p>
<hr>
<h2><span id="q-thread-alive-biao-shi-xian-cheng-dang-qian-shi-fou-chu-yu-huo-yue-ke-yong-zhuang-tai-thread-start-hou-shi-fou-alive-yi-ding-fan-hui-true">Q：thread.alive()表示线程当前是否处于活跃/可用状态。thread.start()后，是否alive()一定返回true？</span><a href="#q-thread-alive-biao-shi-xian-cheng-dang-qian-shi-fou-chu-yu-huo-yue-ke-yong-zhuang-tai-thread-start-hou-shi-fou-alive-yi-ding-fan-hui-true" class="header-anchor">#</a></h2>
<p>活跃状态： 线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestThread</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Begin == &quot;</span> + tt.isAlive());</span><br><span class="line">        tt.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;end == &quot;</span> + tt.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
不一定，有可能在打印时，线程已经运行结束了，或者start后，还未真正启动起来（就是还没进入到run中）</p>
<hr>
<h2><span id="q-xian-cheng-a-ru-xia-ba-xian-cheng-a-zuo-wei-gou-zao-can-shu-chuan-gei-xian-cheng-b-ci-shi-dui-b-xian-cheng-da-yin-this-isalive-hui-xian-shi-shi-me">Q: 线程A如下，把线程A作为构造参数，传给线程B，此时对B线程打印this.isAlive会显示什么？：</span><a href="#q-xian-cheng-a-ru-xia-ba-xian-cheng-a-zuo-wei-gou-zao-can-shu-chuan-gei-xian-cheng-b-ci-shi-dui-b-xian-cheng-da-yin-this-isalive-hui-xian-shi-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this.isAlive()=&quot;</span> + <span class="built_in">this</span>.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(a);</span><br><span class="line">b.start()</span><br></pre></td></tr></table></figure>
<p>A：<br>
此时会打印false!<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147372933056462.png" alt="image.png"></p>
<p>因为把a作为构造参数传入b中， b执行start时， 实际上是在B线程中去调用了 A对象的run方法，而不是启用了A线程。<br>
如果改成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.start()</span><br></pre></td></tr></table></figure>
<p>那么就会打印true了</p>
<hr>
<h2><span id="q-ba-futuretask-fang-jin-thread-zhong-bing-start-hou-hui-zheng-chang-zhi-xing-callable-li-de-nei-rong-ma">Q：把FutureTask放进Thread中，并start后，会正常执行callable里的内容吗？</span><a href="#q-ba-futuretask-fang-jin-thread-zhong-bing-start-hou-hui-zheng-chang-zhi-xing-callable-li-de-nei-rong-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;call 100&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
能正常打印</p>
<h1><span id="synchronized-guan-jian-zi">synchronized关键字</span><a href="#synchronized-guan-jian-zi" class="header-anchor">#</a></h1>
<ul>
<li>即可作为方法的修饰符，也可以作为代码块的修饰符</li>
<li>注意修饰方法时，并不是这个方法上有锁， 而是调用该方法时，需要取该方法所在对象上的锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">     synchroized <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即调用这个f()， 并不是说f同一时刻只能进入一次，而是说进入f时，需要取到A上的锁。</p>
<hr>
<h2><span id="q-diao-yong-xia-mian-de-f-shi-hui-chu-xian-si-suo-ma">Q： 调用下面的f()时，会出现死锁吗？</span><a href="#q-diao-yong-xia-mian-de-f-shi-hui-chu-xian-si-suo-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">     synchroized <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        t()</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     synchroized <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：不会。<br>
1个线程内， 可以重复进入1个对象的synchroized 块。</p>
<ul>
<li>
<p>原理：<br>
当线程请求自己的锁时。JVM会记下锁的持有者，并且给这个锁计数为1。<br>
如果该线程再次请求自己的锁，则可以再次进入，计数为2.<br>
退出时计数-1.<br>
直到全部退出时才会释放锁。</p>
</li>
<li>
<p>目的是为了避免死锁。万一 1个对象在sync方法中调用另一个sync方法，如果是非重入的，就可能导致自己把自己锁住了。</p>
</li>
</ul>
<blockquote>
<blockquote>
<p>sync和JUC-Lock都是可重入锁，原理类似。</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="q-2-ge-xian-cheng-tong-shi-diao-yong-f1-he-f2-hui-chan-sheng-tong-bu-ma">Q:2个线程同时调用f1和f2会产生同步吗？</span><a href="#q-2-ge-xian-cheng-tong-shi-diao-yong-f1-he-f2-hui-chan-sheng-tong-bu-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
不会产生同步。二者不是1个锁。<br>
f1是类锁，等同于synchronized(A.class)<br>
f2是对象锁。</p>
<h1><span id="qi-ta-de-tong-bu-gong-ju">其他的同步工具</span><a href="#qi-ta-de-tong-bu-gong-ju" class="header-anchor">#</a></h1>
<h2><span id="countdownlatch">CountDownLatch</span><a href="#countdownlatch" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>2是计数器初始值。<br>
然后执行latch.await()时， 就会阻塞，直到其他线程中把这个latch进行latch.countDown()，并且计数器降低至0。</p>
<ul>
<li>和join的区别：<br>
join阻塞时，是只等待单个线程的完成<br>
而CountDownLatch可能是为了等待多个线程</li>
</ul>
<hr>
<h3><span id="q-countdownlatch-de-nei-bu-ji-shu-zhi-neng-bei-chong-zhi-ma">Q： countDownLatch的内部计数值能被重置吗？</span><a href="#q-countdownlatch-de-nei-bu-ji-shu-zhi-neng-bei-chong-zhi-ma" class="header-anchor">#</a></h3>
<p>A：<br>
不能重置了。如果要重新计数必须重新new一个。毕竟他的类名就叫DownLatch</p>
<h2><span id="futuretask">FutureTask</span><a href="#futuretask" class="header-anchor">#</a></h2>
<p>可以理解为一个支持有返回值的线程<br>
FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(runable);<br>
当调用task.get()时，就能能达到线程里的返回值</p>
<hr>
<h3><span id="q-diao-yong-futruetask-get-shi-zhe-ge-shi-zu-sai-fang-fa-ma-ru-guo-shi-zu-sai-shi-me-shi-hou-hui-jie-shu">Q：调用futrueTask.get()时，这个是阻塞方法吗？如果是阻塞，什么时候会结束？</span><a href="#q-diao-yong-futruetask-get-shi-zhe-ge-shi-zu-sai-fang-fa-ma-ru-guo-shi-zu-sai-shi-me-shi-hou-hui-jie-shu" class="header-anchor">#</a></h3>
<p>A：<br>
是阻塞方法。</p>
<ol>
<li>线程跑完并返回结果</li>
<li>阻塞时间达到futrueTask.get(xxx)里设定的xxx时间</li>
<li>线程出现异常InterruptedException或者ExecutionException</li>
<li>线程被取消，抛出CancellationException</li>
</ol>
<h2><span id="semaphore">Semaphore</span><a href="#semaphore" class="header-anchor">#</a></h2>
<h3><span id="xin-hao-liang-gai-nian">信号量概念</span><a href="#xin-hao-liang-gai-nian" class="header-anchor">#</a></h3>
<p>就是操作系统里常见的那个概念，java实现，用于各线程间进行资源协调。<br>
用Semaphore(permits)构造一个包含permits个资源的信号量<br>
然后某线程做了消费动作， 则执行semaphore.acquire()，则会消费一个资源<br>
如果某线程做了生产动作，则执行semaphore.release()，则会释放一个资源（即新增一个资源）<br>
更详细的信号量方法说明：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/hanchao5272/article/details/79780045">https://blog.csdn.net/hanchao5272/article/details/79780045</a></p>
<hr>
<h3><span id="q-xin-hao-liang-zhong-gong-ping-mo-shi-he-fei-gong-ping-mo-shi-de-qu-bie-xia-mian-she-cheng-true-jiu-shi-gong-ping-mo-shi">Q： 信号量中，公平模式和非公平模式的区别？下面设成true就是公平模式</span><a href="#q-xin-hao-liang-zhong-gong-ping-mo-shi-he-fei-gong-ping-mo-shi-de-qu-bie-xia-mian-she-cheng-true-jiu-shi-gong-ping-mo-shi" class="header-anchor">#</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new Semaphore(permits,fair):初始化许可证数量和是否公平模式的构造函数</span></span><br><span class="line">semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>A：<br>
其实就是使用哪种公平锁还是非公平锁。<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147404856001732.png" alt="image.png"></p>
<p>Java并发中的NonfairSync（非公平）和fairSync（公平）主要区别为：</p>
<ul>
<li>如果当前线程不是锁的占有者,则NonfairSync并不判断是否有等待队列,直接使用compareAndSwap去进行锁的占用,即谁正好抢到，就给谁用！</li>
<li>如果当前线程不是锁的占有者,则FairSync则会判断当前是否有等待队列,如果有则将自己加到等待队列尾，即严格的先到先得！</li>
</ul>
<h2><span id="cyclicbarrier-zha-lan">CyclicBarrier （栅栏）</span><a href="#cyclicbarrier-zha-lan" class="header-anchor">#</a></h2>
<p>栅栏，一般是在线程中去调用的<br>
它的构造需要指定1个线程数量，和栅栏被破坏前要执行的操作<br>
每当有1个线程调用barrier.await()，就会进入阻塞，同时barrier里的线程计数-1。<br>
当线程计数为0时，  调用栅栏里指定的那个操作后，然后破坏栅栏， 所有被阻塞在await上的线程继续往下走。</p>
<h2><span id="exchanger-jiao-huan-zha-lan">Exchanger  （交换栅栏）</span><a href="#exchanger-jiao-huan-zha-lan" class="header-anchor">#</a></h2>
<p>我理解为两方栅栏，用于交换数据。<br>
简单说就是一个线程在完成一定的事务后，想与另一个线程交换数据<br>
则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据</p>
<h2><span id="yuan-zi-lei-atomicxxx">原子类AtomicXXX</span><a href="#yuan-zi-lei-atomicxxx" class="header-anchor">#</a></h2>
<p>就是内部已实现了原子同步机制</p>
<h3><span id="q-xia-mian-shu-chu-shi-me-kao-cha-getandadd-de-yong-fa">Q：下面输出什么？（考察getAndAdd的用法）</span><a href="#q-xia-mian-shu-chu-shi-me-kao-cha-getandadd-de-yong-fa" class="header-anchor">#</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(num.getAndAdd(<span class="number">1</span>));</span><br><span class="line">System.out.println(num.get());</span><br></pre></td></tr></table></figure>
<p>A：<br>
输出1、2<br>
顾名思义， getAndAdd(),那么就是先get，再加， 类似于num++。<br>
如果是addAndGet()，那么就是++num</p>
<hr>
<h3><span id="q-atomicreference-he-atomicinteger-de-qu-bie">Q：AtomicReference和AtomicInteger的区别？</span><a href="#q-atomicreference-he-atomicinteger-de-qu-bie" class="header-anchor">#</a></h3>
<p>A：<br>
AtomicInteger是对整数的封装，而AtomicReference则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。<br>
即可能会有多个线程修改atomicReference里包含的引用。</p>
<ul>
<li>经典用法：<br>
boolean exchanged = atomicStringReference.compareAndSet(initialReference, newReference)<br>
就是经典的CAS同步法<br>
compreAndSet它会将将引用与预期值（引用）进行比较，如果它们相等，则在AtomicReference对象内设置一个新的引用。类似于一个非负责的自旋锁。</li>
</ul>
<hr>
<ul>
<li>AtomicReferenceArray是原子数组， 可以进行一些原子的数组操作例如 set(index, value)，</li>
</ul>
<hr>
<h3><span id="java-zhong-yi-shi-xian-de-quan-bu-yuan-zi-lei">java中已实现的全部原子类：</span><a href="#java-zhong-yi-shi-xian-de-quan-bu-yuan-zi-lei" class="header-anchor">#</a></h3>
<p><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147422534053370.png" alt="image.png"></p>
<p>注意，没有float，没有short和byte。</p>
<hr>
<h1><span id="xian-cheng-chi">线程池</span><a href="#xian-cheng-chi" class="header-anchor">#</a></h1>
<hr>
<h2><span id="q-threadpoolexecutor-xian-cheng-chi-gou-zao-can-shu-zhong-corepoolsize-he-maximumpoolsize-you-shi-me-qu-bie">Q: ThreadPoolExecutor线程池构造参数中，corePoolSize和maximumPoolSize有什么区别？</span><a href="#q-threadpoolexecutor-xian-cheng-chi-gou-zao-can-shu-zhong-corepoolsize-he-maximumpoolsize-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
当提交新线程到池中时</p>
<ul>
<li>如果当前线程数 &lt; corePoolSize，则会创建新线程</li>
<li>如果当前线程数=corePoolSize，则新线程被塞进一个队列中等待。</li>
<li>如果队列也被塞满了，那么又会开始新建线程来运行任务，避免任务阻塞或者丢弃</li>
<li>如果队列满了的情况下， 线程总数超过了maxinumPoolSize，那么就抛异常或者阻塞（取决于队列性质）。</li>
</ul>
<hr>
<ul>
<li>调用prestartCoreThread()可提前开启一个空闲的核心线程</li>
<li>调用prestartAllCoreThreads()，可提前创建corePoolSize个核心线程。</li>
</ul>
<hr>
<h2><span id="q-xian-cheng-chi-de-keepalive-can-shu-shi-gan-ma-de">Q： 线程池的keepalive参数是干嘛的？</span><a href="#q-xian-cheng-chi-de-keepalive-can-shu-shi-gan-ma-de" class="header-anchor">#</a></h2>
<p>A：当线程数量在corePoolSize到maxinumPoolSize之间时， 如果有线程已跑完，且空闲时间超过keepalive时，则会被清除（注意只限于corePoolSize到maxinumPoolsize之间的线程）</p>
<hr>
<h2><span id="q-he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia">Q: 核心线程可以被回收吗？（线程池没有被回收的情况下）</span><a href="#q-he-xin-xian-cheng-ke-yi-bei-hui-shou-ma-xian-cheng-chi-mei-you-bei-hui-shou-de-qing-kuang-xia" class="header-anchor">#</a></h2>
<p>A:<br>
ThreadPoolExecutor有个allowCoreThreadTimeOut(boolean value)方法，可以设置是否在超期后做回收</p>
<hr>
<h2><span id="q-na-zhe-ge-xian-cheng-shu-she-zhi-duo-shao-ni-shi-zen-me-kao-lu-de-ni">Q: 那这个线程数设置多少，你是怎么考虑的呢？</span><a href="#q-na-zhe-ge-xian-cheng-shu-she-zhi-duo-shao-ni-shi-zen-me-kao-lu-de-ni" class="header-anchor">#</a></h2>
<p>A:<br>
io密集型， 可以设置多一点， 因为多一个线程，他可能也没太占cpu，都是在等待IO。<br>
如果是计算密集型，则要设置少一点，别把cpu搞满载了。</p>
<p>有超线程技术的话， 一般可以设置成2倍CPU数量的线程数</p>
<blockquote>
<blockquote>
<p>超线程技术把多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="q-xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue">Q： 线程池有哪三种队列策略？</span><a href="#q-xian-cheng-chi-you-na-san-chong-dui-lie-ce-lue" class="header-anchor">#</a></h2>
<p>A：</p>
<ol>
<li>握手队列<br>
相当于不排队的队列。可能造成线程数量无限增长直到超过maxinumPoolSize（相当于corePoolSize没什么用了，只以maxinumPoolSize做上限）</li>
<li>无界队列<br>
队列队长无限，即线程数量达到corePoolSize时，后面的线程只会在队列中等待。（相当于maxinumPoolSize没什么用了）<br>
缺陷： 可能造成队列无限增长以至于OOM</li>
<li>有界队列</li>
</ol>
<hr>
<h2><span id="q-xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue">Q： 线程池队列已满且maxinumPoolSize已满时，有哪些拒绝策略？</span><a href="#q-xian-cheng-chi-dui-lie-yi-man-qie-maxinumpoolsize-yi-man-shi-you-na-xie-ju-jue-ce-lue" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>AbortPolicy 默认策略：直接抛出RejectedExecutionException异常</li>
<li>DiscardPolicy 丢弃策略： 直接丢了，什么错误也不报</li>
<li>DiscardOldestPolicy 丢弃队头策略： 即把最先入队的人从队头扔出去，再尝试让该任务进入队尾（队头任务内心：不公平。。。。）</li>
<li>CallerRunsPolicy 调用者处理策略： 交给调用者所在线程自己去跑任务（即谁调用的submit或者execute，他就自己去跑） <strong>注意这个策略会用的比较多</strong></li>
<li>也可以用实现自定义新的RejectedExecutionHandler</li>
</ul>
<hr>
<h2><span id="q-xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie">Q:  线程池为什么需要阻塞队列？</span><a href="#q-xian-cheng-chi-wei-shi-me-xu-yao-zu-sai-dui-lie" class="header-anchor">#</a></h2>
<p>A:<br>
线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。避免大量线程获取这个创建锁。</p>
<hr>
<h2><span id="q-you-yi-xia-wu-chong-executor-ti-gong-de-xian-cheng-chi-zhu-yi-ji-yi-yi-xia-ta-men-de-yong-tu-jiu-neng-li-jie-nei-bu-de-yuan-li-liao">Q：有以下五种Executor提供的线程池，注意记忆一下他们的用途，就能理解内部的原理了。</span><a href="#q-you-yi-xia-wu-chong-executor-ti-gong-de-xian-cheng-chi-zhu-yi-ji-yi-yi-xia-ta-men-de-yong-tu-jiu-neng-li-jie-nei-bu-de-yuan-li-liao" class="header-anchor">#</a></h2>
<ul>
<li>
<p>newCachedThreadPool： 缓存线程池<br>
corePoolSize=0, maxinumPoolSize=+∞，队列长度=0 ，<br>
因此线程数量会在corePoolSize到maxinumPoolSize之间一直灵活缓存和变动， 且不存在队列等待的情况，一来任务我就创建，用完了会释放。<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147438780044960.png" alt="image.png"></p>
</li>
<li>
<p>newFixedThreadPool ：定长线程池<br>
corePoolSize= maxinumPoolSize=构造参数值， 队列长度=+∞。<br>
因此不存在线程不够时扩充的情况</p>
</li>
<li>
<p>newScheduledThreadPool :定时器线程池<br>
提交定时任务用的，构造参数里会带定时器的间隔和单位。 其他和FixedThreadPool相同，属于定长线程池。</p>
</li>
<li>
<p>newSingleThreadExecutor : 单线程池<br>
corePoolSize=maxinumPoolSize=1， 队列长度=+∞<br>
只会跑一个任务， 所以其他的任务都会在队列中等待，因此会严格按照FIFO执行</p>
</li>
<li>
<p>newWorkStealingPool（继承自ForkJoinPool ）： 并行线程池<br>
如果你的任务执行时间很长，并且里面的任务运行并行跑的，那么他会把你的线程任务再细分到其他的线程来分治。<br>
ForkJoinPool介绍：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37542889/article/details/92640903">https://blog.csdn.net/m0_37542889/article/details/92640903</a></p>
</li>
</ul>
<p>A：</p>
<hr>
<h2><span id="q-submit-he-execute-de-qu-bie-shi-shi-me">Q： submit和execute的区别是什么？</span><a href="#q-submit-he-execute-de-qu-bie-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>execute只能接收Runnable类型的任务，而submit除了Runnable，还能接收Callable（Callable类型任务支持返回值）</li>
<li>execute方法返回void，  submit方法返回FutureTask。</li>
<li>异常方面， submit方法因为返回了futureTask对象，而当进行future.get()时，会把线程中的异常抛出，因此调用者可以方便地处理异常。（如果是execute，只能用内部捕捉或者设置catchHandler）</li>
</ul>
<hr>
<h2><span id="q-xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie">Q：线程池中， shutdown、 shutdownNow、awaitTermination的区别？</span><a href="#q-xian-cheng-chi-zhong-shutdown-shutdownnow-awaittermination-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>shutdown: 停止接收新任务，等待所有池中已存在任务完成（ <em><strong>包括等待队列中的线程</strong></em> ）。异步方法，即调用后马上返回。</li>
<li>shutdownNow: 停止接收新任务，并 <em><strong>停止所有正执行的task</strong></em>，返回还在队列中的task列表 。</li>
<li>awaitTermination： <em><strong>仅仅是一个判断方法</strong></em>，判断当前线程池任务是否全部结束。一般用在shutdown后面，因为shutdown是异步方法，你需要知道什么时候才真正结束。</li>
</ul>
<hr>
<h1><span id="thread-zhuang-tai-zhuan-huan">Thread状态转换</span><a href="#thread-zhuang-tai-zhuan-huan" class="header-anchor">#</a></h1>
<h2><span id="q-xian-cheng-de-6-chong-zhuang-tai-shi">Q： 线程的6种状态是：</span><a href="#q-xian-cheng-de-6-chong-zhuang-tai-shi" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>New： 新建了线程，但是还没调用start</li>
<li>RUNNABLE： 运行， 就绪状态包括在运行态中</li>
<li>BLOCKED： 阻塞，一般是因为想拿锁拿不到</li>
<li>WAITING： 等待，一般是wait或者join之后</li>
<li>TIMED_WAITING: 定时等待，即固定时间后可返回，一般是调用sleep或者wait(时间)的。</li>
<li>TERMINATED： 终止状态。</li>
</ul>
<hr>
<p>欣赏一幅好图，能了解调用哪些方法会进入哪些状态。<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147455707018197.png" alt="image.png"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22771739/article/details/82529874">原图链接</a></p>
<h2><span id="q-java-xian-cheng-shi-me-shi-hou-hui-jin-ru-zu-sai-ke-neng-an-duo-xuan-ti-kao">Q： java线程什么时候会进入阻塞（可能按多选题考）：</span><a href="#q-java-xian-cheng-shi-me-shi-hou-hui-jin-ru-zu-sai-ke-neng-an-duo-xuan-ti-kao" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>sleep</li>
<li>wati()挂起，  等待获得别的线程发送的Notify（）消息</li>
<li>等待IO</li>
<li>等待锁</li>
</ul>
<h1><span id="volatile">Volatile</span><a href="#volatile" class="header-anchor">#</a></h1>
<p>用volatile修饰成员变量时， 一旦有线程修改了变量，其他线程可立即看到改变。</p>
<hr>
<h2><span id="q-bu-yong-volatile-xiu-shi-cheng-yuan-bian-liang-shi-wei-shi-me-qi-ta-xian-cheng-hui-wu-fa-li-ji-kan-dao-gai-bian">Q： 不用volatile修饰成员变量时， 为什么其他线程会无法立即看到改变？</span><a href="#q-bu-yong-volatile-xiu-shi-cheng-yuan-bian-liang-shi-wei-shi-me-qi-ta-xian-cheng-hui-wu-fa-li-ji-kan-dao-gai-bian" class="header-anchor">#</a></h2>
<p>A：<br>
线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。<br>
这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值。</p>
<hr>
<h2><span id="q-yong-liao-volatile-shi-bu-shi-jiu-ke-yi-bu-yong-jia-suo-la">Q： 用了volatile是不是就可以不用加锁啦？</span><a href="#q-yong-liao-volatile-shi-bu-shi-jiu-ke-yi-bu-yong-jia-suo-la" class="header-anchor">#</a></h2>
<p>A： 不行。</p>
<ul>
<li>锁并不是只保证1个变量的互斥， 有时候是要保证几个成员在连续变化时，让其他线程无法干扰、读取。</li>
<li>而volatile保证1个变量可变， 保证不了几个变量同时变化时的原子性。</li>
</ul>
<hr>
<h2><span id="q-zhan-shi-yi-duan-java-bing-fa-bian-cheng-shi-zhan-shu-li-de-yi-ge-jing-dian-li-zi-wei-shi-me-xia-mian-zhe-ge-li-zi-ke-neng-hui-si-xun-huan-huo-zhe-shu-chu-0">Q:展示一段《Java并发编程实战》书里的一个经典例子，为什么下面这个例子可能会死循环，或者输出0？</span><a href="#q-zhan-shi-yi-duan-java-bing-fa-bian-cheng-shi-zhan-shu-li-de-yi-ge-jing-dian-li-zi-wei-shi-me-xia-mian-zhe-ge-li-zi-ke-neng-hui-si-xun-huan-huo-zhe-shu-chu-0" class="header-anchor">#</a></h2>
<p><img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147466151081835.png" alt="image.png"></p>
<p>A:<br>
首先理解一下java重排序，可以看一下这篇博文：<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/coshaho/p/8093944.html">https://www.cnblogs.com/coshaho/p/8093944.html</a></p>
<p>然后分析后面那2个奇怪的情况是怎么发生的。</p>
<ul>
<li>永远不输出：<br>
经过程序的指令排序，出现了这种情况：</li>
</ul>
<ol>
<li>ReaderThread在while里读取ready值， 此时是false， 于是存入了ReaderThread的寄存器。</li>
<li>主线程修改ready和number。</li>
<li>ReaderThread没有感知到ready的修改（对于ReaderThread线程，感知不到相关的指令，来让他更新ready寄存器的值），因此进入死循环。</li>
</ol>
<ul>
<li>输出0<br>
经过程序的指令排序，出现了这种情况：<br>
1）主线程设置ready为true<br>
2）ReaderThread在while里读取ready值，是true，于是退出while循环</li>
</ul>
<ol start="3">
<li>ReaderThread读取到number值， 此时number还是初始化的值为0，于是输出0</li>
<li>主线程这时候才修改number=42，此时ReaderThread已经结束了！</li>
</ol>
<p>上面这个问题，可以用volatile或者加锁。当你加了锁时， 如果变量被写了，会有指令去更新另一个寄存器的值，因此就可见了。</p>
<hr>
<h2><span id="q-volatile-bian-liang-ru-guo-ding-yi-de-tai-duo-hui-fa-sheng-shi-me">Q: volatile变量如果定义的太多会发生什么？</span><a href="#q-volatile-bian-liang-ru-guo-ding-yi-de-tai-duo-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
volatile有嗅探机制，如果定义过多，可能会引发总线风暴，导致性能下降。</p>
<hr>
<h1><span id="xian-cheng-qun-zu">线程群组</span><a href="#xian-cheng-qun-zu" class="header-anchor">#</a></h1>
<p>为了方便管理一批线程，我们使用ThreadGroup来表示线程组，通过它对一批线程进行分类管理<br>
使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gourp, ()-&gt;&#123;..&#125;);</span><br></pre></td></tr></table></figure>
<p>即thread除了Thread(Runable)这个构造方法外，还有个Thread(ThreadGroup, Runnable)构造方法</p>
<hr>
<h2><span id="q-zai-xian-cheng-a-zhong-chuang-jian-xian-cheng-b-ta-men-shu-yu-tong-yi-ge-xian-cheng-zu-ma">Q：在线程A中创建线程B， 他们属于同一个线程组吗</span><a href="#q-zai-xian-cheng-a-zhong-chuang-jian-xian-cheng-b-ta-men-shu-yu-tong-yi-ge-xian-cheng-zu-ma" class="header-anchor">#</a></h2>
<p>A：<br>
是的</p>
<hr>
<p>线程组的一大作用是对同一个组线程进行统一的异常捕捉处理，避免每次新建线程时都要重新去setUncaghtExceptionHandler。即线程组自身可以实现一个uncaughtException方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group&quot;</span>) &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">		System.out.println(thread.getName() + throwable.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程如果抛出异常，且没有在线程内部被捕捉，那么此时线程异常的处理顺序是什么？<br>
相信很多人都看过下面这段话，好多讲线程组的博客里都这样写：<br>
（1）首先看看当前线程组（ThreadGroup）有没有父类的线程组，如果有，则使用父类的UncaughtException()方法。<br>
（2）如果没有，就看线程是不是调用setUncaughtExceptionHandler()方法建立Thread.setUncaughtExceptionHandler实例。如果建立，直接使用它的UncaughtException()方法处理异常。<br>
（3）如果上述都不成立就看这个异常是不是ThreadDead实例，如果是，什么都不做，如果不是，输出堆栈追踪信息（printStackTrace）。</p>
<blockquote>
<blockquote>
<blockquote>
<p>来源：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43073128/article/details/90597006">https://blog.csdn.net/qq_43073128/article/details/90597006</a><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43073128/article/details/88280469">https://blog.csdn.net/qq_43073128/article/details/88280469</a></p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>好，别急着记，先看一下下面的题目，问输出什么：<br>
Q:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类线程组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GroupFather</span> <span class="keyword">extends</span> <span class="title class_">ThreadGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupFather</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;groupFather=&quot;</span> + throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 子类线程组</span></span><br><span class="line">    <span class="type">GroupFather</span> <span class="variable">groupSon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupFather</span>(<span class="string">&quot;groupSon&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;groupSon=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(groupSon, ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我异常了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
一看（1），那是不是应该输出groupFather?<br>
错错错，输出的是groupSon这句话在很多地方能看到，但没有去实践过看过源码的人就会这句话被误导。<br>
实际上父线程组不是指类继承关系上的线程组，而是指下面这样的：<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147483889080721.png" alt="image.png"></p>
<p>即指的是构造关系的有父子关系。<br>
如果子类的threadGroup没有去实现uncaughtException方法，那么就会去构造参数里指定的父线程组去调用方法。</p>
<hr>
<h2><span id="q-na-wo-gai-cheng-gou-zao-guan-xi-shang-de-fu-zi-guan-xi-xia-mian-shu-chu-shi-me">Q： 那我改成构造关系上的父子关系，下面输出什么？</span><a href="#q-na-wo-gai-cheng-gou-zao-guan-xi-shang-de-fu-zi-guan-xi-xia-mian-shu-chu-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 父线程组</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">groupFather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;groupFather&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;groupFather=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程组,把groupFather作为parent参数</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">groupSon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(groupFather, <span class="string">&quot;groupSon&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;groupSon=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(groupSon, ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我异常了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
答案输出<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147498561059637.png" alt="image.png"></p>
<p>即只要子线程组有实现过，则会用子线程组里的方法，而不是直接去找的父线程组！</p>
<hr>
<h2><span id="q-ru-guo-wo-rang-zi-ji-zuo-set-bu-zhuo-qi-de-cao-zuo-ni-na-xia-mian-zhe-ge-shu-chu-shi-me">Q：如果我让自己做set捕捉器的操作呢？那下面这个输出什么？</span><a href="#q-ru-guo-wo-rang-zi-ji-zuo-set-bu-zhuo-qi-de-cao-zuo-ni-na-xia-mian-zhe-ge-shu-chu-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 父线程组</span></span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;group&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group=&quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建一个线程，在线程组内</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我异常了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己设置setUncaughtExceptionHandler方法</span></span><br><span class="line">    thread1.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no gourp:&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
看之前的结论里，似乎是应该输出线程组的异常？<br>
但是结果却输出的是：<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147507452005732.png" alt="image.png"></p>
<p>也就是说，如果线程对自己特地执行过setUncaughtExceptionHandler，那么有优先对自己设置过的UncaughtExceptionHandler做处理。</p>
<p>那难道第（2）点这个是错的吗？确实错了，实际上第二点应该指的是全局Thread的默认捕捉器，注意是全局的<br>
实际上那段话出自ThreadGroup里uncaughtException的源码：<br>
<img src="/images/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/1619147517593022275.png" alt="image.png"></p>
<p>这里就解释了之前的那三点，但是该代码中没考虑线程自身设置了捕捉器</p>
<hr>
<h2><span id="xiu-gai-yi-xia-zhi-qian-de-zong-jie-yi-xia-xian-cheng-de-shi-ji-yi-chang-pao-chu-pan-duan-luo-ji">修改一下之前的总结一下线程的实际异常抛出判断逻辑：</span><a href="#xiu-gai-yi-xia-zhi-qian-de-zong-jie-yi-xia-xian-cheng-de-shi-ji-yi-chang-pao-chu-pan-duan-luo-ji" class="header-anchor">#</a></h2>
<ol>
<li>如果线程自身有进行过setUncaughtExceptionHandler,则使用自己设置的按个。</li>
<li>如果没设置过，则看一下没有线程组。并按照以下逻辑判断:<br>
如果线程组有覆写过uncaughtException，则用覆写过的uncaughtException<br>
如果线程组没有覆写过，则去找父线程组（注意是构造体上的概念）的uncaughtException方法。</li>
<li>如果线程组以及父类都没覆写过uncaughtException， 则判断是否用Thread.setDefaultUncaughtExceptionHandler(xxx)去设置全局的默认捕捉器，有的话则用全局默认</li>
<li>如果不是ThreadDeath线程， 则只打印堆栈。</li>
<li>如果是ThreadDeath线程，那么就什么也不处理。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Java反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 23:31:14 / 修改时间：23:38:33" itemprop="dateCreated datePublished" datetime="2022-08-14T23:31:14+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%8F%8D%E5%B0%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/14/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/Java%E5%8F%8D%E5%B0%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#fan-she">反射</a>
<ul>
<li><a href="#q-diao-yong-lei-dui-xiang-class-he-forname-lei-ming-de-qu-bie">Q： 调用类对象.class 和 forName(类名)的区别？</a></li>
<li><a href="#q-yong-instanceof-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q： 用instanceof 可以和父类比较吗，且会返回true吗？</a></li>
<li><a href="#q-yong-getclass-bing-yong-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q： 用getClass并用== 可以和父类比较吗，且会返回true吗</a></li>
<li><a href="#q-yong-getclass-bing-yong-equals-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma-xia-mian-zhe-yang">Q： 用getClass并用.equals可以和父类比较吗，且会返回true吗，下面这样：</a></li>
<li><a href="#q-getdeclaredxxx-you-na-ji-chong">Q： getDeclaredXXX 有哪几种？</a></li>
<li><a href="#q-getmethods-fan-hui-na-xie-fang-fa-getdeclaredmethods-hui-fan-hui-na-xie-fang-fa">Q：getMethods()返回哪些方法， getDeclaredMethods()会返回哪些方法？</a></li>
<li><a href="#q-fan-she-na-dao-method-dui-xiang-hou-gai-dui-xiang-getmodifiers-shi-gan-ma-de">Q： 反射拿到Method对象后，  该对象.getModifiers() 是干嘛的？</a></li>
<li><a href="#q-xia-mian-zhe-yang-dui-yi-ge-wu-mo-ren-gou-zao-de-lei-zhi-xing-newinstance-hui-fa-sheng-shi-me">Q：下面这样对一个无默认构造的类执行newInstance会发生什么？</a>
<ul>
<li><a href="#q-ru-he-ti-gao-fan-she-de-xiao-lu">Q：如何提高反射的效率？</a></li>
</ul>
</li>
<li><a href="#q-yong-fan-she-huo-qu-dao-de-method-dui-xiang-shi-fan-hui-yi-ge-method-yin-yong-huan-shi-fan-hui-1-ge-kao-bei-de-method-dui-xiang">Q：用反射获取到的method对象， 是返回一个method引用，还是返回1个拷贝的method对象？</a></li>
<li><a href="#q-getmethods-hou-zi-ji-zuo-bian-li-huo-qu-fang-fa-he-getmethod-methodname-zhi-jie-huo-qu-fang-fa-wei-shi-me-xing-neng-hui-you-chai-yi">Q:getMethods()后自己做遍历获取方法和getMethod(methodName) 直接获取方法， 为什么性能会有差异？</a></li>
<li><a href="#q-huo-qu-fang-fa-shi-jvm-nei-bu-qi-shi-you-huan-cun-dan-shi-fan-hui-gei-wai-bu-shi-yi-ran-hui-zuo-kao-bei-na-me-gai-method-de-huan-cun-shi-chi-jiu-cun-zai-de-ma">Q:获取方法时，jvm内部其实有缓存，但是返回给外部时依然会做拷贝。那么该method的缓存是持久存在的吗？</a></li>
<li><a href="#q-fan-she-shi-xian-cheng-an-quan-de-ma">Q： 反射是线程安全的吗?</a></li>
<li><a href="#q-fan-she-de-ju-ti-xing-neng-chai-yi-zai-na">Q: 反射的具体性能差异在哪？</a></li>
<li><a href="#q-wei-shi-me-fan-she-mei-fa-zuo-jit-you-hua-ni">Q: 为什么反射没法做JIT优化呢？</a></li>
</ul>
</li>
<li><a href="#dong-tai-dai-li">动态代理</a>
<ul>
<li><a href="#q-jiang-yi-xia-dong-tai-dai-li-de-zuo-yong-yi-ji-ta-he-jing-tai-dai-li-de-qu-bie">Q: 讲一下动态代理的作用 以及他和静态代理的区别</a></li>
<li><a href="#q-jiang-yi-xia-dong-tai-dai-li-zen-me-yong-de">Q: 讲一下动态代理怎么用的？</a></li>
<li><a href="#q-java-dong-tai-dai-li-de-di-ceng-shi-xian-yuan-li">Q: java动态代理的底层实现原理？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="fan-she">反射</span><a href="#fan-she" class="header-anchor">#</a></h1>
<h2><span id="q-diao-yong-lei-dui-xiang-class-he-forname-lei-ming-de-qu-bie">Q： 调用类对象.class 和 forName(类名)的区别？</span><a href="#q-diao-yong-lei-dui-xiang-class-he-forname-lei-ming-de-qu-bie" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;A&gt; classA = A.class;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;A&gt; classA = Class.forName(<span class="string">&quot;A&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>A： 仅使用.class不能进行第一次静态初始化， forname函数则可以</p>
<hr>
<p>例如B是A的基类,下面这段代码如何？<br>
假设有父子2个类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="q-yong-instanceof-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q：  用instanceof 可以和父类比较吗，且会返回true吗？</span><a href="#q-yong-instanceof-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">if</span> (son <span class="keyword">instanceof</span>  Parent) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a instanof B&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： 可以比较，且返回true。</p>
<hr>
<h2><span id="q-yong-getclass-bing-yong-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma">Q： 用getClass并用== 可以和父类比较吗，且会返回true吗</span><a href="#q-yong-getclass-bing-yong-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma" class="header-anchor">#</a></h2>
<p>比如下面这样， 注意A是B的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">if</span> (son.getClass() == Parent.class)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;son class == Parent.class&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： 不可以，编译就会报错了。和Class&lt;泛型&gt;的 ==号比较有关。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810095068062903.png" alt="image.png"></p>
<p>因为getClass返回的是&lt;? extends Son&gt;， .class返回的是Class&lt;Parent&gt;</p>
<hr>
<h2><span id="q-yong-getclass-bing-yong-equals-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma-xia-mian-zhe-yang">Q： 用getClass并用.equals可以和父类比较吗，且会返回true吗，下面这样：</span><a href="#q-yong-getclass-bing-yong-equals-ke-yi-he-fu-lei-bi-jiao-ma-qie-hui-fan-hui-true-ma-xia-mian-zhe-yang" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">if</span> (son.getClass().equals(Parent.class))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;son class.equals(Parent.class)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： 可以比较，正常编译， 但是会返回false，即不相等！</p>
<hr>
<h2><span id="q-getdeclaredxxx-you-na-ji-chong">Q： getDeclaredXXX 有哪几种？</span><a href="#q-getdeclaredxxx-you-na-ji-chong" class="header-anchor">#</a></h2>
<p>A： 5种：</p>
<ul>
<li>注解Annotation</li>
<li>内部类Classed</li>
<li>构造方法Construcotor</li>
<li>字段Field</li>
<li>方法Method<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810106986007259.png" alt="image.png"></li>
</ul>
<hr>
<h2><span id="q-getmethods-fan-hui-na-xie-fang-fa-getdeclaredmethods-hui-fan-hui-na-xie-fang-fa">Q：getMethods()返回哪些方法，  getDeclaredMethods()会返回哪些方法？</span><a href="#q-getmethods-fan-hui-na-xie-fang-fa-getdeclaredmethods-hui-fan-hui-na-xie-fang-fa" class="header-anchor">#</a></h2>
<p>A：<br>
getMethods()返回   本类、父类、父接口 的public方法<br>
getDeclaredMethods()只 返回本类的 <em><strong>所有</strong></em> 方法</p>
<p>其他getXXX和getDeclaredXXX的区别同理。</p>
<hr>
<p>拿到Filed、Method、Constructor之后咋用</p>
<ul>
<li>Method可以invoke（object， args）</li>
<li>Constructor可以newInstance(Object…)来做构造调用。</li>
<li>Filed可以用get(object)、set(object)来设置属性值。</li>
</ul>
<hr>
<h2><span id="q-fan-she-na-dao-method-dui-xiang-hou-gai-dui-xiang-getmodifiers-shi-gan-ma-de">Q： 反射拿到Method对象后，  该对象.getModifiers() 是干嘛的？</span><a href="#q-fan-she-na-dao-method-dui-xiang-hou-gai-dui-xiang-getmodifiers-shi-gan-ma-de" class="header-anchor">#</a></h2>
<p>A： 返回该方法的修饰符，并且是1个整数。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810116021009939.png" alt="image.png"></p>
<hr>
<h2><span id="q-xia-mian-zhe-yang-dui-yi-ge-wu-mo-ren-gou-zao-de-lei-zhi-xing-newinstance-hui-fa-sheng-shi-me">Q：下面这样对一个无默认构造的类执行newInstance会发生什么？</span><a href="#q-xia-mian-zhe-yang-dui-yi-ge-wu-mo-ren-gou-zao-de-lei-zhi-xing-newinstance-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huawei.test</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> i )</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;i=&quot;</span> +i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> (A)Class.forName(<span class="string">&quot;com.huawei.test.A&quot;</span>).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;ClassNotFoundException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;InstantiationException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;IllegalAccessException&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
打印InstantiationException初始化错误。<br>
因为A没有默认构造器了，所以不可以用newInstance来构造。<br>
应该改成这样,通过获取正确的构造器来进行构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> (A)Class.forName(<span class="string">&quot;A&quot;</span>).getConstructor(<span class="type">int</span>.class).newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h3><span id="q-ru-he-ti-gao-fan-she-de-xiao-lu">Q：如何提高反射的效率？</span><a href="#q-ru-he-ti-gao-fan-she-de-xiao-lu" class="header-anchor">#</a></h3>
<p>A：</p>
<ul>
<li>使用高性能反射包，例如ReflectASM</li>
<li>缓存反射的对象，避免每次都要重复去字节码中获取。（缓存！缓存！）</li>
<li>method反射可设置method.setAccessible(true)来关闭安全检查。</li>
<li>尽量不要getMethods()后再遍历筛选，而直接用getMethod(methodName)来根据方法名获取方法</li>
<li>利用hotspot虚拟机中的反射优化技术（jit技术）<br>
参考资料：<br>
<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000003004720">https://segmentfault.com/q/1010000003004720</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/coding-night/p/10772631.html">https://www.cnblogs.com/coding-night/p/10772631.html</a></li>
</ul>
<hr>
<hr>
<h2><span id="q-yong-fan-she-huo-qu-dao-de-method-dui-xiang-shi-fan-hui-yi-ge-method-yin-yong-huan-shi-fan-hui-1-ge-kao-bei-de-method-dui-xiang">Q：用反射获取到的method对象， 是返回一个method引用，还是返回1个拷贝的method对象？</span><a href="#q-yong-fan-she-huo-qu-dao-de-method-dui-xiang-shi-fan-hui-yi-ge-method-yin-yong-huan-shi-fan-hui-1-ge-kao-bei-de-method-dui-xiang" class="header-anchor">#</a></h2>
<p>A：<br>
反射拿method对象时，   会做一次拷贝，而不是直接返回引用，因此最好对频繁使用的同一个method做缓存，而不是每次都去查找。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810152127031226.png" alt="image.png"></p>
<hr>
<h2><span id="q-getmethods-hou-zi-ji-zuo-bian-li-huo-qu-fang-fa-he-getmethod-methodname-zhi-jie-huo-qu-fang-fa-wei-shi-me-xing-neng-hui-you-chai-yi">Q:getMethods()后自己做遍历获取方法和getMethod(methodName) 直接获取方法， 为什么性能会有差异？</span><a href="#q-getmethods-hou-zi-ji-zuo-bian-li-huo-qu-fang-fa-he-getmethod-methodname-zhi-jie-huo-qu-fang-fa-wei-shi-me-xing-neng-hui-you-chai-yi" class="header-anchor">#</a></h2>
<p>A：<br>
getMethods() 返回method数组时，每个method都做了一次拷贝。<br>
getMethod(methodName)只会返回那个方法的拷贝，  性能的差异就体现在拷贝上。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810160296062066.png" alt="image.png"></p>
<hr>
<h2><span id="q-huo-qu-fang-fa-shi-jvm-nei-bu-qi-shi-you-huan-cun-dan-shi-fan-hui-gei-wai-bu-shi-yi-ran-hui-zuo-kao-bei-na-me-gai-method-de-huan-cun-shi-chi-jiu-cun-zai-de-ma">Q:获取方法时，jvm内部其实有缓存，但是返回给外部时依然会做拷贝。那么该method的缓存是持久存在的吗？</span><a href="#q-huo-qu-fang-fa-shi-jvm-nei-bu-qi-shi-you-huan-cun-dan-shi-fan-hui-gei-wai-bu-shi-yi-ran-hui-zuo-kao-bei-na-me-gai-method-de-huan-cun-shi-chi-jiu-cun-zai-de-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不是持久存在的，内存不足时会被回收。<br>
源码如下：<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810168569077686.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class.ReflectionData&lt;T&gt; <span class="title function_">reflectionData</span><span class="params">()</span> &#123;</span><br><span class="line">    SoftReference&lt;Class.ReflectionData&lt;T&gt;&gt; reflectionData = <span class="built_in">this</span>.reflectionData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">    Class.ReflectionData rd;</span><br><span class="line">    <span class="keyword">return</span> reflectionData != <span class="literal">null</span> &amp;&amp; (rd = (Class.ReflectionData)reflectionData.get()) != <span class="literal">null</span></span><br><span class="line">    &amp;&amp; rd.redefinedCount == classRedefinedCount ? rd : <span class="built_in">this</span>.newReflectionData(reflectionData,     classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/Java%E5%8F%8D%E5%B0%84/1616810176787057104.png" alt="image.png"></p>
<p>可以看到这是一个软引用。<br>
软引用的定义：<br>
内存紧张时可能会被回收，不过也可以通过-XX:SoftRefLRUPolicyMSPerMB参数控制回收的时机，<br>
只要发生GC就会将其回收<br>
如果reflectionData被回收之后，又执行了反射方法，那只能通过newReflectionData方法重新创建一个这样的对象了</p>
<hr>
<h2><span id="q-fan-she-shi-xian-cheng-an-quan-de-ma">Q： 反射是线程安全的吗?</span><a href="#q-fan-she-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h2>
<p>A:<br>
是线程安全的。 获取反射的数据时，通过cas去获取。  cas概念可以见多线程一节。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810186202053338.png" alt="image.png"></p>
<hr>
<h2><span id="q-fan-she-de-ju-ti-xing-neng-chai-yi-zai-na">Q: 反射的具体性能差异在哪？</span><a href="#q-fan-she-de-ju-ti-xing-neng-chai-yi-zai-na" class="header-anchor">#</a></h2>
<p>a普通方法调用<br>
b反射方法调用<br>
c关闭安全检查的反射方法调用，性能差异如下：<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/1616810195773033845.png" alt="image.png"></p>
<p>b反射方法调用和c关闭安全检查的反射方法调用的性能差异在哪？<br>
普通方法调用和关闭安全检查的反射方法调用的性能差异在哪？<br>
A:</p>
<ul>
<li>
<p>安全检查的性能消耗在于<br>
，SecurityManager.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION); 这项检测需要运行时申请 RuntimePermission(“accessDeclaredMembers”)。<br>
所以如果不考虑安全检查， 对反射方法调用invoke时， 应当设置 Method#setAccessible(true)</p>
</li>
<li>
<p>普通方法和反射方法的性能差异在于</p>
</li>
</ul>
<ol>
<li>Method#invoke 方法会对参数做封装和解封操作</li>
<li>需要检查方法可见性</li>
<li>需要校验参数</li>
<li>反射方法难以内联</li>
<li>JIT 无法优化</li>
</ol>
<h2><span id="q-wei-shi-me-fan-she-mei-fa-zuo-jit-you-hua-ni">Q: 为什么反射没法做JIT优化呢？</span><a href="#q-wei-shi-me-fan-she-mei-fa-zuo-jit-you-hua-ni" class="header-anchor">#</a></h2>
<p>A:<br>
我们都知道 Java 代码是需要编译才能在虚拟机里运行的，但其实 Java 的编译期是一段不确定的操作过程。因为它可能是一个前端编译器（如 Javac）把 *.java 文件编译成 *.class 文件的过程；也可能是程序运行期的即时编译器（JIT 编译器，Just In Time Compiler）把字节码文件编译成机器码的过程；还可能是静态提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成本地机器码的过程。<br>
其中即时编译器（JIT）在运行期的优化过程对于程序运行来说更重要，Java虚拟机在编译阶段的代码优化就在这里进行，<br>
由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能要比非反射操作慢，因此应该避免在对性能敏感的应用程序中频繁使用Java反射来创建对象</p>
<h1><span id="dong-tai-dai-li">动态代理</span><a href="#dong-tai-dai-li" class="header-anchor">#</a></h1>
<hr>
<h2><span id="q-jiang-yi-xia-dong-tai-dai-li-de-zuo-yong-yi-ji-ta-he-jing-tai-dai-li-de-qu-bie">Q: 讲一下动态代理的作用 以及他和静态代理的区别</span><a href="#q-jiang-yi-xia-dong-tai-dai-li-de-zuo-yong-yi-ji-ta-he-jing-tai-dai-li-de-qu-bie" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>
<p>作用</p>
<p>先弄一个原始接口类Info，里面提供一些接口例如dealInfo()、getInfo()之类的</p>
<p>然后可以有N个实现了这个接口的各种Info子类。</p>
<p>我们希望这些Info字类做dealInfo的时候， 都能在调用前后打一下日志。</p>
<p>但不希望每个子类里强制都添加这个过程。</p>
<p>所以引入一个代理Proxy， 将Info类放进去代理种执行，无论你放什么info子类进去，调用dealInfo时，都会在调用前后打印日志。</p>
</li>
<li>
<p>和静态代理的区别：</p>
<p>静态代理也是给代理传1个对象，然后执行方法时，执行代理对象的方法</p>
<p>但是有个执行问题：</p>
<p>如果我们的类需要加100个方法，那么我们在代理中也要加100个方法，里面反复写“啊，我要调用代理对象的方法”， 这太蠢了</p>
<p>所以引入动态代理， 这样代理和所代理类之间实现了解耦， 没有必要每次改实类时，也要改代理的内容，重复加方法之类的。</p>
<p>动态代理可以直接根据method去调用，并且还能弄一个自己独有的处理。</p>
</li>
</ul>
<hr>
<h2><span id="q-jiang-yi-xia-dong-tai-dai-li-zen-me-yong-de">Q: 讲一下动态代理怎么用的？</span><a href="#q-jiang-yi-xia-dong-tai-dai-li-zen-me-yong-de" class="header-anchor">#</a></h2>
<p>A:<br>
代理Proxy类必须implements InvocationHandler<br>
要有一个代理成员，在构造器中去传参数绑定这个代理成员<br>
并实现Object invoke(Object object, Method method, Object[] args)<br>
在invoke方法中调用method.invoke(subject, args)<br>
然后真正执行时，<br>
接口Info = （Info）Proxy.newProxyInstance（代理类对象.getClass().getClassLoader()，实际对象.handler.getInterfaces(), 代理类对象.）<br>
那么当我们执行Info类的某些函数时，就是通过代理去执行了。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/d190cf550b2ccb10577825cf86f8d3b2a24b99e2.png" alt="d190cf550b2ccb10577825cf86f8d3b2a24b99e2"></p>
<hr>
<h2><span id="q-java-dong-tai-dai-li-de-di-ceng-shi-xian-yuan-li">Q: java动态代理的底层实现原理？</span><a href="#q-java-dong-tai-dai-li-de-di-ceng-shi-xian-yuan-li" class="header-anchor">#</a></h2>
<p>A:<br>
我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象<br>
在invoke方法中调用了被代理对象的相应方法。<br>
通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。<br>
代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法<br>
从而达到代理执行被代理对象的方法。<br>
也就是说，动态代理通过中介类实现了具体的代理功能。<br>
<img src="/images/Java%E5%8F%8D%E5%B0%84/d2cee51a51bbbd8be3c5315d2b39b1c664497474.png" alt="d2cee51a51bbbd8be3c5315d2b39b1c664497474"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/14/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/" class="post-title-link" itemprop="url">第306场周赛-763名-80分钟4题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-14 22:12:42 / 修改时间：15:42:27" itemprop="dateCreated datePublished" datetime="2022-08-14T22:12:42+08:00">2022-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/14/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/14/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458753851.png" alt="1660458753851"></p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>bfs时，必须要记得在对第一个入队节点做vis[start]=true的操作！否则一定会导致WA！</li>
<li></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-306/problems/largest-local-values-in-a-matrix/">矩阵中的局部最大值 - 力扣 (LeetCode) 竞赛</a></p>
<p>直接硬写即可，就是写8个方向的dirs数组比较累</p>
<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458804313.png" alt="1660458804313"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-306/problems/node-with-highest-edge-score/">https://leetcode.cn/contest/weekly-contest-306/problems/node-with-highest-edge-score/</a></p>
<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458823828.png" alt="1660458823828"></p>
<p>看起来也很简单， 遍历一次就等得到所有点的积分了，然后再遍历一次得到最大节点（都不用写sort函数，直接遍历求最大值即可）</p>
<p>比较坑的是相加结果会超int。。。。</p>
<ul>
<li>
<p><code>2 &lt;= n &lt;= 10^5</code></p>
<p>O(n^2)会超int范围，一定要注意</p>
<p>Arrays.sort不支持直接long类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">edgeScore</span><span class="params">(<span class="type">int</span>[] edges)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] counts = <span class="keyword">new</span> <span class="title class_">long</span>[edges.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length;i++) &#123;</span><br><span class="line">            counts[edges[i]][<span class="number">0</span>] += i;</span><br><span class="line">            counts[edges[i]][<span class="number">1</span>] = edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(counts, (a,b)-&gt;(a[<span class="number">0</span>] != b[<span class="number">0</span>] ? (b[<span class="number">0</span>] - a[<span class="number">0</span>] &gt; <span class="number">0</span>?<span class="number">1</span>:-<span class="number">1</span>) : (a[<span class="number">1</span>] - b[<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)counts[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-smallest-number-from-di-string/">6150. 根据模式串构造最小数字 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660458978033.png" alt="1660458978033"></p>
<p>我竟然一时无法冷静，看最多就9位，只想到了dfs，然后写了15分钟。。正确答案肯定不是dfs这么蠢的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">smallestNumber</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; rest = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            Set&lt;Integer&gt; set = Arrays.stream(nums).boxed().collect(Collectors.toSet());</span><br><span class="line">            rest.add(i);</span><br><span class="line">            set.remove(i);</span><br><span class="line">            dfs(pattern, rest, set,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">min</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String p, List&lt;Integer&gt; res, Set&lt;Integer&gt; canSelect,<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == p.length()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> res.stream().map(r -&gt; String.valueOf(r)).collect(Collectors.joining());</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="literal">null</span> || s.compareTo(min) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                min = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> res.get(res.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">sort</span> <span class="operator">=</span> p.charAt(i);</span><br><span class="line">        Set&lt;Integer&gt; copySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(canSelect);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> select : copySet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sort == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (select &lt; now) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (select &gt; now) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            canSelect.remove(select);</span><br><span class="line">            res.add(select);</span><br><span class="line">            dfs(p, res, canSelect, i+<span class="number">1</span>);</span><br><span class="line">            canSelect.add(select);</span><br><span class="line">            res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最佳做法肯定是一次遍历搞定</p>
<p>有个规律</p>
<p>III的时候，就是选取当前最小值，逐步递增</p>
<p>当DDD的时候， 则应该是从DDD的最右边选当前最小值，逐步往左边递增</p>
<p>处理完DDD的时候更新最小值</p>
<p>结果这个处理也很恶心，写死我了</p>
<p>后来想到每次只判断I这个字母前面所存的数字，后面数字存疑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">smallestNumber</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] results = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i &lt; pattern.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(i) == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            results[ri++] = num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern.charAt(i) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">			<span class="comment">// 统计D的最右边，然后从右往左处理</span></span><br><span class="line">            <span class="keyword">while</span> (right+<span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(right+<span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">desLen</span> <span class="operator">=</span> right - i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">highNum</span> <span class="operator">=</span> num + desLen;</span><br><span class="line">            <span class="keyword">while</span> (desLen-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                results[ri++] = highNum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下一个注定是之前放的最小的那个</span></span><br><span class="line">            results[ri++] = num;</span><br><span class="line">            <span class="comment">// num要更新</span></span><br><span class="line">            num = num + (right - i + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            i = right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后是III的情况</span></span><br><span class="line">    <span class="keyword">if</span> (results[results.length-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        results[results.length-<span class="number">1</span>] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(results).boxed().map(r-&gt;r.toString()).collect(Collectors.joining());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660462821305.png" alt="1660462821305"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-special-integers/">6151. 统计特殊整数 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660462871513.png" alt="1660462871513"></p>
<p>排列组合题</p>
<p>处理0的时候很恶心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] = s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] select = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">canSelectCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">nowCanSelect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;nums[i];j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!select[j]) &#123;</span><br><span class="line">                    nowCanSelect++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                nowCanSelect--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nowCanSelect * getSum(canSelectCount - <span class="number">1</span>, s.length() - i - <span class="number">1</span>);</span><br><span class="line">                result += r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newR</span> <span class="operator">=</span> <span class="number">9</span>*getSum(<span class="number">9</span>, s.length()-i-<span class="number">1</span>);</span><br><span class="line">                result += newR;</span><br><span class="line">            &#125;</span><br><span class="line">            canSelectCount --;</span><br><span class="line">            <span class="keyword">if</span> (select[nums[i]]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            select[nums[i]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            sum *= n;</span><br><span class="line">            count--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂存以下数位DP，后面做一下强化以下</p>
<p><img src="/images/%E7%AC%AC306%E5%9C%BA%E5%91%A8%E8%B5%9B-763%E5%90%8D-80%E5%88%86%E9%92%9F4%E9%A2%98/1660462942718.png" alt="1660462942718"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">java泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 00:33:14 / 修改时间：00:38:32" itemprop="dateCreated datePublished" datetime="2022-08-13T00:33:14+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B3%9B%E5%9E%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E6%B3%9B%E5%9E%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#fan-xing-fang-fa">泛型方法</a>
<ul>
<li><a href="#san-chong-fan-xing-can-shu-de-tui-duan-fang-shi">三种泛型参数的推断方式：</a></li>
<li><a href="#q-xia-mian-zhe-duan-dai-ma-na-li-you-wen-ti-shi-tostring-na-li-ma">Q: 下面这段代码哪里有问题？ 是toString()那里吗？</a></li>
</ul>
</li>
<li><a href="#fan-xing-can-shu-he-lei-xing-xiao-chu">泛型参数和类型消除</a>
<ul>
<li><a href="#q-fan-xing-can-shu-t-zai-yun-xing-shi-hui-bian-cheng-shi-me">Q： 泛型参数T在运行时，会变成什么？</a></li>
<li><a href="#q-fan-xing-can-shu-t-ke-yi-ke-yi-shi-yong-instanceof-zuo-bi-jiao-ma">Q: 泛型参数T可以可以使用instanceof做比较吗？</a></li>
<li><a href="#q-fan-xing-can-shu-t-ke-yi-jin-xing-new-t-huo-zhe-new-t-cao-zuo-ma">Q： 泛型参数T可以进行new T()或者new T[]操作吗？</a></li>
<li><a href="#q-neng-diao-yong-fan-xing-can-shu-dui-xiang-li-de-fang-fa-ma">Q： 能调用泛型参数对象里的方法吗？</a></li>
<li><a href="#q-ke-yi-yong-t-zuo-qiang-zhi-zhuan-hua-ma">Q： 可以用T做强制转化吗？</a></li>
</ul>
</li>
<li><a href="#xin-jian-fan-xing-dui-xiang-shi-de-wen-ti">新建泛型对象时的问题</a>
<ul>
<li><a href="#q-xia-mian-zhe-ju-hua-sheng-ming-list-dui-xiang-zuo-bian-fu-lei-fan-xing-you-bian-zi-lei-fan-xing-you-wen-ti-ma">Q： 下面这句话（声明list对象，左边父类泛型，右边子类泛型）有问题吗？</a></li>
<li><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-extends-parent-child-you-shi-me-xian-zhi">Q：这个list对象声明中， <strong>? extends Parent = Child</strong>   有什么限制？</a></li>
<li><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-super-child-parent-you-shi-me-te-dian">Q：这个list对象声明中，? super Child = Parent 有什么特点？</a></li>
<li><a href="#q-list-list-new-arraylist-a-zhe-ge-list-you-shi-me-te-dian">Q：List&lt;?&gt; list = new ArrayList<a>();这个list有什么特点？</a></a></li>
<li><a href="#q-xia-mian-zhe-ge-dai-ma-hui-bao-cuo-ma">Q：下面这个代码会报错吗？</a></li>
</ul>
</li>
<li><a href="#pecs-yuan-ze">PECS原则</a>
<ul>
<li><a href="#q-xia-mian-dai-ma-neng-zheng-chang-yun-xing-ma">Q：下面代码能正常运行吗？</a></li>
<li><a href="#q-ru-guo-shang-wen-yao-zhi-chi-pushlist-ying-gai-zen-me-xiu-gai-pushlist-fang-fa-de-ding-yi">Q： 如果上文要支持pushList，应该怎么修改pushList方法的定义？</a></li>
<li><a href="#q-ru-guo-yao-zhi-chi-polllist-zen-me-xiu-gai-ding-yi">Q： 如果要支持pollList，怎么修改定义？</a></li>
<li><a href="#pecs-yuan-ze-chu-zi-effective-java-zhu-yi-zhi-shi-yi-ge-bian-cheng-jian-yi-er-yi">PECS原则出自Effective Java， 注意只是一个编程建议而已！</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="fan-xing-fang-fa">泛型方法</span><a href="#fan-xing-fang-fa" class="header-anchor">#</a></h1>
<p>一般定义如下，即方法的前面加了个&lt;T&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">f</span><span class="params">(T t)</span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="san-chong-fan-xing-can-shu-de-tui-duan-fang-shi">三种泛型参数的推断方式：</span><a href="#san-chong-fan-xing-can-shu-de-tui-duan-fang-shi" class="header-anchor">#</a></h2>
<ol>
<li>直接在f()前面加确定泛型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fTest.&lt;Integer&gt;f(xxx)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过输入参数确定， 下面这个推断为Integer</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">fTest.f(number)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>可通过 <em><strong>返回值</strong></em> 确定</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = fTest.f(xxx);</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="q-xia-mian-zhe-duan-dai-ma-na-li-you-wen-ti-shi-tostring-na-li-ma">Q: 下面这段代码哪里有问题？ 是toString()那里吗？</span><a href="#q-xia-mian-zhe-duan-dai-ma-na-li-you-wen-ti-shi-tostring-na-li-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">  		System.out.println(t.toString());  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
test是static方法， 因此无法感知A&lt;T&gt;实例里的T<br>
需要改成<br>
public static &lt;T&gt; void test(T t)</p>
<p>toString（）那里没问题，toString就是Object的方法。</p>
<h1><span id="fan-xing-can-shu-he-lei-xing-xiao-chu">泛型参数和类型消除</span><a href="#fan-xing-can-shu-he-lei-xing-xiao-chu" class="header-anchor">#</a></h1>
<h2><span id="q-fan-xing-can-shu-t-zai-yun-xing-shi-hui-bian-cheng-shi-me">Q： 泛型参数T在运行时，会变成什么？</span><a href="#q-fan-xing-can-shu-t-zai-yun-xing-shi-hui-bian-cheng-shi-me" class="header-anchor">#</a></h2>
<p>A： 统一变成Object且不包含任何类型信息。</p>
<hr>
<h2><span id="q-fan-xing-can-shu-t-ke-yi-ke-yi-shi-yong-instanceof-zuo-bi-jiao-ma">Q: 泛型参数T可以可以使用instanceof做比较吗？</span><a href="#q-fan-xing-can-shu-t-ke-yi-ke-yi-shi-yong-instanceof-zuo-bi-jiao-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Object arg)</span></span><br><span class="line">   <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">	  ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A: 不能，编译器会报错。</p>
<hr>
<h2><span id="q-fan-xing-can-shu-t-ke-yi-jin-xing-new-t-huo-zhe-new-t-cao-zuo-ma">Q： 泛型参数T可以进行new T()或者new T[]操作吗？</span><a href="#q-fan-xing-can-shu-t-ke-yi-jin-xing-new-t-huo-zhe-new-t-cao-zuo-ma" class="header-anchor">#</a></h2>
<p>A： 不能，编译器会报错。</p>
<hr>
<h2><span id="q-neng-diao-yong-fan-xing-can-shu-dui-xiang-li-de-fang-fa-ma">Q： 能调用泛型参数对象里的方法吗？</span><a href="#q-neng-diao-yong-fan-xing-can-shu-dui-xiang-li-de-fang-fa-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T.f();</span><br></pre></td></tr></table></figure>
<p>A： 只能调用Object的方法。</p>
<hr>
<h2><span id="q-ke-yi-yong-t-zuo-qiang-zhi-zhuan-hua-ma">Q： 可以用T做强制转化吗？</span><a href="#q-ke-yi-yong-t-zuo-qiang-zhi-zhuan-hua-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> (T)object;</span><br></pre></td></tr></table></figure>
<p>A: 能运行， 但不会真正发生转型， 编译时会触发waring警告。</p>
<h1><span id="xin-jian-fan-xing-dui-xiang-shi-de-wen-ti">新建泛型对象时的问题</span><a href="#xin-jian-fan-xing-dui-xiang-shi-de-wen-ti" class="header-anchor">#</a></h1>
<p>先假定有2个类， 基类Parent 和子类Child</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>回答以下问题：</p>
<h2><span id="q-xia-mian-zhe-ju-hua-sheng-ming-list-dui-xiang-zuo-bian-fu-lei-fan-xing-you-bian-zi-lei-fan-xing-you-wen-ti-ma">Q： 下面这句话（声明list对象，左边父类泛型，右边子类泛型）有问题吗？</span><a href="#q-xia-mian-zhe-ju-hua-sheng-ming-list-dui-xiang-zuo-bian-fu-lei-fan-xing-you-bian-zi-lei-fan-xing-you-wen-ti-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Parent&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Child&gt;()</span><br></pre></td></tr></table></figure>
<p>A：<br>
有问题，编译就错误了。 List&lt;Parent&gt;和ArrayList&lt;Child&gt;并不存在父子类的关系</p>
<hr>
<h2><span id="q-zhe-ge-list-dui-xiang-sheng-ming-zhong-extends-parent-child-you-shi-me-xian-zhi">Q：这个list对象声明中， <strong>? extends Parent = Child</strong>   有什么限制？</span><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-extends-parent-child-you-shi-me-xian-zhi" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Parent</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Child&gt;();</span><br></pre></td></tr></table></figure>
<p>A：<br>
这个list可以调用A a = list.get()， 但是不能list.add(new Parent())</p>
<ul>
<li>原因：<br>
list.get()所做的操作是在返回时， 把内部的&lt;? extend Parent&gt; 强转成Parent，  是合理的，任何Parent的子类都可以转成Parent<br>
list.add(new Parent()）所做的操作是在输入时，  把外部的A转成内部的&lt;? extend Parent&gt;，  这是不合理的，因为我们不知道这个Parent对象可以转成哪个Parent的子类。</li>
</ul>
<hr>
<h2><span id="q-zhe-ge-list-dui-xiang-sheng-ming-zhong-super-child-parent-you-shi-me-te-dian">Q：这个list对象声明中，? super Child = Parent 有什么特点？</span><a href="#q-zhe-ge-list-dui-xiang-sheng-ming-zhong-super-child-parent-you-shi-me-te-dian" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Child&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Parent&gt;();</span><br></pre></td></tr></table></figure>
<p>下面谁会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Parent</span>())</span><br><span class="line">Parent a= list.get();</span><br><span class="line"><span class="type">Child</span> <span class="variable">b</span> <span class="operator">=</span> list.get()</span><br></pre></td></tr></table></figure>
<p>A：<br>
截图如下：<br>
<img src="/images/java%E6%B3%9B%E5%9E%8B/1619454364092008017.png" alt="image.png"></p>
<ul>
<li>Child c = list.get() 或者Parent p = list.get()所做的操作是在返回时， 把内部的&lt;? super Child&gt; 强转成外部的Parent或者child， 是不合理的，  因为编译器觉得child的父类 <em><strong>不一定</strong></em> 能转成parent或者child，所以禁止了这种行为（ 比如parent的父类是object， 但object不一定就能转成parent或者child）<br>
*list.add(new Child())所做的操作是在输入时， 把外部的child或者parent转成内部的&lt;? super Child&gt;， 这是合理的，因为child和parent一定能转成child的父类。</li>
</ul>
<hr>
<h2><span id="q-list-lt-gt-list-new-arraylist-zhe-ge-list-you-shi-me-te-dian">Q：List&lt;?&gt; list = new ArrayList</span><a href="#q-list-lt-gt-list-new-arraylist-zhe-ge-list-you-shi-me-te-dian" class="header-anchor">#</a></h2>
<p>A：<br>
get和add都不行，只能做remove等无返回值无输入A的操作。<br>
PS： 注意，不是说不能调用get或add方法， 而是调用get或add时，不能使用A这个对象去操作。<br>
即无法做add(A) 或者  A a = get(0)<br>
但是可以做add(object)  或者Object o = get(0)<br>
因为？可以转为Object， 但是无法转为A。</p>
<hr>
<h2><span id="q-xia-mian-zhe-ge-dai-ma-hui-bao-cuo-ma">Q：下面这个代码会报错吗？</span><a href="#q-xia-mian-zhe-ge-dai-ma-hui-bao-cuo-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">fruitList.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>());</span><br><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">appleList.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">fruitList.addAll(appleList);</span><br><span class="line">System.out.println(fruitList);</span><br></pre></td></tr></table></figure>
<p>A:<br>
不会报错。会正常打印结果。<br>
<img src="/images/java%E6%B3%9B%E5%9E%8B/1619454374478088912.png" alt="image.png"></p>
<hr>
<h1><span id="pecs-yuan-ze">PECS原则</span><a href="#pecs-yuan-ze" class="header-anchor">#</a></h1>
<p>注意PECS原则和上面的区别！<br>
上面之前提到的? extend或者? supert， 都是在声明对象的时候用的。<br>
而PECS原则是用于泛型对象的方法输入参数！</p>
<p>假设有一个类定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;T&gt; &#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把输入参数塞给自己，类似于生产操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushList</span><span class="params">(List&lt;T&gt; t)</span> &#123;</span><br><span class="line">        list.addAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把自己的内容塞给输入参数，类似于让输入参数做消费。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pollList</span><span class="params">(List&lt;T&gt; t)</span> &#123;</span><br><span class="line">         t.addAll(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则T就是泛型参数。</p>
<h2><span id="q-xia-mian-dai-ma-neng-zheng-chang-yun-xing-ma">Q：下面代码能正常运行吗？</span><a href="#q-xia-mian-dai-ma-neng-zheng-chang-yun-xing-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Number&gt; myList = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">myList.pushList(intList);</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">myList.pollList(objectList);</span><br></pre></td></tr></table></figure>
<p>A:<br>
不能正常运行， pushList和pollList都会报错<br>
因为编译器检查后，认为  List&lt;Integer&gt;和List&lt;Number&gt;不是一个东西！</p>
<hr>
<h2><span id="q-ru-guo-shang-wen-yao-zhi-chi-pushlist-ying-gai-zen-me-xiu-gai-pushlist-fang-fa-de-ding-yi">Q： 如果上文要支持pushList，应该怎么修改pushList方法的定义？</span><a href="#q-ru-guo-shang-wen-yao-zhi-chi-pushlist-ying-gai-zen-me-xiu-gai-pushlist-fang-fa-de-ding-yi" class="header-anchor">#</a></h2>
<p>A：<br>
改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把输入参数塞给自己，类似于生产操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushList</span><span class="params">(List&lt;? extends T&gt; t)</span> &#123;</span><br><span class="line">    list.addAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即编译器认为，List&lt;Integer&gt; 和List&lt;? extend Number&gt;是一个东西，允许!</p>
<hr>
<h2><span id="q-ru-guo-yao-zhi-chi-polllist-zen-me-xiu-gai-ding-yi">Q： 如果要支持pollList，怎么修改定义？</span><a href="#q-ru-guo-yao-zhi-chi-polllist-zen-me-xiu-gai-ding-yi" class="header-anchor">#</a></h2>
<p>A：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把自己的内容塞给输入参数，类似于让输入参数做消费。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pollList</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; t)</span> &#123;</span><br><span class="line">    t.addAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是把自己的东西塞给输入参数， 而想要能塞进去，必须保证自己这个T，是输入参数的子类，反过来说，输入参数必须是T的父类，所以用super<br>
于是编译器认为，List&lt;Object&gt; 和List&lt;? super Number&gt;是一个东西，允许!</p>
<hr>
<h2><span id="pecs-yuan-ze-chu-zi-effective-java-zhu-yi-zhi-shi-yi-ge-bian-cheng-jian-yi-er-yi">PECS原则出自Effective Java， 注意只是一个编程建议而已！</span><a href="#pecs-yuan-ze-chu-zi-effective-java-zhu-yi-zhi-shi-yi-ge-bian-cheng-jian-yi-er-yi" class="header-anchor">#</a></h2>
<ul>
<li>如果有一个类A，泛型参数为T</li>
<li>如果他一般只用于接收输入容器List后，塞入自己内部的T容器， 则类A就叫生产者，   因此输入参数最好定义为&lt;? extend T&gt;最好， 以便能接收任何T子类的容器。</li>
<li>如果他一般只用于接收输入容器后List， 把自己内部的T元素塞给它， 那么这个类A就叫消费者， 输入参数最好定义为&lt;? super T&gt;\ 最好，  以便自己的T元素能塞给任何T元素的父类容器。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">java异常机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 00:31:20 / 修改时间：00:32:33" itemprop="dateCreated datePublished" datetime="2022-08-13T00:31:20+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#yi-chang-ti-xi-fen-lei">异常体系分类</a>
<ul>
<li><a href="#q-throwable-he-error-de-guan-xi">Q： Throwable 和 Error的关系</a></li>
<li><a href="#q-error-he-exception-de-guan-xi">Q： Error和Exception的关系</a></li>
<li><a href="#q-error-ke-yi-bei-catch-bu-zhuo-ma">Q： Error可以被catch捕捉吗？</a></li>
<li><a href="#yi-chang-ti-xi-huan-ke-yi-fen-wei-zhe-2-lei">异常体系还可以分为这2类:</a></li>
</ul>
</li>
<li><a href="#yi-chang-bu-zhuo-he-fan-hui">异常捕捉和返回</a>
<ul>
<li><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1：  finally能通过修改变量，来更新return的变量值吗</a></li>
<li><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</a></li>
<li><a href="#q-shi-me-qing-kuang-xia-finally-kuai-li-de-bu-zou-ke-yi-bu-zhi-xing">Q： 什么情况下finally块里的步骤可以不执行？</a></li>
<li><a href="#q-xian-bu-zhuo-fu-lei-yi-chang-zai-bu-zhuo-zi-lei-yi-chang-hui-fa-sheng-shi-me">Q： 先捕捉父类异常，再捕捉子类异常，会发生什么？</a></li>
<li><a href="#q-throw-yi-chang-de-shi-hou-zai-finally-zhong-zuo-return-na-me-yi-chang-huan-hui-pao-chu-ma">Q：throw异常的时候，在finally中做return，那么异常还会抛出吗？</a></li>
</ul>
</li>
<li><a href="#shou-jian-yi-chang-xiang-guan-wen-ti">受检异常相关问题</a>
<ul>
<li><a href="#q-zi-lei-fu-xie-ji-lei-fang-fa-shi-neng-throws-ji-lei-fang-fa-zhong-bu-cun-zai-de-yi-chang-ma">Q: 子类覆写基类方法时 ， 能throws基类方法中不存在的异常吗？</a></li>
<li><a href="#q-finally-zhong-diao-yong-mou-zi-yuan-de-close-shi-ye-hui-pao-chu-shou-jian-yi-chang-chu-liao-zai-finally-li-zuo-try-catch-huan-neng-zen-me-zuo">Q: finally中调用某资源的close时，也会抛出受检异常，  除了在finally里做try-catch，还能怎么做？</a></li>
<li><a href="#q-xian-cheng-pao-chu-yi-chang-de-hua-gai-zen-me-bu-zhuo">Q: 线程抛出异常的话该怎么捕捉？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="yi-chang-ti-xi-fen-lei">异常体系分类</span><a href="#yi-chang-ti-xi-fen-lei" class="header-anchor">#</a></h1>
<h2><span id="q-throwable-he-error-de-guan-xi">Q：  Throwable 和 Error的关系</span><a href="#q-throwable-he-error-de-guan-xi" class="header-anchor">#</a></h2>
<p>A： Throwable是Error(错误）的基类，也是Exception的基类<br>
1个好图，可看到常见的异常和error<br>
<img src="/images/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/1616809879000046121.png" alt="image.png"></p>
<hr>
<h2><span id="q-error-he-exception-de-guan-xi">Q： Error和Exception的关系</span><a href="#q-error-he-exception-de-guan-xi" class="header-anchor">#</a></h2>
<p>A：</p>
<ul>
<li>Error一般是会直接引起jvm出错的错误，例如Java虚拟机运行错误等，如果出现了当前线程会无法继续运行。</li>
<li>Excpetion是程序本身可以处理的异常。发生后还能正常运行。</li>
</ul>
<hr>
<h2><span id="q-error-ke-yi-bei-catch-bu-zhuo-ma">Q： Error可以被catch捕捉吗？</span><a href="#q-error-ke-yi-bei-catch-bu-zhuo-ma" class="header-anchor">#</a></h2>
<p>A： 只要是Throwable和其子类都是可以throw和catch的。 但是不建议捕捉Error。</p>
<hr>
<h2><span id="yi-chang-ti-xi-huan-ke-yi-fen-wei-zhe-2-lei">异常体系还可以分为这2类:</span><a href="#yi-chang-ti-xi-huan-ke-yi-fen-wei-zhe-2-lei" class="header-anchor">#</a></h2>
<ul>
<li>
<p>unchecked exception（非检查异常）<br>
也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</p>
</li>
<li>
<p>checked exception（检查异常，编译异常）<br>
也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p>
</li>
</ul>
<h1><span id="yi-chang-bu-zhuo-he-fan-hui">异常捕捉和返回</span><a href="#yi-chang-bu-zhuo-he-fan-hui" class="header-anchor">#</a></h1>
<h2><span id="q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma">Q： return-finally陷阱1：  finally能通过修改变量，来更新return的变量值吗</span><a href="#q-return-finally-xian-jing-1-finally-neng-tong-guo-xiu-gai-bian-liang-lai-geng-xin-return-de-bian-liang-zhi-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      a=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:  不能， f返回1。</p>
<hr>
<h2><span id="q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge">Q： return-finally陷阱2： finally里也return时，返回哪个？</span><a href="#q-return-finally-xian-jing-2-finally-li-ye-return-shi-fan-hui-na-ge" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：返回finally里的，返回2。</p>
<hr>
<h2><span id="q-shi-me-qing-kuang-xia-finally-kuai-li-de-bu-zou-ke-yi-bu-zhi-xing">Q： 什么情况下finally块里的步骤可以不执行？</span><a href="#q-shi-me-qing-kuang-xia-finally-kuai-li-de-bu-zou-ke-yi-bu-zhi-xing" class="header-anchor">#</a></h2>
<p>A： 只有在finally之前调用System.exit(0)退出jvm， 才能让finally不执行。</p>
<hr>
<h2><span id="q-xian-bu-zhuo-fu-lei-yi-chang-zai-bu-zhuo-zi-lei-yi-chang-hui-fa-sheng-shi-me">Q： 先捕捉父类异常，再捕捉子类异常，会发生什么？</span><a href="#q-xian-bu-zhuo-fu-lei-yi-chang-zai-bu-zhuo-zi-lei-yi-chang-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;catch Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;catch RuntimeException&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A: 直接编译就错误了。 catch是会按顺序的且匹配1个就不再往下匹配，编译器因此识别出RuntimeExcpetion永远不会被捕捉到，便提前报错。</p>
<hr>
<h2><span id="q-throw-yi-chang-de-shi-hou-zai-finally-zhong-zuo-return-na-me-yi-chang-huan-hui-pao-chu-ma">Q：throw异常的时候，在finally中做return，那么异常还会抛出吗？</span><a href="#q-throw-yi-chang-de-shi-hou-zai-finally-zhong-zuo-return-na-me-yi-chang-huan-hui-pao-chu-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
不会，返回-1.<br>
即finaly中做return会中断throw<br>
因此永远不要在finally中去做return操作</p>
<h1><span id="shou-jian-yi-chang-xiang-guan-wen-ti">受检异常相关问题</span><a href="#shou-jian-yi-chang-xiang-guan-wen-ti" class="header-anchor">#</a></h1>
<h2><span id="q-zi-lei-fu-xie-ji-lei-fang-fa-shi-neng-throws-ji-lei-fang-fa-zhong-bu-cun-zai-de-yi-chang-ma">Q: 子类覆写基类方法时 ， 能throws基类方法中不存在的异常吗？</span><a href="#q-zi-lei-fu-xie-ji-lei-fang-fa-shi-neng-throws-ji-lei-fang-fa-zhong-bu-cun-zai-de-yi-chang-ma" class="header-anchor">#</a></h2>
<p>像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A: 不行，直接编译报错。  即子类覆写父类方法时， throws关键字后面跟的异常必须是小于等于父类方法异常的。<br>
<img src="/images/java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/1616809912530040293.png" alt="image.png"></p>
<hr>
<h2><span id="q-finally-zhong-diao-yong-mou-zi-yuan-de-close-shi-ye-hui-pao-chu-shou-jian-yi-chang-chu-liao-zai-finally-li-zuo-try-catch-huan-neng-zen-me-zuo">Q: finally中调用某资源的close时，也会抛出受检异常，  除了在finally里做try-catch，还能怎么做？</span><a href="#q-finally-zhong-diao-yong-mou-zi-yuan-de-close-shi-ye-hui-pao-chu-shou-jian-yi-chang-chu-liao-zai-finally-li-zuo-try-catch-huan-neng-zen-me-zuo" class="header-anchor">#</a></h2>
<p>像下面这样，finally又有catch，就很难看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TryWithResource</span> <span class="variable">tryWithResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TryWithResource</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(tryWithResource.age);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tryWithResource.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>A：如果是JDK1.7，可以用try-with-resource语法。<br>
需要资源类实现AutoCloseable接口，  并在try的时候在try括号后面跟上资源的创建，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">TryWithResource</span> <span class="variable">tryWithResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TryWithResource</span>()) &#123;</span><br><span class="line">        System.out.println(tryWithResource.age);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不需要写finally，finally+close会通过编译器给我们自动加上。</p>
<hr>
<h2><span id="q-xian-cheng-pao-chu-yi-chang-de-hua-gai-zen-me-bu-zhuo">Q: 线程抛出异常的话该怎么捕捉？</span><a href="#q-xian-cheng-pao-chu-yi-chang-de-hua-gai-zen-me-bu-zhuo" class="header-anchor">#</a></h2>
<p>A： 实现异常处理接口MyUnchecckedExceptionhandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUnchecckedExceptionhandler</span> <span class="keyword">implements</span> <span class="title class_">UncaughtExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获异常处理方法：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把实现类设置给对应线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ExceptionThread</span>());</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUnchecckedExceptionhandler</span>());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>除此之外还有6种方法可以设置，详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/82115437">链接</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">java容器基础概念和应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 00:27:53 / 修改时间：00:30:48" itemprop="dateCreated datePublished" datetime="2022-08-13T00:27:53+08:00">2022-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/13/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#list-xiang-guan-wen-ti">List相关问题</a>
<ul>
<li><a href="#q-arrlist-new-arraylist-arrays-aslist-he-arrlist-arrays-aslist-you-shi-me-qu-bie">Q:arrList = new ArrayList&lt;&gt;(Arrays.asList（）)   和  arrList =   Arrays.asList（）有什么区别</a></li>
<li><a href="#q-na-aslist-zhi-chi-tong-guo-xiu-gai-yuan-shu-zu-lai-xiu-gai-list-nei-rong-ma">Q：那asList()支持通过修改原数组来修改list内容吗？</a></li>
<li><a href="#q-dang-shu-ru-wei-na-xie-zi-mu-shi-die-dai-shi-hui-bao-cuo">Q： 当输入为哪些字母时，迭代时会报错</a></li>
<li><a href="#q-arraylist-de-kuo-rong-gong-shi-he-mo-ren-chu-shi-da-xiao-shi-duo-shao">Q： ArrayList的扩容公式和默认初始大小是多少？</a></li>
<li><a href="#q-vector-de-kuo-rong-gong-shi-shi-duo-shao">Q： Vector的扩容公式是多少？</a></li>
<li><a href="#q-vector-he-arraylist-de-qu-bie">Q：vector和ArrayList的区别</a></li>
<li><a href="#q-wei-shi-me-bu-tui-jian-shi-yong-stack">Q：为什么不推荐使用stack</a></li>
</ul>
</li>
<li><a href="#map-xiang-guan-wen-ti">Map相关问题</a>
<ul>
<li><a href="#q-jie-da-xia-lie-te-xing-he-na-xie-map-you-guan">Q： 解答下列特性和哪些Map有关</a></li>
<li><a href="#q-hashcode-xiang-tong-na-me-equals-ken-ding-true-ma">Q： hashCode相同， 那么equals肯定true吗？</a></li>
<li><a href="#q-equals-wei-true-na-me-hashcode-ken-ding-xiang-tong-ma">Q： equals为true， 那么hashCode肯定相同吗？</a></li>
<li><a href="#q-2-ge-string-ru-guo-nei-rong-xiang-tong-na-me-hashcode-xiang-tong-ma">Q： 2个String如果内容相同，那么hashCode相同吗？</a></li>
<li><a href="#hashtable-hashmap-concurrenthashmap-bi-jiao">HashTable、HashMap、ConcurrentHashMap比较：</a></li>
<li><a href="#q-collections-synchronizedmap-map-he-concurrenthashmap-na-ge-tong-bu-xiao-guo-hao">Q：Collections.synchronizedMap（map）和ConcurrentHashMap,哪个同步效果好？</a></li>
<li><a href="#q-linkedhashmap-de-accessorder-wen-ti-xia-mian-shu-chu-shi-me">Q:linkedHashMap的accessOrder问题,下面输出什么</a></li>
<li><a href="#q-hashmap-wei-shi-me-duo-xian-cheng-shi-yong-shi-ke-neng-hui-zao-cheng-si-xun-huan">Q：hashMap为什么多线程使用时可能会造成死循环？</a></li>
<li><a href="#q-java1-7-he-1-8-zhi-jian-hashmap-zuo-liao-shi-me-gai-jin">Q:java1.7 和1.8 之间， hashMap做了什么改进？</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a></li>
<li><a href="#te-shu-de-yin-yong-rong-qi">特殊的引用容器</a>
<ul>
<li><a href="#q-ru-guo-ra-yin-yong-liao-a-ze-a-bi-bu-ke-neng-bei-hui-shou-ra-shu-yu-shi-me-yin-yong">Q：如果RA引用了A，则A必不可能被回收， RA属于什么引用？</a></li>
<li><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-zai-nei-cun-bu-zu-shi-hui-qiang-zhi-hui-shou-a-ze-ra-shu-yu-shi-me-yin-yong">Q： 如果只有RA引用了A， 在内存不足时会强制回收A，则RA属于什么引用？</a></li>
<li><a href="#hexopostrendercodeblock-figure-class-highlight-java-table-tr-td-class-gutter-pre-span-class-line-1-span-br-pre-td-td-class-code-pre-span-class-line-softreference-lt-string-gt-softreference-span-class-keyword-new-span-span-class-title-class-softreference-span-lt-string-gt-str-span-br-pre-td-tr-table-figure-hexopostrendercodeblock"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></a></li>
<li><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-bu-guan-nei-cun-zu-bu-zu-zhi-yao-la-ji-hui-shou-qi-sao-miao-dao-liao-jiu-hui-zhi-jie-hui-shou-ra-shu-yu">Q： 如果只有RA引用了A， 不管内存足不足，只要垃圾回收器扫描到了，就会直接回收，RA属于：</a></li>
<li><a href="#q-dang-zhi-you-ra-yin-yong-liao-a-shi-du-hui-zai-xia-yi-ci-la-ji-shou-ji-shi-zhi-jie-hui-shou-qie-chuang-jian-yin-yong-shi-bi-xu-yi-lai-yin-yong-dui-lie-zhe-ge-yin-yong-ra-shu-yu">Q： 当只有RA引用了A时，都会在下一次垃圾收集时直接回收，且创建引用时必须依赖引用队列，这个引用RA属于：</a></li>
<li><a href="#q-yin-yong-dui-lie-shi-shi-me-zuo-yong-shi-shi-me">Q： 引用队列是什么，作用是什么？</a></li>
<li><a href="#you-xian-dui-lie">优先队列</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>经典java容器结构图：<br>
<img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218412983051246.png" alt="image.png"></p>
<p>注意哪些属于Collection，哪些属于Map。</p>
<hr>
<h1><span id="list-xiang-guan-wen-ti">List相关问题</span><a href="#list-xiang-guan-wen-ti" class="header-anchor">#</a></h1>
<h2><span id="q-arrlist-new-arraylist-lt-gt-arrays-aslist-he-arrlist-arrays-aslist-you-shi-me-qu-bie">Q:arrList = new ArrayList&lt;&gt;(Arrays.asList（）)   和  arrList =   Arrays.asList（）有什么区别</span><a href="#q-arrlist-new-arraylist-lt-gt-arrays-aslist-he-arrlist-arrays-aslist-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arrList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">List&lt;Integer&gt; arrList2 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">arrList1.add(<span class="number">4</span>);</span><br><span class="line">arrList2.add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>A:执行arrList2.add(4)时会报错。<br>
因为 Arrays.asList()只会返回1个固定大小的列表， 其返回的List是AbstractList，无法调用add、remove和clear， 如果调用会直接抛异常。<br>
异常名字为UnsupportedOperationException<br>
具体原因可以见评论区。</p>
<hr>
<h2><span id="q-na-aslist-zhi-chi-tong-guo-xiu-gai-yuan-shu-zu-lai-xiu-gai-list-nei-rong-ma">Q：那asList()支持通过修改原数组来修改list内容吗？</span><a href="#q-na-aslist-zhi-chi-tong-guo-xiu-gai-yuan-shu-zu-lai-xiu-gai-list-nei-rong-ma" class="header-anchor">#</a></h2>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; arrList = Arrays.asList(ss);</span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(arrList);</span><br></pre></td></tr></table></figure>
<p>上面操作后arrList会报错吗？</p>
<p>A：<br>
不会报错。arrList里的内容变成了{“d”,“b”,“c”}</p>
<h2><span id="q-dang-shu-ru-wei-na-xie-zi-mu-shi-die-dai-shi-hui-bao-cuo">Q： 当输入为哪些字母时，迭代时会报错</span><a href="#q-dang-shu-ru-wei-na-xie-zi-mu-shi-die-dai-shi-hui-bao-cuo" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (String curStr : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(curStr)) &#123;</span><br><span class="line">            list.remove(curStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
删除A或者B会报错，  但是删除C不会！<br>
对于foreach遍历容器，并用remove做删除时，当删除倒数第二个元素时，是不会报错的。<br>
因为：</p>
<hr>
<h2><span id="q-arraylist-de-kuo-rong-gong-shi-he-mo-ren-chu-shi-da-xiao-shi-duo-shao">Q： ArrayList的扩容公式和默认初始大小是多少？</span><a href="#q-arraylist-de-kuo-rong-gong-shi-he-mo-ren-chu-shi-da-xiao-shi-duo-shao" class="header-anchor">#</a></h2>
<p>A：<br>
扩容容量= 原容量 + (原容量右移1位，即0.5倍)= 1.5倍<br>
<img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218437437040318.png" alt="image.png"></p>
<p>初始容量为10.<br>
<img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218442905061711.png" alt="image.png"></p>
<ul>
<li>注意，初始的数组长度还是0，数组长度和容量不是一个东西。</li>
</ul>
<hr>
<h2><span id="q-vector-de-kuo-rong-gong-shi-shi-duo-shao">Q： Vector的扩容公式是多少？</span><a href="#q-vector-de-kuo-rong-gong-shi-shi-duo-shao" class="header-anchor">#</a></h2>
<p>A:<br>
扩容容量= 原容量 *2<br>
<img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218451056083054.png" alt="image.png"></p>
<p>初始大小为10<br>
<img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218456618026072.png" alt="image.png"></p>
<hr>
<h2><span id="q-vector-he-arraylist-de-qu-bie">Q：vector和ArrayList的区别</span><a href="#q-vector-he-arraylist-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
vector是线程安全的， 每个方法都加了syn关键字，频繁的加锁可能导致性能降低</p>
<hr>
<h2><span id="q-wei-shi-me-bu-tui-jian-shi-yong-stack">Q：为什么不推荐使用stack</span><a href="#q-wei-shi-me-bu-tui-jian-shi-yong-stack" class="header-anchor">#</a></h2>
<p>A：<br>
为什么不推荐使用stack<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cosmos-wong/p/11845934.html">https://www.cnblogs.com/cosmos-wong/p/11845934.html</a><br>
stack 继承自vector ， 但是vector里包含了很多不需要的public方法<br>
只是为了实现栈，不用链表来单独实现，而是为了复用简单的方法而迫使它继承 Vector，Stack 和 Vector 本来是毫无关系的。这使得 Stack 在基于数组实现上效率受影响，另外因为继承 Vector 类，Stack 可以复用 Vector 大量方法，这使得 Stack 在设计上不严谨</p>
<hr>
<h1><span id="map-xiang-guan-wen-ti">Map相关问题</span><a href="#map-xiang-guan-wen-ti" class="header-anchor">#</a></h1>
<h2><span id="q-jie-da-xia-lie-te-xing-he-na-xie-map-you-guan">Q： 解答下列特性和哪些Map有关</span><a href="#q-jie-da-xia-lie-te-xing-he-na-xie-map-you-guan" class="header-anchor">#</a></h2>
<ul>
<li>
<p>实现基于散列表，迭代时是不确定随机的顺序的Map为-----------------------------------------HashMap</p>
</li>
<li>
<p>迭代时按照插入顺序进行迭代-----------------------------------------------------LinkedHashMap</p>
</li>
<li>
<p>迭代时按照键值的比较顺序进行迭代-----------------------------------------------------TreeMap</p>
</li>
<li>
<p>基于红黑树的实现-----------------------------------------------------TreeMap</p>
</li>
<li>
<p>线程安全的Map-----------------------------------------------------ConcurrentHashMap</p>
</li>
<li>
<p>键值比较时使用==而不是equal的Map-------------------------------------------------IdentityHashMap</p>
</li>
<li>
<p>可以按区间得到1个子map的Map----------------------sortMap</p>
</li>
<li>
<p>Set也有HashSet、LinkedSet、TreeSet、SortSet等，作用同理。</p>
</li>
</ul>
<hr>
<h2><span id="q-hashcode-xiang-tong-na-me-equals-ken-ding-true-ma">Q： hashCode相同， 那么equals肯定true吗？</span><a href="#q-hashcode-xiang-tong-na-me-equals-ken-ding-true-ma" class="header-anchor">#</a></h2>
<p>A： 不一定。</p>
<h2><span id="q-equals-wei-true-na-me-hashcode-ken-ding-xiang-tong-ma">Q： equals为true， 那么hashCode肯定相同吗？</span><a href="#q-equals-wei-true-na-me-hashcode-ken-ding-xiang-tong-ma" class="header-anchor">#</a></h2>
<p>A： 对。<br>
原因： 参见散列表的原理，明白hashCode的作用后就明白为什么了。<br>
<br></p>
<h2><span id="q-2-ge-string-ru-guo-nei-rong-xiang-tong-na-me-hashcode-xiang-tong-ma">Q： 2个String如果内容相同，那么hashCode相同吗？</span><a href="#q-2-ge-string-ru-guo-nei-rong-xiang-tong-na-me-hashcode-xiang-tong-ma" class="header-anchor">#</a></h2>
<p>A： 对,相同。因为二者equals返回true，所以必定hashCode相同。<br>
Q： 如果在插入后，修改某个key的hashCode，可能造成什么问题？<br>
A：<br>
可能造成内存泄漏。因为map是按计算后的hashCode存放的，而如果在外部修改了某个key的值，可能造成之前塞入的那个哈希所在的地址无法被外部remove(key)，却又无法被gc（因为一直持有），造成内存泄漏。</p>
<hr>
<h2><span id="hashtable-hashmap-concurrenthashmap-bi-jiao">HashTable、HashMap、ConcurrentHashMap比较：</span><a href="#hashtable-hashmap-concurrenthashmap-bi-jiao" class="header-anchor">#</a></h2>
<ul>
<li>key和value不可以为null的是：----------------------------HashTable</li>
<li>线程安全的是：---------------------------------HashTable和ConcurrentHashMap<br>
他们2个的区别：<br>
在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。(具体可参考底层实现原理，总之ConcurrentHashMap最重要的是做了分段)</li>
</ul>
<hr>
<h2><span id="q-collections-synchronizedmap-map-he-concurrenthashmap-na-ge-tong-bu-xiao-guo-hao">Q：Collections.synchronizedMap（map）和ConcurrentHashMap,哪个同步效果好？</span><a href="#q-collections-synchronizedmap-map-he-concurrenthashmap-na-ge-tong-bu-xiao-guo-hao" class="header-anchor">#</a></h2>
<p>A：</p>
<blockquote>
<blockquote>
<blockquote>
<p>Collections.synchronizedMap(map)与ConcurrentHashMap主要区别是：Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步<br>
而ConcurrentHashMap的实现却更加精细,分端加锁</p>
</blockquote>
</blockquote>
</blockquote>
<p>其实Colletions.synchronizedMap就是对放进去的map包了一层sync关键字。<br>
详见：<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/a198720/articles/4227500.html">https://www.cnblogs.com/a198720/articles/4227500.html</a></p>
<hr>
<h2><span id="q-linkedhashmap-de-accessorder-wen-ti-xia-mian-shu-chu-shi-me">Q:linkedHashMap的accessOrder问题,下面输出什么</span><a href="#q-linkedhashmap-de-accessorder-wen-ti-xia-mian-shu-chu-shi-me" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LinkedHashMap&lt;String, String&gt; accessOrderTrue = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    accessOrderTrue.put(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;put后的数据：&quot;</span>+accessOrderTrue);</span><br><span class="line">    accessOrderTrue.get(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    accessOrderTrue.get(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;get后的数据&quot;</span>+accessOrderTrue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
省略key值<br>
put后的数据： {1=1,2=2,3=3,4=4}<br>
get后的数据： {1=1,4=4,2=2,3=3}</p>
<ul>
<li>accessOrder为true时， 会把最近访问过的数据放到链表 <em><strong>末尾</strong></em>。</li>
</ul>
<hr>
<h2><span id="q-hashmap-wei-shi-me-duo-xian-cheng-shi-yong-shi-ke-neng-hui-zao-cheng-si-xun-huan">Q：hashMap为什么多线程使用时可能会造成死循环？</span><a href="#q-hashmap-wei-shi-me-duo-xian-cheng-shi-yong-shi-ke-neng-hui-zao-cheng-si-xun-huan" class="header-anchor">#</a></h2>
<p>A：<br>
<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1e9cf0ac07f4">https://www.jianshu.com/p/1e9cf0ac07f4</a><br>
主要发生在2个线程同时put并进行扩容时， 对同一个对象的链表引用会出现问题。、</p>
<hr>
<h2><span id="q-java1-7-he-1-8-zhi-jian-hashmap-zuo-liao-shi-me-gai-jin">Q:java1.7 和1.8 之间， hashMap做了什么改进？</span><a href="#q-java1-7-he-1-8-zhi-jian-hashmap-zuo-liao-shi-me-gai-jin" class="header-anchor">#</a></h2>
<p>A：<br>
1.7的哈希如果冲突严重，则在一个点上形成的链表会越来越长。<br>
因此1.8做了改进，如果那个点的链表长度超过TREEIFY_THRESHOLD,则会转为红黑树。</p>
<h1><span id="collections">Collections</span><a href="#collections" class="header-anchor">#</a></h1>
<ul>
<li>Collection是接口， Collections是1个工具类</li>
<li>排序： Collections.sort(collection ,Comparator&lt;&gt;)</li>
<li>打乱顺序： Collections.shuffle(collection ,Random)</li>
<li>填充: Collections.fill(list, 对象) ，  注意是浅拷贝填充， 即填充后使用的是同一个引用。</li>
<li>返回不可变容器（即无法对容器做修改）： Collections.unmodifiableMap(容器)<br>
除此之外可以返回空的不可变集合和仅有单个元素的不可变集合。<br>
<img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218468075036317.png" alt="image.png"></li>
</ul>
<hr>
<p><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218476720061727.png" alt="image.png"></p>
<h1><span id="te-shu-de-yin-yong-rong-qi">特殊的引用容器</span><a href="#te-shu-de-yin-yong-rong-qi" class="header-anchor">#</a></h1>
<p>假设有1个对象A， 有1个引用RA指向A</p>
<h2><span id="q-ru-guo-ra-yin-yong-liao-a-ze-a-bi-bu-ke-neng-bei-hui-shou-ra-shu-yu-shi-me-yin-yong">Q：如果RA引用了A，则A必不可能被回收， RA属于什么引用？</span><a href="#q-ru-guo-ra-yin-yong-liao-a-ze-a-bi-bu-ke-neng-bei-hui-shou-ra-shu-yu-shi-me-yin-yong" class="header-anchor">#</a></h2>
<p>A:  强引用StrongRefernce，默认的引用操作都是强引用</p>
<hr>
<h2><span id="q-ru-guo-zhi-you-ra-yin-yong-liao-a-zai-nei-cun-bu-zu-shi-hui-qiang-zhi-hui-shou-a-ze-ra-shu-yu-shi-me-yin-yong">Q： 如果只有RA引用了A， 在内存不足时会强制回收A，则RA属于什么引用？</span><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-zai-nei-cun-bu-zu-shi-hui-qiang-zhi-hui-shou-a-ze-ra-shu-yu-shi-me-yin-yong" class="header-anchor">#</a></h2>
<p>A: 软引用SoftReferencem，用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
<hr>
<h2><span id="q-ru-guo-zhi-you-ra-yin-yong-liao-a-bu-guan-nei-cun-zu-bu-zu-zhi-yao-la-ji-hui-shou-qi-sao-miao-dao-liao-jiu-hui-zhi-jie-hui-shou-ra-shu-yu">Q： 如果只有RA引用了A， 不管内存足不足，只要垃圾回收器扫描到了，就会直接回收，RA属于：</span><a href="#q-ru-guo-zhi-you-ra-yin-yong-liao-a-bu-guan-nei-cun-zu-bu-zu-zhi-yao-la-ji-hui-shou-qi-sao-miao-dao-liao-jiu-hui-zhi-jie-hui-shou-ra-shu-yu" class="header-anchor">#</a></h2>
<p>A： 弱引用WeakReference，  注意和垃圾收集器的启动间隔有关，因此短时间内RA还是可用的。<br>
和这个引用相关的集合：WeakHashMap</p>
<hr>
<h2><span id="q-dang-zhi-you-ra-yin-yong-liao-a-shi-du-hui-zai-xia-yi-ci-la-ji-shou-ji-shi-zhi-jie-hui-shou-qie-chuang-jian-yin-yong-shi-bi-xu-yi-lai-yin-yong-dui-lie-zhe-ge-yin-yong-ra-shu-yu">Q： 当只有RA引用了A时，都会在下一次垃圾收集时直接回收，且创建引用时必须依赖引用队列，这个引用RA属于：</span><a href="#q-dang-zhi-you-ra-yin-yong-liao-a-shi-du-hui-zai-xia-yi-ci-la-ji-shou-ji-shi-zhi-jie-hui-shou-qie-chuang-jian-yin-yong-shi-bi-xu-yi-lai-yin-yong-dui-lie-zhe-ge-yin-yong-ra-shu-yu" class="header-anchor">#</a></h2>
<p>A： 虚引用（幽灵引用）PhantomReference。<br>
和弱引用区别：<br>
虚引用创建时必须依赖引用队列，且用途一般是跟踪对象的垃圾回收，让用户在回收时通过虚引用去触发一些清理行为。</p>
<hr>
<h2><span id="q-yin-yong-dui-lie-shi-shi-me-zuo-yong-shi-shi-me">Q： 引用队列是什么，作用是什么？</span><a href="#q-yin-yong-dui-lie-shi-shi-me-zuo-yong-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： 引用队列可以配合软引用、弱引用及幽灵引用使用，当引用的对象将要被JVM回收时，会将其加入到引用队列。<br>
应用：通过引用队列可以了解JVM垃圾回收情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 引用队列</span></span><br><span class="line">ReferenceQueue&lt;String&gt; rq = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 幽灵引用</span></span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>), rq);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 永远为null（幽灵引用相当于无引用）</span></span><br><span class="line">System.out.println(pr.get());</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218485847000930.png" alt="image.png"></p>
<h2><span id="you-xian-dui-lie">优先队列</span><a href="#you-xian-dui-lie" class="header-anchor">#</a></h2>
<p><img src="/images/java%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/1614218491033053213.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">类初始化顺序和类加载基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-12 00:13:51 / 修改时间：00:16:33" itemprop="dateCreated datePublished" datetime="2022-08-12T00:13:51+08:00">2022-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#java-lei-de-jia-zai-shun-xu">Java类的加载顺序</a>
<ul>
<li><a href="#q-shi-me-shi-hou-hui-jin-xing-jing-tai-bian-liang-de-fu-zhi-he-jing-tai-dai-ma-kuai-de-zhi-xing">Q： 什么时候会进行静态变量的赋值和静态代码块的执行？</a></li>
<li><a href="#q-chu-shi-hua-mou-ge-zi-lei-shi-ye-hui-dui-fu-lei-zuo-jing-tai-chu-shi-hua-ma-shun-xu-ni">Q：初始化某个子类时，也会对父类做静态初始化吗？顺序呢？</a></li>
<li><a href="#q-wei-shi-me-fu-lei-de-method-bu-hui-bei-zi-lei-de-method-chong-xie">Q： 为什么父类的method不会被子类的method重写？</a></li>
<li><a href="#q-wei-shi-me-di-yi-ge-shu-chu-de-shi-e-er-bu-shi-a">Q： 为什么第一个输出的是e而不是a？</a></li>
<li><a href="#q-mei-you-zai-zi-lei-de-gou-zao-qi-zhong-diao-yong-super-shi-ye-hui-jin-xing-fu-lei-dui-xiang-de-shi-li-hua-ma">Q： 没有在子类的构造器中调用super()时，也会进行父类对象的实例化吗？</a></li>
<li><a href="#q-gou-zao-fang-fa-cheng-yuan-xian-shi-fu-zhi-fei-jing-tai-dai-ma-kuai-ji-shu-chu-c-he-h-de-na-2-ju-de-shun-xu-shi-shi-me">Q： 构造方法、成员显示赋值、非静态代码块（即输出c和h的那2句）的顺序是什么？</a></li>
<li><a href="#q-wei-shi-me-animal-shi-li-hua-shi-i-test-zhong-shu-chu-de-shi-i-er-bu-shi-d">Q： 为什么Animal实例化时， i=test()中输出的是i而不是d？</a></li>
<li><a href="#q-tong-shang-ti-ru-guo-test-fang-fa-du-shi-private-huo-zhe-final-shu-xing-na-me-shang-ti-de-qing-kuang-hui-you-bian-hua-ma">Q： 同上题， 如果test方法都是private或者final属性， 那么上题的情况会有变化吗？？</a></li>
</ul>
</li>
<li><a href="#lei-jia-zai-guo-cheng">类加载过程</a>
<ul>
<li><a href="#q-lei-jia-zai-de-3-ge-bi-jing-jie-duan-shi">Q：类加载的3个必经阶段是：</a></li>
</ul>
</li>
<li><a href="#bei-dong-yin-yong-zhong-he-lei-jing-tai-chu-shi-hua-de-guan-xi">被动引用中和类静态初始化的关系</a>
<ul>
<li><a href="#q-new-mou-ge-lei-de-shu-zu-shi-hui-yin-fa-lei-chu-shi-hua-ma">Q：new某个类的数组时，会引发类初始化吗？</a></li>
<li><a href="#q-yin-yong-lei-de-final-jing-tai-zi-duan-hui-yin-fa-lei-chu-shi-hua-ma">Q：引用类的final静态字段，会引发类初始化吗？</a></li>
<li><a href="#q-zi-lei-yin-yong-liao-fu-lei-de-jing-tai-cheng-yuan-ci-shi-zi-lei-hui-zuo-lei-chu-shi-hua-ma">Q：子类引用了父类的静态成员，此时子类会做类初始化嘛？</a></li>
</ul>
</li>
<li><a href="#lei-jia-zai-qi">类加载器</a>
<ul>
<li><a href="#shuang-qin-wei-pai">双亲委派</a></li>
<li><a href="#q-java-zhong-shi-fou-lei-he-jie-kou-de-bao-ming-he-ming-zi-xiang-tong-na-me-jiu-yi-ding-shi-tong-yi-ge-lei-huo-zhe-jie-kou">Q：java中， 是否类和接口的包名和名字相同， 那么就一定是同一个类或者接口？</a></li>
<li><a href="#q-jiang-yi-xia-classloader-yuan-li-yi-ji-ying-yong-chang-jing">Q: 讲一下ClassLoader原理， 以及应用场景</a></li>
<li><a href="#q-ru-guo-zai-ni-xiang-mu-zhong-jian-yi-ge-java-lang-string-de-lei-na-xi-tong-zhong-yong-de-string-lei-shi-ni-ding-yi-de-string-lei-huan-shi-yuan-sheng-api-zhong-de-string-lei">Q:如果在你项目中建一个java.lang.String的类，那系统中用的String类是你定义的String类，还是原生api中的String类？</a></li>
<li><a href="#q-wei-shi-me-yao-yong-shuang-qin-wei-tuo-you-shi-me-hao-chu">Q ： 为什么要用双亲委托，有什么好处？</a></li>
<li><a href="#q-na-wo-ru-guo-zhen-de-you-xu-qiu-bu-xiang-yong-shuang-qin-de-ji-zhi-ni">Q: 那我如果真的有需求， 不想用双亲的机制呢？</a></li>
<li><a href="#q-shu-zu-lei-shi-zen-me-zuo-jia-zai-de">Q: 数组类是怎么做加载的？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>很多时候提到类加载，大家总是没法马上回忆起顺序，这篇文章会用一个例子为你把类加载的诸多问题一次性澄清。</p>
<h1><span id="java-lei-de-jia-zai-shun-xu">Java类的加载顺序</span><a href="#java-lei-de-jia-zai-shun-xu" class="header-anchor">#</a></h1>
<p>引用1个网上的经典例子，并做稍许改动，以便大家更好地理解。<br>
原例子引用自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zfx2013/article/details/89453482">https://blog.csdn.net/zfx2013/article/details/89453482</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> j ?= method();</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     Animal()&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">     &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> j ?= method();</span><br><span class="line"></span><br><span class="line">     Dog()&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">          System.out.println();</span><br><span class="line">          <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行这段main程序，会输出什么？<br>
答案是<br>
eafjicbhig<br>
icbhig</p>
<p>为了方便大家一个个细节去理解， 我换一种方式去提问。</p>
<h2><span id="q-shi-me-shi-hou-hui-jin-xing-jing-tai-bian-liang-de-fu-zhi-he-jing-tai-dai-ma-kuai-de-zhi-xing">Q： 什么时候会进行静态变量的赋值和静态代码块的执行？</span><a href="#q-shi-me-shi-hou-hui-jin-xing-jing-tai-bian-liang-de-fu-zhi-he-jing-tai-dai-ma-kuai-de-zhi-xing" class="header-anchor">#</a></h2>
<p>A：?</p>
<ul>
<li>第一次创建某个类或者某个类的子类的实例</li>
<li>访问类的静态变量、调用类的静态方法</li>
<li>使用反射方法forName</li>
<li>调用主类的main方法(本例子的第一次静态初始化其实属于这个情况，调用了Dog的main方法）<br>
注： 类初始化只会进行一次， 上面任何一种情况触发后，之后都不会再引起类初始化操作。</li>
</ul>
<hr>
<h2><span id="q-chu-shi-hua-mou-ge-zi-lei-shi-ye-hui-dui-fu-lei-zuo-jing-tai-chu-shi-hua-ma-shun-xu-ni">Q：初始化某个子类时，也会对父类做静态初始化吗？顺序呢？</span><a href="#q-chu-shi-hua-mou-ge-zi-lei-shi-ye-hui-dui-fu-lei-zuo-jing-tai-chu-shi-hua-ma-shun-xu-ni" class="header-anchor">#</a></h2>
<p>A：如果父类之前没有被静态初始化过，那就会进行， 且顺序是先父类再子类。 后面的非静态成员初始化也是如此。<br>
所以会先输出eafj。</p>
<hr>
<h2><span id="q-wei-shi-me-fu-lei-de-method-bu-hui-bei-zi-lei-de-method-chong-xie">Q： 为什么父类的method不会被子类的method重写？</span><a href="#q-wei-shi-me-fu-lei-de-method-bu-hui-bei-zi-lei-de-method-chong-xie" class="header-anchor">#</a></h2>
<p>A： 静态方法是类方法，不会被子类重写。毕竟类方法调用时，是必定带上类名的。</p>
<hr>
<h2><span id="q-wei-shi-me-di-yi-ge-shu-chu-de-shi-e-er-bu-shi-a">Q： 为什么第一个输出的是e而不是a？</span><a href="#q-wei-shi-me-di-yi-ge-shu-chu-de-shi-e-er-bu-shi-a" class="header-anchor">#</a></h2>
<p>A： 因为类变量的显示赋值代码和静态代码块代码按照从上到下的顺序执行。<br>
Animal的静态初始化过程中，method的调用在static代码块之前，所以先输出e再输出a。<br>
而Dog的静态初始化过程中，method的调用在static代码块之后，因此先输出f，再输出j</p>
<hr>
<h2><span id="q-mei-you-zai-zi-lei-de-gou-zao-qi-zhong-diao-yong-super-shi-ye-hui-jin-xing-fu-lei-dui-xiang-de-shi-li-hua-ma">Q： 没有在子类的构造器中调用super()时，也会进行父类对象的实例化吗？</span><a href="#q-mei-you-zai-zi-lei-de-gou-zao-qi-zhong-diao-yong-super-shi-ye-hui-jin-xing-fu-lei-dui-xiang-de-shi-li-hua-ma" class="header-anchor">#</a></h2>
<p>A： 会的。会自动调用父类的默认构造器。 ?super()主要是用于需要调用父类的特殊构造器的情况。<br>
因此会先进行Animal的对象实例化，再进行Dog的对象实例化</p>
<hr>
<h2><span id="q-gou-zao-fang-fa-cheng-yuan-xian-shi-fu-zhi-fei-jing-tai-dai-ma-kuai-ji-shu-chu-c-he-h-de-na-2-ju-de-shun-xu-shi-shi-me">Q： 构造方法、成员显示赋值、非静态代码块（即输出c和h的那2句）的顺序是什么？</span><a href="#q-gou-zao-fang-fa-cheng-yuan-xian-shi-fu-zhi-fei-jing-tai-dai-ma-kuai-ji-shu-chu-c-he-h-de-na-2-ju-de-shun-xu-shi-shi-me" class="header-anchor">#</a></h2>
<p>A：?</p>
<ol>
<li>成员显示赋值、非静态代码块（按定义顺序）</li>
<li>构造方法<br>
因此Animal的实例化过程输出icb（如果对输出i有疑问，见下面一题）<br>
接着进行Dog的实例化，输出hig</li>
</ol>
<hr>
<h2><span id="q-wei-shi-me-animal-shi-li-hua-shi-i-test-zhong-shu-chu-de-shi-i-er-bu-shi-d">Q： 为什么Animal实例化时， i=test()中输出的是i而不是d？</span><a href="#q-wei-shi-me-animal-shi-li-hua-shi-i-test-zhong-shu-chu-de-shi-i-er-bu-shi-d" class="header-anchor">#</a></h2>
<p>A:因为你真正创建的是Dog子类，Dog子类中的test()方法由于签名和父类test方法一致，因此test方法被重写了。?<br>
此时即使在父类中调用，也还是用使用子类Dog的方法。除非你new的是Animal。</p>
<hr>
<h2><span id="q-tong-shang-ti-ru-guo-test-fang-fa-du-shi-private-huo-zhe-final-shu-xing-na-me-shang-ti-de-qing-kuang-hui-you-bian-hua-ma">Q： 同上题， 如果test方法都是private或者final属性， 那么上题的情况会有变化吗？？</span><a href="#q-tong-shang-ti-ru-guo-test-fang-fa-du-shi-private-huo-zhe-final-shu-xing-na-me-shang-ti-de-qing-kuang-hui-you-bian-hua-ma" class="header-anchor">#</a></h2>
<p>A: ?<br>
因为private和final方法是不能被子类重写的。<br>
所以Animal实例化时，i=test输出d。</p>
<hr>
<p>总结一下顺序：</p>
<ol>
<li>父类静态变量显式赋值、父类静态代码块（按定义顺序）</li>
<li>子类静态变量显式赋值、子类静态代码块（按定义顺序）</li>
<li>父类非静态变量显式赋值（父类实例成员变量）、父类非静态代码块（按定义顺序）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）、子类非静态代码块（按定义顺序）</li>
<li>子类构造函数。</li>
</ol>
<h1><span id="lei-jia-zai-guo-cheng">类加载过程</span><a href="#lei-jia-zai-guo-cheng" class="header-anchor">#</a></h1>
<h2><span id="q-lei-jia-zai-de-3-ge-bi-jing-jie-duan-shi">Q：类加载的3个必经阶段是：</span><a href="#q-lei-jia-zai-de-3-ge-bi-jing-jie-duan-shi" class="header-anchor">#</a></h2>
<p>A：</p>
<ol>
<li>加载（类加载器读取二进制字节流，生成java类对象）</li>
<li>链接（验证，分配静态域初始零值）</li>
<li>初始化（前面的题目讲的其实就是初始化时的顺序）<br>
更详细的如下：<br>
<img src="/images/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image(142).png" alt="image.png"></li>
</ol>
<h1><span id="bei-dong-yin-yong-zhong-he-lei-jing-tai-chu-shi-hua-de-guan-xi">被动引用中和类静态初始化的关系</span><a href="#bei-dong-yin-yong-zhong-he-lei-jing-tai-chu-shi-hua-de-guan-xi" class="header-anchor">#</a></h1>
<h2><span id="q-new-mou-ge-lei-de-shu-zu-shi-hui-yin-fa-lei-chu-shi-hua-ma">Q：new某个类的数组时，会引发类初始化吗？</span><a href="#q-new-mou-ge-lei-de-shu-zu-shi-hui-yin-fa-lei-chu-shi-hua-ma" class="header-anchor">#</a></h2>
<p>像下面输出什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">static</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ?</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          A[] as = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">5</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：?<br>
new数组时，不会引发类初始化。<br>
什么都不输出。</p>
<hr>
<h2><span id="q-yin-yong-lei-de-final-jing-tai-zi-duan-hui-yin-fa-lei-chu-shi-hua-ma">Q：引用类的final静态字段，会引发类初始化吗？</span><a href="#q-yin-yong-lei-de-final-jing-tai-zi-duan-hui-yin-fa-lei-chu-shi-hua-ma" class="header-anchor">#</a></h2>
<p>像下面输出什么?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">static</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;A.a=&quot;</span> + A.a);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A： 不会引发。<br>
不会输出initA。 去掉final就会引发了。<br>
（注意这里必须是基本类型常量， 如果是引用类型产量，则会引发类初始化）</p>
<hr>
<h2><span id="q-zi-lei-yin-yong-liao-fu-lei-de-jing-tai-cheng-yuan-ci-shi-zi-lei-hui-zuo-lei-chu-shi-hua-ma">Q：子类引用了父类的静态成员，此时子类会做类初始化嘛？</span><a href="#q-zi-lei-yin-yong-liao-fu-lei-de-jing-tai-cheng-yuan-ci-shi-zi-lei-hui-zuo-lei-chu-shi-hua-ma" class="header-anchor">#</a></h2>
<p>如下会输出什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">static</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initA&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">          <span class="keyword">static</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;initB&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;B.a=&quot;</span> + B.a);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：?<br>
子类不会初始化。<br>
打印initA,却不会打印initB。</p>
<h1><span id="lei-jia-zai-qi">类加载器</span><a href="#lei-jia-zai-qi" class="header-anchor">#</a></h1>
<h2><span id="shuang-qin-wei-pai">双亲委派</span><a href="#shuang-qin-wei-pai" class="header-anchor">#</a></h2>
<hr>
<p>类加载时的双亲委派模型，不知道能怎么出题。。。反正就记得优先去父类加载器中看类是否能加载。<br>
就贴个图吧<br>
<img src="/images/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/image(143).png" alt="image.png"></p>
<hr>
<p>注意，上面的图有问题。<br>
Bootsrap不是ClassLoader的子类，他是C++编写的。<br>
而ExtClassLoader和AppClassLoader都是继承自ClassLoader的</p>
<h2><span id="q-java-zhong-shi-fou-lei-he-jie-kou-de-bao-ming-he-ming-zi-xiang-tong-na-me-jiu-yi-ding-shi-tong-yi-ge-lei-huo-zhe-jie-kou">Q：java中， 是否类和接口的包名和名字相同， 那么就一定是同一个类或者接口？</span><a href="#q-java-zhong-shi-fou-lei-he-jie-kou-de-bao-ming-he-ming-zi-xiang-tong-na-me-jiu-yi-ding-shi-tong-yi-ge-lei-huo-zhe-jie-kou" class="header-anchor">#</a></h2>
<p>A：<br>
错误。<br>
1个jvm中， 类和接口的唯一性由 <em><strong>二进制名称以及它的定义类加载器</strong></em> 共同决定。<br>
因此2个不同的加载器加载出来相同的类或接口时， 实际上是不同的。</p>
<hr>
<h2><span id="q-jiang-yi-xia-classloader-yuan-li-yi-ji-ying-yong-chang-jing">Q: 讲一下ClassLoader原理， 以及应用场景</span><a href="#q-jiang-yi-xia-classloader-yuan-li-yi-ji-ying-yong-chang-jing" class="header-anchor">#</a></h2>
<p>loaderClass  双亲加载实现（这里会体现先去父亲找，再自己）<br>
findClass  如何根据名字，生成1个class（内部需要借助defineClass）<br>
defineClass  通过这个方法生成1个class类</p>
<p>例如需要根据类目，从某个远端网络加载获取这个类， 而且获取过来的时候还是加密的，需要在findClass里对byte数组做解密并加载。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/82757435">https://blog.csdn.net/zzti_erlie/article/details/82757435</a></p>
<hr>
<h2><span id="q-ru-guo-zai-ni-xiang-mu-zhong-jian-yi-ge-java-lang-string-de-lei-na-xi-tong-zhong-yong-de-string-lei-shi-ni-ding-yi-de-string-lei-huan-shi-yuan-sheng-api-zhong-de-string-lei">Q:如果在你项目中建一个java.lang.String的类，那系统中用的String类是你定义的String类，还是原生api中的String类？</span><a href="#q-ru-guo-zai-ni-xiang-mu-zhong-jian-yi-ge-java-lang-string-de-lei-na-xi-tong-zhong-yong-de-string-lei-shi-ni-ding-yi-de-string-lei-huan-shi-yuan-sheng-api-zhong-de-string-lei" class="header-anchor">#</a></h2>
<p>A:<br>
用的原生api中的string， 因为双亲委派机制。</p>
<hr>
<h2><span id="q-wei-shi-me-yao-yong-shuang-qin-wei-tuo-you-shi-me-hao-chu">Q ： 为什么要用双亲委托，有什么好处？</span><a href="#q-wei-shi-me-yao-yong-shuang-qin-wei-tuo-you-shi-me-hao-chu" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>对于任意一个类，都需要由加载它的&quot;类加载器和这个类本身&quot;来一同确立其在Java虚拟机中的唯一性。那么双亲委派可以保证顺序加载的特性。</li>
<li>核心类的安全。Object类如果不使用双亲委派原则的话，那么A创建的Object对象就可能和B创建的Object是不一样的。不使用双亲委派原则无法保证一些java核心类库的唯一性</li>
<li>例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</li>
</ul>
<hr>
<h2><span id="q-na-wo-ru-guo-zhen-de-you-xu-qiu-bu-xiang-yong-shuang-qin-de-ji-zhi-ni">Q: 那我如果真的有需求， 不想用双亲的机制呢？</span><a href="#q-na-wo-ru-guo-zhen-de-you-xu-qiu-bu-xiang-yong-shuang-qin-de-ji-zhi-ni" class="header-anchor">#</a></h2>
<p>A:<br>
按照上 面说的， 自己重写类加载的loaderClass就行了， 不走双亲机制的那块代码。</p>
<hr>
<h2><span id="q-shu-zu-lei-shi-zen-me-zuo-jia-zai-de">Q: 数组类是怎么做加载的？</span><a href="#q-shu-zu-lei-shi-zen-me-zuo-jia-zai-de" class="header-anchor">#</a></h2>
<p>A:<br>
数组类是由AppClassLoader加载的。<br>
数组类打印className时，前面会有个[Lxx类<br>
二维数组就是[[Lxxx类<br>
数组类的父类型是Object</p>
<p>注意此时加载的是数组类，而数组类里面的对象是不会做自动加载的<br>
因此xx类的静态代码并不会被直接调用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">类和接口基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-12 00:09:30 / 修改时间：00:20:20" itemprop="dateCreated datePublished" datetime="2022-08-12T00:09:30+08:00">2022-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/12/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-base/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#xiu-shi-fu">修饰符</a>
<ul>
<li><a href="#q-ge-xiu-shi-fu-suo-dai-biao-de-ke-jian-xing">Q： 各修饰符所代表的可见性？</a></li>
<li><a href="#q-wai-bu-lei-ke-yi-yong-private-huo-zhe-protect-xiu-shi-ma">Q： 外部类可以用private或者protect修饰吗？</a></li>
<li><a href="#jie-shi-yi-xia-final-de-zuo-yong">解释以下final的作用</a>
<ul>
<li><a href="#q-final-cheng-yuan">Q： final 成员？</a></li>
<li><a href="#q-final-can-shu">Q： final 参数？</a></li>
<li><a href="#q-final-fang-fa">Q： final方法</a></li>
<li><a href="#q-final-lei">Q： final类</a></li>
</ul>
</li>
<li><a href="#q-final-ju-bu-bian-liang-ke-yi-zuo-wei-fei-final-de-can-shu-chuan-ru-ma-hui-bian-yi-bao-cuo-ma">Q:final局部变量可以作为非final的参数传入吗？会编译报错吗？</a></li>
</ul>
</li>
<li><a href="#lei">类</a>
<ul>
<li><a href="#q-chong-zai-he-chong-xie-de-qu-bie">Q： 重载和重写的区别？</a></li>
<li><a href="#q-ru-guo-zi-lei-chong-xie-liao-fu-lei-zhong-de-fang-fa-na-me-zi-lei-zhong-huan-neng-diao-yong-fu-lei-zhong-de-tong-ming-fang-fa-ma">Q: 如果子类重写了父类中的方法， 那么子类中还能调用父类中的同名方法吗？</a></li>
<li><a href="#q-zen-yang-neng-bi-mian-zi-lei-zai-chong-xie-fu-lei-de-fang-fa-bu-xiao-xin-nong-cheng-liao-chong-zai">Q: 怎样能避免子类在重写父类的方法，不小心弄成了重载？</a></li>
<li><a href="#q-fu-lei-de-cheng-yuan-bian-liang-neng-bei-chong-xie-fu-gai-ma">Q：父类的成员变量能被重写/覆盖嘛？</a></li>
<li><a href="#q-nei-bu-lei-shi-sha-nei-bu-lei-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q：内部类是啥，内部类能访问外部类的成员吗？</a></li>
<li><a href="#q-a-zhong-you-1-ge-nei-bu-lei-c-a-de-zi-lei-b-zhong-ye-you-1-ge-nei-bu-lei-c-b-zhong-de-c-hui-fu-gai-a-zhong-de-c-ma">Q： A中有1个内部类C， A的子类B中也有1个内部类C， B中的C会覆盖A中的C吗？</a></li>
<li><a href="#q-ke-yi-zai-nei-bu-lei-zhong-ding-yi-jing-tai-cheng-yuan-ma">Q：可以在内部类中定义静态成员吗？</a></li>
<li><a href="#q-ni-ming-lei-shi-sha-ni-ming-lei-neng-fang-wen-wai-mian-de-bian-liang-huo-zhe-dui-xiang-ma">Q： 匿名类是啥， 匿名类能访问外面的变量或者对象吗？</a></li>
<li><a href="#q-qian-tao-lei-shi-sha-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q: 嵌套类是啥，能访问外部类的成员吗？</a></li>
</ul>
</li>
<li><a href="#jie-kou">接口</a>
<ul>
<li><a href="#q-jie-kou-zhong-ru-guo-yao-ding-yi-cheng-yuan-bian-liang-na-cheng-yuan-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中如果要定义成员变量，那成员的默认修饰符是什么？</a></li>
<li><a href="#q-jie-kou-zhong-ge-fang-fa-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中各方法的默认修饰符是什么？</a></li>
<li><a href="#q-jie-kou-zhong-ke-yi-ding-yi-shi-xian-ju-ti-fang-fa-ma">Q： 接口中可以定义实现具体方法嘛？</a></li>
</ul>
</li>
<li><a href="#mei-ju">枚举</a>
<ul>
<li><a href="#q-enum-ke-yi-bei-ji-cheng-ma">Q： enum可以被继承吗？</a></li>
<li><a href="#q-switch-enum-shi-xu-yao-jia-default-ma">Q： switch(enum)时需要加default吗？</a></li>
<li><a href="#q-enum-ji-lei-li-shi-xian-liao-values-fang-fa-ma">Q： Enum基类里实现了values()方法吗？</a></li>
</ul>
</li>
<li><a href="#jing-tai-fen-pai-he-dong-tai-fen-pai">静态分派和动态分派</a>
<ul>
<li><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派？</a></li>
<li><a href="#q-she-ji-ru-xia-ge-chong-bu-tong-shu-ju-lei-xing-de-jing-tai-fen-pai-ru-he-ying-dui">Q： 涉及如下各种不同数据类型的静态分派如何应对？</a></li>
<li><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派：</a></li>
<li><a href="#q-jing-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai-dong-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai">Q：静态分派属于单分派还是多分派？动态分派属于单分派还是多分派？</a></li>
<li><a href="#q-lei-fang-fa-zai-class-wen-jian-zhong-shi-shi-me-yang-de-shi-fu-hao-yin-yong-huan-shi-zhi-jie-yin-yong">Q：类方法在class文件中是什么样的? 是符号引用还是直接引用？</a></li>
<li><a href="#q-shi-me-shi-hou-fang-fa-de-fu-hao-yin-yong-hui-zhuan-wei-shi-ji-fang-fa-qu-zhong-de-zhi-jie-yin-yong">Q：什么时候方法的符号引用会转为实际方法区中的直接引用？</a></li>
<li><a href="#q-dong-tai-fen-pai-ji-duo-tai-xu-ni-ji-li-shi-zen-me-que-ding-diao-yong-na-ge-fang-fa-de">Q：动态分派(即多态）， 虚拟机里是怎么确定调用哪个方法的？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="xiu-shi-fu">修饰符</span><a href="#xiu-shi-fu" class="header-anchor">#</a></h1>
<h2><span id="q-ge-xiu-shi-fu-suo-dai-biao-de-ke-jian-xing">Q： 各修饰符所代表的可见性？</span><a href="#q-ge-xiu-shi-fu-suo-dai-biao-de-ke-jian-xing" class="header-anchor">#</a></h2>
<p>public: 可被所有使用<br>
protect： 只能被自己和子类使用，或者同一个包路径<br>
private： 只能自己使用，儿子都不行<br>
不加修饰符即default权限： 包访问权限，和他在同一包内的类都可以访问他，包外的则都不能访问</p>
<hr>
<h2><span id="q-wai-bu-lei-ke-yi-yong-private-huo-zhe-protect-xiu-shi-ma">Q： 外部类可以用private或者protect修饰吗？</span><a href="#q-wai-bu-lei-ke-yi-yong-private-huo-zhe-protect-xiu-shi-ma" class="header-anchor">#</a></h2>
<p>A： 不能，只能用public或者包访问权限。 内部类可以。</p>
<hr>
<h2><span id="jie-shi-yi-xia-final-de-zuo-yong">解释以下final的作用</span><a href="#jie-shi-yi-xia-final-de-zuo-yong" class="header-anchor">#</a></h2>
<h3><span id="q-final-cheng-yuan">Q： final 成员？</span><a href="#q-final-cheng-yuan" class="header-anchor">#</a></h3>
<p>A： 如果是基本类型，则指值不能被改变。 如果是对象，指对象的引用不可改变，但是引用处的内容可改变。</p>
<hr>
<p>编译器会要求final成员必须初始化或者构造器里赋值，且后续不能再主动赋值。</p>
<h3><span id="q-final-can-shu">Q： final 参数？</span><a href="#q-final-can-shu" class="header-anchor">#</a></h3>
<p>A： 参数不可变，只能读不能修改，同上</p>
<hr>
<h3><span id="q-final-fang-fa">Q： final方法</span><a href="#q-final-fang-fa" class="header-anchor">#</a></h3>
<p>A： 方法不能被子类重写。</p>
<hr>
<h3><span id="q-final-lei">Q： final类</span><a href="#q-final-lei" class="header-anchor">#</a></h3>
<p>A： 该类不能被继承。</p>
<hr>
<h2><span id="q-final-ju-bu-bian-liang-ke-yi-zuo-wei-fei-final-de-can-shu-chuan-ru-ma-hui-bian-yi-bao-cuo-ma">Q:final局部变量可以作为非final的参数传入吗？会编译报错吗？</span><a href="#q-final-ju-bu-bian-liang-ke-yi-zuo-wei-fei-final-de-can-shu-chuan-ru-ma-hui-bian-yi-bao-cuo-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	changeA(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">	<span class="comment">// change A...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
可以作为非final的参数传入，不会编译报错。</p>
<hr>
<h1><span id="lei">类</span><a href="#lei" class="header-anchor">#</a></h1>
<h2><span id="q-chong-zai-he-chong-xie-de-qu-bie">Q： 重载和重写的区别？</span><a href="#q-chong-zai-he-chong-xie-de-qu-bie" class="header-anchor">#</a></h2>
<p>A：<br>
重载是方法名相同，参数不同。<br>
重写是方法参数等都一致的情况下重写父类的方法。</p>
<hr>
<h2><span id="q-ru-guo-zi-lei-chong-xie-liao-fu-lei-zhong-de-fang-fa-na-me-zi-lei-zhong-huan-neng-diao-yong-fu-lei-zhong-de-tong-ming-fang-fa-ma">Q: 如果子类重写了父类中的方法， 那么子类中还能调用父类中的同名方法吗？</span><a href="#q-ru-guo-zi-lei-chong-xie-liao-fu-lei-zhong-de-fang-fa-na-me-zi-lei-zhong-huan-neng-diao-yong-fu-lei-zhong-de-tong-ming-fang-fa-ma" class="header-anchor">#</a></h2>
<p>A: 可以，super.xxx即可（C++中不可以调用父类中的同名重载方法)。</p>
<hr>
<h2><span id="q-zen-yang-neng-bi-mian-zi-lei-zai-chong-xie-fu-lei-de-fang-fa-bu-xiao-xin-nong-cheng-liao-chong-zai">Q: 怎样能避免子类在重写父类的方法，不小心弄成了重载？</span><a href="#q-zen-yang-neng-bi-mian-zi-lei-zai-chong-xie-fu-lei-de-fang-fa-bu-xiao-xin-nong-cheng-liao-chong-zai" class="header-anchor">#</a></h2>
<p>（即你想重写父类的f(int), 却不小心写成了f(int，int)，导致调用f(int)时还是调用了父类的f ，怎么能避免这种失误？）<br>
A: 加个@Override关键字即可，原文解释：<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/69e4b13dbfbb57476c7f29e7a5b00ee24db66776.png" alt="69e4b13dbfbb57476c7f29e7a5b00ee24db66776"></p>
<hr>
<h2><span id="q-fu-lei-de-cheng-yuan-bian-liang-neng-bei-chong-xie-fu-gai-ma">Q：父类的成员变量能被重写/覆盖嘛？</span><a href="#q-fu-lei-de-cheng-yuan-bian-liang-neng-bei-chong-xie-fu-gai-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main&#123;</span><br><span class="line">	<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">   System.out.println(a.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
输出A。<br>
注意成员变量不具有多态性，因此你定义的是A，赋值的是B， 那么输出的依旧是A里的成员。<br>
如果是被重写的方法的话，那会用B里的方法。</p>
<hr>
<h2><span id="q-nei-bu-lei-shi-sha-nei-bu-lei-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q：内部类是啥，内部类能访问外部类的成员吗？</span><a href="#q-nei-bu-lei-shi-sha-nei-bu-lei-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma" class="header-anchor">#</a></h2>
<p>A：<br>
内部类概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">   		...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B就是A的内部类,B能访问A的所有成员</p>
<hr>
<h2><span id="q-a-zhong-you-1-ge-nei-bu-lei-c-a-de-zi-lei-b-zhong-ye-you-1-ge-nei-bu-lei-c-b-zhong-de-c-hui-fu-gai-a-zhong-de-c-ma">Q： A中有1个内部类C， A的子类B中也有1个内部类C， B中的C会覆盖A中的C吗？</span><a href="#q-a-zhong-you-1-ge-nei-bu-lei-c-a-de-zi-lei-b-zhong-ye-you-1-ge-nei-bu-lei-c-b-zhong-de-c-hui-fu-gai-a-zhong-de-c-ma" class="header-anchor">#</a></h2>
<p>A： 不会， 因为使用时是通过B.C或者A.C去调用的，存在命名空间的关系。</p>
<hr>
<h2><span id="q-ke-yi-zai-nei-bu-lei-zhong-ding-yi-jing-tai-cheng-yuan-ma">Q：可以在内部类中定义静态成员吗？</span><a href="#q-ke-yi-zai-nei-bu-lei-zhong-ding-yi-jing-tai-cheng-yuan-ma" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    	<span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line">   		...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
不可以。 除非在class B前面加static变为静态类</p>
<hr>
<h2><span id="q-ni-ming-lei-shi-sha-ni-ming-lei-neng-fang-wen-wai-mian-de-bian-liang-huo-zhe-dui-xiang-ma">Q： 匿名类是啥， 匿名类能访问外面的变量或者对象吗？</span><a href="#q-ni-ming-lei-shi-sha-ni-ming-lei-neng-fang-wen-wai-mian-de-bian-liang-huo-zhe-dui-xiang-ma" class="header-anchor">#</a></h2>
<p>A： 匿名类概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>(构造参数)&#123;</span><br><span class="line">   &#123;构造器内容&#125;</span><br><span class="line">   类定义 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类如果要用外面的对象， 外面的对象必须要定义为final。</p>
<hr>
<h2><span id="q-qian-tao-lei-shi-sha-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma">Q: 嵌套类是啥，能访问外部类的成员吗？</span><a href="#q-qian-tao-lei-shi-sha-neng-fang-wen-wai-bu-lei-de-cheng-yuan-ma" class="header-anchor">#</a></h2>
<p>A：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> sa;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B只能访问A中的静态成员sa, 而不能访问a。</p>
<h1><span id="jie-kou">接口</span><a href="#jie-kou" class="header-anchor">#</a></h1>
<p>类是单继承，接口可以多继承</p>
<hr>
<h2><span id="q-jie-kou-zhong-ru-guo-yao-ding-yi-cheng-yuan-bian-liang-na-cheng-yuan-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中如果要定义成员变量，那成员的默认修饰符是什么？</span><a href="#q-jie-kou-zhong-ru-guo-yao-ding-yi-cheng-yuan-bian-liang-na-cheng-yuan-de-mo-ren-xiu-shi-fu-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： public static final</p>
<hr>
<h2><span id="q-jie-kou-zhong-ge-fang-fa-de-mo-ren-xiu-shi-fu-shi-shi-me">Q： 接口中各方法的默认修饰符是什么？</span><a href="#q-jie-kou-zhong-ge-fang-fa-de-mo-ren-xiu-shi-fu-shi-shi-me" class="header-anchor">#</a></h2>
<p>A： public abstract</p>
<hr>
<h2><span id="q-jie-kou-zhong-ke-yi-ding-yi-shi-xian-ju-ti-fang-fa-ma">Q： 接口中可以定义实现具体方法嘛？</span><a href="#q-jie-kou-zhong-ke-yi-ding-yi-shi-xian-ju-ti-fang-fa-ma" class="header-anchor">#</a></h2>
<p>A：<br>
java8以上版本可以。<br>
引入了default关键字，在接口中用default关键字修饰接口，就可以在接口中去实现这个接口了。</p>
<hr>
<h1><span id="mei-ju">枚举</span><a href="#mei-ju" class="header-anchor">#</a></h1>
<h2><span id="q-enum-ke-yi-bei-ji-cheng-ma">Q： enum可以被继承吗？</span><a href="#q-enum-ke-yi-bei-ji-cheng-ma" class="header-anchor">#</a></h2>
<p>像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> extend B&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A： 不可以。enum标识符本身被编译器处理过，自身就继承自Enum类，而java不支持多重继承。但支持实现接口<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6ae62ac7072c2bf308db83b832dafce68ed2d5cf.png" alt="6ae62ac7072c2bf308db83b832dafce68ed2d5cf"></p>
<hr>
<h2><span id="q-switch-enum-shi-xu-yao-jia-default-ma">Q： switch(enum)时需要加default吗？</span><a href="#q-switch-enum-shi-xu-yao-jia-default-ma" class="header-anchor">#</a></h2>
<p>A： 可以不需要。</p>
<hr>
<h2><span id="q-enum-ji-lei-li-shi-xian-liao-values-fang-fa-ma">Q： Enum基类里实现了values()方法吗？</span><a href="#q-enum-ji-lei-li-shi-xian-liao-values-fang-fa-ma" class="header-anchor">#</a></h2>
<p>A： 没有实现， values方法是编译器加的。因此从List<enum>里取出的对象，是不能调用values（）的。<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3f7ff65142341ef0771067edc7698616e0ce6154.png" alt="3f7ff65142341ef0771067edc7698616e0ce6154"></enum></p>
<hr>
<p>Q：enum里的枚举的默认修饰符默认是？<br>
A：static final</p>
<hr>
<h1><span id="jing-tai-fen-pai-he-dong-tai-fen-pai">静态分派和动态分派</span><a href="#jing-tai-fen-pai-he-dong-tai-fen-pai" class="header-anchor">#</a></h1>
<h2><span id="q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派？</span><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();          <span class="comment">//静态分派</span></span><br><span class="line">       print(father);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Father father)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;this is father&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Son son)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;this is son&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
输出this is father。 属于静态分派。<br>
静态分派概念： 编译器就能确定调用哪个方法。<br>
这里2个print属于重载方法，通过输入参数的定义类型即立刻确定调用哪个<br>
静态分派取决于静态类型</p>
<p>静态类型概念： 编译期写在java文件里能马上看到的类型<br>
例如 A a = Factory.create(args);<br>
那么左边的A就是静态类型， 而右边的类型取决于运行期，是不确定的。</p>
<hr>
<h2><span id="q-she-ji-ru-xia-ge-chong-bu-tong-shu-ju-lei-xing-de-jing-tai-fen-pai-ru-he-ying-dui">Q： 涉及如下各种不同数据类型的静态分派如何应对？</span><a href="#q-she-ji-ru-xia-ge-chong-bu-tong-shu-ju-lei-xing-de-jing-tai-fen-pai-ru-he-ying-dui" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overload</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">char</span> arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Object arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> arg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 测试代码</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出什么？<br>
A：<br>
输出 hello char<br>
因为‘a’是一个char类型数据（即静态类型是char），所以会选择参数类型为char的重载方法。<br>
若注释掉sayHello(char arg)方法，那么会输出 hello int<br>
因为‘a’除了可代表字符串，还可代表数字97。因此当没有最合适的sayHello(char arg)方式进行重载时，会选择第二合适（第二优先级）的方法重载，即sayHello(int arg)</p>
<p>总结：当没有最合适的方法进行重载时，会选优先级第二高的的方法进行重载，如此类推。<br>
优先级顺序为：char&gt;int&gt;long&gt;float&gt;double&gt;Character（自动装箱）&gt;Serializable（接口，从下往上）&gt;Object（父类1，父类2，从下往上）&gt;…<br>
其中…为变长参数，将其视为一个数组元素。变长参数的重载优先级最低。<br>
因为 char 转型到 byte 或 short 的过程是不安全的，所以不会选择参数类型为byte 或 short的方法进行重载，故优先级列表里也没有。</p>
<p><strong>上面可以看到，重载时选择方法的优先级顺序是基本类型-&gt;高精度类型-&gt;包装类-&gt;接口（从下往上）-&gt;父类（从下往上）-&gt;可变参数</strong></p>
<hr>
<h2><span id="q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai">Q： 下面输出什么，属于什么分派：</span><a href="#q-xia-mian-shu-chu-shi-me-shu-yu-shi-me-fen-pai" class="header-anchor">#</a></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();       </span><br><span class="line">     father.name();    </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>A：<br>
输出son，属于动态分派。运行的时候根据所指向的具体对象才确定调用哪个方法</p>
<hr>
<h2><span id="q-jing-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai-dong-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai">Q：静态分派属于单分派还是多分派？动态分派属于单分派还是多分派？</span><a href="#q-jing-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai-dong-tai-fen-pai-shu-yu-dan-fen-pai-huan-shi-duo-fen-pai" class="header-anchor">#</a></h2>
<p>A：<br>
静态分派是多分派。<br>
动态分派是单分派。<br>
多分派概念: 分派时即要考虑调用者的类型，也要考虑参数类型。<br>
而单分派只考虑调用者的类型。</p>
<p>动态分派原理：</p>
<hr>
<h2><span id="q-lei-fang-fa-zai-class-wen-jian-zhong-shi-shi-me-yang-de-shi-fu-hao-yin-yong-huan-shi-zhi-jie-yin-yong">Q：类方法在class文件中是什么样的? 是符号引用还是直接引用？</span><a href="#q-lei-fang-fa-zai-class-wen-jian-zhong-shi-shi-me-yang-de-shi-fu-hao-yin-yong-huan-shi-zhi-jie-yin-yong" class="header-anchor">#</a></h2>
<p>A：<br>
class文件中， 所定义的方法 都只是符号引用，即只是个符号，知道方法名字， 但是不知道方法的实际指令运行地址<br>
符号引用如下，不过我这展示的时class_info即类的符号引用， 实际上还会有method_info即方法的引用：<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ce8d672af3d63cb9a8b56a2325651bea772d8970.png" alt="ce8d672af3d63cb9a8b56a2325651bea772d8970"></p>
<p>然后方法在class文件中时这样存放的， 先是一个method_count数量，接着再存储方法。<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/03f7962c02a331c88824602f1052a7f866ae687f.png" alt="03f7962c02a331c88824602f1052a7f866ae687f"></p>
<p>此时是不知道方法的指令地址的。 除非从符号引用转为直接引用。</p>
<hr>
<h2><span id="q-shi-me-shi-hou-fang-fa-de-fu-hao-yin-yong-hui-zhuan-wei-shi-ji-fang-fa-qu-zhong-de-zhi-jie-yin-yong">Q：什么时候方法的符号引用会转为实际方法区中的直接引用？</span><a href="#q-shi-me-shi-hou-fang-fa-de-fu-hao-yin-yong-hui-zhuan-wei-shi-ji-fang-fa-qu-zhong-de-zhi-jie-yin-yong" class="header-anchor">#</a></h2>
<p>A：<br>
类加载的解析阶段会把满足「编译期可知，运行期不可变」的方法的符号引用替换为指向方法区的直接引用，不会延迟到运行时再去完成。</p>
<ul>
<li>构造</li>
<li>私有</li>
<li>静态<br>
final修饰<br>
上面这4类方法在类加载时都会被识别出来，并转成 指向方法区的直接引用（即能知道了指令地址了，而不是字节码的符号）</li>
</ul>
<hr>
<h2><span id="q-dong-tai-fen-pai-ji-duo-tai-xu-ni-ji-li-shi-zen-me-que-ding-diao-yong-na-ge-fang-fa-de">Q：动态分派(即多态）， 虚拟机里是怎么确定调用哪个方法的？</span><a href="#q-dong-tai-fen-pai-ji-duo-tai-xu-ni-ji-li-shi-zen-me-que-ding-diao-yong-na-ge-fang-fa-de" class="header-anchor">#</a></h2>
<p>如下， 他怎么确定调用的是Son实现的do， 还是father实现的do？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">f.<span class="keyword">do</span>(a);</span><br></pre></td></tr></table></figure>
<p>A：<br>
首先，通过静态分派， 他知道一定选用的是f(int a) 这个方法，但是他不知道选用哪个类的do(int a)方法。<br>
<a target="_blank" rel="noopener" href="http://xn--f-376av22dj41a1vi.do">而你执行f.do</a>(a)时， 操作数栈上会存放一个对象引用</p>
<p><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/4b25d6e4706cecfa8651680fb19d2603db8113e0.png" alt="4b25d6e4706cecfa8651680fb19d2603db8113e0"></p>
<p>那么执行f方法的虚拟机指令就会通过这个对象引用，找到他的实际类型的class<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ee1b41d71b7c0e897c34fa86deb79fb9a242cad8.png" alt="ee1b41d71b7c0e897c34fa86deb79fb9a242cad8"></p>
<p>他会在这个实际类中查找是否有实现这个方法，具体看class文件中有没有这个方法的定义<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1dc65dc0cda6cf91e650f456d2351518465e6ebb.png" alt="1dc65dc0cda6cf91e650f456d2351518465e6ebb"></p>
<p>如果没有找到，他就去父类找，父类的关系class文件中就可以知道<br>
<img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/95427daaed60924141c46d48a56efb4f66c97691.png" alt="95427daaed60924141c46d48a56efb4f66c97691"></p>
<p>如果父类没有，就接着往上找，直到找到实现了的。</p>
<p><img src="/images/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/0cd5d2504cda48e554facaded21ffbf82b8af33a.png" alt="0cd5d2504cda48e554facaded21ffbf82b8af33a"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/home/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/5/">5</a><a class="extend next" rel="next" href="/home/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
