<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="冲破黎明前的黑暗">
<meta property="og:url" content="http://breakdawncoder.com/home/page/4/index.html">
<meta property="og:site_name" content="冲破黎明前的黑暗">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/home/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>冲破黎明前的黑暗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冲破黎明前的黑暗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">jdk动态代理原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 16:09:35" itemprop="dateCreated datePublished" datetime="2022-06-05T16:09:35+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:51:40" itemprop="dateModified" datetime="2022-08-10T00:51:40+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/java%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java常见应用原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#jdk-dong-tai-dai-li">jdk动态代理</a></li>
<li><a href="#shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou">实现jdk动态代理时需要哪些步骤？</a></li>
<li><a href="#jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me">JDK动态代理的invoke原理是什么？</a></li>
<li><a href="#wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi">为什么Proxy.newProxyInstance必须要传入一个类加载器？</a></li>
<li><a href="#wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me">为什么jdk动态代理必须依赖一个接口？底层逻辑是什么？</a></li>
<li><a href="#na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni">那么spring里AOP所用的CGLIB为啥不需要接口呢？</a></li>
<li><a href="#na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao">那么CGLIB和jdk动态代理哪个更好？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h2><span id="jdk-dong-tai-dai-li">jdk动态代理</span><a href="#jdk-dong-tai-dai-li" class="header-anchor">#</a></h2>
<h2><span id="shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou">实现jdk动态代理时需要哪些步骤？</span><a href="#shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou" class="header-anchor">#</a></h2>
<ol>
<li>有一个目标类Class， 目标类必须implment某个行为接口Inteface</li>
<li>有一个代理类XxxProxy，实现自InvocationHandler接口</li>
<li>代理类必须实现一个invoke方法， invoke方法的入参是  被代理对象（目标对象）、执行方法（method的反射对象）、执行参数<br>
通过调用“ 执行方法.invoke(被代理对象，执行参数)” 这个常见的反射操作，  即可执行实际调用方法，然后你可以在这个方法的前后做各种处理或者改造。</li>
<li>使用Proxy.newProxyInstance(被代理类的类加载器， 被代理类的接口， 这个proxy代理对象)生成一个做过绑定的代理对象，能被调用的方法都是行为接口Inteface里的。</li>
</ol>
<hr>
<h2><span id="jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me">JDK动态代理的invoke原理是什么？</span><a href="#jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me" class="header-anchor">#</a></h2>
<p>proxy类里面真正的那个代理方法字节码类似如下（这个类就是给被别人调用的代理类，是newProxyxxx（）操作后的那个类，不是invokeHandler类）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Proxy0.class</span><br><span class="line">public final void sayHello(object[] args) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// this.h就是继承了invokeHandler的那个类对象</span><br><span class="line">		this.h.invoke(this, m3, args);</span><br><span class="line">	&#125; catch(Excetion ...) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">static &#123;</span><br><span class="line">	m3 = Class.forname(&quot;那个接口的类名&quot;).getMethod(&quot;sayHello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>m3就是通过static初始化阶段生成一个m方法， 然后调用sayHello时，调用invokeHandler.invoke，从而走进他里面实现的那个方法。</p>
<p>Proxy.newProxyInstance()会通过调用sun.misc.ProxyGenerator.generateProxyClass()来生成一个字节码，从而得到一个描述代理类的字节码数组。<br>
生成字节码的过程就是根据class文件的格式规范去拼装字节码。</p>
<p>更多源码逻辑见<a target="_blank" rel="noopener" href="https://blog.csdn.net/Trunks2009/article/details/123106582">Proxy源码解析</a></p>
<hr>
<h2><span id="wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi">为什么Proxy.newProxyInstance必须要传入一个类加载器？</span><a href="#wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi" class="header-anchor">#</a></h2>
<p><img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/48a3a4503f728f9ce9520a2c4820e9a9858c237a.png" alt="48a3a4503f728f9ce9520a2c4820e9a9858c237a"><br>
因为他需要创建一个新的proxy类时，必须要基于接口去构造一个新的类对象，后面再使用类对象去反射一个实际代理对象<br>
<img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/08a7c84b1abfab8a47fa544fd0de4603c1699e88.png" alt="08a7c84b1abfab8a47fa544fd0de4603c1699e88"></p>
<hr>
<h2><span id="wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me">为什么jdk动态代理必须依赖一个接口？底层逻辑是什么？</span><a href="#wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me" class="header-anchor">#</a></h2>
<p>因为真正给用户调用的那个代理对象类XXXProxy$0， 实际上他为了做相关的代理操作（比如将inovkeHnandler作为成员，并调用各种字节码生产方法），需要extends Proxy这个类<br>
也就是说他的类结构长这样：<br>
<img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5d5edf4370eff2c399096e1fefdd76e9cb7c90ee.png" alt="5d5edf4370eff2c399096e1fefdd76e9cb7c90ee"><br>
因为java是单继承，导致父类已经被Proxy占用了，但你有需要对Worker对象做代理封装，并提供这个接口对外提供的方法，因此只能用implements的形式。</p>
<p>另一个更好的解释：</p>
<blockquote>
<blockquote>
<p>Cglib代理实际上是通过继承，也就是生成一个继承被代理对象的类，编译成class文件时还会额外生成一个fastclass文件<br>
该文件记录各个method的class索引（类名+方法名+参数），当执行某个方法时，通过计算索引，定位到具体的方法，代理对象执行该方法，然后super调用父类（执行了被代理对象的方法）。<br>
生成代理对象时通过fastclass索引机制直接定位到被代理对象的class文件，从而实现反复调用，等于说是class复用，每次都是直接拿被代理对象的class内容执行的。</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni">那么spring里AOP所用的CGLIB为啥不需要接口呢？</span><a href="#na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni" class="header-anchor">#</a></h2>
<p>因为CGLIB是直接继承被代理类做字节码增加的，相当于做了字节码改造。</p>
<p>而jdk动态代理需要继承自Proxy类，利用父类的机制引用invokeHandler+反射的方法，来做代理操作。</p>
<hr>
<h2><span id="na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao">那么CGLIB和jdk动态代理哪个更好？</span><a href="#na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao" class="header-anchor">#</a></h2>
<ol>
<li>性能上比较</li>
</ol>
<ul>
<li>jdk动态代理生成类速度快，调用慢</li>
<li>cglib生成类速度慢，但后续调用快</li>
</ul>
<p>但是实际上JDK的速度在版本升级的时候每次都提高很多性能,而CGLIB仍止步不前.<br>
在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eea9a3acbaad">JDK 动态代理和Cglib性能对比</a></p>
<ol start="2">
<li>稳定性上比较</li>
</ol>
<ul>
<li>jdk动态代理Java本身支持，不用担心依赖问题，随着版本稳定升级和优化。</li>
<li>而CGLIB是外部技术，字节码库需要进行更新以保证在新版java上能运行<br>
；</li>
</ul>
<ol start="3">
<li>使用上比较<br>
jdk动态代理必须依赖接口，CGLIB不需要，在设计不当的历史包袱下<br>
如果必须对非接口对象做代理，那么只能用CGLIB临时过度。</li>
</ol>
<p>因此spring实现AOP时，都是优先使用jdk动态代理，如果没有实现接口，才改成CGLIB过度，这也是为什么我们spring里的service类一般都要先定义1个接口，即使你只有1个service实现类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java类加载全过程详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 14:16:01" itemprop="dateCreated datePublished" datetime="2022-06-05T14:16:01+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:50:38" itemprop="dateModified" datetime="2022-08-10T00:50:38+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/jvm%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">jvm原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu">关于类初始化的时机和误区</a></li>
<li><a href="#you-wu-dao-de-jia-zai-san-bu-qu">有误导的“加载三部曲”</a></li>
<li><a href="#jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu">加载：不仅仅是读取字节流</a>
<ul>
<li><a href="#lei-jia-zai-qi">类加载器</a>
<ul>
<li><a href="#shuang-qin-wei-pai">双亲委派</a>
<ul>
<li><a href="#shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa">双亲委派的详细执行过程和中间方法</a></li>
<li><a href="#shuang-qin-wei-pai-de-hao-chu">双亲委派的好处</a></li>
<li><a href="#fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban">父加载器中要加载某个类A时，A需要使用子加载器来加载，但是父加载器没有子加载器的代码，怎么办？</a></li>
</ul>
</li>
<li><a href="#osgi-wang-zhuang-lei-jia-zai-qi">OSGI网状类加载器</a>
<ul>
<li><a href="#wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi">为什么OSGI可以实现热部署，但是双亲委派不可以？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#shu-zu-lei-shi-ru-he-jia-zai-de">数组类是如何加载的？</a></li>
</ul>
</li>
<li><a href="#lian-jie">连接</a>
<ul>
<li><a href="#yan-zheng">验证</a>
<ul>
<li><a href="#wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui">文件格式校验（class文件对不对）</a></li>
<li><a href="#yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui">元数据验证（我的父亲对不对）</a>
<ul>
<li><a href="#yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi">元数据验证中的类解析</a></li>
</ul>
</li>
<li><a href="#zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui">字节码验证（我的指令对不对）</a></li>
<li><a href="#fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui">符号引用验证（我的指令调用的目标对不对）</a>
<ul>
<li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi">符号引用验证中的字段解析</a></li>
<li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi">符号引用验证中的类方法解析</a></li>
<li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi">符号引用验证中的接口方法解析</a>
<ul>
<li><a href="#yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma">疑问1：为什么接口方法还要解析？接口里不是没有代码吗？</a></li>
<li><a href="#yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me">疑问2：为什么要区分类的方法和接口方法？不能用同一种思路去解析么？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#zhun-bei">准备</a>
<ul>
<li><a href="#lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei">类静态成员默认值的准备</a></li>
<li><a href="#fang-fa-biao-de-zhun-bei">方法表的准备</a>
<ul>
<li><a href="#chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma">重要问题：interface的接口方法，会有方法表吗？</a></li>
<li><a href="#wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao">为什么接口不能有方法表？</a></li>
<li><a href="#java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie">java的虚表和C++的虚表有什么区别？</a></li>
<li><a href="#java-xu-biao-de-sheng-cheng-guo-cheng">java虚表的生成过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jie-xi">解析</a>
<ul>
<li><a href="#jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan">解析的误区：并不是一个单纯的阶段</a></li>
<li><a href="#jing-tai-jie-xi">静态解析</a></li>
<li><a href="#jie-xi-he-fen-pai-de-qu-bie">解析和分派的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chu-shi-hua">初始化</a>
<ul>
<li><a href="#cinit-fang-fa-xi-jie-jie-xi">cinit方法细节解析</a>
<ul>
<li><a href="#yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de">疑问1：cinit方法中的代码是如何生成的？</a></li>
<li><a href="#yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma">疑问2：cinit类初始化是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#chu-shi-hua-zhong-de-dong-tai-jie-xi">初始化中的动态解析</a></li>
<li><a href="#kuo-zhan-invoke-dynamic-shi-shi-me">扩展:invoke_dynamic是什么</a>
<ul>
<li><a href="#dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie">动态语言和静态语言的区别</a></li>
<li><a href="#java-de-methodhandle-yong-fa">java的MethodHandle用法</a></li>
<li><a href="#methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa">methodHandle典型应用场景：如何调用爷爷类的虚方法</a></li>
<li><a href="#java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma">java的methodHandle机制和reflection的反射有什么区别吗？</a></li>
<li><a href="#invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi">invoke_dynamic指令原理。是否涉及动态分派、类加载和解析？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zui-hou-de-wan-zheng-da-tu">最后的完整大图</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu">关于类初始化的时机和误区</span><a href="#guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu" class="header-anchor">#</a></h1>
<p>书籍的第一步部分上来就先讲了类初始化的时机，整理成图片如下：<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652581844567633533.png" alt="image.png"><br>
看起来非常多，很难记住，很折磨。</p>
<p>个人认为，书籍把这一部分放到章节的最前面不太合理，曾经一度让我把上面的这些事件，理解成了类加载的时机，也不懂这些规则的缘由（根本原因还是此时读者对类加载的理解不够深。）</p>
<p>先贴一下类加载和类初始化的区别：</p>
<ul>
<li>类加载概念：将class文件加载到jvm中并生成class对象，并根据情况做初始化。</li>
<li>类初始化概念：调用类class文件中默认存在的&lt;cinit&gt;类初始化方法。</li>
</ul>
<p>而我们容易产生误解的原因，是因为书中没有这句话：：<strong>所谓的类初始化时机，只是针对cinit类初始化方法的调用，并不是指的类加载时机！</strong></p>
<p>以上图中红色的部分为例：<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652582629860693478.png" alt="image.png"><br>
这里书籍中没有解释这3个规则的原因，在没理解原理前，强行记忆这3条是没有任何意义的。我认为是作者的失误。</p>
<p>在这里我挑其中一个做补充：<br>
<strong>“使用类里的static final 常量，不会触发初始化”</strong><br>
想要理解这个规则，需要先理解class文件原理。<br>
对于类的static final常量字段，它的常量值是存放在字段的constanValue属性中。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652583662013743457.png" alt="image.png"><br>
正因为如此，static final常量并不需要通过cinit方法中的指令来完成赋值。<br>
所以也就没有必要在这时候调用&lt;cinit&gt;方法了。</p>
<p>因此对于“儿子类调用父类的静态成员，不用对儿子类做类初始化”也是一个道理，儿子类的类静态成员没有被使用到，没必要做cinit。</p>
<p>对于上面的分析，可以浓缩为一句话：<br>
<strong>“如果我们急需使用static成员，且这个成员的值是要通过cinit方法赋值的，那么我们才做cinit初始化”</strong></p>
<p><strong>新的疑问</strong>：那为什么仅仅是new一个对象时，也一定要做cinit类初始化呢？<br>
假设此时我还没用到static成员，那么new一个对象时，是否可以省去cinit，等用到静态成员的时候，再去触发cinit？</p>
<p>这涉及到了类初始化的另一个容易被忽视的点：<strong>“cinit类初始化方法，并不仅仅是做类成员的赋值，其实还可能包含一些初始化行为调用”</strong>，这可以是资源的启动或者加载等类对象必须要用到的内容。</p>
<p>因此在一切可能触发类对象实际行为前，必须触发cinit避免出错。</p>
<p>所以刚才的长篇大论，可以再次进行优化，浓缩为：<br>
<strong>“当需要用到static成员的初始赋值，或者对类对象进行正式使用时，才会触发cinit类初始化，目的是为了保证类对象或者类成员的正确使用”</strong><br>
拿着这一句话，去回看前面的类初始化时机的触发时机和不触发的时机时，相信你就会有更深的理解了，甚至也不需要强行去记忆每一条规则了。</p>
<hr>
<h1><span id="you-wu-dao-de-jia-zai-san-bu-qu">有误导的“加载三部曲”</span><a href="#you-wu-dao-de-jia-zai-san-bu-qu" class="header-anchor">#</a></h1>
<p>有一个很经典的回答，叫做<strong>类加载三部曲：加载、连接、初始化</strong><br>
好像类加载过程就是这三步按照顺序串行拼装起来的。</p>
<p>实际上这3个过程是存在交叉的！<br>
只能说，“最早发生”的时机，是按照这个顺序发生，但是中间加载过程是有很多的，具体后面会结合我画的图以及原理解释进行呈现。</p>
<h1><span id="jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu">加载：不仅仅是读取字节流</span><a href="#jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu" class="header-anchor">#</a></h1>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652594910504257328.png" alt="image.png"><br>
对于加载，很容易只理解成只是“从文件里加载二进制字节到内存”。<br>
这个过程显然是必须最先执行的，否则连类的基本信息都获取不到。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595413217848779.png" alt="image.png"><br>
可以看到这个过程很灵活，只要你从你能想到的地方拿到字节流即可，任意形式都行。</p>
<p>然而，对于“加载”，除了获取字节流，实际上还包含了“把字节流转成方法区里的数据结构，进行存储defineClass”、“生成一个class对象，存储在堆中”这两步。</p>
<p>这2步是穿插在连接过程中的。<br>
比如字节流转数据结构的过程，必须在确认字节流的正确性之后完成。<br>
而生成class对象同理，符合一个class对象的条件时，才能将其在堆中生成。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595269171806676.png" alt="image.png"><br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595359889871663.png" alt="image.png"></p>
<p>加载过程是由类加载器classloader完成的，在这里对classLoader也顺便做一个详细的分析。</p>
<h2><span id="lei-jia-zai-qi">类加载器</span><a href="#lei-jia-zai-qi" class="header-anchor">#</a></h2>
<h3><span id="shuang-qin-wei-pai">双亲委派</span><a href="#shuang-qin-wei-pai" class="header-anchor">#</a></h3>
<p>类加载时的双亲委派模型，反正就记得优先去父类加载器中看类是否能加载。</p>
<p>这个过程和多态方法调用是相反的，多态方法是子类覆写了的话则优先子类调用，类加载则是父加载器能加载则加载。</p>
<p><strong>注意：Bootsrap不是ClassLoader的子类，他是C++编写的。</strong><br>
而ExtClassLoader和AppClassLoader都是继承自ClassLoader的</p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/a4c77999a2f8a0d5bc6401d05efeca9cdcecef43.png" alt="a4c77999a2f8a0d5bc6401d05efeca9cdcecef43"></p>
<h4><span id="shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa">双亲委派的详细执行过程和中间方法</span><a href="#shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa" class="header-anchor">#</a></h4>
<p>loaderClass（className）  双亲加载实现（这里会体现先去父亲找，再自己）<strong>注意，jdk1.2之后不提倡覆盖loadClass方法，这个方法可以理解为一个模板方法</strong>。</p>
<p><strong>但如果确实有需要破坏双亲委派的需求，则可以重写loaderClass方法，解除双亲委派机制</strong></p>
<p>findClass()  如何根据名字，寻找并生成1个class（内部需要借助defineClass）<br>
defineClass()  通过这个方法将字节码生成1个class类，基本不用改动。</p>
<p>例如需要根据类目，从某个远端网络加载获取这个类， 而且获取过来的时候还是加密的，需要在findClass里对byte数组做解密，解密完成，再调用defineClass生成class类。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/82757435">https://blog.csdn.net/zzti_erlie/article/details/82757435</a></p>
<h4><span id="shuang-qin-wei-pai-de-hao-chu">双亲委派的好处</span><a href="#shuang-qin-wei-pai-de-hao-chu" class="header-anchor">#</a></h4>
<p>书中提到的原因就一个： java类随着类加载器，具备了带有优先级的层次关系。<br>
保证了例如object类在每个环境里都是同一种，不会出现混乱。</p>
<h4><span id="fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban">父加载器中要加载某个类A时，A需要使用子加载器来加载，但是父加载器没有子加载器的代码，怎么办？</span><a href="#fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban" class="header-anchor">#</a></h4>
<p>可以使用线程上下文TCCL机制， 例如java的JNDI服务，JNDI是在启动类加载器里入加载的（JDK1.3的rt.jar)， 但是JNDI会加载很多扩展性很强的新资源类。</p>
<p>因此可以在JNDI加载类的过程中，从TCCL这个context对象中，拿到set进去的用户加载器，然后进行加载即可。（JDBC、JBI等SPI机制都是如此）</p>
<h3><span id="osgi-wang-zhuang-lei-jia-zai-qi">OSGI网状类加载器</span><a href="#osgi-wang-zhuang-lei-jia-zai-qi" class="header-anchor">#</a></h3>
<p>OSGI中， 每一个程序模块（bundle）都有一个自己的类加载器，当需要更换一个bundle时，就把bundle连同类加载器一起换掉，实现代码的热替换</p>
<p>它是一个网状的类加载结构，只有java.*以及委派名单的，才会用双亲委派机制，否则都是各种网状的加载。加载过程如下所示：</p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/62408d2e1e08530789333ccd-1651765505820.png" alt="OSGI加载"></p>
<h4><span id="wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi">为什么OSGI可以实现热部署，但是双亲委派不可以？</span><a href="#wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi" class="header-anchor">#</a></h4>
<p>首先，理解双亲委派模型下，不能热部署的原因：<br>
<strong>如果有新升级的同名类要加入，它只能在新给出的一个加载器去加载， 但是双亲模型限定了必须是先交给父加载器加载，这导致了升级困难，无法让新的加载器去做抢先加载。</strong></p>
<p>OSGi类加载模型则是网络图状的，可以在bundle间互相委托<br>
例如bundleA、B都依赖于bundleC，当他们访问bundleC中的类时，就会委托给bundleC的类加载器，由它来查找类；如果它发现还要依赖bundleE中的类，就会再委托给bundleE的类加载器。</p>
<blockquote>
<blockquote>
<p>另一篇文章的解释：</p>
</blockquote>
<ul>
<li>由于类加载机制的原因，导致一个类一旦加载进去就再也无法释放，因此，OSGi引入了基于插件的类加载机制</li>
<li>举例说明：plugin1里有examples.Test1类，而pulgin2里也有examples.Test1类，在载入这两个插件时，两个类是可以同时载入进入到类缓存中，这归功于OSGi实现的插件类加载器(ClassLoader)</li>
<li>我们把“examples.Test”服务的 Service Ranking 属性更改成了 100，那么其他bundle使用这个bundle对应的example类时，就会用优先级最高的类。</li>
<li>在不需要停止服务和其他插件都不用更新的情况下，我们只需要再安装一个更新版本的插件，其所注册的服务就可以自动更新并应用到所有调用该插件的插件中，达到了热部署的目的。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/yipsilon/article/details/83369177">OSGi的热部署特性及实现</a></li>
</ul>
</blockquote>
<h2><span id="shu-zu-lei-shi-ru-he-jia-zai-de">数组类是如何加载的？</span><a href="#shu-zu-lei-shi-ru-he-jia-zai-de" class="header-anchor">#</a></h2>
<p>数组类是由AppClassLoader加载的。<br>
数组类打印className时，前面会有个[Lxx类<br>
二维数组就是[[Lxxx类<br>
<strong>数组类的父类型是Object</strong></p>
<p>注意此时加载的是数组类，而数组类里面的对象是不会做自动加载的<br>
因此xx类的静态代码并不会被直接调用</p>
<h1><span id="lian-jie">连接</span><a href="#lian-jie" class="header-anchor">#</a></h1>
<p>连接过程可以说是最难记住的一个过程， 里面包含了各种校验啊之类的，让人摸不清头脑。这里会通过更细致的解释和图解，让你明白连接过程究竟做了什么。<br>
首先连接过程分为 验证、准备和解析，<strong>“解析”并不是连接的最后一步，而是在验证过程中实时发生的！</strong>。 下文会为你详细解释为什么。</p>
<h2><span id="yan-zheng">验证</span><a href="#yan-zheng" class="header-anchor">#</a></h2>
<h3><span id="wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui">文件格式校验（class文件对不对）</span><a href="#wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui" class="header-anchor">#</a></h3>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652596406384448149.png" alt="image.png"><br>
注意这里的校验，都是一些最简单的校验，相当于无需做太多的语法分析操作等操作， 都是基于class文件格式定义进行的基础校验。</p>
<p>然而如果对加载的文件有充分的自信，来源可靠，那么确实可以省去这个步骤，提升连接效率，因此会有一个-Xverify:none的选项供使用。</p>
<h3><span id="yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui">元数据验证（我的父亲对不对）</span><a href="#yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui" class="header-anchor">#</a></h3>
<p>这里验证了class文件里面继承特性相关的重要信息，例如继承关系是否合理、是否实现了抽象类或接口的方法<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652596978343390083.png" alt="image.png"></p>
<p>注意，这个元数据验证的过程，<strong>会触发父类或者接口的解析（加载）操作！</strong><br>
书上提到了4个解析情况以及流程：</p>
<ul>
<li>类解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析<br>
却没有解释这4个解析过程是在哪里发生的。后面我会逐一提到，来真正理解这4个解析过程。</li>
</ul>
<h4><span id="yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi">元数据验证中的类解析</span><a href="#yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi" class="header-anchor">#</a></h4>
<p>还记得class文件中，父类是指向一个constant_class_info吗？这个东西当时看就是一个utf字符串，没什么意义。你没法知道父类究竟有什么方法，是不是抽象类。<br>
因此必须拿到父类的类信息，要么是已经在方法区中，要么需要重新加载。<br>
而类解析的过程如下：<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598263182568128.png" alt="image.png"><br>
可以看到这个过程中也会发生加载，甚至好多次加载。</p>
<hr>
<h3><span id="zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui">字节码验证（我的指令对不对）</span><a href="#zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui" class="header-anchor">#</a></h3>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598525735605413.png" alt="image.png"><br>
这个验证不要和前面的“文件格式验证”搞混了。<br>
前面的“元数据验证”都只是针对类、方法、字段等和父类进行确认、校验。<br>
但是还没有涉及到每个方法里的code属性。</p>
<p>code属性虽然在编译出来时是正确的，但是无法保证传输过程中被人篡改。<br>
如果发生操作操作数栈时，栈里没东西，或者试图在局部变量表边界外写入局部变量，就可能导致不可估量的后果。</p>
<p>因此此刻会进行最基本的指令分析，确认对操作数栈、局部变量表的操作是安全、正确的。</p>
<p>但是，逐个指令分析，会不会太慢了？如果代码很长的话。</p>
<p>还记得class文件的code属性中，还包含了一个stackMapTable属性么，估计很多人都跳过了这个属性。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598909384718936.png" alt="image.png"><br>
这个属性就是用在字节码验证这个过程，可以立即让编译器编译出class时，提前把各位置的情况写入stackMap中，jvm加载时只对这个stackMap做校验确认是对的即可。<br>
但代价就是可能不安全了，因为这个stackMap是可以被篡改的。</p>
<h3><span id="fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui">符号引用验证（我的指令调用的目标对不对）</span><a href="#fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui" class="header-anchor">#</a></h3>
<p>注意前面的“字节码验证”是简单的确认，但不会持有过多的其他类的信息。<br>
但是方法肯定会涉及对其他类的调用。</p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652599879633278954.png" alt="image.png"></p>
<p>此时就会涉及到符号引用验证，确认自己是否拥有对方方法的访问权限。<br>
那么你就需要找到目标类的类信息存放地址，确认方法权限，或者字段权限。<br>
于是会在这里触发字段解析、类方法解析或者接口解析！<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652601092434475198.png" alt="image.png"><br>
书上只提到了这3个解析过程的流程，却没有详细解释其中的一些缘由，我会做更详细的补充。</p>
<h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi">符号引用验证中的字段解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi" class="header-anchor">#</a></h4>
<p>class中的constant_filed_info终于露出了它的真面目，原来是用在这个地方，即和字段相关的指令会用到它，并通过字段符号引用， 解析到这个字段真正的定义位置。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652601973522659730.png" alt="image.png"><br>
像经常遇到的NoSuchFieldError报错，就是在这个过程中爆出来的。<br>
而且接口字段的优先级是大于父类的字段的。</p>
<h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi">符号引用验证中的类方法解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi" class="header-anchor">#</a></h4>
<p>当调用方法前，需要先确认对象方法是否有权限访问。那么就必须这个类的信息进行确认。<br>
<strong>注意：这个过程并不是动态分派的那个过程，此刻并没有触发任何的方法调用！仅仅是确认代码中静态类型的访问权限是否正确之类的！</strong><br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652602585506110322.png" alt="image.png"></p>
<ul>
<li>对类方法做解析的时候，会判断此时是类还是接口。如果是接口，竟然会报“IncompatibleClassChangeError”。</li>
<li>还有如果是抽象类，也会报“AbstractMethodError”，因为正常情况下，你的jvm指令调用的方法，必须是实例化的对象所对应的方法，不可能直接调用抽象类方法的。</li>
</ul>
<h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi">符号引用验证中的接口方法解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi" class="header-anchor">#</a></h4>
<p>看起来像是将类方法解析中的接口和方法互换了位置。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652603187639739722.png" alt="image.png"></p>
<h5><span id="yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma">疑问1：为什么接口方法还要解析？接口里不是没有代码吗？</span><a href="#yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma" class="header-anchor">#</a></h5>
<p>因为接口类里每个interface方法，本身也是一个方法，只不过没有详细的code属性。但方法的访问修饰符之类的都存在，因此验证阶段还是需要进行校验。</p>
<h5><span id="yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me">疑问2：为什么要区分类的方法和接口方法？不能用同一种思路去解析么？</span><a href="#yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me" class="header-anchor">#</a></h5>
<p>我理解的几个原因：</p>
<ol>
<li>向上搜索时的逻辑不同，对于类方法，直接找父类即可， 而接口则需要遍历所有父接口。而且类方法还要考虑抽象类的问题，接口不需要。</li>
<li>类方法和接口方法本身就是两个不同的符号引用， 一个是constant_method_ref，另一个是constant_interface_ref，用2套逻辑没什么毛病</li>
<li>如果硬要问为什么要区分这2个符号引用，明明内容都是类索引+描述符索引？<br>
这是因为后面在实际调用方法时，二者有显著区别，具体见下文的“方法表的准备”。</li>
</ol>
<h2><span id="zhun-bei">准备</span><a href="#zhun-bei" class="header-anchor">#</a></h2>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652604139278590043.png" alt="image.png"></p>
<h3><span id="lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei">类静态成员默认值的准备</span><a href="#lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei" class="header-anchor">#</a></h3>
<p>对于准备阶段，大家一般只记得需要对一些非final的类静态成员做默认初始值操作。</p>
<h3><span id="fang-fa-biao-de-zhun-bei">方法表的准备</span><a href="#fang-fa-biao-de-zhun-bei" class="header-anchor">#</a></h3>
<p>除了这个默认值赋值，还有一个动作，是准备方法表。<br>
方法表就是为了多态而生，简化动态分派时频繁的迭代循环带来的不必要消耗：<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652604259330823080.png" alt="image.png"><br>
通过前面的验证过程，我们已经获知了父类信息。<br>
因此可以准备一个方法表，把父类方法堆到最前面，自己的方法堆到后面，后面直接根据索引获取方法调用地址即可！</p>
<h4><span id="chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma">重要问题：interface的接口方法，会有方法表吗？</span><a href="#chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma" class="header-anchor">#</a></h4>
<p>intefacer接口是不具有方法表的！<br>
因此这可能也是jvm特地区分了class_inteface_info和class_method_info这2个常量，以及特地用invoke_inteface和invoke_virtual指令来区分2类方法的调用。因为他们的调用逻辑可能大相径庭。</p>
<h4><span id="wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao">为什么接口不能有方法表？</span><a href="#wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao" class="header-anchor">#</a></h4>
<p>这是由于Java可以实现多个接口，不同的类可能会实现了多个或者不同的接口，在虚表里该接口所实现方法的索引会不一致。</p>
<p>假设有A、B、C三个接口类</p>
<ul>
<li>类X实现了A、B两个接口，假设A和B接口放在虚表里，那么调用A接口方法我们假设它是在t位置。</li>
<li>类T实现了B、C、A接口，按照实现顺序，先放B的方法，再放A的方法，最后放C的方法。这样调用接口A时，就不一定是t位置了，我们无法直接确定A里面方法的位置，因为一个类可以实现多个接口，而且顺序可以随意更改！</li>
</ul>
<p>这样每次解析的虚表索引都可能会不同，因此不能进行缓存，需要每次都进行重新的解析。<br>
<strong>因此，接口的方法调用会比普通的子类继承的虚函数调用要慢。</strong></p>
<h4><span id="java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie">java的虚表和C++的虚表有什么区别？</span><a href="#java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie" class="header-anchor">#</a></h4>
<p>C++：<br>
当编译器遇到调用虚方法的代码时，是通过vtable指针以及对应方法在虚表里的offset，然后获取对应的函数指针实现的，由于offset在编译过程就已经固定了，这样在执行过程中几乎没有产生任何额外的计算就实现了多态调用，效率相当高。<br>
<strong>缺点就是当你修改了一个dll链接文件，另一个dll链接文件可能还是用的老的偏移，这导致你即使重启程序了，仍然还是错误的调用。 你必须将两个链接文件都重新编译才可以。</strong></p>
<p>但对于java而言，只需要替换一个jar包即可， 类之间的方法调用关系，方法偏移，都是可以类加载过程中去生成的。</p>
<p>换言之，最大的区别就是修改部分方法带来的影响，java是最小的</p>
<h4><span id="java-xu-biao-de-sheng-cheng-guo-cheng">java虚表的生成过程</span><a href="#java-xu-biao-de-sheng-cheng-guo-cheng" class="header-anchor">#</a></h4>
<ol>
<li>在加载该类的时候，常量池的所有<strong>虚函数的签名</strong>（包括调用的以及自身定义的）都会<strong>添加到全局的符号表</strong>（事实上是一个HashTable）。</li>
<li><strong>首先对字符值进行Hash值计算，然后在全局HashTable进行查找</strong>，如果发现已经存在对应的Hash值，则返回对应的符号指针Symbol *，否则创建新的Symbol并添加到HashTable中，然后返回新创建的Symbol *。这样常量池就把字符串的引用转换成符号的引用。另外这个过程可以确保所有字符串在jvm只存有一个引用。、</li>
<li>当在某个类对象调用虚方法的时候，通过调用函数的符号和自身定义的符号进行比较（由于这里都是引用全局符号表的唯一符号，因此可以通过内存地址进行快速比较），就会解析出调用虚函数的信息，<strong>通过信息就可以获取虚表的索引，然后调用对应的虚函数字节码</strong></li>
<li>为了提高调用时的性能，Java采用的是Lazy解析，<strong>第一次解析出虚表的索引后，则会保留到cache里面</strong>，这样下次调用就可以从缓存直接获取索引</li>
</ol>
<h2><span id="jie-xi">解析</span><a href="#jie-xi" class="header-anchor">#</a></h2>
<h3><span id="jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan">解析的误区：并不是一个单纯的阶段</span><a href="#jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan" class="header-anchor">#</a></h3>
<p>解析其实分为“静态解析”和“动态解析”。<br>
因此将解析说成是“连接”中的一部分是不严谨的， 只有静态解析，才是“连接”的一部分。</p>
<p>静态解析在初始化前发生，但动态解析则可能在初始化或者初始化之后才去使用。</p>
<h3><span id="jing-tai-jie-xi">静态解析</span><a href="#jing-tai-jie-xi" class="header-anchor">#</a></h3>
<p>静态解析用于解析私有方法、父类构造器、final方法等不存在多态可能的方法。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652605263696340667.png" alt="image.png"></p>
<h3><span id="jie-xi-he-fen-pai-de-qu-bie">解析和分派的区别</span><a href="#jie-xi-he-fen-pai-de-qu-bie" class="header-anchor">#</a></h3>
<p>静态分派、动态分派， 指的是2个方法的不同阶段，他们不存在冲突的关系，即方法会先触发静态分派，再触发动态分派。</p>
<p>静态分派可以理解为编译器在编写class文件时，通过方法名+描述符+优先级，确定了这个位置调用的是哪个方法。</p>
<p>但是由于多态的特性，具体执行者可能不同，因此后面还会触发动态分派。</p>
<p>而静态解析和动态解析是2个不同的解析，前者是默认定死了方法引用位置，后者则必须依赖动态分派，对一个方法而言不可能同时存在动态和静态解析的情况。</p>
<h1><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor">#</a></h1>
<h2><span id="cinit-fang-fa-xi-jie-jie-xi">cinit方法细节解析</span><a href="#cinit-fang-fa-xi-jie-jie-xi" class="header-anchor">#</a></h2>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606173785989291.png" alt="image.png"><br>
关于初始化时机的解释，在开头就已经阐述过了，这里不再重复解释。</p>
<h3><span id="yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de">疑问1：cinit方法中的代码是如何生成的？</span><a href="#yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de" class="header-anchor">#</a></h3>
<p>cinit方法 是编译器收集所有类静态变量的赋值动作和静态语句块static{}中的语句合并产生，按照顺序收集。<br>
因此类加载赋值的顺序和类定义顺序有关，原理就取决于cinit生成的原理。</p>
<h3><span id="yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma">疑问2：cinit类初始化是线程安全的吗？</span><a href="#yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h3>
<p>是线程安全的，虚拟机会保证一个类的加载和cinit方法会被正确的加锁、同步。<br>
因此多线程场景下，同时使用一个之前没初始化过的类，且类初始化过程耗时非常久的话， 且可能会造成线程阻塞。<br>
而这也是可以利用类初始化+内部类的方式，来做单例模式的实现的原理：</p>
<h2><span id="chu-shi-hua-zhong-de-dong-tai-jie-xi">初始化中的动态解析</span><a href="#chu-shi-hua-zhong-de-dong-tai-jie-xi" class="header-anchor">#</a></h2>
<p>而初始化过程中，可能会涉及其他对象实例方法的调用，因此是可能发生动态解析过程的！<br>
类方法和接口方法的解析过程如下<br>
类方法的解析可以借助虚方法表简化解析过程。<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606407501364079.png" alt="image.png"></p>
<h2><span id="kuo-zhan-invoke-dynamic-shi-shi-me">扩展:invoke_dynamic是什么</span><a href="#kuo-zhan-invoke-dynamic-shi-shi-me" class="header-anchor">#</a></h2>
<h3><span id="dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie">动态语言和静态语言的区别</span><a href="#dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie" class="header-anchor">#</a></h3>
<p>动态类型语言： 类型检查的主体是运行期而不是编译器。 例如PHP、Lua\python<br>
而静态类型语言就是编译器将类型都检查完，比如C++、java</p>
<p>静态语言的好处：在编译器就能确定类型，可以进行严谨的类型检查， 代价就是代码会很臃肿。<br>
动态语言编写时更为随意，可以快速开发和运行。</p>
<h3><span id="java-de-methodhandle-yong-fa">java的MethodHandle用法</span><a href="#java-de-methodhandle-yong-fa" class="header-anchor">#</a></h3>
<p>jdk1.7之后提供的 MethodHandle， 类似于C/C++里的函数指针， 或者C#里的delegate。<br>
C里面可以<br>
sort(list, size,  int (* compare)(int, int))<br>
即传入一个函数指针，这个函数是哪个类调用的？不知道</p>
<p>java提供了methodHandle用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is a print:&quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodHandle <span class="title function_">getPrintlnMethodHandle</span><span class="params">(Object object)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 返回值，入参</span></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup()</span><br><span class="line">                <span class="comment">// 找到对象所对应的类，确认是否存在方法</span></span><br><span class="line">                .findVirtual(object.getClass(), <span class="string">&quot;println&quot;</span>, methodType)</span><br><span class="line">                <span class="comment">// 这个对对象绑定上去调用. java的反射不是也能做到吗》？</span></span><br><span class="line">                .bindTo(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">ClassA</span> <span class="variable">classA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line">        <span class="comment">// invokeExact：执行并传入参数，classA和System.out不是同一个父类或者接口，但是可以执行相同的方法</span></span><br><span class="line">        getPrintlnMethodHandle(classA).invokeExact(<span class="string">&quot;afdsafds&quot;</span>);</span><br><span class="line">        getPrintlnMethodHandle(System.out).invokeExact(<span class="string">&quot;afdsafds&quot;</span>);</span><br><span class="line">        <span class="comment">// 以后排序就可以这样做了：  sort(list, MethodHandle mt)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中methodHandle背后就是由invoke_dynamic指令触发的。</p>
<h3><span id="methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa">methodHandle典型应用场景：如何调用爷爷类的虚方法</span><a href="#methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa" class="header-anchor">#</a></h3>
<p>如何在儿子类中，分派调用祖父类的虚方法？ 且儿子类和父类都已经实现了这个虚方法。父类不能提供新的方法</p>
<p>通过loopup().findSpecial(祖父类， “方法名”， MethodHandle.methodType(返回值，入参),  当前类)<br>
拿到一个方法句柄mh<br>
然后方法句柄mh.invoke(this)，即可调用祖父类的方法。</p>
<h3><span id="java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma">java的methodHandle机制和reflection的反射有什么区别吗？</span><a href="#java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma" class="header-anchor">#</a></h3>
<ol>
<li>调用指令层面：</li>
</ol>
<ul>
<li>reflection是模拟java代码调用，不关心底层指令</li>
<li>而methodHandle是模拟了字节码的执行，上面的Loopup().findVirtual，等同于invokevirtual指令（同理还有invokestatic\invokeinteface\invokespecial)</li>
</ul>
<ol start="2">
<li>method对象大小问题</li>
</ol>
<ul>
<li>reflection返回的method对象，包含的信息更多，例如签名、描述、属性等，返回的method比较重量级</li>
<li>而methodHandle仅包含执行方法相关的信息，是轻量级、</li>
</ul>
<ol start="3">
<li>可以基于methodHandle手动做虚拟机的相关调用优化（例如内联），而反射无法实现。</li>
<li>从最终设计目的而言，反射只针对java， 而methodHandle的核心目的在于可以将其他无类型的语言运行在java迅即之上！</li>
</ol>
<h3><span id="invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi">invoke_dynamic指令原理。是否涉及动态分派、类加载和解析？</span><a href="#invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi" class="header-anchor">#</a></h3>
<p>我们首先看下invoke_dynamic指令调用的dynamic_info常量长什么样的：<br>
<img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606577911480954.png" alt="image.png"><br>
可以看到它只包含了一个方法索引和描述，但似乎没包含方法属于哪个类。</p>
<p>它的作用是用java实现一些类似于脚本语言的逻辑，脚本语言不关心静态类型，不做编译检查，只关心运行期的内容。所以invoke_dynamic以及constant_dynamic_info应运而生。但书本和工作中对这块的接触都不是太深，因此我的理解也只能局限于此了。</p>
<p>书上还有句话可以记一下：<strong>除了invokeddynamic动态调用指令， 其他的invokevirual之类的，都会缓存解析结果。</strong></p>
<hr>
<h1><span id="zui-hou-de-wan-zheng-da-tu">最后的完整大图</span><a href="#zui-hou-de-wan-zheng-da-tu" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8">在线地址</a><br>
<a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8">https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8</a></p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/5e7eed6ce4b08b6157409373.png" alt="完整大图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">jvm垃圾收集器演进和原理详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-31 07:52:57" itemprop="dateCreated datePublished" datetime="2022-05-31T07:52:57+08:00">2022-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:50:49" itemprop="dateModified" datetime="2022-08-10T00:50:49+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/jvm%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">jvm原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重读了一遍《深入理解java虚拟机》， 发现第一遍读垃圾回收器相关的进化历程时，没有细细去研究各自的区别，觉得太多了记不住。<br>
实际上理解了这个进化过程，这对于我们理解回收器是有很大帮助的。</p>
<p><strong>看来经典书籍要多读多总结，是有道理的。</strong><br>
于是在阅读这个章节时，画了一张大的演化图，方便理解变化和区别。</p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#serial-old-he-serial-dan-xian-cheng-shou-ji-qi">Serial Old和Serial（单线程收集器）</a>
<ul>
<li><a href="#serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma">Serial类型的收集器被淘汰了吗？它还有优势吗？</a></li>
</ul>
</li>
<li><a href="#parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi">ParOld和ParNew收集器（多线程收集器）</a></li>
<li><a href="#parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan">Parallel Scavenge收集器（对回收时间的优化开端）</a>
<ul>
<li><a href="#ru-he-li-jie-tun-tu-liang">如何理解吞吐量</a></li>
<li><a href="#parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de">Parallel Savenge收集器是如何控制吞吐量的</a></li>
<li><a href="#dai-jie-shi-shi-me">代价是什么？</a></li>
</ul>
</li>
<li><a href="#cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu">CMS收集器（Concurrent Mark Sweep, 并发收集概念的重大提出）</a>
<ul>
<li><a href="#cms-jie-duan-1-chu-shi-biao-ji">CMS阶段1：初始标记</a>
<ul>
<li><a href="#gcroot-de-xuan-qu-yuan-ze-shi-shi-me">GCRoot的选取原则是什么？</a></li>
<li><a href="#parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma">ParNew年轻代收集时，需要遍历CMS老年代的所有GCROOT吗？</a></li>
</ul>
</li>
<li><a href="#cms-jie-duan-2-bing-fa-biao-ji">CMS阶段2：并发标记</a>
<ul>
<li><a href="#bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de">并发标记用了怎样的算法去标记的？</a></li>
<li><a href="#bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng">并发标记时如何记录引用变更？</a></li>
<li><a href="#shi-me-shi-kua-dai-yin-yong">什么是跨代引用？</a></li>
<li><a href="#ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang">如何避免跨代引用，保障并发标记安全（写屏障</a></li>
</ul>
</li>
<li><a href="#cms-jie-duan-3-chong-xin-biao-ji">CMS阶段3：重新标记</a></li>
<li><a href="#cms-jie-duan-4-bing-fa-qing-chu">CMS阶段4：并发清除</a>
<ul>
<li><a href="#wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa">为什么是要用“标记-清除”这么缺点大的方法？</a></li>
<li><a href="#cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang">CMS如何解决标记-清除后碎片过多，无法放入新对象的情况？</a></li>
<li><a href="#bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban">并发回收过程中，如果工作线程突然生成大量新垃圾，导致内存不足怎么办？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi">G1收集器（回收概念发生诸多变革，目前最先进收集器）</a>
<ul>
<li><a href="#g1-xiang-bi-cms-de-chong-da-sheng-ji-dian">G1相比CMS的重大升级点：</a></li>
<li><a href="#region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma">region之间都要通过BFS遍历吗？</a></li>
</ul>
</li>
<li><a href="#wan-zheng-da-tu">完整大图</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="serial-old-he-serial-dan-xian-cheng-shou-ji-qi">Serial Old和Serial（单线程收集器）</span><a href="#serial-old-he-serial-dan-xian-cheng-shou-ji-qi" class="header-anchor">#</a></h1>
<p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830465493764891.png" alt="image.png"></p>
<ul>
<li>Serial Old指的是老年代收集器，使用标记-整理清理垃圾</li>
<li>Serial指的是年轻代收集器，使用复制算法清理垃圾。</li>
</ul>
<p>Serial就是单线程的意思，不仅代表它使用单线程做回收，<strong>更意味着他会进行stop world暂停工作线程</strong></p>
<h2><span id="serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma">Serial类型的收集器被淘汰了吗？它还有优势吗？</span><a href="#serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma" class="header-anchor">#</a></h2>
<p>没有，它是client模式下默认的收集器。<br>
优势在于，它具有<strong>最高的单线程收集效率</strong><br>
而client模式一般不会用于处理大量请求，因此非常适合serial。</p>
<p>除了client，书上还提了另外2个功能：</p>
<ul>
<li>Serial Old收集器会作为CMS的后备预案</li>
<li>与Parallel Scavenge搭配使用</li>
</ul>
<h1><span id="parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi">ParOld和ParNew收集器（多线程收集器）</span><a href="#parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi" class="header-anchor">#</a></h1>
<p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830556269329780.png" alt="image.png"><br>
Par收集器就是Serial收集器的多线程版本，其他策略则都与serial一致。</p>
<p><strong>注意， 虽然是多线程收集器，但是用户的工作线程仍然是暂停状态（为了防止收集过程中发生变化导致回收错误</strong></p>
<p>ParNew收集器可以与CMS收集器配合使用。</p>
<h1><span id="parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan">Parallel Scavenge收集器（对回收时间的优化开端）</span><a href="#parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan" class="header-anchor">#</a></h1>
<p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830818239387635.png" alt="image.png"></p>
<p>Parallel Scavenge 收集器是一个<strong>新生代收集器</strong>，他不包含老年代。<br>
前两代的收集器，默认必须收集完成，对工作线程影响巨大。<br>
<strong>这是首次开始关注回收时间对工作线程影响的一代收集器，成为了垃圾收集器升级优化的一个重要开端。</strong></p>
<h2><span id="ru-he-li-jie-tun-tu-liang">如何理解吞吐量</span><a href="#ru-he-li-jie-tun-tu-liang" class="header-anchor">#</a></h2>
<p>虚拟机运行了100分钟， 垃圾收集花掉了一分钟，那么吞吐量就是100%。</p>
<h2><span id="parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de">Parallel Savenge收集器是如何控制吞吐量的</span><a href="#parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de" class="header-anchor">#</a></h2>
<p>通过控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数，以及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br>
通过修改这2个参数，jvm可以计算一个合适的新生代空间，<strong>空间越小，回收时间越快</strong>，他的停顿时间便能够满足吞吐量要求。</p>
<ul>
<li>换句话说，本质上就是通过你设定的吞吐量或者暂停时间，自适应地得到一个新生代空间大小而已。</li>
</ul>
<h2><span id="dai-jie-shi-shi-me">代价是什么？</span><a href="#dai-jie-shi-shi-me" class="header-anchor">#</a></h2>
<p>新生代越小，那么意味着老年代的空间就越大。</p>
<p>虽然能做到基本不停顿或者停顿间隔很小，但这样就会<strong>导致新生代频繁发生minorGc，并不断将垃圾扔给老年代收集器</strong>，容易在下一个时间段触发更多的fullGc。<br>
因此这个策略仅仅是饮鸠止渴，无法真正解决问题。</p>
<ul>
<li>注意，这里ParaleelSavenge的吞吐量，指的就是新生代的吞吐量，不代表fullGc占用的时间。</li>
</ul>
<h1><span id="cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu">CMS收集器（Concurrent Mark Sweep, 并发收集概念的重大提出）</span><a href="#cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu" class="header-anchor">#</a></h1>
<p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652831748531127900.png" alt="image.png"><br>
而从这一代开始，jvm终于想到了可以如何尽可能少地暂停工作线程的方式，提出了并发收集的概念。</p>
<p>首先明确并行收集和并发收集的区别</p>
<ul>
<li>并行收集：指用多线程来收集，但是工作线程仍然暂停</li>
<li>并发收集：收集线程和工作线程允许不冲突地交替并发执行</li>
</ul>
<hr>
<p>CMS是老年代收集器，必须和parNew等结合使用<br>
使用的是回收-清除算法，有较多碎片。</p>
<hr>
<h2><span id="cms-jie-duan-1-chu-shi-biao-ji">CMS阶段1：初始标记</span><a href="#cms-jie-duan-1-chu-shi-biao-ji" class="header-anchor">#</a></h2>
<p>初始标记就是对GCRoot对象进行标记，以GCroot作为起点。<br>
GCRoot的那4种经典对象，瞄一眼就好</p>
<blockquote>
<blockquote>
<p>虚拟机栈（栈帧中的本地变量表）中的引用的对象<br>
方法区中的类静态属性引用的对象<br>
方法区中的常量引用的对象<br>
本地方法栈中JNI（Native方法）的引用对象</p>
</blockquote>
</blockquote>
<h3><span id="gcroot-de-xuan-qu-yuan-ze-shi-shi-me">GCRoot的选取原则是什么？</span><a href="#gcroot-de-xuan-qu-yuan-ze-shi-shi-me" class="header-anchor">#</a></h3>
<p>这个问题很有意思，为什么要这样选择？如果能理解这个问题，也就不需要去死记硬背上面的内容了。</p>
<p>首先，可能有很多个方法栈，每个栈都有一个栈顶的栈帧，说明这是<strong>正在执行</strong>的方法， 在此刻是一定不需要被回收的！<br>
因此选取了2种栈的栈顶作为GCRoot选取位置。</p>
<p>而方法区中的对象一般不会被释放，长期持有，因此方法区中的静态引用对象、常量引用对象也是稳定能被使用的。</p>
<h3><span id="parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma">ParNew年轻代收集时，需要遍历CMS老年代的所有GCROOT吗？</span><a href="#parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma" class="header-anchor">#</a></h3>
<p>CMS是老年代的收集器， 经常要和年轻代收集器例如ParDoNew配合。（因此上面4个阶段都是处理老年代回收的，年轻代内存占用小，不需要那么麻烦）<br>
那么当ParNew年轻代回收时，是否也要把老年代的所有GCROOT都算上？后面全部遍历的话，时间是不是太久了？</p>
<p>因此才有了<strong>卡表</strong>的出现！<br>
卡表作为一个比特位的集合，每一个比特位可以用来表示年老代的某一区域中的所有对象是否持有新生代对象的引用。<br>
这样新生代在GC时，可以先扫描卡表，只有卡表的标记位为1时，才需要扫描给定区域的年老代对象。而卡表位为0的所在区域的年老代对象，一定不包含有对新生代的引用，从而提高了年轻代的回收效率！</p>
<h2><span id="cms-jie-duan-2-bing-fa-biao-ji">CMS阶段2：并发标记</span><a href="#cms-jie-duan-2-bing-fa-biao-ji" class="header-anchor">#</a></h2>
<p>这时候不会做stopWorld。标记线程和工作线程同时进行。</p>
<h3><span id="bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de">并发标记用了怎样的算法去标记的？</span><a href="#bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de" class="header-anchor">#</a></h3>
<p>当通过gcRoot做并发标记的时候，是一种bfs搜索。<br>
有一种三色标记法可以作为参考：</p>
<ul>
<li>白色：还没有搜索过的对象（白色对象会被当成垃圾对象）</li>
<li>灰色：正在搜索的对象</li>
<li>黑色：搜索完成的对象（不会当成垃圾对象，不会被GC）</li>
</ul>
<ol>
<li>默认起始是白色节点。</li>
<li>是每次标记当前搜索节点的引用节点（类似于相邻点）为灰色，入队列。</li>
<li>当相邻点全部入队列完成，则把当前搜索节点置黑色。然后根据队列取队头继续处理灰色节点</li>
</ol>
<p>是不是和数据结构的bfs非常类似？</p>
<h3><span id="bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng">并发标记时如何记录引用变更？</span><a href="#bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng" class="header-anchor">#</a></h3>
<p>对于CMS在并发标记时的引用变更，书上没有细讲，只是一笔带过，个人认为错失了许多精华。<br>
有些类似的概念确实有在G1收集器里简单阐述，但是很难让人马上和CMS中对应起来。个人认为应该在CMS的章节就提前给出。<br>
下面以我自己的理解，给出对CMS并发标记过程的理解。</p>
<h3><span id="shi-me-shi-kua-dai-yin-yong">什么是跨代引用？</span><a href="#shi-me-shi-kua-dai-yin-yong" class="header-anchor">#</a></h3>
<p>首先基于上面提到的三色标记，给出跨代引用问题的例子和解释。<br>
假设此时正处于并发标记中，且正好在bfs处理A这个节点。<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652881948481607802.png" alt="image.png"><br>
这时取消了A对B的引用，以及B对C的引用，同时新增了A对C的引用，变成如图所示：<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652881964705631549.png" alt="image.png"><br>
那么当继续搜索入队的B时，将无法再走到C，C永远被标记为白色，就会出现严重的后果：误杀了C，从而导致A对C调用时报错！<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882075127270117.png" alt="image.png"></p>
<h3><span id="ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang">如何避免跨代引用，保障并发标记安全（写屏障</span><a href="#ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang" class="header-anchor">#</a></h3>
<p>CMS引入了一个叫“写屏障”的东西，写屏障工作示意如下：<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882482680209447.png" alt="image.png"><br>
而标记栈就会在后面的“重新标记”阶段用上。</p>
<h2><span id="cms-jie-duan-3-chong-xin-biao-ji">CMS阶段3：重新标记</span><a href="#cms-jie-duan-3-chong-xin-biao-ji" class="header-anchor">#</a></h2>
<p>前面的写屏障为我们把为标记却被新增引用的对象放入了栈中。<br>
此时会进入StopWorld，我们可以从栈中取出标记对象进行“重新标记”了。<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882580296867154.png" alt="image.png"></p>
<h2><span id="cms-jie-duan-4-bing-fa-qing-chu">CMS阶段4：并发清除</span><a href="#cms-jie-duan-4-bing-fa-qing-chu" class="header-anchor">#</a></h2>
<p>最后清除的时候，选用了“标记-清除”算法，来进行回收和处理。<br>
同时采用并发机制，避免影响了工作线程。<br>
“标记-清除”算法的示意图如下：<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652883305646281243.png" alt="image.png"></p>
<h3><span id="wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa">为什么是要用“标记-清除”这么缺点大的方法？</span><a href="#wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa" class="header-anchor">#</a></h3>
<p>因为老年代算法，要么是标记-整理，要么是标记-清除<br>
<strong>而标记-整理算法是无法和工作线程并发执行的</strong><br>
所以才选择标记-清除，这也导致了碎片带来的隐患</p>
<h3><span id="cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang">CMS如何解决标记-清除后碎片过多，无法放入新对象的情况？</span><a href="#cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang" class="header-anchor">#</a></h3>
<p>当因为碎片过多，无法放入新对象时，会触发fullGC，此时会做1次内存碎片的合并（整理）操作</p>
<p>还提供了一个参数，设置多少次非合并的fullGC时，可做一次碎片的集中合并和整理。</p>
<h3><span id="bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban">并发回收过程中，如果工作线程突然生成大量新垃圾，导致内存不足怎么办？</span><a href="#bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban" class="header-anchor">#</a></h3>
<p>因为并发回收时工作线程还在运行，可能产生大量的对象，导致老年代被填满。<br>
这时候CMS会触发一个“Concurrent Mod Failure”机制，并紧急替换为SerialOld收集进行stopWorld回收。<br>
因此，<strong>CMS可能存在临时退化为SerialOld的可能</strong></p>
<h1><span id="g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi">G1收集器（回收概念发生诸多变革，目前最先进收集器）</span><a href="#g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi" class="header-anchor">#</a></h1>
<p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652884348846944605.png" alt="image.png"></p>
<p>G1收集器，书上感觉并没有讲得特别深，很多概念、区别都没讲好，个人认为是种遗憾，因此我在透彻学习G1之前，我也只能简单写写了。</p>
<h2><span id="g1-xiang-bi-cms-de-chong-da-sheng-ji-dian">G1相比CMS的重大升级点：</span><a href="#g1-xiang-bi-cms-de-chong-da-sheng-ji-dian" class="header-anchor">#</a></h2>
<ol>
<li><strong>回收范围不同</strong>。 CMS是老年代收集器，必须和parNew等结合使用。  G1则可以同时管理老年代和年轻代。</li>
<li><strong>停顿目标不同</strong>。 CMS会让停顿时间尽可能小， G1则建立了可预测的时间模型。</li>
<li><strong>清理方式不同</strong>。 CMS是标记-清除，  G1是标记-整理，碎片大大减少。</li>
<li><strong>G1支持筛选回收</strong> G1可以根据每个region的价值进行回收，CMS则不行。</li>
<li><strong>并发标记后的最终标记处理方式不同</strong><br>
这个标记方式的区别讲述起来有点抽象，简而言之就是：</li>
</ol>
<ul>
<li>CMS是希望记录所有新增的引用，并重新做好多次BFS，保证没有疏漏，代价非常大。</li>
<li>G1则是只更新o = null这种删除引用的情况。对于新增的引用，直接认为那个对象不需要杀。<br>
换句话说，<strong>CMS更严谨，做细致的重新检查。 而G1为了性能，会漏掉一些本该被回收的对象，但是无关大雅，大不了就下次再回收</strong>。</li>
</ul>
<h2><span id="region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma">region之间都要通过BFS遍历吗？</span><a href="#region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma" class="header-anchor">#</a></h2>
<p>这个问题，和之前CMS中回收年轻代时， 是否要走一遍全量的老年代是一个道理。</p>
<p>G1里用的是一个RememberSet来避免全region扫描的。<br>
每个G1的region都有一个<strong>记忆集(Rset)</strong><br>
记忆集会记录下当前这个region中的对象被哪些对象所引用。<br>
例如，region2中的两个对象分别被region1中的对象和region3中的对象所引用，那么，region2的记忆集记录的就是region1和region3中的引用region2的对象的引用。</p>
<p>这样一来在回收region2的时候，就不用扫描全部的region了，只需要访问记忆集，就知道当前region2里面的对象被哪些对象所引用，判断其是不是存活对象。</p>
<p><strong>简单来说，就是标记我这个region被哪些region引用，简化扫描，避免不必要的检索。</strong></p>
<hr>
<p>但是书上提到了一句话（P85)：</p>
<blockquote>
<blockquote>
<p>“通过cardTable卡表把相关引用信息记录到被引用对象所属的region的rememberedSet之中”</p>
</blockquote>
</blockquote>
<p>这里我就点没看懂，卡表不是老年代对年轻代的引用么，为什么G1里也有？不是用了记忆集吗？不解，等以后有解答了，再来修改这里的内容。</p>
<hr>
<h1><span id="wan-zheng-da-tu">完整大图</span><a href="#wan-zheng-da-tu" class="header-anchor">#</a></h1>
<p>关于垃圾收集，书上倾向于先将一些基本概念或者基本回收思路，再讲发展流程，同时对G1缺少更细致的解释，这就容易混杂起来，导致垃圾收集器的进化那一章节看得很迷。</p>
<p>后面找到了一本书，叫做《The Garbage Collection Handbook》，已经收藏，有时间的话可以看看，据说对G1做了非常细致的讲解<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652885621080294993.png" alt="image.png"></p>
<p>最后送上完整大图：<br>
<img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/5d139636e4b065dc2c6b9a50.png" alt="垃圾收集器大图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/29/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/29/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">jvm内存区域原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-29 14:53:55" itemprop="dateCreated datePublished" datetime="2022-05-29T14:53:55+08:00">2022-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:50:59" itemprop="dateModified" datetime="2022-08-10T00:50:59+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/jvm%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">jvm原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/29/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/29/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重读了一遍《深入理解java虚拟机》， 发现第一遍读“运行时数据区”相关内容的时候，只关注了最简单的概念部分，对于其中的细节部分没有深入探究，觉得那些东西太底层了，没啥用。<br>
其实他们背后的原理，和我们平时运行进程时的各种报错息息相关。<br>
另外如果能理解运行时数据区，也能够对“代码究竟是如何运行的”有更深的理解。</p>
<p><strong>看来经典书籍要多读多总结，是有道理的。</strong><br>
于是在阅读这个章节时，针对每个结构，思考了非常多的问题，提出了很多QA，方便进行深度的思考和学习。</p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#jvm-quan-ju-jie-gou">jvm全局结构</a></li>
<li><a href="#java-dui">java堆</a>
<ul>
<li><a href="#q-dui-shi-xian-cheng-zhi-jian-gong-yong-de-dan-zhe-yang-hui-dao-zhi-pin-fan-fa-sheng-chong-tu-shi-fou-yao-kao-lu-bing-fa-wen-ti-zen-me-ban">Q: 堆是线程之间共用的，但这样会导致频繁发生冲突，是否要考虑并发问题？怎么办？</a></li>
<li><a href="#q-dan-shi-ru-guo-qia-qiao-duo-ge-xian-cheng-zai-shi-tu-jing-zheng-tong-yi-ge-tlab-yu-liu-kong-jian-shi-ji-du-zai-shi-tu-kuo-rong-fa-sheng-chong-tu-zen-me-ban">Q: 但是如果恰巧多个线程在试图竞争同一个TLAB预留空间时（即都在试图扩容），发生冲突怎么办？</a></li>
<li><a href="#q-fen-pei-de-shi-hou-zai-tlab-qu-yu-li-zen-me-zhi-dao-fang-zai-na-ge-wei-zhi-ni">Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？</a></li>
</ul>
</li>
<li><a href="#cheng-xu-ji-shu-qi">程序计数器</a>
<ul>
<li><a href="#q-pc-ji-shu-qi-shi-zheng-ge-jvm-gong-you-de-ma">Q:PC计数器是整个jvm共有的吗？</a></li>
<li><a href="#q-pc-ji-shu-qi-you-sha-yong-na-ru-guo-mei-you-pc-ji-cun-qi-ni-wo-bu-shi-ye-neng-yi-tiao-tiao-zhi-xing-yu-dao-return-zhi-ling-fan-hui-dui-ying-di-zhi-ji-ke-xu-yao-pc-ji-cun-qi-zuo-sha">Q:PC计数器有啥用？ 那如果没有PC寄存器呢？ 我不是也能一条条执行，遇到return指令，返回对应地址即可，需要PC寄存器做啥？</a></li>
<li><a href="#q-wei-shi-me-native-fang-fa-de-cheng-xu-ji-shu-qi-wei-0-undefine-ru-guo-fa-sheng-xian-cheng-qie-huan-zen-me-ban">Q:为什么native方法的程序计数器为0（undefine）？如果发生线程切换，怎么办？</a></li>
<li><a href="#q-pc-ji-shu-qi-li-cun-de-dao-di-shi-sha-shi-zhi-ling-di-zhi-ma">Q: PC计数器里存的到底是啥？是指令地址吗？</a></li>
<li><a href="#q-na-me-zen-me-zhi-dao-shi-ji-de-zi-jie-ma-wei-zhi">Q: 那么怎么知道实际的字节码位置？</a></li>
</ul>
</li>
<li><a href="#xu-ni-ji-zhan-qu-yu">虚拟机栈区域</a>
<ul>
<li><a href="#xian-cheng-zhan-zheng">线程栈帧</a>
<ul>
<li><a href="#q-shi-me-shi-zhan-zheng">Q： 什么是栈帧？</a></li>
<li><a href="#q-zhan-zheng-li-bao-han-shi-me">Q： 栈帧里包含什么？</a></li>
<li><a href="#q-zhan-zheng-de-da-xiao-shi-me-shi-hou-que-ding">Q: 栈帧的大小什么时候确定？</a></li>
</ul>
</li>
<li><a href="#cao-zuo-shu-zhan">操作数栈</a>
<ul>
<li><a href="#q-shi-me-shi-cao-zuo-shu-zhan">Q： 什么是操作数栈</a></li>
<li><a href="#q-wei-shi-me-yi-ding-yao-you-cao-zuo-shu-zhan">Q: 为什么一定要有操作数栈？</a></li>
</ul>
</li>
<li><a href="#ju-bu-bian-liang-biao">局部变量表</a>
<ul>
<li><a href="#q-shi-me-shi-ju-bu-bian-liang-biao">Q: 什么是局部变量表？</a></li>
<li><a href="#q-ju-bu-bian-liang-de-cao-you-shi-shi-me">Q: 局部变量的槽又是什么？</a></li>
<li><a href="#q-ju-bu-bian-liang-biao-li-de-returnaddress-he-zhan-zheng-li-de-fan-hui-di-zhi-returnaddress-you-sha-qu-bie">Q: 局部变量表里的returnAddress和栈帧里的返回地址returnAddress有啥区别？</a></li>
<li><a href="#q-ju-bu-bian-liang-biao-de-slot-ke-yi-bei-fu-gai-ma-zhe-ge-she-ji-you-shi-me-hao-chu">Q: 局部变量表的slot可以被覆盖吗？这个设计有什么好处</a></li>
<li><a href="#q-she-zhi-null-zhi-jiu-yi-ding-hui-fu-gai-slot-ma">Q: 设置null值，就一定会覆盖slot吗？</a></li>
<li><a href="#q-wei-shi-me-java-zhong-ju-bu-bian-liang-mei-you-mo-ren-chu-shi">Q:为什么java中局部变量没有默认初始？</a></li>
<li><a href="#q-zhan-zheng-zhi-jian-ke-neng-cun-zai-gong-xiang-bian-liang-biao-de-qing-kuang-ma">Q: 栈帧之间可能存在共享变量表的情况吗？</a></li>
</ul>
</li>
<li><a href="#dong-tai-lian-jie">动态链接</a>
<ul>
<li><a href="#q-zhan-zheng-li-de-dong-tai-lian-jie-you-shi-sha">Q : 栈帧里的动态链接又是啥？</a></li>
</ul>
</li>
<li><a href="#fan-hui-di-zhi">返回地址</a>
<ul>
<li><a href="#q-ji-ran-you-pc-ji-cun-qi-zhan-zheng-li-de-fan-hui-di-zhi-de-zuo-yong-shi-shi-me">Q: 既然有PC寄存器，栈帧里的返回地址的作用是什么？</a></li>
<li><a href="#q-zhan-zheng-zhong-de-fang-fa-tui-chu-shi-hui-hong-fa-na-xie-dong-zuo">Q: 栈帧中的方法退出时，会触发哪些动作？</a></li>
<li><a href="#q-zhan-zheng-chu-liao-shang-mian-ti-dao-de-ji-ge-huan-you-qi-ta-de-xin-xi-ma">Q: 栈帧除了上面提到的几个，还有其他的信息吗？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fang-fa-qu">方法区</a>
<ul>
<li><a href="#q-fang-fa-qu-li-cun-de-shi-class-zi-jie-ma-ma">Q: 方法区里存的是class字节码吗？</a></li>
<li><a href="#q-yuan-kong-jian-yu-yong-jiu-dai-dao-di-shi-zen-me-hui-shi">Q: 元空间与永久代到底是怎么回事？</a></li>
<li><a href="#q-wei-shi-me-yao-ti-huan-yong-jiu-dai">Q: 为什么要替换永久代</a></li>
</ul>
</li>
<li><a href="#zui-hou-de-gan-xiang">最后的感想</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="jvm-quan-ju-jie-gou">jvm全局结构</span><a href="#jvm-quan-ju-jie-gou" class="header-anchor">#</a></h1>
<p>首先是一张经典的jvm运行时内存区域划分的图，我自己画了一张：</p>
<p><img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1653815416671.png" alt="1653815416671"></p>
<hr>
<p>Q: 存在多个线程时，刚才提到的5个区域是怎么分布的？<br>
A:<br>
每个线程，都有自己独立的虚拟机栈、独立的程序计数器PC。</p>
<p>而方法区和堆是线程们共用的。</p>
<hr>
<h1><span id="java-dui">java堆</span><a href="#java-dui" class="header-anchor">#</a></h1>
<p>java堆的内容比较多，这里不探究对象分配的原理，后面会补充新的文章。这里只讨论堆的一些其他细节问题。</p>
<hr>
<h2><span id="q-dui-shi-xian-cheng-zhi-jian-gong-yong-de-dan-zhe-yang-hui-dao-zhi-pin-fan-fa-sheng-chong-tu-shi-fou-yao-kao-lu-bing-fa-wen-ti-zen-me-ban">Q: 堆是线程之间共用的，但这样会导致频繁发生冲突，是否要考虑并发问题？怎么办？</span><a href="#q-dui-shi-xian-cheng-zhi-jian-gong-yong-de-dan-zhe-yang-hui-dao-zhi-pin-fan-fa-sheng-chong-tu-shi-fou-yao-kao-lu-bing-fa-wen-ti-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
线程分配堆空间时，会先根据TLAB进行独立分配。</p>
<blockquote>
<blockquote>
<p>TLAB ——Thread Local Allocation Buffer， 中文名为线程本地分配缓冲区。<br>
启用了 TLAB 之后(-XX:+UseTLAB, 默认是开启的)，JVM 会针对每一个线程在 Java 堆中预留一个内存区域。<br>
一旦某个区域确定划分给某个线程，之后<strong>该线程需要分配内存的时候，会优先在这片区域中申请</strong>。这个区域针对分配内存这个动作而言是该线程私有的，因此在分配的时候不用进行加锁等保护性的操作</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="q-dan-shi-ru-guo-qia-qiao-duo-ge-xian-cheng-zai-shi-tu-jing-zheng-tong-yi-ge-tlab-yu-liu-kong-jian-shi-ji-du-zai-shi-tu-kuo-rong-fa-sheng-chong-tu-zen-me-ban">Q: 但是如果恰巧多个线程在试图竞争同一个TLAB预留空间时（即都在试图扩容），发生冲突怎么办？</span><a href="#q-dan-shi-ru-guo-qia-qiao-duo-ge-xian-cheng-zai-shi-tu-jing-zheng-tong-yi-ge-tlab-yu-liu-kong-jian-shi-ji-du-zai-shi-tu-kuo-rong-fa-sheng-chong-tu-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
在预留这个动作发生的时候，需要进行加锁或者采用** CAS（compareAndSet) **等操作进行保护，避免多个线程预留同一个区域</p>
<hr>
<h2><span id="q-fen-pei-de-shi-hou-zai-tlab-qu-yu-li-zen-me-zhi-dao-fang-zai-na-ge-wei-zhi-ni">Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？</span><a href="#q-fen-pei-de-shi-hou-zai-tlab-qu-yu-li-zen-me-zhi-dao-fang-zai-na-ge-wei-zhi-ni" class="header-anchor">#</a></h2>
<p>A:<br>
具体的分配内存有两种情况（和垃圾回收机制有关）</p>
<ol>
<li>第一种情况是内存空间绝对规整。（对应使用回收-整理/复制算法的垃圾回收区）</li>
<li>第二种情况是内存空间是不连续的。（对应使用回收-清除算法的垃圾回收区）</li>
</ol>
<p>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</p>
<p>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</p>
<h1><span id="cheng-xu-ji-shu-qi">程序计数器</span><a href="#cheng-xu-ji-shu-qi" class="header-anchor">#</a></h1>
<h2><span id="q-pc-ji-shu-qi-shi-zheng-ge-jvm-gong-you-de-ma">Q:PC计数器是整个jvm共有的吗？</span><a href="#q-pc-ji-shu-qi-shi-zheng-ge-jvm-gong-you-de-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不是的，是每个线程各自有一个， 而且是java自己定义的线程PC， 和CPU里的PC寄存器不同。</p>
<hr>
<h2><span id="q-pc-ji-shu-qi-you-sha-yong-na-ru-guo-mei-you-pc-ji-cun-qi-ni-wo-bu-shi-ye-neng-yi-tiao-tiao-zhi-xing-yu-dao-return-zhi-ling-fan-hui-dui-ying-di-zhi-ji-ke-xu-yao-pc-ji-cun-qi-zuo-sha">Q:PC计数器有啥用？ 那如果没有PC寄存器呢？ 我不是也能一条条执行，遇到return指令，返回对应地址即可，需要PC寄存器做啥？</span><a href="#q-pc-ji-shu-qi-you-sha-yong-na-ru-guo-mei-you-pc-ji-cun-qi-ni-wo-bu-shi-ye-neng-yi-tiao-tiao-zhi-xing-yu-dao-return-zhi-ling-fan-hui-dui-ying-di-zhi-ji-ke-xu-yao-pc-ji-cun-qi-zuo-sha" class="header-anchor">#</a></h2>
<p>A: PC寄存器的作用在于多线程切换的时候，能找到每个线程执行的位置，所以它是线程私有的一个寄存器，知道当前运行到哪了。如果没有，一旦随机切换就不知道咋办了。你总需要一个地方存储这个线程当前执行情况，但又要保持独立性，所以不可能存到其他线程的空间里。</p>
<hr>
<h2><span id="q-wei-shi-me-native-fang-fa-de-cheng-xu-ji-shu-qi-wei-0-undefine-ru-guo-fa-sheng-xian-cheng-qie-huan-zen-me-ban">Q:为什么native方法的程序计数器为0（undefine）？如果发生线程切换，怎么办？</span><a href="#q-wei-shi-me-native-fang-fa-de-cheng-xu-ji-shu-qi-wei-0-undefine-ru-guo-fa-sheng-xian-cheng-qie-huan-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
注意，jvm内存结构里的PC计数器是jvm自己定义的“字节码指令”执行寄存器。<br>
对于native方法，并不在字节码的范围，不指向方法区里的任何指令位置。</p>
<p>因此native方法其实不是由jvm管理的，如果线程切换，他执行到哪边，取决于OS的底层机器码计数器实现。</p>
<blockquote>
<blockquote>
<p>以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="q-pc-ji-shu-qi-li-cun-de-dao-di-shi-sha-shi-zhi-ling-di-zhi-ma">Q: PC计数器里存的到底是啥？是指令地址吗？</span><a href="#q-pc-ji-shu-qi-li-cun-de-dao-di-shi-sha-shi-zhi-ling-di-zhi-ma" class="header-anchor">#</a></h2>
<p>A:<br>
错误！ 存的不是地址，而是这个方法的字节码偏移。例如0、1、5、6这种。<br>
<img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800419071211329.png" alt="image.png"></p>
<hr>
<h2><span id="q-na-me-zen-me-zhi-dao-shi-ji-de-zi-jie-ma-wei-zhi">Q: 那么怎么知道实际的字节码位置？</span><a href="#q-na-me-zen-me-zhi-dao-shi-ji-de-zi-jie-ma-wei-zhi" class="header-anchor">#</a></h2>
<p>A: 这个就要结合下文提到的栈帧中的动态链接，来联合计算实际字节码位置了。</p>
<h1><span id="xu-ni-ji-zhan-qu-yu">虚拟机栈区域</span><a href="#xu-ni-ji-zhan-qu-yu" class="header-anchor">#</a></h1>
<hr>
<h2><span id="xian-cheng-zhan-zheng">线程栈帧</span><a href="#xian-cheng-zhan-zheng" class="header-anchor">#</a></h2>
<h3><span id="q-shi-me-shi-zhan-zheng">Q： 什么是栈帧？</span><a href="#q-shi-me-shi-zhan-zheng" class="header-anchor">#</a></h3>
<p>A： 每个线程有一个自己的栈帧，然后运行到每个方法时，每个方法中都会可以理解为是摄影里的一帧。<br>
<img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800601102172178.png" alt="image.png"></p>
<hr>
<h3><span id="q-zhan-zheng-li-bao-han-shi-me">Q： 栈帧里包含什么？</span><a href="#q-zhan-zheng-li-bao-han-shi-me" class="header-anchor">#</a></h3>
<p>A：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法返回地址</li>
</ul>
<p>其实与上面这4样配合的，还有个上文提到的“程序计数器”，才共同实现了jvm指令的执行。</p>
<hr>
<h3><span id="q-zhan-zheng-de-da-xiao-shi-me-shi-hou-que-ding">Q: 栈帧的大小什么时候确定？</span><a href="#q-zhan-zheng-de-da-xiao-shi-me-shi-hou-que-ding" class="header-anchor">#</a></h3>
<p>A：<br>
在编译程序代码的时候.<br>
注意， 图例提到的栈大小，并不是指线程堆栈的最大深度，<br>
而是指“操作数栈”的最大深度。（注意这个深度存在类文件字节码中对应方法的属性表中）<br>
<img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800735895914907.png" alt="image.png"></p>
<p>即jvm能够通过分析代码中可能存在多少个变量以及计算空间，来确定局部变量表和最大操作数栈的一个深度。</p>
<h2><span id="cao-zuo-shu-zhan">操作数栈</span><a href="#cao-zuo-shu-zhan" class="header-anchor">#</a></h2>
<h3><span id="q-shi-me-shi-cao-zuo-shu-zhan">Q： 什么是操作数栈</span><a href="#q-shi-me-shi-cao-zuo-shu-zhan" class="header-anchor">#</a></h3>
<p>A：<br>
可以理解为jvm做计算时，需要一个临时的寄存器，把需要计算的数据或者传方法的参数放到栈中，然后做计算。<br>
<img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800699980785954.png" alt="image.png"></p>
<hr>
<h3><span id="q-wei-shi-me-yi-ding-yao-you-cao-zuo-shu-zhan">Q: 为什么一定要有操作数栈？</span><a href="#q-wei-shi-me-yi-ding-yao-you-cao-zuo-shu-zhan" class="header-anchor">#</a></h3>
<p>如果要做a+b,我直接从变量表上取a的值和b的值，加起来不就好了？<br>
A:<br>
那我如果是 a + b<em>c呢，  这个b</em>c的值放哪里？<br>
如果是a+b*(c+d)呢？<br>
这时候如果你学习过数据结构里栈的应用 ，就会知道 模拟一个计算器，往往需要一个栈。<br>
而操作数栈就是这个作用。<br>
当你学习jvm指令时，就会看到有专门的指令就是取栈顶或者把值推送到栈顶的指令。<br>
这样做加法的时候，也就不用关心变量的地址了，只要你把栈顶的值存好，我直接拿去加就行。</p>
<hr>
<h2><span id="ju-bu-bian-liang-biao">局部变量表</span><a href="#ju-bu-bian-liang-biao" class="header-anchor">#</a></h2>
<h3><span id="q-shi-me-shi-ju-bu-bian-liang-biao">Q: 什么是局部变量表？</span><a href="#q-shi-me-shi-ju-bu-bian-liang-biao" class="header-anchor">#</a></h3>
<p>A：<br>
每个线程所在栈帧都会有一个自己的局部变量表，里面存储方法中使用到的局部变量。<br>
<img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800897811439190.png" alt="image.png"></p>
<hr>
<h3><span id="q-ju-bu-bian-liang-de-cao-you-shi-shi-me">Q: 局部变量的槽又是什么？</span><a href="#q-ju-bu-bian-liang-de-cao-you-shi-shi-me" class="header-anchor">#</a></h3>
<p>A:</p>
<ul>
<li>returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</li>
<li>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）</li>
<li>slot的长度可以随着处理器、操作系统的不同而变化， 不是绝对的32位。<br>
jvm概念中说的是”slot一定能存放下1个boolean\byte\int\引用地址\返回地址returnAddress“等不包括long在内的内容。</li>
<li>如果要访问long，需要做2次局部变量slot的读取，读取n和n+1，不允许单独访问，如果有问题会在字节码校验中报错。</li>
</ul>
<hr>
<h3><span id="q-ju-bu-bian-liang-biao-li-de-returnaddress-he-zhan-zheng-li-de-fan-hui-di-zhi-returnaddress-you-sha-qu-bie">Q: 局部变量表里的returnAddress和栈帧里的返回地址returnAddress有啥区别？</span><a href="#q-ju-bu-bian-liang-biao-li-de-returnaddress-he-zhan-zheng-li-de-fan-hui-di-zhi-returnaddress-you-sha-qu-bie" class="header-anchor">#</a></h3>
<p>A:<br>
局部变量表里的的returnAddress，是老版本jvm用于处理异常跳转的（jsr\jsr_w\ret指令，新版本基本都用code里的异常表来代替），而栈帧里的返回地址，是返回到上一层栈帧的代码调用位置，更新PC计数器用的。</p>
<hr>
<h3><span id="q-ju-bu-bian-liang-biao-de-slot-ke-yi-bei-fu-gai-ma-zhe-ge-she-ji-you-shi-me-hao-chu">Q: 局部变量表的slot可以被覆盖吗？这个设计有什么好处</span><a href="#q-ju-bu-bian-liang-biao-de-slot-ke-yi-bei-fu-gai-ma-zhe-ge-she-ji-you-shi-me-hao-chu" class="header-anchor">#</a></h3>
<p>A:</p>
<ul>
<li>可以减少局部变量表的空间，通过分析每个局部变量的使用生命周期，在某变量不再被使用后，让其他变量可以覆盖这个槽的位置。</li>
<li>另一方面，覆盖的机制，可以将一些局部变量上已经不使用的大对象解除引用，例如对一些大的变量做=null的操作，那么可以尽早进行垃圾回收（因为栈帧的局部变量表里的每个slot都是一个gcRoot）</li>
</ul>
<hr>
<h3><span id="q-she-zhi-null-zhi-jiu-yi-ding-hui-fu-gai-slot-ma">Q: 设置null值，就一定会覆盖slot吗？</span><a href="#q-she-zhi-null-zhi-jiu-yi-ding-hui-fu-gai-slot-ma" class="header-anchor">#</a></h3>
<p>A:<br>
不一定，有时候JIT编译优化，可能会处理掉这个无用的=null的操作，且能正确处理slot中已经不被使用的变量。<br>
按照书里的说法，正好有大对象，然后还停留在局部变量表里的概率是比较低的。不建议那么做了</p>
<hr>
<h3><span id="q-wei-shi-me-java-zhong-ju-bu-bian-liang-mei-you-mo-ren-chu-shi">Q:为什么java中局部变量没有默认初始？</span><a href="#q-wei-shi-me-java-zhong-ju-bu-bian-liang-mei-you-mo-ren-chu-shi" class="header-anchor">#</a></h3>
<p>A:<br>
我的理解，局部变量在局部变量表中，而局部变量表是运行时生成的， 而非在堆上生成，因此不会有堆对象创建时的那个默认值赋值操作。 即jvm定义上， 就是局部变量没有初始化前的’准备‘这个阶段的，也就不存在默认赋值的指令行为。</p>
<p>如果硬要说为什么，如果每个局部变量都复制，肯定会影响执行效率，因此不如不赋值。，所以必须通过赋值指令在运行时给他赋值。（没找到很好的解释，有更好理解的可以帮忙回答一下，其实就是）</p>
<p>另外如果每个局部变量都有，那可能指令数量就会变多，因为你需要放入很多赋值指令？</p>
<p>阅读JMM内存模型时的另一个解释：</p>
<blockquote>
<blockquote>
<p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性.<br>
线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来<br>
对于全局变量（类对象成员），必须有默认初始化，为了满足多线程环境下的最小安全性。<br>
但对于局部变量，不存在被多线程使用，因此一定后面可以拼接一个指令，所以不需要默认初始化的动作。</p>
</blockquote>
</blockquote>
<hr>
<h3><span id="q-zhan-zheng-zhi-jian-ke-neng-cun-zai-gong-xiang-bian-liang-biao-de-qing-kuang-ma">Q: 栈帧之间可能存在共享变量表的情况吗？</span><a href="#q-zhan-zheng-zhi-jian-ke-neng-cun-zai-gong-xiang-bian-liang-biao-de-qing-kuang-ma" class="header-anchor">#</a></h3>
<p>即执行多次方法，一个栈上有多个栈帧，每个栈帧都有各自的局部变量表和操作数栈，然后上下层之间共享</p>
<p>A:<br>
可能存在。即上下两个栈帧之间， 可能有操作数栈可以直接操作另一个栈帧局部变量的情况。这样可以避免额外的参数复制传递。<br>
什么时候触发？不清楚</p>
<hr>
<h2><span id="dong-tai-lian-jie">动态链接</span><a href="#dong-tai-lian-jie" class="header-anchor">#</a></h2>
<h3><span id="q-zhan-zheng-li-de-dong-tai-lian-jie-you-shi-sha">Q : 栈帧里的动态链接又是啥？</span><a href="#q-zhan-zheng-li-de-dong-tai-lian-jie-you-shi-sha" class="header-anchor">#</a></h3>
<p>A:<br>
首先明确一点， 每一个栈帧，不一定是”动态”链接，但一定会有一个指向常量池中方法的引用。</p>
<p>为什么栈帧里需要存这个指向方法的引用？</p>
<p>首先，当你进入一个方法，准备生成一个栈帧，放到线程上时，你需要知道你这个代码执行的是什么代码，才能进行后面的操作。</p>
<p>如果是构造方法、final方法，则会编译器进行静态链接。<br>
如果是虚方法，则会进行动态链接，运行期只是从类对象中，拿到了一个符号引用，</p>
<p>但是这个引用指向哪个方法？则通过下面的过程进行定位和寻找，把符号引用转成实际方法的直接引用。<br>
<img src="/images/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8E%9F%E7%90%86/1652800987016832820.png" alt="image.png"><br>
因此要提供一个引用，指向常量池里的方法。指向后，就能知道程序位置。<br>
然后<strong>字节码实际引用位置 + PC计数器偏移</strong>，就能知道当前线程执行到哪个方法的哪一步指令上了。</p>
<p>（关于动态链接这个名称的由来，是因为“动态分派”的存在，你这个方法位置是不确定的，和实际对象+方法名有关， 所以称为动态链接。）</p>
<hr>
<h2><span id="fan-hui-di-zhi">返回地址</span><a href="#fan-hui-di-zhi" class="header-anchor">#</a></h2>
<h3><span id="q-ji-ran-you-pc-ji-cun-qi-zhan-zheng-li-de-fan-hui-di-zhi-de-zuo-yong-shi-shi-me">Q: 既然有PC寄存器，栈帧里的返回地址的作用是什么？</span><a href="#q-ji-ran-you-pc-ji-cun-qi-zhan-zheng-li-de-fan-hui-di-zhi-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h3>
<p>A:<br>
方法A调用方法B的时候，PC寄存器会跟着移动到B方法去。当B执行完后，要能返回A继续执行，就需要A当时执行到的那条指令的地址。所以，在B的栈帧中保存A当时的指令地址（当时PC寄存器的值），当B执行完后，根据此返回地址跳回A。通过返回地址，从而知道当前线程的上一级应该从PC的第几行偏移开始。</p>
<p>另外除了正常通过ret指令退出，还可能是出现异常时，如果没有在异常表里被捕捉并处理，也会通过异常完成出口， 使用返回地址返回到上一层。</p>
<hr>
<h3><span id="q-zhan-zheng-zhong-de-fang-fa-tui-chu-shi-hui-hong-fa-na-xie-dong-zuo">Q: 栈帧中的方法退出时，会触发哪些动作？</span><a href="#q-zhan-zheng-zhong-de-fang-fa-tui-chu-shi-hui-hong-fa-na-xie-dong-zuo" class="header-anchor">#</a></h3>
<p>A:</p>
<ol>
<li>当前栈帧出栈</li>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>如果有返回值，把返回值压入操作数栈的栈顶（因为马上就要被调用了）</li>
<li>调整这个线程栈的PC计数器，改成returnAddress对应的那个指令位置地址，然后继续往下调用执行。</li>
</ol>
<hr>
<h3><span id="q-zhan-zheng-chu-liao-shang-mian-ti-dao-de-ji-ge-huan-you-qi-ta-de-xin-xi-ma">Q: 栈帧除了上面提到的几个，还有其他的信息吗？</span><a href="#q-zhan-zheng-chu-liao-shang-mian-ti-dao-de-ji-ge-huan-you-qi-ta-de-xin-xi-ma" class="header-anchor">#</a></h3>
<p>A:<br>
有些支持调试的虚拟机，可能会补充很多调试相关的信息。</p>
<h1><span id="fang-fa-qu">方法区</span><a href="#fang-fa-qu" class="header-anchor">#</a></h1>
<h2><span id="q-fang-fa-qu-li-cun-de-shi-class-zi-jie-ma-ma">Q: 方法区里存的是class字节码吗？</span><a href="#q-fang-fa-qu-li-cun-de-shi-class-zi-jie-ma-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不是。经过类的加载、链接、初始化之后， class字节码对于进程来说就没用了。<br>
存了以下内容：</p>
<ul>
<li>每个类的类型信息：类名、父类类名、修饰符、接口</li>
<li>字段信息field（域信息）：字段名、字段类型、字段修饰符</li>
<li>方法信息，包括方法名、类型、参数、修饰符、字节码、一场表<br>
如下：</li>
<li>类的静态变量</li>
<li>常量池，存储常量<br>
注意，符号引用、类引用、实际类名等信息等都是放在常量池中的。</li>
</ul>
<hr>
<h2><span id="q-yuan-kong-jian-yu-yong-jiu-dai-dao-di-shi-zen-me-hui-shi">Q:  元空间与永久代到底是怎么回事？</span><a href="#q-yuan-kong-jian-yu-yong-jiu-dai-dao-di-shi-zen-me-hui-shi" class="header-anchor">#</a></h2>
<p>A:<br>
方法区和“PermGen space”又有着本质的区别。<br>
<strong>前者是 JVM 的规范，而后者则是 JVM 规范的一种实现</strong><br>
并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。</p>
<p><strong>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小</strong><br>
-XX:MetaspaceSize和-XX:MaxMetaspaceSize</p>
<hr>
<h2><span id="q-wei-shi-me-yao-ti-huan-yong-jiu-dai">Q: 为什么要替换永久代</span><a href="#q-wei-shi-me-yao-ti-huan-yong-jiu-dai" class="header-anchor">#</a></h2>
<p>A:<br>
替换永久代的其他原因：</p>
<ol>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ol>
<hr>
<h1><span id="zui-hou-de-gan-xiang">最后的感想</span><a href="#zui-hou-de-gan-xiang" class="header-anchor">#</a></h1>
<p>好累，终于写完了，感觉能看到最后的人不会太多，但一通详细地分析和解决中间发现的问题，还是收获了不少。</p>
<p>关于jvm运行时数据区，最重要的不是去死记硬背，而是试图在脑中构建一个指令运行的逻辑流程。</p>
<p>且对于很多没有学习过计算机底层原理（例如CSAPP这本书） 的人来说， 是很难接触到计算机是如何执行机器码指令的。<br>
而java虚拟机栈可以更好理解 指令是如何运行的（虽然这不是机器码，而是jvm字节码）。<br>
但是通过运行时数据区的各种行为和概念， 我们可以快速对应到java中常见的各种操作。<br>
这对于很多入门时直奔删减改查的同学来说， 是不可多得的学习底层的机会。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/06/%E9%9A%8F%E7%AC%94/sleep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/06/%E9%9A%8F%E7%AC%94/sleep/" class="post-title-link" itemprop="url">解决失眠的科学疗法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-06 23:08:31" itemprop="dateCreated datePublished" datetime="2022-05-06T23:08:31+08:00">2022-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 23:57:29" itemprop="dateModified" datetime="2022-08-10T23:57:29+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/06/%E9%9A%8F%E7%AC%94/sleep/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/06/%E9%9A%8F%E7%AC%94/sleep/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="shui-mian-xian-zhi-fa">睡眠限制法</span><a href="#shui-mian-xian-zhi-fa" class="header-anchor">#</a></h1>
<ul>
<li>
<p>首要目标： 增加睡眠时间/卧床时间的占比，建立床=睡眠的潜意识。</p>
</li>
<li>
<p>主要方式： 在无法显著增加睡眠时间的情况下，减少卧床时间。</p>
</li>
<li>
<p>具体措施：</p>
<ol>
<li>根据之前往期的入睡统计，安排严格的上床和入睡。例如晚上12点睡，早上6点30起。</li>
<li>困了就上床，上床后不要玩手机，避免增加无效卧床时间。</li>
<li>如果在床上不困，就立刻起床，避免增加无效的卧床时间。</li>
<li>减少午睡甚至不午睡，将困意集中到晚上的时间。</li>
</ol>
</li>
</ul>
<h1><span id="ru-shui-fen-wei-de-gou-jian">入睡氛围的构建</span><a href="#ru-shui-fen-wei-de-gou-jian" class="header-anchor">#</a></h1>
<ol>
<li>睡前不要做需要耗费脑子导致精神集中无法放松的事情， 例如做算法题、高强度学习等。</li>
<li>提前1h洗澡、洗头，避免上床前才洗。</li>
<li>手机的新闻、游戏日常任务尽量白天能刷就刷，睡前告诉自己都已经刷过了，不需要再刷了。（可以将自己需要刷的东西列一个清单，睡前看一下自己是不是白天都刷过了）</li>
</ol>
<h1><span id="ru-he-chu-li-shui-mian-shi-de-jiao-lu">如何处理睡眠时的焦虑</span><a href="#ru-he-chu-li-shui-mian-shi-de-jiao-lu" class="header-anchor">#</a></h1>
<ol>
<li>睡少了 并不等于 第二天会完蛋。大部分人不会从事过于高精密的工作。</li>
<li>如果有睡眠外的焦虑， 尝试在睡前安排一定的”焦虑时间“，让自己充分将焦虑的想法念出来或者写出来，这样上床后如果还焦虑，可以告诉自己”刚才都已经焦虑过了，也写出来了，现在想也就没意义了“</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/06/%E9%9A%8F%E7%AC%94/%E5%A4%B1%E7%9C%A0%E7%96%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/06/%E9%9A%8F%E7%AC%94/%E5%A4%B1%E7%9C%A0%E7%96%97%E6%B3%95/" class="post-title-link" itemprop="url">解决失眠的科学疗法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-06 23:08:31" itemprop="dateCreated datePublished" datetime="2022-05-06T23:08:31+08:00">2022-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:54:37" itemprop="dateModified" datetime="2022-08-10T00:54:37+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/06/%E9%9A%8F%E7%AC%94/%E5%A4%B1%E7%9C%A0%E7%96%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/06/%E9%9A%8F%E7%AC%94/%E5%A4%B1%E7%9C%A0%E7%96%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="shui-mian-xian-zhi-fa">睡眠限制法</span><a href="#shui-mian-xian-zhi-fa" class="header-anchor">#</a></h1>
<ul>
<li>
<p>首要目标： 增加睡眠时间/卧床时间的占比，建立床=睡眠的潜意识。</p>
</li>
<li>
<p>主要方式： 在无法显著增加睡眠时间的情况下，减少卧床时间。</p>
</li>
<li>
<p>具体措施：</p>
<ol>
<li>根据之前往期的入睡统计，安排严格的上床和入睡。例如晚上12点睡，早上6点30起。</li>
<li>困了就上床，上床后不要玩手机，避免增加无效卧床时间。</li>
<li>如果在床上不困，就立刻起床，避免增加无效的卧床时间。</li>
<li>减少午睡甚至不午睡，将困意集中到晚上的时间。</li>
</ol>
</li>
</ul>
<h1><span id="ru-shui-fen-wei-de-gou-jian">入睡氛围的构建</span><a href="#ru-shui-fen-wei-de-gou-jian" class="header-anchor">#</a></h1>
<ol>
<li>睡前不要做需要耗费脑子导致精神集中无法放松的事情， 例如做算法题、高强度学习等。</li>
<li>提前1h洗澡、洗头，避免上床前才洗。</li>
<li>手机的新闻、游戏日常任务尽量白天能刷就刷，睡前告诉自己都已经刷过了，不需要再刷了。（可以将自己需要刷的东西列一个清单，睡前看一下自己是不是白天都刷过了）</li>
</ol>
<h1><span id="ru-he-chu-li-shui-mian-shi-de-jiao-lu">如何处理睡眠时的焦虑</span><a href="#ru-he-chu-li-shui-mian-shi-de-jiao-lu" class="header-anchor">#</a></h1>
<ol>
<li>睡少了 并不等于 第二天会完蛋。大部分人不会从事过于高精密的工作。</li>
<li>如果有睡眠外的焦虑， 尝试在睡前安排一定的”焦虑时间“，让自己充分将焦虑的想法念出来或者写出来，这样上床后如果还焦虑，可以告诉自己”刚才都已经焦虑过了，也写出来了，现在想也就没意义了“</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/04/%E9%9A%8F%E7%AC%94/heart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/%E9%9A%8F%E7%AC%94/heart/" class="post-title-link" itemprop="url">心理成长感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-04 23:35:22" itemprop="dateCreated datePublished" datetime="2022-05-04T23:35:22+08:00">2022-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 23:57:33" itemprop="dateModified" datetime="2022-08-10T23:57:33+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/04/%E9%9A%8F%E7%AC%94/heart/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/04/%E9%9A%8F%E7%AC%94/heart/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</a></li>
<li><a href="#ji-hua-he-xing-dong">计划和行动</a></li>
<li><a href="#biao-da-nei-xin">表达内心</a></li>
<li><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</a></li>
<li><a href="#zuo-jue-ding-zuo-jue-ze">做决定/做抉择</a></li>
<li><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h2><span id="zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</span><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou" class="header-anchor">#</a></h2>
<ul>
<li>
<p>有时候，他人对你的疑问，例如“天气这么好，你怎么没出去玩呢？” ，<strong>也许仅仅只是他寒暄时提出的一个观点而已，并非对你做职责或者命令</strong>。 以此类推， 对于其他的一些疑问，不要过于恶意地揣测或者做过多想象。</p>
</li>
<li>
<p>不要因为身边大部分人做了什么就感到焦虑，他们的行为可以是你的参考，但并非是最适合你的。<strong>你需要清楚自己内心想要的是什么，内心的感受是怎样的，并尊重和理解自己的感受，坚持自己的那份个性</strong>，而不是为了迎合他人去隐瞒自己的喜好、感受或者真实想法。 无论是假期活动还是工作待遇等，都是如此。</p>
</li>
<li>
<p>“我想逃避”也是一种感受， 逃避是一种可以被理解的行为，但可能是一种不合时宜的行为，因为逃避更像是儿童时期做出的避险行为。<strong>自己需要意识到自己当前的行为模式是否是陈旧的</strong>，以及是否应当稍微找起来，尝试做点和儿童时期不一样的事情。</p>
</li>
</ul>
<h2><span id="ji-hua-he-xing-dong">计划和行动</span><a href="#ji-hua-he-xing-dong" class="header-anchor">#</a></h2>
<ul>
<li>
<p><strong>不要通过幻想，来给自己设定过于严苛的计划或者目的</strong>。 后果就是一旦发生阻碍或者完不成，挫败感会很重，以后做计划也会愈发纠结和犹豫。   因此尽量千万不要定“我xx月前必须怎么怎么”、“我必须每天xxx”，这样对意外情况容错性会降低，或者一次没成，后面就可能直接不再考虑 。</p>
</li>
<li>
<p><strong>想要做一件事， 核心不在于计划， 而在于是否开始逐步行动</strong>，这个行动是可以很小的，但只要你开了头，就相当于获取了这件事的入门门槛。 无论是写博客、跑步、学习、刷题，都是如此。不要把时间浪费在纠结上， 与其纠结，还不如先拆分好之后，随便挑一件做。</p>
<p>对于跑步，应该是“我想跑的时候就跑，这次简单跑个500米试试，并非要周三或者周五，只是想开个头而已”</p>
<p>例如博客，我想写的时候就写一下， 今天空，正好想做，就做了</p>
<p>例如去哪个地方，那就先提前做些小的准备，当你准备充分了，自然也就有选择的余地，而不是强行设置期限，导致自己陷入焦虑之中。</p>
</li>
<li>
<p>当很多想做的事情交叉重叠，<strong>先做影响最近的</strong>，例如洗澡、扫地、拖地，再做比较久远影响的。</p>
</li>
</ul>
<h2><span id="biao-da-nei-xin">表达内心</span><a href="#biao-da-nei-xin" class="header-anchor">#</a></h2>
<ul>
<li>尽可能真实地表达你的想法或者目的，并付诸以该想法为最首要的行为。以下是解释：</li>
</ul>
<ol>
<li>要避免为了掩盖想法，找别的理由去掩饰**</li>
</ol>
<p>例如你想送人笔记本电脑，却总是说不出”我想送你笔记本让你改善你的生活质量“这句话，特地找了  一堆理由，例如”我在公司看到一个便宜的内购“、”我多买了一台笔记本，不要了给你吧“， 却刻意掩埋 了自己的想法。</p>
<ol start="2">
<li>
<p>要避免因为过分考虑后果，导致对”行为“频繁地做调整，当你试图期望让该‘行为’能适配所有的后果时，你的行为本身就不太符合根本目的了</p>
<p>例如你要送人一台新的笔记本电脑，却总是考虑被拒绝的后果，于是换成了一台旧电脑并自己装好系统，以准备被拒绝时可以转交给父母使用。   这样会导致收到礼物的对方并不会觉得开心和尊重。</p>
</li>
</ol>
<p><strong>实际上被拒绝后的事，应该是一种预案，但不能改变行为本身，偏离核心目的</strong>，例如被拒绝了，那你和父母说等你回来再安装即可，或者提供其他的措施，而不是为了后果，直接改变了礼物本身，偏离了希望交好的目的。</p>
<h2><span id="he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</span><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi" class="header-anchor">#</a></h2>
<ol>
<li>切忌二极管思维， <strong>不能一味的赞同别人或者听从别人， 也不能一味地要求别人听从自己的一切要求</strong>。前者是懦弱儿童思维，后者是霸道父亲思维，都是不可取的</li>
<li>不能因为别人不满足我的要求，<strong>就立刻在内心觉得不爽或者不舒服</strong>， 在产生一定的情绪前，先思考对方为什么会这么说/这么做，搞清楚原因后，再决定是发泄情绪还是做应对措施，<strong>“内心默默不爽”对于事情解决是没有任何意义的</strong></li>
</ol>
<h2><span id="zuo-jue-ding-zuo-jue-ze">做决定/做抉择</span><a href="#zuo-jue-ding-zuo-jue-ze" class="header-anchor">#</a></h2>
<ol>
<li>不做决定本身就是一种选择， 这种选择会浪费你的时间和机会成本。</li>
<li>当实在决定不了，先尝试性在2个决定上做一些前置工作，至少保证事情在推进。</li>
<li></li>
</ol>
<h2><span id="gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</span><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi" class="header-anchor">#</a></h2>
<ul>
<li>
<p>工作之内的事情一般会有目标和绩效。工作之外的事情，则要注意不要带入工作思维。</p>
</li>
<li>
<p>避免定过于高的目标，例如一定要完成xxxx，一定要达到xxx， 而忽略了做这件事的意义。</p>
</li>
<li>
<p>不如先开始做，做一部分，如果真的不喜欢就不要勉强</p>
</li>
<li>
<p>注意并不是只有工作技能上的提升才叫提升或者成长， 个人心理、生理状态等进步都是一种提升，因此不要只看这一周工作上有没有学习或者进步之类的。  如果人的焦虑、恐惧症状比前几周有改善，或者开始关注到自己的感受和内心想法，那么也是一种进步。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/04/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">第一阶段心理成长感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-04 23:35:22" itemprop="dateCreated datePublished" datetime="2022-05-04T23:35:22+08:00">2022-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:55:38" itemprop="dateModified" datetime="2022-08-10T00:55:38+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/04/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/04/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</a></li>
<li><a href="#ji-hua-he-xing-dong">计划和行动</a></li>
<li><a href="#biao-da-nei-xin">表达内心</a></li>
<li><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</a></li>
<li><a href="#zuo-jue-ding-zuo-jue-ze">做决定/做抉择</a></li>
<li><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h2><span id="zun-chong-ge-ren-nei-xin-de-gan-shou">尊重个人内心的感受</span><a href="#zun-chong-ge-ren-nei-xin-de-gan-shou" class="header-anchor">#</a></h2>
<ul>
<li>
<p>有时候，他人对你的疑问，例如“天气这么好，你怎么没出去玩呢？” ，<strong>也许仅仅只是他寒暄时提出的一个观点而已，并非对你做职责或者命令</strong>。 以此类推， 对于其他的一些疑问，不要过于恶意地揣测或者做过多想象。</p>
</li>
<li>
<p>不要因为身边大部分人做了什么就感到焦虑，他们的行为可以是你的参考，但并非是最适合你的。<strong>你需要清楚自己内心想要的是什么，内心的感受是怎样的，并尊重和理解自己的感受，坚持自己的那份个性</strong>，而不是为了迎合他人去隐瞒自己的喜好、感受或者真实想法。 无论是假期活动还是工作待遇等，都是如此。</p>
</li>
<li>
<p>“我想逃避”也是一种感受， 逃避是一种可以被理解的行为，但可能是一种不合时宜的行为，因为逃避更像是儿童时期做出的避险行为。<strong>自己需要意识到自己当前的行为模式是否是陈旧的</strong>，以及是否应当稍微找起来，尝试做点和儿童时期不一样的事情。</p>
</li>
</ul>
<h2><span id="ji-hua-he-xing-dong">计划和行动</span><a href="#ji-hua-he-xing-dong" class="header-anchor">#</a></h2>
<ul>
<li>
<p><strong>不要通过幻想，来给自己设定过于严苛的计划或者目的</strong>。 后果就是一旦发生阻碍或者完不成，挫败感会很重，以后做计划也会愈发纠结和犹豫。   因此尽量千万不要定“我xx月前必须怎么怎么”、“我必须每天xxx”，这样对意外情况容错性会降低，或者一次没成，后面就可能直接不再考虑 。</p>
</li>
<li>
<p><strong>想要做一件事， 核心不在于计划， 而在于是否开始逐步行动</strong>，这个行动是可以很小的，但只要你开了头，就相当于获取了这件事的入门门槛。 无论是写博客、跑步、学习、刷题，都是如此。不要把时间浪费在纠结上， 与其纠结，还不如先拆分好之后，随便挑一件做。</p>
<p>对于跑步，应该是“我想跑的时候就跑，这次简单跑个500米试试，并非要周三或者周五，只是想开个头而已”</p>
<p>例如博客，我想写的时候就写一下， 今天空，正好想做，就做了</p>
<p>例如去哪个地方，那就先提前做些小的准备，当你准备充分了，自然也就有选择的余地，而不是强行设置期限，导致自己陷入焦虑之中。</p>
</li>
<li>
<p>当很多想做的事情交叉重叠，<strong>先做影响最近的</strong>，例如洗澡、扫地、拖地，再做比较久远影响的。</p>
</li>
</ul>
<h2><span id="biao-da-nei-xin">表达内心</span><a href="#biao-da-nei-xin" class="header-anchor">#</a></h2>
<ul>
<li>尽可能真实地表达你的想法或者目的，并付诸以该想法为最首要的行为。以下是解释：</li>
</ul>
<ol>
<li>要避免为了掩盖想法，找别的理由去掩饰**</li>
</ol>
<p>例如你想送人笔记本电脑，却总是说不出”我想送你笔记本让你改善你的生活质量“这句话，特地找了  一堆理由，例如”我在公司看到一个便宜的内购“、”我多买了一台笔记本，不要了给你吧“， 却刻意掩埋 了自己的想法。</p>
<ol start="2">
<li>
<p>要避免因为过分考虑后果，导致对”行为“频繁地做调整，当你试图期望让该‘行为’能适配所有的后果时，你的行为本身就不太符合根本目的了</p>
<p>例如你要送人一台新的笔记本电脑，却总是考虑被拒绝的后果，于是换成了一台旧电脑并自己装好系统，以准备被拒绝时可以转交给父母使用。   这样会导致收到礼物的对方并不会觉得开心和尊重。</p>
</li>
</ol>
<p><strong>实际上被拒绝后的事，应该是一种预案，但不能改变行为本身，偏离核心目的</strong>，例如被拒绝了，那你和父母说等你回来再安装即可，或者提供其他的措施，而不是为了后果，直接改变了礼物本身，偏离了希望交好的目的。</p>
<h2><span id="he-ren-gou-tong-jue-de-bu-shu-fu-shi">和人沟通觉得不舒服时</span><a href="#he-ren-gou-tong-jue-de-bu-shu-fu-shi" class="header-anchor">#</a></h2>
<ol>
<li>切忌二极管思维， <strong>不能一味的赞同别人或者听从别人， 也不能一味地要求别人听从自己的一切要求</strong>。前者是懦弱儿童思维，后者是霸道父亲思维，都是不可取的</li>
<li>不能因为别人不满足我的要求，<strong>就立刻在内心觉得不爽或者不舒服</strong>， 在产生一定的情绪前，先思考对方为什么会这么说/这么做，搞清楚原因后，再决定是发泄情绪还是做应对措施，<strong>“内心默默不爽”对于事情解决是没有任何意义的</strong></li>
</ol>
<h2><span id="zuo-jue-ding-zuo-jue-ze">做决定/做抉择</span><a href="#zuo-jue-ding-zuo-jue-ze" class="header-anchor">#</a></h2>
<ol>
<li>不做决定本身就是一种选择， 这种选择会浪费你的时间和机会成本。</li>
<li>当实在决定不了，先尝试性在2个决定上做一些前置工作，至少保证事情在推进。</li>
<li></li>
</ol>
<h2><span id="gong-zuo-zhi-wai-de-xing-qu-chang-shi">工作之外的兴趣、尝试</span><a href="#gong-zuo-zhi-wai-de-xing-qu-chang-shi" class="header-anchor">#</a></h2>
<ul>
<li>
<p>工作之内的事情一般会有目标和绩效。工作之外的事情，则要注意不要带入工作思维。</p>
</li>
<li>
<p>避免定过于高的目标，例如一定要完成xxxx，一定要达到xxx， 而忽略了做这件事的意义。</p>
</li>
<li>
<p>不如先开始做，做一部分，如果真的不喜欢就不要勉强</p>
</li>
<li>
<p>注意并不是只有工作技能上的提升才叫提升或者成长， 个人心理、生理状态等进步都是一种提升，因此不要只看这一周工作上有没有学习或者进步之类的。  如果人的焦虑、恐惧症状比前几周有改善，或者开始关注到自己的感受和内心想法，那么也是一种进步。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/03/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-object-in-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-object-in-heap/" class="post-title-link" itemprop="url">java堆中分配对象的原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-03 23:07:31" itemprop="dateCreated datePublished" datetime="2022-05-03T23:07:31+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:50:20" itemprop="dateModified" datetime="2022-08-10T00:50:20+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/jvm%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">jvm原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/03/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-object-in-heap/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/03/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-object-in-heap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="java-dui-xiang-zai-dui-zhong-de-fen-pei-yuan-li">Java对象在堆中的分配原理</span><a href="#java-dui-xiang-zai-dui-zhong-de-fen-pei-yuan-li" class="header-anchor">#</a></h1>
<p>java对象new的一个过程<br>
<img src="/images/java-object-in-heap/7499e987f62965de977d2434a2587a1bcf9b3149.png" alt="7499e987f62965de977d2434a2587a1bcf9b3149"></p>
<hr>
<p>Q: 什么是TLAB?<br>
A:<br>
TLAB ——Thread Local Allocation Buffer<br>
线程本地分配缓冲区</p>
<p>如果没有启用 TLAB，多个并发执行的线程需要创建对象、申请分配内存的时候，有可能在 Java 堆的同一个位置申请，这时就需要对拟分配的内存区域进行加锁或者采用 CAS 等操作，保证这个区域只能分配给一个线程。冲突概率很大</p>
<p>启用了 TLAB 之后(-XX:+UseTLAB, 默认是开启的)，JVM 会针对每一个线程在 Java 堆中预留一个内存区域<br>
一旦某个区域确定划分给某个线程，之后该线程需要分配内存的时候，会优先在这片区域中申请。这个区域针对分配内存这个动作而言是该线程私有的，因此在分配的时候不用进行加锁等保护性的操作</p>
<hr>
<p>Q: TLAB给线程预分配空间的时候，如果多个线程竞争同一个预留空间冲突了怎么办？<br>
A:<br>
在预留这个动作发生的时候，需要进行加锁或者采用 CAS 等操作进行保护，避免多个线程预留同一个区域</p>
<hr>
<p>Q: 分配的时候，在TLAB区域里，怎么知道放在哪个位置呢？<br>
A:<br>
具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<p>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。<br>
对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</p>
<hr>
<p>java对象在内存上的分配：<br>
<img src="/images/java-object-in-heap/9624dbbc45d4b10ae636df5b0766b5cc5bcfbe25.png" alt="9624dbbc45d4b10ae636df5b0766b5cc5bcfbe25"></p>
<hr>
<p>Q: 对象的hashcode确定是创建对象的时候生成的？<br>
A:<br>
不对。采用延迟加载技术</p>
<hr>
<p>Q: 如何计算一个java对象大小？<br>
例如下面的person？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Xiaoming&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">married</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">birthday</span> <span class="operator">=</span> <span class="number">128902093242L</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sallary</span> <span class="operator">=</span> <span class="number">1200.00d</span>;</span><br><span class="line">	<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A:<br>
这里假设使用64位机器，采用指针压缩，则对象头的大小为：8(_mark)+4(_klass) = 12（如果没开启，k_class即对象引用地址占8个字节）</p>
<p>然后实例数据的大小为： 4(age)+4(name) + 8(birthday) + 8(sallary) + 2(tag) +  4(引用，开启指针压缩) +  1或4(married)  = 31 or 34</p>
<p>因此最终的对象本身大小为：12+31+5(padding) = 48 或者 12+ 34 + 2(padding) = 48</p>
<blockquote>
<p>PS1: 注意布尔值可能是1或者4，根据虚拟机规范不同有不同，4字节的话好处是CPU</p>
</blockquote>
<blockquote>
<p>PS2: 注意，指针压缩不仅仅影响对象头，还影响了对象内的引用大小。</p>
</blockquote>
<p>更详细的见<a target="_blank" rel="noopener" href="https://blog.csdn.net/yunqiinsight/article/details/80431831">如何计算Java对象所占内存的大小</a></p>
<hr>
<p>Q: 对象头里的markword到底是啥？<br>
A:<br>
markword根据锁标记的状态，里面存储的了不同的内容。<br>
<img src="/images/java-object-in-heap/ba9578e95096512cbd024da4b88b117e4a14e449.png" alt="ba9578e95096512cbd024da4b88b117e4a14e449"><br>
<img src="/images/java-object-in-heap/ff1ad3a49021dba3739e0c3cb66c2dd636ec242a.png" alt="ff1ad3a49021dba3739e0c3cb66c2dd636ec242a"><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26542493/article/details/90938070">java对象头 MarkWord</a></p>
<hr>
<p>Q: 哈希code 有锁的时候，hashcode又去哪了？<br>
A:<br>
identity_hashcode：31位的对象标识hashCode，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。</p>
<hr>
<p>Q: 对象内存字节为什么要按8字节对齐？<br>
A:<br>
对齐填充是底层CPU数据总线读取内存数据时的要求<br>
例如，通常CPU按照字单位读取，如果一个完整的数据体不需要对齐，那么在内存中存储时，其地址有极大可能横跨两个字<br>
例如某数据块地址未对齐，存储为1-4，而cpu按字读取，需要把0-3字块读取出来，再把4-7字块读出来，最后合并舍弃掉多余的部分。这种操作会很多很多，且很频繁<br>
但如果进行了对齐，则一次性即可取出目标数据，将会大大节省CPU资源。</p>
<p>另一种说法：</p>
<blockquote>
<blockquote>
<p>Scott oaks在书上给出的理由是：<br>
其实在JVM中（不管是32位的还是64位的），对象已经按8字节边界对齐了;对于大部分处理器，这种对齐方案都是最优的。所以使用压缩的oop并不会损失什么。如果JVM<br>
中的第一个对象保存到位置0，占用57字节，那下一个对象就要保存到位置64，浪费了7<br>
字节，无法再分配。<strong>这种内存取舍是值得的（而且不管是否使用压缩的oop，都是这样），因为在8字节对齐的位置，对象可以更快地访问</strong>。</p>
<p>不过这也是为什么JVM没有尝试模仿36位引用（可以访问64GB的内存）的原因。在那种情况下，对象就要在16字节的边界上对齐，在堆中保存压缩指针所节约的成本，就被为对齐对象而浪费的内存抵消了。<br>
** 8字节对齐，是为了效率的提升，以空间换时间的一种方案**。当然你还可以16字节对齐。但是8字节是最优选择。</p>
</blockquote>
</blockquote>
<hr>
<p>Q: jvm的指针压缩原理是什么？<br>
A:<br>
我们都知道java中的对象都是8字节对齐的，8字节对齐有一个特点就是总是加上1 000。 发现了吗， 所有对象的指针后三位总是0。这就是指针压缩的点。</p>
<p>压缩原理就是两句话：<br>
1：存储的时候，后三位抹除0.<br>
就变成：test1=00，test2=10<br>
2：使用的时候，后三位补0.</p>
<p>它的指针不再表示对象在内存中的精确位置，而是表示 偏移量 。这意味着 32 位的指针可以引用 40 亿个 对象 ， 而不是 40 亿个字节。最终， 也就是说堆内存增长到 32 GB 的物理内存，也可以用 32 位的指针表示。（4字节指针地址原先只能表示4个G的大小）</p>
<hr>
<p>Q: 指针压缩什么时候会失效？<br>
A:<br>
因为寄存器中2的32次方只能寻址到32g左右(不是准确的32g，有可能在31g就发生指压缩失效)<br>
所以当你的内存超过32g时，jvm就默认停用压缩指针，用64位寻址来操作，这样可以保证能寻址到你的所有内存，但这样所有的对象都会变大，实际上未开启开启后的比较，40g的对象存储个数比不上30g的存储个数</p>
<hr>
<p>Q: 为什么对象头里的kclass也会受指针压缩的影响？class实例不是存储在方法区里么？<br>
A:<br>
JDK1.6中Class实例在方法区<br>
JDK1.8之后， class实例本身就是一个对象，分配在java堆中。而class字节码加载后的各种细节内容则存储在永久代中。</p>
<p>HotSpot并不把永久代中的instanceKlass暴露给Java<br>
而会另外创建对应的class对象instanceOopDesc来表示java.lang.Class对象（即这个对象里不会包含class细节字节码的内容），并将后者称为前者的“Java镜像”， 对象头里的klass就是持有指向类oopDesc引用(_java_mirror便是该instanceKlass对Class对象的引用)；</p>
<hr>
<p>Q: 在方法栈中执行代码时，如何通过引用定位到堆里的对象？<br>
A:<br>
两种方式，通过句柄池，或者通过指针。如下图所示<br>
<img src="/images/java-object-in-heap/5d0f1b24e4b024123de4f669.png" alt="引用对象"></p>
<hr>
<p>Q: 句柄和指针的区别是什么？<br>
A:<br>
句柄池， 引用中的句柄地址不会发生改变引用变动时，只会变动句柄中数据指针的内存<br>
可以理解为，句柄池方式， 创建新对象后，句柄位置就定下来了。后面如果频繁修改引用， 只会修改句柄里的指针，但是本地变量表里寻找的位置都不会变化，因此不用经常跳到各种本地变量表去修改。</p>
<ul>
<li>频繁gc、修改引用的，用句柄池引用</li>
<li>频繁访问固定对象的，用指针引用</li>
</ul>
<hr>
<p>Q: 怎么确认用的是句柄引用还是指针引用？<br>
A:<br>
sun HotSpot用的指针引用，速度快<br>
访问方式，取决于虚拟机的实现。</p>
<hr>
<p>Q： 方法里创建基本类型的局部变量时， 为什么不把基本类型放堆中呢？<br>
A:<br>
因为其占用的空间一般是 1~8 个字节——需要空间比较少，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的。</p>
<p>可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据</p>
<hr>
<p>Q: 那我new出来的对象， 一定都在堆中吗？<br>
A:<br>
HotSpot虚拟机引入了JIT优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>
<hr>
<p>Q: 刚才new对象的过程，可能存在重排序吗？<br>
A:<br>
存在。<br>
①「JVM」为对象分配一块内存M。<br>
②在内存M上为对象进行初始化。<br>
③将内存M的地址复制给singleton变量。<br>
可以是「①②③」或者「①③②」。 这也导致了双重检查锁时，为什么有了sync还要加volatile。</p>
<p>但是另一种说法，是JDK高版本之后， 将这个new语句看成一个大号的volatile写，因此这个大号volatile写前后会有内存屏障，与volatile读隔离开来，因此虽然volatile读不知道大号volatile写的内部顺序，但是知道它的结果一定是执行完那三步的。<br>
因此重排序仍然存在，但是会特地限制其他对该对象的new的过程是有屏障的。</p>
<hr>
<p>Q: 上面的过程的指令码是什么样的？<br>
A:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: new           #16 // class jvm/fenixsoft/DynamicDispath$Man</span><br><span class="line">    3: dup   // 将栈顶复制一份再推进栈</span><br><span class="line">    4: invokespecial #18 // Method jvm/fenixsoft/DynamicDispach$Man.&quot;&lt;init&gt;&quot;:()V   调用初始化方法</span><br><span class="line">    7: astore_1  // 将引用赋值到局部变量表里</span><br></pre></td></tr></table></figure>
<p>那么为什么要进行备份呢？</p>
<p>一开始是new指令在堆上分配了内存并向操作数栈压入了指向这段内存的引用<br>
之后dup指令又备份了一份，那么操作数栈顶就有两个<br>
再后是调用invokespecial #18指令进行初始化，此时会消耗一个引用作为传给构造器的“this”参数， 注意这个指令会将栈顶的引用拿走，因此dup指令都是用于这种场景的，即栈顶的引用存在消耗。</p>
<p>那么还剩下一个引用，会被astore_1指令存储到局部变量表中，后面调用的代码会用到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/05/03/why-study-java-stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/why-study-java-stack/" class="post-title-link" itemprop="url">【反八股系列】一、为什么我们要学习java虚拟机栈的原理？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-03 19:15:36" itemprop="dateCreated datePublished" datetime="2022-05-03T19:15:36+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-04 15:15:59" itemprop="dateModified" datetime="2022-05-04T15:15:59+08:00">2022-05-04</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/03/why-study-java-stack/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/03/why-study-java-stack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>曾经的八股文：</p>
<p>xxx</p>
<p>现在的八股文：</p>
<p>xxx</p>
<p>为了找回对编程最初的乐趣</p>
<p>决定自制反八股系列的知识视频</p>
<p>本系列的三大宗旨：</p>
<p>拒绝死记硬背</p>
<p>拒绝管中窥豹</p>
<p>拒绝浅尝则止</p>
<hr>
<p>对于jvm的虚拟机内存结构，大家应该都能背会有“2个堆”、“2个栈”、“1个计数器” 这种内容，就像下面这张图一样。  其中java的栈是虚拟机指令执行的关键。</p>
<p>那么，为什么我们要学习背后的这个虚拟机栈呢？ 我的代码能跑起来不就了可以吗？</p>
<p>哦，是面试要用么？然而个人不希望这些内容成为新一代的“科技八股文”。</p>
<p>因此本系列希望先从为什么学习入手，再深入到更深层次的东西，，希望能带来的是长久的收获，而非短暂的记忆。</p>
<hr>
<p>为什么我们要学习背后的虚拟机栈。</p>
<p>首先，你debug的时候，你都不知道这个是什么东西，瞎猜可不行，你要知道暂停时现在是个请什么情况， IDE上的东西到底是什么，他们对程序运行又有什么影响</p>
<p>[debug图片]</p>
<p>其次，虚拟机栈的内容是很多重要知识的前置知识点。  垃圾收集的GC-ROOT与栈有关， JIT优化和栈有关。如果你不知道，那么在遇到相关知识点，只会产生“这是啥”、“这又是啥”的连锁反应， 就有可能陷入背诵八股文的折磨却不知所以然的地步。</p>
<p>最后，java虚拟机栈为我们生动展示了 一个小心的迷你的CPU执行逻辑。</p>
<p>对于很多没有学习过计算机底层原理（例如CSAPP这本书） 的人来说， 是完全不知道计算机是如何执行机器码指令的。 而java虚拟机栈可以更好理解 指令是如何运行的， 虽然这个指令不是真正的机器码执行， 而是jvm字节码指令。  但是通过字节码指令， 我们可以快速对应到java中常见的各种操作。</p>
<p>这对于很多入门时直奔删减改查的同学来说， 是不可多得的学习底层的机会。</p>
<p>另外数据结构里学习的栈的知识也会在这里得以应用。</p>
<hr>
<p>清楚了上述好处后，我们开始深入了解虚拟机栈的细节。</p>
<p>首先，栈帧是什么？</p>
<p>不需要去记忆概念，就记得我们调试时，框框里的每一行，就是一个栈帧。 可以看到除了栈顶的方法正在执行外， 其他行都仿佛静止了一般， 因此就像拍照时的一帧。</p>
<p>对于栈帧里有什么， 经典背诵4件套：</p>
<p>局部变量表，</p>
<p>操作数栈，</p>
<p>动态链接，</p>
<p>方法返回地址，</p>
<p>其实与上面这4样配合的，还有个虚拟机栈所使用的“程序计数器”，才共同实现了jvm指令的执行。</p>
<p>首先对局部变量表而言， 为什么要有这个东西？</p>
<p>5 4 3 2 1 .</p>
<p>因为我们声明的局部变量a、b、c等， 都需要有一个地方存放， 但局部变量只有这个方法中才会使用， 所以才会在栈帧中开辟局部连量表的空间。</p>
<p>那么，变量表有多大呢？</p>
<p>编译时指定定死了</p>
<p>为什么能定死？</p>
<p>因为编译器很聪明，通过分析代码，他就能知道到底这个方法要用几个变量。</p>
<p>为什么我们需要思考这个问题？因为我们要考虑我们写的代码，可能会带来多大的局部栈的消耗。</p>
<p>例如，我在一个for循环里反复定义同一个变量，那局部变量表是不是在无限增大？我是不是要提前加大栈的分配内存？</p>
<p>其实不需要， 因为编译器支持变量表的复用，  它会知道你在重复声明变量，所以实际字节码指令中，它会明确写下“这个变量继续放到前面那个槽”的指令，  从而覆盖使用了之前的槽。</p>
<p>你问我怎么分析的？ 请阅读《编译原理》。</p>
<p>然后操作数栈又是干什么的？ 如果要做a+b,我直接从变量表上取a的值和b的值，加起来不就好了？</p>
<p>直接让CPU取a和b的值拿去算完回来，不就好了？</p>
<p>那我如果是 a + b*c呢</p>
<p>b*c的值放哪里？</p>
<p>如果是a+b*(c+d)呢？</p>
<p>这时候如果你学习过数据结构里栈的应用 ，就会知道 模拟一个计算器，往往需要一个栈。</p>
<p>而操作数栈就是这个作用。</p>
<p>当你学习jvm指令时，就会看到有专门的指令就是取栈顶或者把值推送到栈顶的指令。</p>
<p>这样做加法的时候，也就不用关心变量的地址了，只要你把栈顶的值存好，我直接拿去加就行。</p>
<p>那么动态链接又是个什么玩意？</p>
<p>就这么说， 你怎么知道这个方法此时要做哪些动作？</p>
<p>肯定有一段代码区（即jvm指令），让我一条条执行对吧？</p>
<p>那么这个代码区放哪呢？我总需要知道一个地址， 因此，动态链接，就是这个方法代码的位置。</p>
<p>那干嘛叫动态链接这么抽象啊？</p>
<p>因为有的方法往往是等运行的时候才知道地址， 所以统一就叫做动态链接了，这就是未来会提到的java多态的核心本质而。</p>
<p>那么返回地址比较好理解，方法执行完成， 返回上一层方法执行的位置。</p>
<p>等等，这个地址是实际的地址吗？例如0x2313212这种？</p>
<p>应该是把，不然怎么叫地址？</p>
<p>但是我已经有动态链接标记的方法指令的起始位置了，你为什么还要整这么长？</p>
<p>哦，那就用偏移值就可以了！</p>
<p>那现在再看，程序计数器，代表的是什么</p>
<p>很显然和方法返回地址一样， 也是指令偏移值，  这样通过动态链接 + 计数器， 就能知道这个方法当前执行到什么位置了， 即使发生了线程切换或者方法返回， 都不用担心了~！</p>
<p>那么再深度扩展一下，根据以上理解，是否能清楚下面这个的原因代码的原因</p>
<p>当你知道远离后，你就不需要记忆这种情况，而是一想背后的实现，就能明白这么写是不对的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">   System.out.println(<span class="string">&quot;value : &quot;</span> + getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> i; </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        i++; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是在执行 finally 语句块之前，try 或者 catch 语句块会保留其返回值到本地变量表（Local Variable Table）中。待 subroutine 执行完毕之后，再恢复保留的返回值到操作数栈中，然后通过 return 或者 throw 语句将其返回给该方法的调用者（invoker）</p>
<p>因为你要处理finally块时， 操作数栈要腾出来给finally使用， 因此返回值不能放在这，所以整了个局部变量ret放进去， 执行完成返回来。</p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/74771.htm">https://www.jb51.net/article/74771.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/home/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/home/">1</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/home/page/5/">5</a><a class="extend next" rel="next" href="/home/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
