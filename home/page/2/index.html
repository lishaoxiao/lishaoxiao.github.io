<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="冲破黎明前的黑暗">
<meta property="og:url" content="http://breakdawncoder.com/home/page/2/index.html">
<meta property="og:site_name" content="冲破黎明前的黑暗">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/home/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>冲破黎明前的黑暗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冲破黎明前的黑暗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/" class="post-title-link" itemprop="url">第二阶段心理成长感悟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-01 23:35:22" itemprop="dateCreated datePublished" datetime="2022-08-01T23:35:22+08:00">2022-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:58:06" itemprop="dateModified" datetime="2022-08-10T00:58:06+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/01/%E9%9A%8F%E7%AC%94/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BF%83%E7%90%86%E6%88%90%E9%95%BF%E6%84%9F%E6%82%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me">思考追求工作高绩效的价值是什么</a></li>
</ul>
<!-- tocstop -->
</div> 
<h1><span id="si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me">思考追求工作高绩效的价值是什么</span><a href="#si-kao-zhui-qiu-gong-zuo-gao-ji-xiao-de-jie-zhi-shi-shi-me" class="header-anchor">#</a></h1>
<p>我是觉得在某个大公司做工作，就是有意义的吗？</p>
<p>做的项目影响的人数越多，我就越有价值吗？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/" class="post-title-link" itemprop="url">第304场周赛-897-4题（心态重要）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-01 22:12:42" itemprop="dateCreated datePublished" datetime="2022-08-01T22:12:42+08:00">2022-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-31 22:58:44" itemprop="dateModified" datetime="2022-07-31T22:58:44+08:00">2022-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/01/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659277621782.png" alt="1659277621782"></p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-qi-zong-jie">本期总结：</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>只记录一下对我而言比较有意义的题目</p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>永远保持冷静，不要激动，下次可以录屏，记录自己的心态和过程</li>
<li>图里有环的判断并不是走回自己，而是走到了重复走过的点</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">6132. 使数组中所有元素都等于零 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278338228.png" alt="1659278338228"></p>
<p>这题花了七分钟，不应该。</p>
<p>题目没看懂</p>
<p>**选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 **最小的 <strong>非零</strong> 元素</p>
<p>又要求最少操作数，那么只能是每次选nums中的最小即可,这里想复杂了，以为是选某个区间范围内的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(nums);</span><br><span class="line">        <span class="keyword">if</span> (min == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] -= min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            min = Math.min(nums[i], min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/">6133. 分组的最大数量 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278765664.png" alt="1659278765664"></p>
<p>脑筋急转弯啊这是</p>
<p>跟grades根本没关系</p>
<p>直接排序后，每次取1个、2个、3个即可</p>
<p>拿就是看这样增加到什么时候为止结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGroups</span><span class="params">(<span class="type">int</span>[] grades)</span> &#123;</span><br><span class="line">        <span class="comment">//Arrays.sort(grades);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> grades.length;</span><br><span class="line">        <span class="keyword">while</span> (len - (k+<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = len - (k+<span class="number">1</span>);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/">6134. 找到离给定两个节点最近的节点 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659278866526.png" alt="1659278866526"></p>
<p>这题思路其实也容易想：</p>
<p>先从node1一直往下遍历，直到遇到尽头或者环，记录每个点的距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dis[node1] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> edges[node1];</span><br><span class="line"><span class="keyword">while</span> (node != -<span class="number">1</span> &amp;&amp; dis[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">    dis[node] = d++;</span><br><span class="line">    node = edges[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后node2也一直往下走，遇到node1走过的点（通过dis是否为-1判断）则计算最小值和要选择的点。同时也要判断环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="number">0</span>;</span><br><span class="line">node = node2;</span><br><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[edges.length];</span><br><span class="line"><span class="keyword">while</span> (node!=-<span class="number">1</span> &amp;&amp; !vis[node]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[node] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.max(d, dis[node]) &lt; result) &#123;</span><br><span class="line">            result = Math.max(d, dis[node]);</span><br><span class="line">            select = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d++;</span><br><span class="line">    vis[node] = <span class="literal">true</span>;</span><br><span class="line">    node = edges[node];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是自己提前想漏了很多点</p>
<p>遗漏点1：环的判断并不是走回自己啊，而是走到了重复走过的点！</p>
<p>遗漏点2：要注意节点距离相同的情况，要选节点编号最小！</p>
<p>遗漏点3：冷静冷静，不要妄自生气，你及时没进200，也拿到了每日3题的积分了！</p>
<p>这种easy题做了40分钟还错了2次很不应该！</p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279307738.png" alt="1659279307738"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-cycle-in-a-graph/">6135. 图中的最长环 - 力扣（LeetCode）</a></p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279326269.png" alt="1659279326269"></p>
<p>大放水，欸，知道每个点不需要重复走， 这个思路就能处理了</p>
<p>但是要注意  ”碰到自己走过的点即成环了“ 和”碰到别人走过的点，不用再走“是有区别的，不能一起判断</p>
<p>所以我用了一个root来判断</p>
<p><img src="/images/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-897-4%E9%A2%98/1659279449222.png" alt="1659279449222"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88/" class="post-title-link" itemprop="url">22年8月刷题日记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 22:12:42" itemprop="dateCreated datePublished" datetime="2022-07-29T22:12:42+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-14 00:24:58" itemprop="dateModified" datetime="2022-08-14T00:24:58+08:00">2022-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">刷题日记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/29/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/22%E5%B9%B48%E6%9C%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="22-nian-8-yue-shua-ti-ri-ji">22年8月刷题日记</span><a href="#22-nian-8-yue-shua-ti-ri-ji" class="header-anchor">#</a></h1>
<p>[toc]</p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#2022-07-30">2022-07-30</a></li>
<li><a href="#2022-07-29">2022-07-29</a></li>
<li><a href="#2022-08-01">2022-08-01</a></li>
<li><a href="#2022-08-03">2022-08-03</a></li>
<li><a href="#2022-08-04">2022-08-04</a></li>
<li><a href="#2022-08-05">2022-08-05</a></li>
<li><a href="#2022-08-07">2022-08-07</a></li>
<li><a href="#2022-08-08">2022-08-08</a></li>
<li><a href="#2022-08-09">2022-08-09</a></li>
<li><a href="#2022-08-10">2022-08-10</a></li>
<li><a href="#2022-08-11">2022-08-11</a></li>
<li><a href="#2022-08-12">2022-08-12</a></li>
<li><a href="#2022-08-13">2022-08-13</a></li>
</ul>
<!-- tocstop -->
</div> 
<hr>
<h1><span id="2022-07-30">2022-07-30</span><a href="#2022-07-30" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列 - 力扣（LeetCode）</a></p>
<p>简单，题意理解了就好， 排列组合的数学应用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串 - 力扣（LeetCode）</a></p>
<p>简单，推导出贪心规律，从左到右只要符合平衡，就一定可以从更大的平衡串中拆掉</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数 - 力扣（LeetCode）</a></p>
<p>“111011011”这种二进制字符串如何快速转int整数？</p>
<p>可以用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(&quot;111011011&quot;, 2) </span><br></pre></td></tr></table></figure>
<p>2指代二进制</p>
<h1><span id="2022-07-29">2022-07-29</span><a href="#2022-07-29" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-square/">593. 有效的正方形 - 力扣（LeetCode）</a></p>
<p><strong>如何用4个点判断是否是一个正方形？</strong></p>
<ul>
<li>
<p>方法1： 设置顺时针点为1-&gt;2-&gt;3-&gt;4，然后根据边长相同、22边平行、勾股定理3者判断是否为正方形。</p>
<p>1-&gt;2-&gt;3-&gt;4点的判定先根据横坐标最小，再根据纵坐标最小。</p>
</li>
<li>
<p>方法二：正方形的任意3个点都是等边直角三角形，判断4次即可，注意额外加一个三角形中边的判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validSquare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b, <span class="type">int</span>[] c, <span class="type">int</span>[] d)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calc(a, b, c) &amp;&amp; calc(a, b, d) &amp;&amp; calc(a, c, d) &amp;&amp; calc(b, c, d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/furthest-building-you-can-reach/">1642. 可以到达的最远建筑 - 力扣（LeetCode）</a></p>
<p>简单贪心题。</p>
<p>注意PriorityQueue默认小顶堆</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/">1285. 找到连续区间的开始和结束数字 - 力扣（LeetCode）</a></p>
<ul>
<li>
<p>row_number() over() 指每一行在整个表分区中的序号</p>
</li>
<li>
<p>over()是窗口函数，不会做汇聚动作，因此行数不会发生变化。只会给出每一行所处分区的某个特定值（例如各分区的和 sum over(PARTITION  by xxx)）</p>
</li>
<li>
<p>id - <strong>row_number() over()</strong> diff   外层套一个group by diff可以用来求解连续区间的问题</p>
</li>
</ul>
<hr>
<h1><span id="2022-08-01">2022-08-01</span><a href="#2022-08-01" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合 - 力扣（LeetCode）</a></p>
<ul>
<li>dfs全排列搜索问题且要求不能重复，关键语句就是”预处理排序。选的时候前一位相同，则必须是连续选的情况，不可以前面的相同数字还没选，却选了自己“</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == nums[i] &amp;&amp; lastIndex != i-<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>list.remove(int) 就是按索引移除。  list.remove(object)是针对非int对象的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-plus-sign/">764. 最大加号标志 - 力扣（LeetCode）</a></p>
<ul>
<li>
<p>写了4个2重循环好麻烦，就是提前预处理好每个点的上下左右到最近0的距离即可</p>
</li>
<li>
<p>for (int y = 0, dis=0; y &lt; n;y++)    此时int等同于声明了dis，外层不可再声明dis了</p>
</li>
</ul>
<hr>
<h1><span id="2022-08-03">2022-08-03</span><a href="#2022-08-03" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">2265. 统计值等于子树平均值的节点数 - 力扣（LeetCode）</a></p>
<p>直接后序遍历即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p>
<p>翻转问题还是写一个reverse的简单方法会比较快，用stringBuilder不一定快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distribute-candies/">575. 分糖果 - 力扣（LeetCode）</a></p>
<p>集合应用，没啥好说的</p>
<h1><span id="2022-08-04">2022-08-04</span><a href="#2022-08-04" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/">1403. 非递增顺序的最小子序列 - 力扣（LeetCode）</a></p>
<p>排序即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计 - 力扣（LeetCode）</a></p>
<p>将出点和入点放入数组中，出点位置+seats， 入点位置-seats即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/print-foobar-alternately/">1115. 交替打印 FooBar - 力扣（LeetCode）</a></p>
<p>第一次做多线程的题目，还蛮有意思的</p>
<p>要求交替打印n次foo和bat</p>
<p>其实可以用资源的角度来理解</p>
<p>即需要打印foo时，说明生产了一个foo令牌，才可以打印</p>
<p>如果要打印bar，则要求有bar令牌才可以。</p>
<p>那么就很容易想到用2个阻塞队列或者2个信号量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; fooSync = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingDeque&lt;Integer&gt; barSync = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fooSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fooSync.take();</span><br><span class="line">            printFoo.run();</span><br><span class="line">            barSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            barSync.take();</span><br><span class="line">            printBar.run();</span><br><span class="line">            fooSync.put(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以用一个boolean布尔值来表示此时打印foo还是打印bar，然后利用等待-唤醒机制。</p>
<p>如果用java自带语法，可以是wait和notify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">2</span>*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                 printFoo.run();</span><br><span class="line">                 count--;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// printBar.run() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                count--;</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用JUC，则用Condition即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FooBar</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                condition.signal();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="2022-08-05">2022-08-05</span><a href="#2022-08-05" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-way-to-form-string/">1055. 形成字符串的最短路径 - 力扣（LeetCode）</a></p>
<p>2个字符串长度最多1000，双指针即可，没啥难的</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cyJERH/">剑指 Offer II 092. 翻转字符 - 力扣（LeetCode）</a></p>
<p>提前预处理往左看的1的个数和往右看的0的个数</p>
<p>然后再遍历一次，每次把左边翻0，右边翻1，因为预处理过了所以可以马上得到答案</p>
<p>但是这个做法比较消耗2个O(n)的空间</p>
<p>用动态规划可以节省很多空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFlipsMonoIncr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">// dp0代表位置为i时变成000..00所需翻转的数量</span></span><br><span class="line">    <span class="comment">// dp1代表位置为i时变成0001111所需翻转的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>, dp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last0</span> <span class="operator">=</span> dp0;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last1</span> <span class="operator">=</span> dp1;</span><br><span class="line">        dp0 = last0 + (c==<span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        dp1 = (c==<span class="string">&#x27;1&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>) + Math.min(last0, last1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp0, dp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindrome/">409. 最长回文串 - 力扣（LeetCode）</a></p>
<p>就是数量统计题而已</p>
<hr>
<h1><span id="2022-08-07">2022-08-07</span><a href="#2022-08-07" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/exclusive-time-of-functions/submissions/">636. 函数的独占时间 - 力扣（LeetCode）</a></p>
<p>栈的应用题，start和end等同于左括号和右括号</p>
<p>注意用int[]数组来简化新类的定义操作，注意每次end出栈后，要把这段程序占用的总时间加到栈顶</p>
<hr>
<h1><span id="2022-08-08">2022-08-08</span><a href="#2022-08-08" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-gold/">1219. 黄金矿工 - 力扣（LeetCode）</a></p>
<p>提示dfs最大深度为25，则认为可以直接做带vis访问标记的dfs且不需要做记忆化结果。</p>
<p>另外dfs时也不要忘记对初始点的vis处理</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/submissions/">1365. 有多少小于当前数字的数字 - 力扣（LeetCode）</a></p>
<p>虽然是简单题，数量级别只有500，但还是考虑写了一下最快性能，直接按值做键处理，就能知道比每个值小的数量了，然后再分别设置。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/special-binary-string/">761. 特殊的二进制序列 - 力扣（LeetCode）</a></p>
<p>这题没做出来，直接看答案了</p>
<p>0和1的数量相等  +  任意前缀1数量大于0，  类似于括号匹配</p>
<p>要我们调整括号对使得字典序尽可能大</p>
<p>这样就很容易想到递归了，即最外层括号可以不管， 然后只对内层做处理， 内层找到每一个括号对，然后按字典序排序。</p>
<ul>
<li>
<p>字符串list快速拼接：list.stream().collect(Collectors.joining());</p>
</li>
<li>
<p>s.subString(a,b)中b是开区间</p>
</li>
</ul>
<h1><span id="2022-08-09">2022-08-09</span><a href="#2022-08-09" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/">1413. 逐步求和得到正数的最小值 - 力扣（LeetCode）</a></p>
<p>遍历求和，求中间sum距离1的最大差值即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-in-binary-tree/">1367. 二叉树中的列表 - 力扣（LeetCode）</a></p>
<p>O(二叉树节点*链表节点)的复杂度符合要求</p>
<p>遍历每个点为起点，然后往下搜索判断能否找到即可，还是挺有意思的递归应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        nodes.add(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, List&lt;Integer&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkToDown(node, nodes, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(node.left, nodes)  ||   dfs(node.right, nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">checkToDown</span><span class="params">(TreeNode node, List&lt;Integer&gt; nodes, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nodes.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val != nodes.get(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> checkToDown(node.left, nodes, index+<span class="number">1</span>) || checkToDown(node.right, nodes, index+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7WHec2/">剑指 Offer II 077. 链表排序 - 力扣（LeetCode）</a></p>
<p>要求在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序</p>
<p>那所有排序方法里，只有递归排序可以实现了</p>
<p>而且得是从下往上递归</p>
<p>先11合并，再22合并，再44合并。</p>
<p>链表归并排序处理的几个坑：</p>
<ol>
<li>头节点可能变更的话，最好提前创建一个dummy头节点，这样dummy头节点.next就是新节点了</li>
<li>注意记录下一个排序序列的起始节点，用于确认是否第二个序列到末尾结束了。</li>
<li>还要记录上次排序序列的末尾节点， 用于排序后更新  上次末尾节点.next</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">listLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            listLen++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要总是改变头节点的情况下，最好定义一个空头节点用来更新头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">emptyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        emptyHead.next = head;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; listLen) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> emptyHead;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> emptyHead.next;</span><br><span class="line">            <span class="keyword">while</span>(head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> head1;</span><br><span class="line">                <span class="comment">// 走过len步，找到第二个比较序列的头部</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; head2 != <span class="literal">null</span>;i++) &#123;</span><br><span class="line">                    head2 = head2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找不到第二个序列头部了，则不用比较直接结束这次排序</span></span><br><span class="line">                <span class="keyword">if</span> (head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找一下下一次排序序列的开始节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">nextSortStartNode</span> <span class="operator">=</span> head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len &amp;&amp; nextSortStartNode != <span class="literal">null</span>;i++) &#123;</span><br><span class="line">                    nextSortStartNode = nextSortStartNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 合并，并更新新合并序列的末尾节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">newSortHead</span> <span class="operator">=</span> sortBatch(head1, head2, nextSortStartNode);</span><br><span class="line">                <span class="comment">// 更新头节点</span></span><br><span class="line">                preNode.next = newSortHead;</span><br><span class="line">                <span class="comment">// 定位末尾节点</span></span><br><span class="line">                <span class="keyword">while</span>(preNode.next != nextSortStartNode) &#123;</span><br><span class="line">                    preNode = preNode.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                head1 = nextSortStartNode;</span><br><span class="line">            &#125;</span><br><span class="line">            len*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emptyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode <span class="title function_">sortBatch</span><span class="params">(ListNode head1, ListNode head2, ListNode nextNode)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> head3;</span><br><span class="line">        <span class="keyword">while</span>(node1 != head2 || node2 != nextNode) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> node1 != head2 ? node1.val : Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> node2 != nextNode ? node2.val : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">                node3.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node3.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node3 = node3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node3.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> head3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1><span id="2022-08-10">2022-08-10</span><a href="#2022-08-10" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">1253. 重构 2 行二进制矩阵 - 力扣（LeetCode）</a></p>
<p>还是蛮容易推导的一个数组题，先处理掉所有0和2的情况</p>
<p>再处理1的情况，先把1都分配给上边，上边不够之后再分配给下边，最后检查是否清零即可。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-minimum-value/">1102. 得分最高的路径 - 力扣（LeetCode）</a></p>
<p>很有意思的搜索题，我想到了bfs，且这个bfs是支持刷新点的bfs。先优先按最大的走</p>
<p>如果发现当前点被人走过，但是自己是比他优（不能相等），则可以刷新对方自己继续走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已经有人走过，且自己不能刷新最好记录，则没必要走了，别人已经在走了</span></span><br><span class="line"><span class="keyword">if</span> (gMin[ny][nx] != Integer.MIN_VALUE &amp;&amp; gMin[ny][nx] &gt;= Math.min(grid[ny][nx], lastMin)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">gMin[ny][nx] = Math.min(grid[ny][nx], lastMin);</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ny, nx, gMin[ny][nx]&#125;);</span><br></pre></td></tr></table></figure>
<p>当然看答案还有dfs+二分， 即确定目标最小值之后， dfs搜索最多10000次。</p>
<p>复杂度O(10000 * (log2(10^9)))</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/UHnkqh/">剑指 Offer II 024. 反转链表 - 力扣（LeetCode）</a></p>
<p>用递归做比较有趣</p>
<hr>
<h1><span id="2022-08-11">2022-08-11</span><a href="#2022-08-11" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-the-lonely-nodes/">1469. 寻找所有的独生节点</a></p>
<p>直接递归判断，简单</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sparse-array-search-lcci/">面试题 10.05. 稀疏数组搜索 - 力扣（LeetCode）</a></p>
<p>二分搜索，但我还是遍历了一遍先过滤空字符串了。导致性能是1ms</p>
<p>但差距不大是因为那些人也要定位后在0上去走，消耗不会差别太大。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串 - 力扣（LeetCode）</a></p>
<p>很简单的滑动窗口</p>
<ol>
<li>第一波做出来性能20ms，不是最佳。因为用了Stream去判断是否有重复</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">int</span>[] counts)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(counts).noneMatch(c -&gt; c &gt;= <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>去掉Stream改用简单for循环，性能就到 5 ms 了</p>
</li>
<li>
<p>去掉k&gt;26的判断，提升到4ms</p>
</li>
<li>
<p>避免每次26次判断，用repeatCount值来记录，这样每次最多判断2次，结果还是4ms</p>
<p><img src="/images/22%E5%B9%B48%E6%9C%88/1660233587305.png" alt="1660233587305"></p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reformat-the-string/">1417. 重新格式化字符串</a></p>
<p>一般那种要你交叉放数字的，都可能有一种改进点是看你能否空间复杂度为O(1)（不包含结果输出空间）</p>
<p>这就需要原地算法，双指针进行交换</p>
<hr>
<h1><span id="2022-08-12">2022-08-12</span><a href="#2022-08-12" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/">1282. 用户分组 - 力扣（LeetCode）</a></p>
<p>按数量建哈希表，每个数量对应一个列表，列表满了就放入结果中并重置，很简单</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数 - 力扣（LeetCode）</a></p>
<p>只能取左右两边，那么等同于滑动窗口，只不过是反着求中间的滑动窗口最小值</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或 - 力扣（LeetCode）</a></p>
<p>很有意思，要求 <code>nums[i] XOR nums[j]</code> 的最大运算 结果</p>
<p>想了半天终于想起来有一个字典树这玩意，一开始觉得麻烦，后来还是写了 ，答案也有这个思路，很棒</p>
<p>只不过自己得记住，要先在字典树中试图求解最大运算结果，  求解完成后，才能把自己再插入字典树中</p>
<hr>
<h1><span id="2022-08-13">2022-08-13</span><a href="#2022-08-13" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/goal-parser-interpretation/">1678. 设计 Goal 解析器 - 力扣（LeetCode）</a></p>
<p>直接取临时字符串然后判断即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/">1874. 两个数组的最小乘积和 - 力扣（LeetCode）</a></p>
<p>直接排序后第一个数组的最大乘第二个数组的最小，依次处理即可，很简单，虽然我不知道怎么证明 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II - 力扣（LeetCode）</a></p>
<p>一次就AC了， 想到了动态规划</p>
<p>每次求出左边的最大值</p>
<p>然后看一下自己当前位置往左边遍历时，选取那个左边位置作为一块，能否满足要求，能满足要求则就看判断当前最大分割块即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (左边最大值 小于 我当前位置从右往左遍历时的最小值， 说明可以分割)&#123;</span><br><span class="line">    dp[当前位置] = Math.max(dp[左边界-<span class="number">1</span>] + <span class="number">1</span>  , dp[当前位置]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">数据库锁、事务、隔离级别超详细原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-28 23:01:11 / 修改时间：23:09:22" itemprop="dateCreated datePublished" datetime="2022-07-28T23:01:11+08:00">2022-07-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/28/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>将下面这些数据库的概念单独拿出来时，相信很多人都有了解或者记忆过，但是将这些概念全部串联在一起时，可能就会很混乱。<br>
我这里举个例子：</p>
<ul>
<li>排他锁、共享锁</li>
<li>行锁、表锁、意向锁、间隙锁、next-key锁</li>
<li>悲观锁、乐观锁</li>
<li>两阶段锁协议</li>
<li>LCBB锁并发控制协议、MVCC多版本控制协议</li>
<li>脏读、不可重复读、幻读</li>
<li>RU\RC\RR\SE隔离级别<br>
然后自己问自己一个问题：</li>
</ul>
<ol>
<li>这一堆锁的关联关系究竟是什么？</li>
<li>各隔离级别究竟是怎么用各种锁+MVCC来解决事务读问题的？</li>
</ol>
<hr>
<p>首先，我们完全不考虑数据库引擎、隔离级别设置之类的，就当作你用一个超简陋的儿科级别数据库来存放和更新数据。</p>
<p>假设你的商城服务正好在<strong>同时执行</strong>如下的2种事情</p>
<ul>
<li>张三给穷光蛋李四转账100元。</li>
<li>李四尝试下单购买100元的衣服</li>
</ul>
<p>李四在最开始余额只有0元钱。<br>
注意因为是同时执行，在没有做任何保护的情况下，就可能会出现下图这样的情况<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463857433006958-1659020780284.png" alt="image.png"></p>
<p>可以看到李四明明没有钱，却扣费了，变成了很奇怪的-100元。</p>
<hr>
<p><strong>Q: 那这个有问题的读过程叫什么？</strong><br>
A: 这个过程就叫做<strong>脏读</strong>。  即更新回退的时，另一个事务读到了脏数据，判断失误，导致做了错误的处理。<br>
<strong>根本原因是2个事务都是先查后扣，却没有提前保护的形式</strong></p>
<hr>
<p>Q: 在不修改数据库隔离级别的情况下， 我们可以如何用sql语句手动解决这个脏读？<br>
A: 那很显然就是加锁对事务过程做提前保护， 不让B去判断和扣费。<br>
sql语句里有个 ”for update“ 语法， 会手动锁住李四那一行，在调用commit后释放<br>
具体见下面绿色的标注部分：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463870583057788-1659020780291.png" alt="image.png"></p>
<hr>
<p><strong>Q: 刚才看到”锁住李四这一行“， 那么这个就叫行级锁。什么情况下会变成锁住整个表？</strong><br>
A:<br>
name ='李四’这句话， 如果name是索引列的话，就会加行锁<br>
如果不是索引列， 就会变成表锁。<br>
换言之， <strong>行锁的本质是在索引节点上加锁</strong><br>
如果无法在索引节点上加锁，那就会直接变成整张表的锁，代价就会很大。</p>
<p>另外表锁也可以单独用lock table的语法手动加锁</p>
<hr>
<p><strong>Q:  如果一个事务A申请了行锁，锁住某一行， 另一个事务B申请了表锁，那B会被阻塞吗？</strong><br>
A:<br>
B事务既然申请表锁，说明可能会用到A中的每一行。<br>
B申请的流程可以是下面这样：</p>
<ol>
<li>判断表是否已被其他事务用表锁锁表</li>
<li>判断表中的每一行是否已被行锁锁住。<br>
但2这一步也太耗时了。<br>
因此A申请行锁前，会优先申请一个意向锁，再申请行锁。<br>
然后B申请时，第2步改成判断意向锁即可，有意向锁就阻塞。</li>
</ol>
<p>简单点说， 意向锁就是行锁操作用来阻塞表锁用的。 但行锁和行锁之间不会互相阻塞，除非行有冲突。</p>
<hr>
<p>刚才看到的for update会限制其他并行事务的所有读写操作，而且是2个事务上都加了”for update“。<br>
那么这个锁就叫做”排他锁“， 属于非常强势的锁， 相当于其他读写操作马上全部拦住了。</p>
<p>这里使用排他锁来解决脏读的原因是因为后面有<strong>查询余额+扣余额</strong>的代码，写这段代码的人必须做提前保护，<strong>以避免自己读到一个可能被修改的数据，导致判断和修改失误</strong>。</p>
<hr>
<p>和排他锁对应的是“共享锁”，也就是熟知的读写锁。<br>
可以让多个事务同时读，但是不允许修改 。<br>
手动加共享锁的方式:把for update改成  lock in share mode即可</p>
<p><strong>Q: 那么什么时候使用共享锁比排他锁要好呢？</strong><br>
A:<br>
可以看下面的例子：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463921737079966-1659020780298.png" alt="image.png"></p>
<p>可以看到没有查自身+更新自身的操作， 仅仅是查+更新其他表，表之间也互不关联，对余额的实时性也不是要求太高。</p>
<ul>
<li>如果都加排他锁，各种select操作就会很慢。</li>
<li>但如果不加共享锁， T6这边删除时，就可能产生冗余数据，所以还是得加锁。</li>
</ul>
<hr>
<p><strong>Q: 那我加的共享锁（S锁）和排他锁（X)什么时候释放呢？是每次执行完update马上释放吗？</strong><br>
A:<br>
这里就涉及了“两阶段锁”协议。</p>
<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
<p>说人话， 就是在事务中需要加锁时再加锁， 直到commit完一次性解锁。</p>
<p>为什么要两阶段锁，看到的一句话是<br>
<strong>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</strong></p>
<hr>
<p><strong>Q: 两阶段锁协议可以避免死锁吗？</strong><br>
A:<br>
不能避免，但是可以通过死锁检测算法进行事务解除。</p>
<hr>
<p>重新回到张三李四转账+下单的场景上来。<br>
for update这种锁，其实也是一种“悲观锁” ，加锁解锁比较耗时， 默认经常发生竞争。<br>
但如果我的转账和下单过程要求非常快，每次只有几毫秒，那加悲观锁成本就太大了<br>
这时候就可以手动使用乐观锁， 需要你自己在余额表里增加version列，增加后如下所示：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646463991504080949-1659020780303.png" alt="image.png"></p>
<p>这样就不需要特地加锁了，每次循环判断即可，前提是冲突发生概率比较低，阻塞时间比较短。</p>
<hr>
<p>刚才一个小小的脏读，就已经解决了下面3个问题</p>
<ul>
<li>排他锁和共享锁的区别：前者是拒绝所有读写 ， 后者是允许并发读拒绝写</li>
<li>行锁和表锁的区别： 前者是对单行加锁 ， 后者是对整表加锁，  区别是 是否涉及索引</li>
<li>悲观锁和乐观锁的区别：  前者主动用数据库自带的锁， 后者自己添加version版本号<br>
外加一个两阶段锁协议</li>
</ul>
<hr>
<p>继续回到脏读问题， 前面我们学习的所有概念，都是和数据库自身隔离级别无关，使用数据库的锁语法或者version版本号来避免。</p>
<p>但数据库发展这么强大，怎么可能需要我们频繁自己写这种复杂逻辑，于是数据库诞生了隔离级别设置。</p>
<p>前面会发生脏读的隔离级别， 叫做RU（read uncommited)<br>
即RU级别时， 我可以在别的事务没完全commit好时就读到数据。</p>
<hr>
<p><strong>Q: 先来个小问题，RU级别没有任何锁，对吗？</strong><br>
A:<br>
错误， RU级别做update等增删改操作时，仍然会默认在事务更新操作中增加排他锁，避免update冲突。<br>
切记脏读的发生原因，是查询+更新+回滚时没加锁导致其他查询操作出现失误判断。<br>
即查询这块可能读到没提交的数据，导致错误，而不是更新的并发问题。</p>
<hr>
<p><strong>Q: 当我们的数据库被设置成RC级别（Read commited）时， 可以解决脏读， 那么背后是怎么解决的呢？</strong><br>
A:<br>
业界有两种方式</p>
<ul>
<li>LBCC基于锁的并发控制（Lock-Based Concurrency Control)）</li>
<li>MVCC基于多版本的并发控制协议(Multi-Version Concurrency Control)</li>
</ul>
<p>LBCC其实就是类似前面手动用悲观锁的方式， 事务操作中查询时默认试图加锁，因此就可能被update的排他锁阻塞住，避免了脏读。</p>
<p>但代价就是效率很低。很多场景下，select的次数是远大于update的。</p>
<p>所以InnoDb 基于乐观锁的概念， 想了一个MVCC，自己在事务的背后实现了一套类似乐观锁的机制来处理这种情况。 确保了尽可能不在读操作上加锁， 排他锁只对更新操作生效。</p>
<hr>
<p><strong>Q: MVCC究竟是怎么做的呢？</strong><br>
A:<br>
简单来说，就是默认给每个数据行加了一个版本号列TRX_ID和回滚版本链ROLL_BT，具体可以看《高性能mysql》书里的这段描述：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464034268062917-1659020780312.png" alt="image.png"></p>
<p>简而言之</p>
<ul>
<li>查的时候，只查当前事务之前的记录，或者回滚版本比当前大的已删记录。</li>
<li>增的时候，加新版本的记录</li>
<li>删的时候，把老记录标记上回滚版本</li>
<li>改的时候，本质上是加新记录， 同时把老记录标上回滚版本</li>
</ul>
<hr>
<p><strong>Q: MVCC机制下， 什么是快照读，什么是当前读？</strong><br>
A:</p>
<ul>
<li>快照读：对于select读操作，统一默认不加锁，使用历史版本数据。</li>
<li>当前读：对于insert、update、delete操作，仍然需要加X锁，因为涉及了数据变更，必须使用最新数据进行修改</li>
</ul>
<hr>
<p><strong>Q: 那么回到刚才的脏读问题，  MVCC究竟是怎么在读不加锁的情况下， 解决脏读的？</strong><br>
A:<br>
首先，每次select都不用任何锁， 每次都是快照读，不会阻塞，因此会变成下面这样：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464042249047653-1659020780329.png" alt="image.png"></p>
<p>总结这个图，就是</p>
<ol>
<li>每次读时，会生成一个readView，用来记录当前还没提交的事务版本号。</li>
<li>根据自己事务的版本号version，去寻找小于自己当前版本且不在readView集合中的记录。</li>
</ol>
<p>这样的话就保证了读的数据必须是已经完成提交的，是不是很简单？</p>
<hr>
<p><strong>Q: 如果事务B中不做余额判断，支持直接赊账+扣费， 那是不是会导致先扣费，然后回滚成0这样的情况？</strong><br>
A:<br>
不会。<br>
上面提过， MVCC中更新操作都是“当前读”，仍然需要<strong>加X锁</strong>， 且因为涉及了数据变更，必须使用<strong>最新数据版本</strong>进行修改</p>
<p>换言之， update等操作， 还是会加锁，且用最新版本更新，避免了脏更新的问题，如下：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464053974009576-1659020780335.png" alt="image.png"></p>
<hr>
<p><strong>Q: 上面这个过程有什么隐患</strong><br>
A:<br>
如果1个事务中连续读2次余额，可能有“不可重复读”的风险，即前后读的数据发生了不一致<br>
如下所示<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464111781086895-1659020780344.png" alt="image.png"></p>
<p>因此RC隔离级别无法解决 “不可重复读的问题”</p>
<hr>
<p><strong>Q: RR（可重复读，Repeat Read)的隔离级别又是怎么解决上面这个问题的？</strong><br>
A:<br>
本质上就是readView生成时的区别<br>
上面RC不可重复读的图中可以看到，每次读时，都取了最新的readView。 这可能导致事务A提交后， 事务B观察到的readView集合发生了变化。</p>
<p>因此RR机制改变了readView的生成方式， 每次读时只使用事务B最开始拿到的那个readView，这样永远就只取老的数据了。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464120144079067-1659020780350.png" alt="image.png"></p>
<hr>
<p><strong>Q: 那读问题中的幻读又是什么？</strong><br>
A:<br>
刚才的”不可重复读“，是一个事务中查询2次结果，<strong>发现值对不上</strong>。<br>
而”幻读“，是指一个事务中查询2批结果，发现这2批<strong>数量对不上</strong>，就好象发生了幻觉。<br>
就像下图所示展示：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464126365033284-1659020780356.png" alt="image.png"></p>
<hr>
<p><strong>Q: RR隔离级别中的MVCC机制可以解决上面的问题吗？</strong><br>
A:<br>
可以解决。<br>
通过查询的快照读，能够保证只查询到同一批数据。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464132401059589-1659020780360.png" alt="image.png"></p>
<hr>
<p><strong>Q: 那如果像下面这样， 事务A连续做两次更新呢，单纯靠MVCC能避免更新操作的幻读么？</strong><br>
A:<br>
如果<strong>只依靠MVCC</strong>，那就无法避免了， 因为update操作是”当前读“，每次取最新版本做更新， 这会导致update中的读操作出现幻读，前后更新的记录数量不一样了。<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464140021048467-1659020780364.png" alt="image.png"></p>
<hr>
<p><strong>Q: 那数据库怎么处理这种2次updete中间做insert的幻读情况呢？</strong><br>
A:<br>
之前有了解到， update过程仍然会加锁，</p>
<p>RR级别会启用一个叫”间隙锁“（Gap锁）的玩意，专门来防这样情况。<br>
即调用 update xxx where name ='李四’时， 不仅仅在李四的行上加锁，  更会在中间所有行的间隙、左右边界的两边，加上一个gap间隙锁，就像下面这个图一样：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464152390001303-1659020780369.png" alt="image.png"></p>
<p>可以看到，订单D的插入过程被update过程的间隙锁拦住了，于是无法插入，置到事务结束才会释放。<br>
因此事务中两次update之间的幻读是可以避免的，也能。</p>
<hr>
<p><strong>Q: 那行锁、间隙锁、next-key锁是什么区别？</strong><br>
A:<br>
行锁就是单个行（单个索引节点）加锁<br>
间隙锁就是在行（索引节点之间）加锁<br>
next-key就是“行锁+间隙锁”，一起使用。</p>
<hr>
<p><strong>Q: 如果name这个字段不是索引，而是普通字段，那间隙锁会怎么加？</strong><br>
A:<br>
那就会给整个表的所有间隙都加上锁！<br>
因为数据库无法确认到底是哪个范围，所以干脆全加上。<br>
这就会导致整表锁住，性能很差。</p>
<hr>
<p><strong>Q: 那是不是只要name是索引，就不会给整个表全加间隙锁了？</strong><br>
A:<br>
不对， 如果where条件写的有问题，不符合最左匹配原则，那也会导致索引失效， 以至于给整个表加锁。</p>
<hr>
<p><strong>Q:  刚才看到说RR可以解决2次select之间的幻读， 也能解决2次update之间的幻读， 那为什么很多资料里，仍然说RR不能解决幻读？</strong><br>
A:<br>
这个问题我也是翻了好多资料， 终于找到了一个合理的解释。<br>
看下面这个场景：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464161376010263-1659020780370.png" alt="image.png"></p>
<p>发现什么区别没，  事务B的insert操作，发生在了事务A的update之前。因此事务B的insert操作没有被间隙锁阻塞。</p>
<p>而update用的是当前读， 于是更新的数量和 最初select的数量匹配不上了。</p>
<p>Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读，所以这个场景下，算出现幻读了。</p>
<p>这也就是下面这个图的来源：<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86/1646464168471063981-1659020780375.png" alt="image.png"></p>
<hr>
<p><strong>Q: 那串行化serializable隔离级别，为什么就能避免幻读了？</strong><br>
A:<br>
Se级别时，会从MVCC并发控制退化为基于锁的并发控制（LCBB）。<br>
不区别快照读和当前读<br>
所有的读操作都是当前读，读加读锁(S锁)，写加写锁(X锁)。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</p>
<p>这就是我们文章最开头手动加锁的那个过程了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/" class="post-title-link" itemprop="url">第303场周赛-463名-4题（pair类、var特性、双指针而不是二分）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-24 22:12:42" itemprop="dateCreated datePublished" datetime="2022-07-24T22:12:42+08:00">2022-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 00:22:32" itemprop="dateModified" datetime="2022-07-26T00:22:32+08:00">2022-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/24/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-qi-zong-jie">本期总结：</a></li>
<li><a href="#2352-xiang-deng-xing-lie-dui-https-leetcode-cn-problems-equal-row-and-column-pairs">2352. 相等行列对</a></li>
<li><a href="#2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode-https-leetcode-cn-problems-design-a-food-rating-system">2353. 设计食物评分系统 - 力扣（LeetCode）</a></li>
<li><a href="#2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode-https-leetcode-cn-problems-number-of-excellent-pairs">2354. 优质数对的数目 - 力扣（LeetCode）</a></li>
</ul>
<!-- tocstop -->
</div> 
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658763277173.png" alt="1658763277173"></p>
<p>只记录一下对我而言比较有意义的题目</p>
<h2><span id="ben-qi-zong-jie">本期总结：</span><a href="#ben-qi-zong-jie" class="header-anchor">#</a></h2>
<ol>
<li>考虑用Pair包装而不是设计class实体类</li>
<li>var特性可以简化变量名的打印</li>
<li>双点有序(&gt;k)等问题，优先考虑用双指针而不是二分， 先确定固定哪个点，再看怎么移动，最多就4种情况。</li>
</ol>
<h2><span id="2352-xiang-deng-xing-lie-dui"></span><a href="#2352-xiang-deng-xing-lie-dui" class="header-anchor">#</a></h2>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658763341991.png" alt="1658763341991"></p>
<p>看着很简单啊，我的想法是直接对每一行搞成一个字符串， 然后做成hasMap，记录这个字符串出现的次数</p>
<p>在拿列去map里匹配即可</p>
<p>结果忘记了数字的范围是1-10^9， 并非0-9，不能直接拼，还得加逗号。痛失五分钟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">equalPairs</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ylen</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xlen</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        String[] rows = <span class="keyword">new</span> <span class="title class_">String</span>[ylen];</span><br><span class="line">        String[] cols = <span class="keyword">new</span> <span class="title class_">String</span>[xlen];</span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">                sb.append(grid[y][x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s)) &#123;</span><br><span class="line">                map.put(s, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(s).add(y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen;x++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; ylen;y++) &#123;</span><br><span class="line">                sb.append(grid[y][x]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">                count += map.get(s).size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外java处理字符串和map问题确实比python要麻烦，如果要冲速度，我是不是得学一下python？</p>
<p>题解里的python，可以快速转数量统计的map</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalPairs</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(cnt[col] <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">zip</span>(*grid))</span><br></pre></td></tr></table></figure>
<h2><span id="2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode"></span><a href="#2353-she-ji-shi-wu-ping-fen-xi-tong-li-kou-leetcode" class="header-anchor">#</a></h2>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764007681.png" alt="1658764007681"></p>
<p>很明显就是一个会更新的优先队列集合</p>
<p>需要用优先队列加一个检查更新的map实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">            String name;</span><br><span class="line">            String cuisines;</span><br><span class="line">            <span class="type">int</span> rate;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String name, String cuisines, <span class="type">int</span> rate)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">                <span class="built_in">this</span>.cuisines = cuisines;</span><br><span class="line">                <span class="built_in">this</span>.rate = rate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Queue&lt;Food&gt;&gt; queues;</span><br><span class="line">        Map&lt;String, Food&gt; nowFoodMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FoodRatings</span><span class="params">(String[] foods, String[] cuisines, <span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> foods.length;</span><br><span class="line">            queues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">                <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(foods[i], cuisines[i], ratings[i]);</span><br><span class="line">                nowFoodMap.put(foods[i], food);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!queues.containsKey(cuisines[i])) &#123;</span><br><span class="line">                    queues.put(cuisines[i], <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(</span><br><span class="line">                            a.rate != b.rate ? (b.rate - a.rate): (a.name.compareTo(b.name)))));</span><br><span class="line">                &#125;</span><br><span class="line">                queues.get(cuisines[i]).offer(food);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeRating</span><span class="params">(String food, <span class="type">int</span> newRating)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cu</span> <span class="operator">=</span> nowFoodMap.get(food).cuisines;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(food, cu, newRating);</span><br><span class="line">            nowFoodMap.put(food, food1);</span><br><span class="line">            queues.get(cu).offer(food1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">highestRated</span><span class="params">(String cuisine)</span> &#123;</span><br><span class="line">            Queue&lt;Food&gt; queue = queues.get(cuisine);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (food != nowFoodMap.get(food.name)) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> food.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FoodRatings object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);</span></span><br><span class="line"><span class="comment"> * obj.changeRating(food,newRating);</span></span><br><span class="line"><span class="comment"> * String param_2 = obj.highestRated(cuisine);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>但是定义类的时候比较麻烦，后面可以考虑以下的效率优化：</p>
<ol>
<li>
<p>用Pair做二元组，避免定义内部类麻烦</p>
</li>
<li>
<p>用var避免定义变量类型</p>
</li>
</ol>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764157594.png" alt="1658764157594"></p>
<h2><span id="2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode"></span><a href="#2354-you-zhi-shu-dui-de-shu-mu-li-kou-leetcode" class="header-anchor">#</a></h2>
<p><img src="/images/%E7%AC%AC303%E5%9C%BA%E5%91%A8%E8%B5%9B-463%E5%90%8D-4%E9%A2%98/1658764316137.png" alt="1658764316137"></p>
<p>其实这个脑筋急转弯通过纸上推演，很快能得到</p>
<p><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的1的个数，等同于num1和num2中1的个数总和</p>
<p>就变成就一个数组中，a[x] + a[y]共有多少对</p>
<p>这个子问题的解法我想复杂了，竟然想到用二分法。。。又因为很久没写了，对二分不熟了，导致浪费了大量时间确认二分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countExcellentPairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = Arrays.stream(nums).mapToObj(Integer::valueOf).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ontCounts = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span>[] newNums = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : set) &#123;</span><br><span class="line">            newNums[t++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = newNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            ontCounts[i] = Integer.bitCount(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ontCounts);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oneCount</span> <span class="operator">=</span> ontCounts[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">needOneCount</span> <span class="operator">=</span> k - oneCount;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  left + (right - left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ontCounts[mid] &lt; needOneCount) &#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ontCounts[mid] &gt;= needOneCount)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> right;</span><br><span class="line">            result += Math.max(<span class="number">0</span>, ontCounts.length - select);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比二分要更快速的可能是用双指针求解这类问题</p>
<p>但是双指针的方向可能要好好想想</p>
<p>即2个指针哪个优先固定， 再移动哪个，哪个方向移动</p>
<p>这题需要left=0, right=length， 固定住left， 让right移动找到一个位置后，right右边的所有点和left想家肯定都满足&gt; k</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ontCounts.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;left&lt;ontCounts.length;left++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (right &gt;=<span class="number">0</span> &amp;&amp; ontCounts[left] + ontCounts[right] &gt;= k) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    result += (ontCounts.length - <span class="number">1</span> - right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">AQS和JUC核心原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-17 21:24:55" itemprop="dateCreated datePublished" datetime="2022-07-17T21:24:55+08:00">2022-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:49:08" itemprop="dateModified" datetime="2022-08-10T00:49:08+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/17/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#java-zhong-aqs-jiu-jing-shi-zuo-shi-me-de">java中AQS究竟是做什么的？</a></li>
<li><a href="#aqs-jian-yao-bu-zou">AQS简要步骤</a></li>
<li><a href="#aqs-de-zi-yuan-state">AQS的资源state</a>
<ul>
<li><a href="#state-ding-yi">state定义</a></li>
<li><a href="#yi-jing-you-cas-fang-fa-liao-wei-shi-me-zi-yuan-state-huan-yao-ding-yi-cheng-volatile-de">已经有CAS方法了，为什么资源state还要定义成volatile的？</a></li>
<li><a href="#dui-zi-yuan-de-cao-zuo-shi-me-shi-hou-yong-cas-shi-me-shi-yong-setstate">对资源的操作什么时候用CAS，什么使用setState？</a></li>
</ul>
</li>
<li><a href="#aqs-de-clh-dui-lie">AQS的CLH队列</a>
<ul>
<li><a href="#wei-shi-me-xu-yao-yi-ge-clh-dui-lie">为什么需要一个CLH队列</a></li>
<li><a href="#clh-ben-zhi-shi-yi-ge-queue-rong-qi-ma">CLH本质？是一个Queue容器吗</a></li>
<li><a href="#ru-dui-shi-zen-me-bao-zheng-an-quan-de">入队是怎么保证安全的？</a></li>
<li><a href="#chu-dui-guo-cheng-hui-fa-sheng-shi-me">出队过程会发生什么？</a></li>
</ul>
</li>
<li><a href="#aqs-xiang-xi-zi-yuan-huo-qu-liu-cheng">AQS详细资源获取流程</a>
<ul>
<li><a href="#1-tryacquire-chang-shi-huo-qu-zi-yuan">1. tryAcquire尝试获取资源</a>
<ul>
<li><a href="#reentrantlock-zhong-de-tryacquire-shi-xian">ReentrantLock中的tryAcquire实现</a></li>
</ul>
</li>
<li><a href="#2-addwaiter-tian-jia-dao-deng-dai-dui-lie">2.addWaiter 添加到等待队列</a></li>
<li><a href="#3-acquirequeued-xun-huan-zu-sai-jing-zheng">3. acquireQueued循环阻塞-竞争</a></li>
<li><a href="#4-shouldparkafterfailedacquire-jian-cha-shi-fou-ke-yi-zu-sai">4.shouldParkAfterFailedAcquire 检查是否可以阻塞</a></li>
<li><a href="#5-parkandcheckinterrupt-zu-sai-xian-cheng">5.parkAndCheckInterrupt() 阻塞线程</a>
<ul>
<li><a href="#locksupport-park-he-pu-tong-de-wait-notify-du-you-sha-qu-bie">lockSupport.park()和普通的wait|notify都有啥区别？</a></li>
</ul>
</li>
<li><a href="#6-zong-ti-liu-cheng-tu">6.总体流程图</a></li>
<li><a href="#pin-fan-chu-xian-de-interruptd-zhong-duan-biao-ji-shi-zuo-shi-me-yong-de">频繁出现的interruptd中断标记是做什么用的？</a></li>
</ul>
</li>
<li><a href="#aqs-de-xiang-xi-zi-yuan-shi-fang-liu-cheng">AQS的详细资源释放流程</a></li>
<li><a href="#aqs-ru-he-shi-xian-gong-ping-he-fei-gong-ping">AQS如何实现公平和非公平？</a>
<ul>
<li><a href="#gong-ping-he-fei-gong-ping-suo-de-you-dian-he-que-dian">公平和非公平锁的优点和缺点</a></li>
<li><a href="#lock-lei-shi-mo-ren-gong-ping-huan-shi-fei-gong-ping">Lock类是默认公平还是非公平？</a></li>
</ul>
</li>
<li><a href="#du-zhan-mo-shi-he-gong-xiang-mo-shi-de-aqs-qu-bie">独占模式和共享模式的AQS区别</a>
<ul>
<li><a href="#gong-xiang-mo-shi-xin-hao-liang-semaphore-de-sync-tong-bu-qi">共享模式信号量Semaphore的Sync同步器</a></li>
</ul>
</li>
<li><a href="#aqs-ru-he-chu-li-chong-ru">AQS如何处理重入</a></li>
<li><a href="#aqs-ru-he-xiang-ying-chao-shi">AQS如何响应超时</a>
<ul>
<li><a href="#spinfortimeoutthreshold-shi-shi-me">spinForTimeoutThreshold是什么？</a></li>
</ul>
</li>
<li><a href="#aqs-de-condition-tiao-jian-dui-lie">AQS的condition条件队列</a>
<ul>
<li><a href="#condition-de-yong-fa">condition的用法</a></li>
<li><a href="#condition-he-object-wait-notify-de-qu-bie">condition 和 object.wait/notify的区别</a></li>
<li><a href="#condition-yuan-li-fen-xi">condition原理分析</a>
<ul>
<li><a href="#chao-da-yuan-li-liu-cheng-tu">超大原理流程图</a></li>
<li><a href="#dai-ma-jie-gou-bu-fen">代码结构部分：</a></li>
<li><a href="#yuan-li-shi-xian-bu-fen">原理实现部分：</a>
<ul>
<li><a href="#deng-dai-dui-lie">等待队列：</a></li>
<li><a href="#deng-dai-guo-cheng">等待过程</a></li>
<li><a href="#huan-xing-guo-cheng-signal">唤醒过程signal()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#yong-yu-gao-bing-fa-de-aqs-shi-xian-suo">用于高并发的AQS实现锁</a>
<ul>
<li><a href="#du-xie-suo-reentrantreadwritelock">读写锁ReentrantReadWriteLock</a>
<ul>
<li><a href="#mei-you-reentrantreadwritelock-qian-jdk-shi-zen-me-shi-xian-du-xie-ji-zhi-de">没有ReentrantReadWriteLock前，jdk是怎么实现读写机制的？</a></li>
<li><a href="#yong-liao-reentrantreadwritelock-hou-ke-yi-zen-me-zuo">用了ReentrantReadWriteLock后可以怎么做？</a></li>
<li><a href="#reentrantreadwritelock-zhi-chi-de-te-xing">ReentrantReadWriteLock支持的特性</a></li>
<li><a href="#du-xie-suo-de-shi-xian-he-xin-yuan-li">读写锁的实现核心原理</a>
<ul>
<li><a href="#du-xie-suo-de-state-zi-yuan-zhuang-tai-she-ji">读写锁的state资源状态设计</a></li>
<li><a href="#xie-suo-de-huo-qu-he-shi-fang">写锁的获取和释放</a></li>
<li><a href="#du-suo-de-huo-qu-he-shi-fang">读锁的获取和释放</a></li>
</ul>
</li>
<li><a href="#du-xie-suo-de-suo-jiang-ji">读写锁的锁降级</a></li>
</ul>
</li>
<li><a href="#you-chuo-suo-stampedlock">邮戳锁StampedLock</a>
<ul>
<li><a href="#du-xie-suo-you-shi-me-que-dian">读写锁有什么缺点？</a></li>
<li><a href="#you-chuo-suo-wei-shi-me-neng-jie-jue-ji-e">邮戳锁为什么能解决饥饿</a></li>
<li><a href="#shi-me-shi-hou-yong-du-xie-suo-shi-me-shi-hou-yong-you-chuo-suo">什么时候用读写锁，什么时候用邮戳锁？</a></li>
<li><a href="#you-chuo-suo-de-que-dian">邮戳锁的缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="java-zhong-aqs-jiu-jing-shi-zuo-shi-me-de">java中AQS究竟是做什么的？</span><a href="#java-zhong-aqs-jiu-jing-shi-zuo-shi-me-de" class="header-anchor">#</a></h1>
<p>当你使用java实现一个线程同步的对象时，一定会包含一个问题：</p>
<p><strong>你该如何保证多个线程访问该对象时，正确地进行阻塞等待，正确地被唤醒？</strong></p>
<p>关于这个问题，java的设计者认为应该是一套通用的机制</p>
<p>因此将一套线程阻塞等待以及被唤醒时锁分配的机制称之为AQS</p>
<p>全称 <strong>A</strong>bstract<strong>Q</strong>uened<strong>S</strong>ynchronizer</p>
<p>中文名即抽象的队列式同步器 。</p>
<p>基于AQS，实现了例如ReentenLock之类的经典JUC类。</p>
<h1><span id="aqs-jian-yao-bu-zou">AQS简要步骤</span><a href="#aqs-jian-yao-bu-zou" class="header-anchor">#</a></h1>
<ol>
<li>
<p>线程访问资源，如果资源足够，则把线程封装成一个Node，设置为活跃线程进入CLH队列，并扣去资源</p>
</li>
<li>
<p>资源不足，则变成等待线程Node，也进入CLH队列</p>
</li>
<li>
<p>CLH是一个如下图所示的双向链式队列</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658065224905.png" alt="1658065224905"></p>
</li>
</ol>
<h1><span id="aqs-de-zi-yuan-state">AQS的资源state</span><a href="#aqs-de-zi-yuan-state" class="header-anchor">#</a></h1>
<h2><span id="state-ding-yi">state定义</span><a href="#state-ding-yi" class="header-anchor">#</a></h2>
<p>AQS中的资源是一个int值，而且是volatile的，并提供了3个方法给子类使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cas方法</span></span><br><span class="line">compareAndSetState(<span class="type">int</span> oldState, <span class="type">int</span> newState);</span><br></pre></td></tr></table></figure>
<p>如果state上限只有1，那么就是独占模式Exclusive，例如 ReentrantLock</p>
<p>如果state上限大于1，那就是共享模式Share，例如 Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>
<h2><span id="yi-jing-you-cas-fang-fa-liao-wei-shi-me-zi-yuan-state-huan-yao-ding-yi-cheng-volatile-de">已经有CAS方法了，为什么资源state还要定义成volatile的？</span><a href="#yi-jing-you-cas-fang-fa-liao-wei-shi-me-zi-yuan-state-huan-yao-ding-yi-cheng-volatile-de" class="header-anchor">#</a></h2>
<p>对外暴露的getter/setter方法，是走不了CAS的。而且setter/getter没有被synchronized修饰。所以必须要volatile，保证可见性</p>
<p>这样基于AQS的实现可以直接通过getter/setter操作state变量，并且保证可见性，也避免重排序带来的影响。比如CountDownLatch，ReentrantReadWriteLock，Semaphore都有体现（各种getState、setState）</p>
<h2><span id="dui-zi-yuan-de-cao-zuo-shi-me-shi-hou-yong-cas-shi-me-shi-yong-setstate">对资源的操作什么时候用CAS，什么使用setState？</span><a href="#dui-zi-yuan-de-cao-zuo-shi-me-shi-hou-yong-cas-shi-me-shi-yong-setstate" class="header-anchor">#</a></h2>
<p>volatile的state成员有一个问题，就是如果是复合操作的话不能保证复合操作的原子性</p>
<p>因此涉及 state增减的情况，采用CAS</p>
<p>如果是state设置成某个固定值，则使用setState</p>
<h1><span id="aqs-de-clh-dui-lie">AQS的CLH队列</span><a href="#aqs-de-clh-dui-lie" class="header-anchor">#</a></h1>
<h2><span id="wei-shi-me-xu-yao-yi-ge-clh-dui-lie">为什么需要一个CLH队列</span><a href="#wei-shi-me-xu-yao-yi-ge-clh-dui-lie" class="header-anchor">#</a></h2>
<p>这个队列的目的是为了公平锁的实现</p>
<p>即为了保证先到先得，要求每个线程封装后的Node按顺序拼接起来。</p>
<h2><span id="clh-ben-zhi-shi-yi-ge-queue-rong-qi-ma">CLH本质？是一个Queue容器吗</span><a href="#clh-ben-zhi-shi-yi-ge-queue-rong-qi-ma" class="header-anchor">#</a></h2>
<p>不是的，本质上是一个链表式的队列</p>
<p>因此核心在于链表节点Node的定义</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658066659779.png" alt="1658066659779"></p>
<p>除了比较容易想到的prev和next指针外</p>
<p>还包含了该节点内的线程</p>
<p>以及 waitStatus 等待状态</p>
<p>4种等待状态如下：</p>
<ul>
<li>CANCELLED（1）： 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</li>
<li>SIGNAL（-1）：后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</li>
<li>CONDITION（-2） ： 点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</li>
<li>PROPAGATE（-3）   ： 表示下一次共享式同步状态获取将会无条件地传播下去</li>
<li>INIT（ 0）:</li>
</ul>
<h2><span id="ru-dui-shi-zen-me-bao-zheng-an-quan-de">入队是怎么保证安全的？</span><a href="#ru-dui-shi-zen-me-bao-zheng-an-quan-de" class="header-anchor">#</a></h2>
<p>入队过程可能引发冲突</p>
<p>因此会用CAS保障入队安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//多次尝试，直到成功为止</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置为尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="chu-dui-guo-cheng-hui-fa-sheng-shi-me">出队过程会发生什么？</span><a href="#chu-dui-guo-cheng-hui-fa-sheng-shi-me" class="header-anchor">#</a></h2>
<p>一旦有节点出队，说明有线程释放资源了，队头的等待线程可以开始尝试获取了。</p>
<p>于是首节点的线程释放同步状态后，将会唤醒它的后继节点（next）</p>
<p>而后继节点将会在获取同步状态成功时将自己设置为首节点</p>
<p>**注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态 **</p>
<h1><span id="aqs-xiang-xi-zi-yuan-huo-qu-liu-cheng">AQS详细资源获取流程</span><a href="#aqs-xiang-xi-zi-yuan-huo-qu-liu-cheng" class="header-anchor">#</a></h1>
<h2><span id="1-tryacquire-chang-shi-huo-qu-zi-yuan">1. tryAcquire尝试获取资源</span><a href="#1-tryacquire-chang-shi-huo-qu-zi-yuan" class="header-anchor">#</a></h2>
<p>AQS使用的设计模式是模板方法模式。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 发现中断过，则触发中断异常</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即AQS抽象基类AbstractQueuedSynchronizer给外部调用时，都是调的acquire(int arg)方法。这个方法的内容是写死的。<br>
而acquire中，需要调用<strong>tryAcquire(arg)， 这个方法是需要子类实现的，作用是判断资源是否足够获取arg个</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mutou_ren/article/details/103864432">(2条消息) AQS子类的tryAcquire和tryRelease的实现_Mutou_ren的博客-CSDN博客_aqs tryacquire</a></p>
<h3><span id="reentrantlock-zhong-de-tryacquire-shi-xian">ReentrantLock中的tryAcquire实现</span><a href="#reentrantlock-zhong-de-tryacquire-shi-xian" class="header-anchor">#</a></h3>
<p>这里暂时只谈论一种容易理解的tryAcuire实现，其他附加特性的tryAcquire先不提。</p>
<p>里面主要就做这几件事：</p>
<ol>
<li>获取当前锁的资源数</li>
<li>资源数为0，说明可以抢， 确认是前置节点是头节点，进行CAS试图争抢，抢成功就返回true，并设置当前线程</li>
<li>没抢成功，返回false</li>
<li>如果是重入的，则直接set设置增加后的状态值，状态值此时不一定为0和1了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">// state==0代表当前没有锁，可以进行获取</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="comment">// 非公平才有的判断，会判断是否还有前驱节点，直接自己为头节点了或者同步队列空了才会继续后面的锁的获取操作</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() </span><br><span class="line">                     <span class="comment">//CAS设置state为acquires，成功后标记exclusiveOwnerThread为当前线程</span></span><br><span class="line">                    &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前占有线程等于自己，代表重入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="comment">// 出现负数，说明溢出了</span></span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// 因为是重入操作，可以直接进行state的增加，所以不需要CAS</span></span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-addwaiter-tian-jia-dao-deng-dai-dui-lie">2.addWaiter 添加到等待队列</span><a href="#2-addwaiter-tian-jia-dao-deng-dai-dui-lie" class="header-anchor">#</a></h2>
<p>当获取资源失败，会进行addWaiter(Node.EXCLUSIVE)， arg)。</p>
<p>目的是创建一个等待节点Node，并添加到等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过CAS竞争队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 竞争队尾失败，于是进行CAS频繁循环竞争队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="3-acquirequeued-xun-huan-zu-sai-jing-zheng">3. acquireQueued循环阻塞-竞争</span><a href="#3-acquirequeued-xun-huan-zu-sai-jing-zheng" class="header-anchor">#</a></h2>
<p>，并在 &quot;处于头节点时尝试获取资源-&gt;睡眠-&gt;唤醒“中循环。</p>
<p>当已经跑完任务的线程释放资源时，会唤醒之前阻塞的线程。</p>
<p>当被唤醒后，就会检查自己是不是头节点，如果不是，且认为可以阻塞，那就继续睡觉去了</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/HuiShouGuoQu/p/13596507.html">AQS（acquireQueued(Node, int) 3）–队列同步器 - 小窝蜗 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 标识是否获取资源失败                </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前线程是否被中断过</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前继节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前继节点为头结点，说明排队马上排到自己了，可以尝试获取资源，若获取资源成功，则执行下述操作</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 说明前继节点已经释放掉资源了，将其next置空，好让虚拟机提前回收掉前继节点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 获取资源成功，修改标记位</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若前继节点不是头结点，或者获取资源失败，</span></span><br><span class="line">            <span class="comment">// 则需要判断是否需要阻塞该节点持有的线程</span></span><br><span class="line">            <span class="comment">// 若可以阻塞，则继续执行parkAndCheckInterrupt()函数，</span></span><br><span class="line">            <span class="comment">// 将该线程阻塞直至被唤醒</span></span><br><span class="line">            <span class="comment">// 唤醒后会检查是否已经被中断，若返回true，则将interrupted标志置于true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终获取资源失败，则当前节点放弃获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="4-shouldparkafterfailedacquire-jian-cha-shi-fou-ke-yi-zu-sai">4.shouldParkAfterFailedAcquire 检查是否可以阻塞</span><a href="#4-shouldparkafterfailedacquire-jian-cha-shi-fou-ke-yi-zu-sai" class="header-anchor">#</a></h2>
<p>该方法不会直接阻塞线程，因为一旦线程挂起，后续就只能通过唤醒机制，中间还发生了内核态用户态切换，消耗很大。</p>
<p>因此会先不断确认前继节点的实际状态，在只能阻塞的情况下才会去阻塞。</p>
<p>并且会过滤掉cancel的线程节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取前继节点的等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果等待状态为Node.SIGNAL(-1)，则直接返回true即可以阻塞</span></span><br><span class="line">    <span class="comment">// 因为这说明前继节点完成资源的释放或者中断后，会主动唤醒后继节点的（这也即是signal信号的含义），因此方法外面不用再反复CAS了，直接阻塞吧</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前继节点的等待值大于0即CANCELLED（1）,说明前继节点的线程发生过cancel动作</span></span><br><span class="line">    <span class="comment">// 那就继续往前遍历，直到当前节点的前继节点的状态不为cancel</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 前继节点的等待状态不为SIGNAL(-1)，也不为Cancel(1)</span></span><br><span class="line">        <span class="comment">// 那么只能是PROPAGATE(-3)或者CONDITION(-2)或者INITIAL（0）</span></span><br><span class="line">        <span class="comment">// 直接设置成SIGNAL，下一次还没CAS成功，就直接睡觉了</span></span><br><span class="line">        <span class="comment">// 因此在前面所有节点没辩护的情况下， 最多一次之后就会返回true让外面阻塞</span></span><br><span class="line">       compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-parkandcheckinterrupt-zu-sai-xian-cheng">5.parkAndCheckInterrupt()  阻塞线程</span><a href="#5-parkandcheckinterrupt-zu-sai-xian-cheng" class="header-anchor">#</a></h2>
<p>使用LockSupport.park来阻塞当前这个对象所在的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">             LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    		 <span class="comment">// 确认是否是中断导致的park结束，并清除中断标记</span></span><br><span class="line">             <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(Object blocker)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="locksupport-park-he-pu-tong-de-wait-notify-du-you-sha-qu-bie">lockSupport.park()和普通的wait|notify都有啥区别？</span><a href="#locksupport-park-he-pu-tong-de-wait-notify-du-you-sha-qu-bie" class="header-anchor">#</a></h3>
<ol>
<li>面向的主体不一样。LockSuport主要是针对Thread进进行阻塞处理，可以指定阻塞队列的目标对象，每次可以指定具体的线程唤醒。Object.wait()是以对象为纬度，阻塞当前的线程和唤醒单个(随机)或者所有线程。</li>
<li>实现机制不同。虽然LockSuport可以指定monitor的object对象，但和object.wait()，两者的阻塞队列并不交叉。可以看下测试例子。object.notifyAll()不能唤醒LockSupport的阻塞Thread.</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f16b838ccd8">底层实现原理</a><br>
简而言之，是用mutex和condition保护了一个_counter的变量，当park时，这个变量置为了0，当unpark时，这个变量置为1。<br>
底层用的C语言的pthread_mutex_unlock、pthread_cond_wait 、pthread_cond_signal ，但是针对了mutex和_cond两个变量进行加锁。</p>
<h2><span id="6-zong-ti-liu-cheng-tu">6.总体流程图</span><a href="#6-zong-ti-liu-cheng-tu" class="header-anchor">#</a></h2>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658647899304.png" alt="1658647899304"></p>
<h2><span id="pin-fan-chu-xian-de-interruptd-zhong-duan-biao-ji-shi-zuo-shi-me-yong-de">频繁出现的interruptd中断标记是做什么用的？</span><a href="#pin-fan-chu-xian-de-interruptd-zhong-duan-biao-ji-shi-zuo-shi-me-yong-de" class="header-anchor">#</a></h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010499733/article/details/106982708/">(2条消息) JUC并发编程基石AQS之中断_LuxBai的博客-CSDN博客_aqs中断</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/218f7f81d2da">看！源码之AQS中断设计与实现(内涵jvm部分实现) - 简书 (jianshu.com)</a></p>
<p>对线程调用 t1.interrupt();时</p>
<p>会导致 LockSupport.park() 阻塞的线程重新被唤醒</p>
<p>即有两种唤醒情况： 被前置节点唤醒，或者被外部中断唤醒</p>
<p>这时候要根据调用的acuire类型决定是否在中断发生时结束锁的获取。</p>
<p>上面介绍的是不可中断锁。</p>
<p>在parkAndCheckInterrupt中，当park结束阻塞时时,使用的是 Thread.interrupted() 而不是 .isInterrupted() 来返回中断状态</p>
<p>因为前者会返回线程当前的中断标记状态<strong>同时清除中断标志位</strong>（置为false）</p>
<p>外层CAS循环时， 就不会让线程受中断标记影响，只是记录一下是否发生过中断</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658419508199.png" alt="1658419508199"></p>
<p>当获取锁成功后，如果发现有过线程中断，则会触发中断异常，</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658419648382.png" alt="1658419648382"></p>
<p>之后便由获取锁的调用者自己决定是否要处理线程中断。像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么另一种情况就是可中断锁了。</p>
<p>ReentranLock有一个lockInterruptibly()方法就是这种情况</p>
<p>线程被唤醒时，如果发现自己被中断过，就会直接抛异常而不是继续获取锁</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658419756962.png" alt="1658419756962"></p>
<p>因此如果你的线程对中断很敏感，那么就是用可中断锁，及时响应。</p>
<p>如果不敏感，也要注意处理中断异常。</p>
<h1><span id="aqs-de-xiang-xi-zi-yuan-shi-fang-liu-cheng">AQS的详细资源释放流程</span><a href="#aqs-de-xiang-xi-zi-yuan-shi-fang-liu-cheng" class="header-anchor">#</a></h1>
<p>首先AQS提供的模板方法为release方法。</p>
<p>核心逻辑就是对资源进行尝试性释放</p>
<p>如果成功，就唤醒等待队列中的第一个头节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否释放成功，tryRelease是子类要实现的方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 判断头节点是否正在阻塞中，是的话唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒头节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下ReteenLock中的tryRelease实现</p>
<p>就是减一下资源值。</p>
<p>当资源值清零，则说明可以解除了对当前点的占用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">     	<span class="comment">// 设置当前占用线程为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要CAS，因为只有持有锁的人才能做释放，不担心竞争</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="aqs-ru-he-shi-xian-gong-ping-he-fei-gong-ping">AQS如何实现公平和非公平？</span><a href="#aqs-ru-he-shi-xian-gong-ping-he-fei-gong-ping" class="header-anchor">#</a></h1>
<p>以ReteenLock为例，它内部tryAcquire有两种同步器的实现</p>
<ul>
<li>
<p>非公平同步器NonfairSync</p>
</li>
<li>
<p>公平同步器FairSync</p>
</li>
</ul>
<p>公平同步器和非公平同步器都是ReentrantLock中定义的一个static内部类</p>
<p>ReentrantLock根据配置的不同，使用这2个同步器做资源的获取和同步操作</p>
<p>他们二者的提供的lock操作，本质上就是AQS的acquire(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>二者在公平和非公平的实现区别上，就是唤醒线程后，只有等待队列的队头节点才会尝试竞争。</p>
<p>而非公平锁是只要唤醒了就可以尝试竞争。</p>
<p>因此核心区别在于hasQueuedPredecessors方法！</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658665318338.png" alt="1658665318338"></p>
<h2><span id="gong-ping-he-fei-gong-ping-suo-de-you-dian-he-que-dian">公平和非公平锁的优点和缺点</span><a href="#gong-ping-he-fei-gong-ping-suo-de-you-dian-he-que-dian" class="header-anchor">#</a></h2>
<ol>
<li>饥饿问题</li>
</ol>
<p>非公平锁可能引发“饥饿”，即一个线程反复抢占获取，而其他线程一直拿不到。</p>
<p>而公平锁不存在饥饿，只要排上队了就一定能拿到</p>
<ol start="2">
<li>
<p>性能问题</p>
<p>非公平锁的平均性能比公平锁要高， 因为非公平锁中所有人都可以CAS抢占，如果同步块的时间非常短，那么可能所有人都不需要阻塞，减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p>
</li>
</ol>
<p>性能测试中公平锁的耗时是非公平锁的94.3倍， 总切换次数是133倍</p>
<h2><span id="lock-lei-shi-mo-ren-gong-ping-huan-shi-fei-gong-ping">Lock类是默认公平还是非公平？</span><a href="#lock-lei-shi-mo-ren-gong-ping-huan-shi-fei-gong-ping" class="header-anchor">#</a></h2>
<p>默认是非公平的，原因就是上文考虑的性能差距过大问题， 因此公平锁只能用于特定对性能要求不高且饥饿发生概率不大的场景中。</p>
<h1><span id="du-zhan-mo-shi-he-gong-xiang-mo-shi-de-aqs-qu-bie">独占模式和共享模式的AQS区别</span><a href="#du-zhan-mo-shi-he-gong-xiang-mo-shi-de-aqs-qu-bie" class="header-anchor">#</a></h1>
<ul>
<li>
<p>名字上， 共享模式都会带一个shard</p>
</li>
<li>
<p>返回值上，独占模式相关acuire方法放回的是boolean类型， 而共享模式返回的是int值</p>
</li>
<li>
<p>核心概念上， 区别在于同一时刻能否有多个线程可以获取到其同步状态</p>
</li>
<li>
<p>释放时，共享模式需要用CAS进行释放， 而独占模式的release方法则不需要，直接setState即可。</p>
</li>
<li>
<p>共享模式应用：信号量、读写锁</p>
</li>
</ul>
<h2><span id="gong-xiang-mo-shi-xin-hao-liang-semaphore-de-sync-tong-bu-qi">共享模式信号量Semaphore的Sync同步器</span><a href="#gong-xiang-mo-shi-xin-hao-liang-semaphore-de-sync-tong-bu-qi" class="header-anchor">#</a></h2>
<p>先实现了一个静态内部类Sync</p>
<p>和上面的RLock类一个区别在于需要state初始化值，不一定为1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="type">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再继承实现了FairSync和NoFairSync</p>
<p>使用CAS实现值的增加或者减少</p>
<p>公平/非公平的区别同样是hasQueuedPredecessors的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 队头判断，公平锁核心</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 信号量不足，直接返回负数</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 能抢成功，返回修改后的值，抢失败则for循环继续</span></span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="aqs-ru-he-chu-li-chong-ru">AQS如何处理重入</span><a href="#aqs-ru-he-chu-li-chong-ru" class="header-anchor">#</a></h1>
<p>通过current == getExclusiveOwnerThread()来判断并进行非CAS的setState操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">    <span class="comment">// 出现负数，说明溢出了</span></span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    <span class="comment">// 因为是重入操作，可以直接进行state的增加，所以不需要CAS</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意处理重入问题时，如果是独占锁，是可以直接setState而不需要CAS的，因为不会竞争式地重入！</p>
<p>ReentrantLock释放时，也会处理重入，关键点就是对getState() - release后的处理，是否返回true或者false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有资源数为0才会解锁</span></span><br><span class="line">        <span class="comment">// 才算释放成功，否则这锁还是占住了</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="aqs-ru-he-xiang-ying-chao-shi">AQS如何响应超时</span><a href="#aqs-ru-he-xiang-ying-chao-shi" class="header-anchor">#</a></h1>
<p>AQS提供的方法中带有Nanos后缀的方法就是支持超时中断的方法。</p>
<p>核心逻辑就是每次阻塞前，确认nanosTimeout是否已经超时了。</p>
<p>每次唤醒时，将nanosTimeout减去阻塞所花的时间，重新确认，并修改lastTime</p>
<p>关键部分见下图</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658648788193.png" alt="1658648788193"></p>
<h2><span id="spinfortimeoutthreshold-shi-shi-me">spinForTimeoutThreshold是什么？</span><a href="#spinfortimeoutthreshold-shi-shi-me" class="header-anchor">#</a></h2>
<p>首先这个值是写死的1000L即1000纳秒</p>
<p>1000纳秒是个非常小的数字，而小于等于1000纳秒的超时等待，无法做到十分的精确，那么就不要使用这么短的一个超时时间去影响超时计算的精确性，所以这时线程不做超时等待，直接做自旋就好了。</p>
<h1><span id="aqs-de-condition-tiao-jian-dui-lie">AQS的condition条件队列</span><a href="#aqs-de-condition-tiao-jian-dui-lie" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/glamour2015/article/details/105499426/">(2条消息) AQS条件队列及中断机制_glamour2015的博客-CSDN博客_aqs中断</a></p>
<h2><span id="condition-de-yong-fa">condition的用法</span><a href="#condition-de-yong-fa" class="header-anchor">#</a></h2>
<p>condition用于显式的等待通知，等待过程可以挂起并释放锁，唤醒后重新拿到锁。</p>
<p>和直接用lock\unlock去做等待通知的区别在于，lock是不会释放锁的，但是利用的condition的await则可以，且唤醒后会自动重新拿回锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// if(xxxx)判断不满足条件，等待，释放锁</span></span><br><span class="line">            condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 做完事情了，通知condition上等待的开始抢占</span></span><br><span class="line">            condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也提供了一些支持中断、支持超时的等待方法</p>
<h2><span id="condition-he-object-wait-notify-de-qu-bie">condition 和 object.wait/notify的区别</span><a href="#condition-he-object-wait-notify-de-qu-bie" class="header-anchor">#</a></h2>
<ol>
<li>
<p>object的wait依赖sync， 只能最多有一个等待队列。  而通过newCondition可以制造多个等待队列</p>
</li>
<li>
<p>wait不支持中断，而condition支持</p>
</li>
<li>
<p>condition支持等待特定时间</p>
</li>
</ol>
<h2><span id="condition-yuan-li-fen-xi">condition原理分析</span><a href="#condition-yuan-li-fen-xi" class="header-anchor">#</a></h2>
<h3><span id="chao-da-yuan-li-liu-cheng-tu">超大原理流程图</span><a href="#chao-da-yuan-li-liu-cheng-tu" class="header-anchor">#</a></h3>
<ul>
<li>
<p>await()， 简单来讲就是把当前线程放入condition的等待队列中，然后调用LockSupport.park拉起线程。如果被其他线程通过signal唤醒，则放入同步队列中竞争锁，竞争成功则返回，否则继续竞争。</p>
</li>
<li>
<p>signal方法，就是拿到condition的等待队列头节点，用cas修改节点状态，改成功则唤醒线程。但有可能被别人抢先，所以需要cas操作。</p>
</li>
</ul>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/7f51fc61f099394d01172d9c0b622ff815037302.png" alt="dd"></p>
<h3><span id="dai-ma-jie-gou-bu-fen">代码结构部分：</span><a href="#dai-ma-jie-gou-bu-fen" class="header-anchor">#</a></h3>
<p>​	Lock提供了newCondition接口给外部锁调用</p>
<p>​	而newCondition()返回的Condition是一个接口</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1659283503458.png" alt="1659283503458"></p>
<p>​	这个接口的实现类是ConditionObject，放在AQS抽象类的内部类中</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1659283517022.png" alt="1659283517022"></p>
<h3><span id="yuan-li-shi-xian-bu-fen">原理实现部分：</span><a href="#yuan-li-shi-xian-bu-fen" class="header-anchor">#</a></h3>
<h4><span id="deng-dai-dui-lie">等待队列：</span><a href="#deng-dai-dui-lie" class="header-anchor">#</a></h4>
<ul>
<li>
<p>每个condition都有一个属于自己的等待队列</p>
</li>
<li>
<p>每次调用condition.await， 就插入到等待队列尾部</p>
</li>
<li>
<p>等待队列插入封装线程的节点时不需要在尾部CAS， 因为必须先获取锁，才能调用await，因此不用CAS竞争</p>
</li>
<li>
<p>每个Lock只有一个同步队列（用于lock()时阻塞和竞争用）， 但是可能会有多个等待队列（用于condition的await）</p>
</li>
</ul>
<h4><span id="deng-dai-guo-cheng">等待过程</span><a href="#deng-dai-guo-cheng" class="header-anchor">#</a></h4>
<ol>
<li>
<p>添加线程到condition的等待队列尾部</p>
</li>
<li>
<p>释放占用的锁，并唤醒同步队列的后继节点</p>
</li>
<li>
<p>此时肯定不在aqs的同步队列中了， 用park方法进入阻塞状态</p>
</li>
<li>
<p>被唤醒，唤醒时可能是通过sign()被人放入了同步队列， 也可能是被中断唤醒，因此要做checkInterruptWhileWaiting检查看是否继续， 如果同意继续，就继续睡眠，直到进入同步队列</p>
</li>
<li>
<p>尝试acquireQueued竞争和抢占state同步状态</p>
</li>
<li>
<p>退出前，顺带用unlinkCancelledWaiters清理已经不是CONDITION状态的等待队列节点</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 添加本线程到等待队列尾部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁，唤醒同步队列中的后继节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果已经在同步队列中了，说明被成功sign唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 阻塞挂起</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 确认是否需要中断时就退出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在同步队列中，那就按同步队列的规则在队列中用CAS竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 清理已经不是CONDITION状态的等待队列节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="huan-xing-guo-cheng-signal">唤醒过程signal()</span><a href="#huan-xing-guo-cheng-signal" class="header-anchor">#</a></h4>
<ol>
<li>
<p>检查调用signal时，是否当前线程获取了锁，不是则抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取condition队列中的第一个等待节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Node</span> first = firstWaiter;</span><br><span class="line"><span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">doSignal</span>(first);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用CAS清除CONDITION状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用AQS的enq(firstWaitNode)，将这个节点放入到同步队列的队尾（需要CAS支撑？因为可能是共享的，即使获取了锁也需要竞争)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动入同步队列成功后（可能经历了几次CAS），再用unpark方法唤醒，那个线程就进入了上面代码中Park之后的部分了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">    LockSupport.unpark(node.thread);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果是signalAll方法，则等待队列中每个节点都执行一次signal方法，全部移入同步队列中并唤醒（唤醒后他们很可能还会因为抢不到资源而阻塞，但队列位置不同了，也无法再通过sign唤醒了）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">    first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    transferForSignal(first);</span><br><span class="line">    first = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="yong-yu-gao-bing-fa-de-aqs-shi-xian-suo">用于高并发的AQS实现锁</span><a href="#yong-yu-gao-bing-fa-de-aqs-shi-xian-suo" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041266961?sort=newest">JAVA并发编程——ReentrantReadWriteLock锁降级和StampedLock - SegmentFault 思否</a></p>
<h2><span id="du-xie-suo-reentrantreadwritelock">读写锁ReentrantReadWriteLock</span><a href="#du-xie-suo-reentrantreadwritelock" class="header-anchor">#</a></h2>
<p>读写锁，顾名思义，用于读多写少的场景，这种情况下一般读是没必要强行做互斥的。</p>
<h3><span id="mei-you-reentrantreadwritelock-qian-jdk-shi-zen-me-shi-xian-du-xie-ji-zhi-de">没有ReentrantReadWriteLock前，jdk是怎么实现读写机制的？</span><a href="#mei-you-reentrantreadwritelock-qian-jdk-shi-zen-me-shi-xian-du-xie-ji-zhi-de" class="header-anchor">#</a></h3>
<p>jdk5之前是没有读写锁的。</p>
<p>因此需要手写一套等待和通知机制。</p>
<p>写操作开始时，所有晚于写操作的读操作会通过wait进入阻塞状态。</p>
<p>写操作完成后，主动用notifyAll进行通知，其他的读操作再继续执行</p>
<p>写操作和写操作之间的同步则通过sync关键字保障同步</p>
<h3><span id="yong-liao-reentrantreadwritelock-hou-ke-yi-zen-me-zuo">用了ReentrantReadWriteLock后可以怎么做？</span><a href="#yong-liao-reentrantreadwritelock-hou-ke-yi-zen-me-zuo" class="header-anchor">#</a></h3>
<p>提供了读锁和写锁</p>
<p>读的时候获取读锁</p>
<p>写的时候获取写锁</p>
<p>一旦写锁lock住，后面的读写都会阻塞住，直到写锁被释放。</p>
<p>代码示例: 一个用HashMap + 读写锁实现的安全Cache(代码出自《java并发编程艺术）)</p>
<p>关注里面什么时候用r.lock，什么时候用的w.lock</p>
<p>且都用了finally来保证锁的释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">    <span class="comment">// 获取一个key对应的value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        	r.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> map.get(key);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    r.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置key对应的value，并返回旧的value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空所有的内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    map.clear();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="reentrantreadwritelock-zhi-chi-de-te-xing">ReentrantReadWriteLock支持的特性</span><a href="#reentrantreadwritelock-zhi-chi-de-te-xing" class="header-anchor">#</a></h3>
<p>支持公平和非公平锁的实现：提供了带Fair的读写锁，吞吐量仍旧是非公平优先</p>
<p>支持重进入： 写线程获取写锁后， 可以再次基于这个线程获取写锁或者读进行重入</p>
<h3><span id="du-xie-suo-de-shi-xian-he-xin-yuan-li">读写锁的实现核心原理</span><a href="#du-xie-suo-de-shi-xian-he-xin-yuan-li" class="header-anchor">#</a></h3>
<h4><span id="du-xie-suo-de-state-zi-yuan-zhuang-tai-she-ji">读写锁的state资源状态设计</span><a href="#du-xie-suo-de-state-zi-yuan-zhuang-tai-she-ji" class="header-anchor">#</a></h4>
<p>因为AQS只提供了getState()和setState（）两个方法来表示状态， 为了不引入新的成员破坏设计，仍旧基于一个state值来实现读写状态。</p>
<p>state是一个32位的int值， 此时前16位表示写锁的重入数量， 后16位表示为写锁持有的数量。</p>
<p>可直接通过excludesiveCount(getState())得到写锁的数量值。</p>
<h4><span id="xie-suo-de-huo-qu-he-shi-fang">写锁的获取和释放</span><a href="#xie-suo-de-huo-qu-he-shi-fang" class="header-anchor">#</a></h4>
<p>核心关键点：</p>
<ol>
<li>
<p>写锁属于独占锁，因此实现和调用的都是tryAcquire方法，不带shard</p>
</li>
<li>
<p>发现有读锁的时候，会直接false获取写锁失败</p>
</li>
<li>
<p>写锁支持重入，重入时同样不需要CAS</p>
</li>
<li>
<p>公平锁仍然会考虑头节点问题，非头节点直接获取写锁失败</p>
</li>
</ol>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658673384503.png" alt="1658673384503"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="du-suo-de-huo-qu-he-shi-fang">读锁的获取和释放</span><a href="#du-suo-de-huo-qu-he-shi-fang" class="header-anchor">#</a></h4>
<ol>
<li>
<p>读锁属于共享锁，因此相关方法都带了一个shard</p>
</li>
<li>
<p>读锁中对state的处理都多了一个1&lt;&lt;16</p>
</li>
<li>
<p>读锁是共享锁，所以tryAcquire方法中就已经在一直做CAS试图获取读锁</p>
<p><strong>读锁之间不存在阻塞只有CAS，除非遇到写锁，才有可能在外层阻塞</strong></p>
</li>
<li>
<p>存在写锁， 但如果是重入场景（即同一个线程），则允许读锁的重入，这是下文锁降级的应用基础</p>
</li>
<li>
<p>JDK6中引入了当前线程读取读锁的次数getHoldCount，增加了threadLocal来保存各线程读锁的次数情况，实现比较复杂。下面只给出去掉hold的代码：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">// 一直处理，读锁竞争都是CAS，不存在阻塞！</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 有写锁且不是重入，返回-1获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cas修改值</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc)) </span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="du-xie-suo-de-suo-jiang-ji">读写锁的锁降级</span><a href="#du-xie-suo-de-suo-jiang-ji" class="header-anchor">#</a></h3>
<p>说人话能一个线程同时加2个锁，支持逐步释放。就是当你在一个线程中需要操作完数据完后马上读数据，且希望数据在方法结束前不会变（避免脏读），可以先加写锁，在写完后加读锁，  然后释放写锁， 此时还会保留读锁（降级）， 就能保证data的正常使用。</p>
<p>锁降级并非一个特性， 只是一种应用做法，即当你涉及写完要马上读数据操作的情况，可以先加读锁，再释放写锁！</p>
<p><img src="/images/AQS%E5%92%8CJUC%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1658670285725.png" alt="1658670285725"></p>
<h2><span id="you-chuo-suo-stampedlock">邮戳锁StampedLock</span><a href="#you-chuo-suo-stampedlock" class="header-anchor">#</a></h2>
<h3><span id="du-xie-suo-you-shi-me-que-dian">读写锁有什么缺点？</span><a href="#du-xie-suo-you-shi-me-que-dian" class="header-anchor">#</a></h3>
<p>读写锁容易造成写饥饿。例如读有9999+的时候，写动作就得等9999+结束才能触发</p>
<p>即读的动作占用了太多写动作的等待时间了。</p>
<h3><span id="you-chuo-suo-wei-shi-me-neng-jie-jue-ji-e">邮戳锁为什么能解决饥饿</span><a href="#you-chuo-suo-wei-shi-me-neng-jie-jue-ji-e" class="header-anchor">#</a></h3>
<p>邮戳锁提供了一个乐观读的方法</p>
<p>这个方法并不需解锁动作，它也不会去阻塞写动作</p>
<p>只有当发现邮戳（可以理解为数据库MVCC里的版本号）有变化</p>
<p>则升级为悲观读，以期待读到最新的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前邮戳，这个方法不会阻塞写方法！</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 校验此时是否邮戳不匹配</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 如果不匹配，说明发生了写操作！读动作最好等写动作结束后再触发！</span></span><br><span class="line">	<span class="comment">// 锁升级 为悲观读readLock</span></span><br><span class="line">    stamp = stampedLock.readLock();<span class="comment">//锁升级为悲观读</span></span><br><span class="line">    <span class="comment">// 处理...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    stampedLock.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="shi-me-shi-hou-yong-du-xie-suo-shi-me-shi-hou-yong-you-chuo-suo">什么时候用读写锁，什么时候用邮戳锁？</span><a href="#shi-me-shi-hou-yong-du-xie-suo-shi-me-shi-hou-yong-you-chuo-suo" class="header-anchor">#</a></h3>
<p>读写锁是读可以阻塞写，读是优先的！</p>
<p>而邮戳锁中，只有写才可以阻塞读， 写是优先的！</p>
<p><strong>因此读动作重要的话选读写锁， 如果写动作（写要及时响应）比较重要的话则选邮戳锁</strong></p>
<h3><span id="you-chuo-suo-de-que-dian">邮戳锁的缺点</span><a href="#you-chuo-suo-de-que-dian" class="header-anchor">#</a></h3>
<ul>
<li>
<p>StampedLock 不支持重入，如果写锁之后再做写，就阻塞了</p>
</li>
<li>
<p>StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</p>
</li>
<li>
<p>使用 StampedLock一定不要调用中断操作，即不要调用interrupt() 方法</p>
</li>
</ul>
<p>​        如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly()和写锁writeLockInterruptibly()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/10/%E9%9A%8F%E7%AC%94/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/10/%E9%9A%8F%E7%AC%94/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/" class="post-title-link" itemprop="url">被讨厌的勇气</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-10 19:48:56 / 修改时间：23:46:41" itemprop="dateCreated datePublished" datetime="2022-07-10T19:48:56+08:00">2022-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%BF%83%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">心理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/10/%E9%9A%8F%E7%AC%94/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/10/%E9%9A%8F%E7%AC%94/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="bai-tuo-guo-qu-lun">摆脱过去论</span><a href="#bai-tuo-guo-qu-lun" class="header-anchor">#</a></h2>
<p>封闭自己不愿接触外界，因为自己遭遇了不公的对待</p>
<p>哀叹家暴，导致自己无法自立</p>
<p>因为脸红恐惧症，无法接触对方……</p>
<p>本质上都是因为害怕被别人讨厌，所以故意用过去的经历作为借口，来拒绝被讨厌的情况发生。</p>
<p>对于那些人来说，维持现状是最符合内心舒适的感觉，因此会制造很多的借口。</p>
<p>但现状所带来的后果又一直在折磨，反复循环。</p>
<h2><span id="fan-nao-de-gen-yuan">烦恼的根源</span><a href="#fan-nao-de-gen-yuan" class="header-anchor">#</a></h2>
<p>人的不幸都是自己选择的，不是社会或者世界，而是自己亲手选择的。</p>
<p>烦恼的根源，都来自于人际关系。</p>
<p>总是希望获得别人的认可，因此为了避免不认可的情况，刻意做出了逃避</p>
<h2><span id="ru-he-kan-dai-zi-bei-gan">如何看待自卑感</span><a href="#ru-he-kan-dai-zi-bei-gan" class="header-anchor">#</a></h2>
<p>认为我是世界的中心。</p>
<p>认为所有人都在关注我的一举一动</p>
<p>认为我的事情，就是别人的事情，  以及别人的看法，就是我的价值。</p>
<p>为了避免被讨厌，搬出自己不行的自卑，来逃避</p>
<h2><span id="zen-me-huo-de-bei-tao-yan-de-yong-qi">怎么获得被讨厌的勇气？</span><a href="#zen-me-huo-de-bei-tao-yan-de-yong-qi" class="header-anchor">#</a></h2>
<p>课题分离</p>
<p>我无法掌控他人，他人也无法掌控我。</p>
<p>我的选择是我的课题，他的想法干涉不了我。</p>
<p>他的选择是他的课题，我不需要去干涉他。</p>
<p>我只要尽力做我想做的， 他如何回应，他是接受还是讨厌，是他的课题。我不应该为之付出痛苦或者焦虑的情绪。</p>
<p>我不能可以追求对方的回报，我也不能无底线的回报别人的付出，分离！</p>
<h2><span id="zen-me-huo-de-xing-fu">怎么获得幸福？</span><a href="#zen-me-huo-de-xing-fu" class="header-anchor">#</a></h2>
<h4><span id="ta-ren-gong-xian">“他人贡献”</span><a href="#ta-ren-gong-xian" class="header-anchor">#</a></h4>
<p>只要知道自己的存在是有价值的，是对他人、社会、整体有贡献的</p>
<p>只有在感觉自己有价值的时候，才能有勇气。</p>
<p>这个价值不是别人赋予的，而是自己赋予的，自己认可的价值。</p>
<p><strong>他人贡献不代表为了他人的期待而活，共同体，范围要看广，不只是某个人不满意就不代表你没有了他人贡献！</strong></p>
<h4><span id="zhi-mian-ren-sheng-de-ke-ti-gong-zuo-jiao-you-ai">直面人生的课题（工作、交友、爱）</span><a href="#zhi-mian-ren-sheng-de-ke-ti-gong-zuo-jiao-you-ai" class="header-anchor">#</a></h4>
<p>自己主动动起来，而不是等着别人来赠予。</p>
<p>无论遇到什么不好的反馈，都是别人的课题，我只要做了自己希望做的事情就好！</p>
<h2><span id="ru-he-shi-bie-ta-ren-gong-xian-zhong-de-ta-ren">如何识别他人贡献中的“他人”？</span><a href="#ru-he-shi-bie-ta-ren-gong-xian-zhong-de-ta-ren" class="header-anchor">#</a></h2>
<ol>
<li>
<p>优先信任而不是怀疑</p>
<p>永远保持对人的信任，而不是怀疑……</p>
</li>
<li>
<p>共同体理论。</p>
</li>
</ol>
<p>当你的行为被某人讨厌， 这个人并不代表的全部，不代表整个“共同体”</p>
<p>你的行为或者存在可以放大， 学校、公司、社会、家庭，都是共同体。</p>
<p>因此不要因为部分人的讨厌而自责，你对其他的人肯定仍然存在着贡献，不一定是行为，仅仅是存在就可以是贡献。</p>
<h2><span id="ru-he-gai-bian">如何改变</span><a href="#ru-he-gai-bian" class="header-anchor">#</a></h2>
<p>不再关注过去，不再幻想未来。</p>
<p>关注此时此刻</p>
<p>此时此刻就像漫无目的的跳舞。</p>
<p>但只要跳了，做了，就有一定的微小变化，无论最终是否达到，只要享受此时此刻就好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/" class="post-title-link" itemprop="url">java常见容器使用原理（Map\List等)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-07 23:29:15" itemprop="dateCreated datePublished" datetime="2022-07-07T23:29:15+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:51:46" itemprop="dateModified" datetime="2022-08-10T00:51:46+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/java%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java常见应用原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>[toc]</p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#arraylist-yuan-li">ArrayList原理</a></li>
<li><a href="#copyonwritearraylist-yuan-li">CopyOnWriteArrayList 原理</a>
<ul>
<li><a href="#wei-shi-me-xu-yao-xie-shi-fu-zhi">为什么需要写时复制？</a></li>
<li><a href="#ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu">如何避免多线程修改的冲突？</a></li>
<li><a href="#ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian">如何保证更新后，数组引用的变动能及时对外呈现？</a></li>
</ul>
</li>
<li><a href="#hashmap-he-xin-yuan-li">HashMap核心原理</a>
<ul>
<li><a href="#hashmap-wan-zheng-de-put-guo-cheng">hashMap完整的put过程</a></li>
<li><a href="#hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie">hashMap的扩容过程，java7和8扩容的区别</a></li>
<li><a href="#wei-shi-me-java8-yao-gai-cheng-wei-cha-fa">为什么java8要改成尾插法？</a></li>
<li><a href="#sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me">虽然解决了死循环问题， 但java8的hashMap仍然是线程不安全的，为什么？</a></li>
<li><a href="#ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni">具体到底满足什么情况，才会resize扩容呢？</a></li>
<li><a href="#kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni">扩容后，capacity扩容多少倍呢？</a></li>
</ul>
</li>
<li><a href="#concurrenthashmap-he-xin-yuan-li">ConcurrentHashMap 核心原理</a>
<ul>
<li><a href="#jdk6-7-zhong-de-shi-xian-yuan-li">JDK6-7中的实现原理</a>
<ul>
<li><a href="#chu-shi-hua-map">初始化map</a>
<ul>
<li><a href="#chu-shi-hua-segment-shu-zu-tong-guo-concurrencylevel-he-ssize">初始化segment数组（通过concurrencyLevel和ssize）</a></li>
<li><a href="#chu-shi-hua-segmentshift-duan-pian-yi-liang-he-segmentmask-duan-yan-ma">初始化segmentShift段偏移量和segmentMask段掩码</a></li>
<li><a href="#chu-shi-hua-mei-ge-segment">初始化每个segment</a></li>
</ul>
</li>
<li><a href="#ding-wei-segment">定位Segment</a></li>
<li><a href="#get-cao-zuo">get操作</a></li>
<li><a href="#put-cao-zuo">put操作</a></li>
<li><a href="#size-cao-zuo">size操作</a></li>
</ul>
</li>
<li><a href="#jdk8-de-gai-zao-sheng-ji-chong-yao">JDK8的改造升级（重要）</a></li>
</ul>
</li>
<li><a href="#concurrentlinkedqueue-he-xin-yuan-li">ConcurrentLinkedQueue核心原理</a></li>
</ul>
<!-- tocstop -->
</div> 
<h1><span id="arraylist-yuan-li">ArrayList原理</span><a href="#arraylist-yuan-li" class="header-anchor">#</a></h1>
<p>Q: 讲一下啊arrayList的扩容原理？<br>
A:<br>
比较简单，算出新容量后，直接Arrays.copy拷贝到新数组，搞定<br>
<img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/c0f46fd3dbc58ac475051f1102dd4c43f80fc8e0.png" alt="c0f46fd3dbc58ac475051f1102dd4c43f80fc8e0"></p>
<p>扩容容量= 原容量 + (原容量右移1位，即0.5倍)= 1.5倍<br>
<img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/395ae953519c9a0a9cba440644a6d8dd4999db66.png" alt="395ae953519c9a0a9cba440644a6d8dd4999db66"></p>
<hr>
<p>Q: arrayList的初始最大容量是多少？可以更改吗？<br>
A:<br>
初始容量为10。不可修改<br>
<img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/11f8400ec134b045dae9118f28877a284924b1c3.png" alt="11f8400ec134b045dae9118f28877a284924b1c3"></p>
<h1><span id="copyonwritearraylist-yuan-li">CopyOnWriteArrayList 原理</span><a href="#copyonwritearraylist-yuan-li" class="header-anchor">#</a></h1>
<p>就是一个写时复制列表</p>
<p>当发生“删除/修改/新增”时，会先新建一个数组，更新后的数据拷贝到数组中</p>
<p>最后再更新到CopyOnWriteArrayList的数组成员引用上。</p>
<h2><span id="wei-shi-me-xu-yao-xie-shi-fu-zhi">为什么需要写时复制？</span><a href="#wei-shi-me-xu-yao-xie-shi-fu-zhi" class="header-anchor">#</a></h2>
<p>针对多线程环境下，读多写少的情况，如果每个读都加线程同步，太浪费了</p>
<p>因此可以读的时候不加锁</p>
<p>只有写的时候加锁，写完更新</p>
<p>读的时候可能会有点延迟的数据，但不影响。</p>
<h2><span id="ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu">如何避免多线程修改的冲突？</span><a href="#ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu" class="header-anchor">#</a></h2>
<p>加了一个sync锁，修改动作是线程安全的。</p>
<h2><span id="ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian">如何保证更新后，数组引用的变动能及时对外呈现？</span><a href="#ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian" class="header-anchor">#</a></h2>
<p>数组成员设置成volatile</p>
<h1><span id="hashmap-he-xin-yuan-li">HashMap核心原理</span><a href="#hashmap-he-xin-yuan-li" class="header-anchor">#</a></h1>
<h2><span id="hashmap-wan-zheng-de-put-guo-cheng">hashMap完整的put过程</span><a href="#hashmap-wan-zheng-de-put-guo-cheng" class="header-anchor">#</a></h2>
<ol>
<li>首先，要获取key的哈希值。<br>
如果为空，就统一是0<br>
否则，调用对象的.hashCode()方法，接着再与自己的右移16位进行异或，以便充分利用高位信息。</li>
<li>接着判断内部node数组是否为空，如果是，先进行初始化扩容。默认为16。</li>
<li>根据(n-1)&amp;hash值，获取哈希表索引位置。 （&amp;的性能比取余要高,具体讨论见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21070971">CPU取余原理</a>）</li>
<li>哈希表的node数组中，存放的是每组链表的头节点。<br>
先检查头节点是否和自己要存放的key完全匹配 （hash值相同，key值相同，先hash再key，是因为hash的判断简单，key的equals判断可能会复杂）<br>
如果匹配，得到需要替换的节点。</li>
<li>头节点和自己要放的key不匹配，则判断一下这个头节点是否是红黑树节点，如果是，说明已经升级成红黑树了，调用putTree插入到红黑树中。</li>
<li>如果不是红黑树， 那就是遍历链表，完全匹配就得到需要替换的节点。如果到尾部了，也没匹配的，则插入新节点。</li>
<li>如果前面找到了要替换的节点，则判断一下是否可以替换（是否没要求putIfAbsent，或者value为null），是就替换，不是就结束</li>
<li>如果前面是插入了新节点，非替换， 则要modCount++（方便迭代器确认map是否更新），  同时++size， 然后和扩容阈值做判断， 如果太大，就resize进行扩容<br>
<img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/61d85897f346fb06cb884b84.png" alt="hashMap-put详解"></li>
</ol>
<hr>
<h2><span id="hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie">hashMap的扩容过程，java7和8扩容的区别</span><a href="#hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie" class="header-anchor">#</a></h2>
<ol>
<li>java7：</li>
</ol>
<ul>
<li>当resize时，新建一个数组newTable</li>
<li>遍历原table中的每个链表和节点，重新hash，找到新的位置放入</li>
<li>放入的方式是头插法，即始终插在链表的头节点。</li>
</ul>
<ol start="2">
<li>java8:</li>
</ol>
<ul>
<li>不再每个点rehash放置，而是最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标. 避免了频繁的哈希计算和搬移过程。</li>
<li>使用尾插法在链表上插入节点</li>
<li>桶内元素超过8个，链表转成红黑树</li>
</ul>
<hr>
<h2><span id="wei-shi-me-java8-yao-gai-cheng-wei-cha-fa">为什么java8要改成尾插法？</span><a href="#wei-shi-me-java8-yao-gai-cheng-wei-cha-fa" class="header-anchor">#</a></h2>
<p>A:<br>
多线程时，java7的map-put可能造成死循环。<br>
A线程扩容到那一半， 还处在遍历链表做头插法搬移的过程时，存了2个局部变量，当前链点now指向a， next指向b，正准备搬移（a-&gt;b-&gt;c这样的链表，a是头节点）</p>
<p>B线程则同时完成线程扩容，但是map里都是引用，浅拷贝，** 因为是头插法， 会导致顺序变化**， 原本a-&gt;b-&gt;c 变成了c-&gt;b-&gt;a。<br>
因此A恢复时， 链点还是a，next还是b， 于是往下走到了b， 取bbs的next时，已经变成了a， 于是发生了a-&gt;b-&gt;a的循环<br>
导致后续操作的next都是错误操作，引发环形指针。</p>
<p>java8里改成尾插法，这样做resize时，a-&gt;b-&gt;c 如果仍然哈希到同一个节点， 顺序是不会发生变化的。</p>
<hr>
<h2><span id="sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me">虽然解决了死循环问题， 但java8的hashMap仍然是线程不安全的，为什么？</span><a href="#sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
因为缺乏同步，导致同节点发生哈希碰撞时，if条件的判断都可能是有问题的，导致本该插在链表头节点后面的，结果直接作为链表头覆盖到数组上了。</p>
<hr>
<h2><span id="ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni">具体到底满足什么情况，才会resize扩容呢？</span><a href="#ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni" class="header-anchor">#</a></h2>
<p>A:<br>
　HashMap负载因子 LoadFactor，默认值为0.75f。<br>
　衡量HashMap是否进行Resize的条件如下：<br>
　HashMap.Size &gt;= Capacity * LoadFactor</p>
<p>另一种情况。JDK1.8源码中，执行树形化之前，会先检查数组长度，如果长度小于64，则对数组进行扩容，而不是进行树形化</p>
<hr>
<h2><span id="kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni">扩容后，capacity扩容多少倍呢？</span><a href="#kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni" class="header-anchor">#</a></h2>
<p>A:<br>
哈希表每次扩容是两倍</p>
<h1><span id="concurrenthashmap-he-xin-yuan-li">ConcurrentHashMap 核心原理</span><a href="#concurrenthashmap-he-xin-yuan-li" class="header-anchor">#</a></h1>
<p>CHM结构</p>
<p>每个concurrentHashMap里有一个segment数组</p>
<p>每个segment里有HashEntry数组</p>
<p>每个hashEntry可以演变为链表或者红黑树</p>
<p><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/1659369632360.png" alt="1659369632360"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_18300037/article/details/123795776">https://blog.csdn.net/qq_18300037/article/details/123795776</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/every__day/article/details/114293107">https://blog.csdn.net/every__day/article/details/114293107</a></p>
<h2><span id="jdk6-7-zhong-de-shi-xian-yuan-li">JDK6-7中的实现原理</span><a href="#jdk6-7-zhong-de-shi-xian-yuan-li" class="header-anchor">#</a></h2>
<h3><span id="chu-shi-hua-map">初始化map</span><a href="#chu-shi-hua-map" class="header-anchor">#</a></h3>
<h4><span id="chu-shi-hua-segment-shu-zu-tong-guo-concurrencylevel-he-ssize">初始化segment数组（通过concurrencyLevel和ssize）</span><a href="#chu-shi-hua-segment-shu-zu-tong-guo-concurrencylevel-he-ssize" class="header-anchor">#</a></h4>
<p>sszie即segment size，是seg数组的大小</p>
<p>ssize一定是2的N次方，且一定是 大于等于concurrencyLevel的最小值</p>
<p>sszie的最大值为65535</p>
<p>ssize的默认值是16</p>
<h4><span id="chu-shi-hua-segmentshift-duan-pian-yi-liang-he-segmentmask-duan-yan-ma">初始化segmentShift段偏移量和segmentMask段掩码</span><a href="#chu-shi-hua-segmentshift-duan-pian-yi-liang-he-segmentmask-duan-yan-ma" class="header-anchor">#</a></h4>
<p>这2个变量用于后面定位segment的散列算法使用</p>
<p>sshift  是 ssize的2的次方数</p>
<p>segmentShift  = 32 - sshift   默认等于32-4=28</p>
<p>segmentMask =  ssize -1  默认等于15</p>
<h4><span id="chu-shi-hua-mei-ge-segment">初始化每个segment</span><a href="#chu-shi-hua-mei-ge-segment" class="header-anchor">#</a></h4>
<p>每个segment里有一个entry数组</p>
<p>这个数组的大小cap也是2的N次方，  且大于等于 initialCapacity(就是你传的初始容量值) / ssize 即<strong>平均每段数量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<p>loadFactor默认0.75</p>
<p>initialCapatity默认值为16</p>
<h3><span id="ding-wei-segment">定位Segment</span><a href="#ding-wei-segment" class="header-anchor">#</a></h3>
<p>对于一个key ，先是获取hashcode， 然后对hashcode进行变种算法再散列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个算法能保证各位都能利用上，尽可能均匀， 相比hashmap里单纯和高16位做异或不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<p>segmentShift的作用是让hash通过右移动，只保留符合ssize的2进制位数长度</p>
<p>顺便通过和segmentMask进行&amp;操作，剔除其他的位</p>
<p>总目的就是为了让32位的hash偏移后保持在ssize的范围内</p>
<p>按默认值而言，即   (hash&gt;&gt;&gt;28) &amp; 15</p>
<h3><span id="get-cao-zuo">get操作</span><a href="#get-cao-zuo" class="header-anchor">#</a></h3>
<p>先按照上文进行哈希， 获取segment后再进行get操作</p>
<p>整个过程都不需要加锁！</p>
<p>除非读到的值时空的，才会加锁重读确认（可能是被修改过了）</p>
<p>获取segment这个操作中，涉及的数组count、存储HashEntry的value，都涉及成了volatile，保持可见性。</p>
<h3><span id="put-cao-zuo">put操作</span><a href="#put-cao-zuo" class="header-anchor">#</a></h3>
<p>put操作处理共享变量（例如count等）是一定会加锁的。</p>
<p>区别在于扩容时，只对某一个segment扩容，不会影响其他的segment</p>
<p>扩容时会先创建容量两倍的数组，重新放入后在修改引用。</p>
<p>CHM是插入前先判断，再选择是否扩容</p>
<p>而hashMap是插入后判断，再选择是否扩容</p>
<h3><span id="size-cao-zuo">size操作</span><a href="#size-cao-zuo" class="header-anchor">#</a></h3>
<p>size自然是要把所有segment里的size进行相加</p>
<p>但是for循环相加可能会有前面的segment被修改，导致size变化，但如果加锁又太耗时间</p>
<p>因此引入了modCount，如果统计完成过程中发现modCount变化，则会加锁的方式重新统计。</p>
<h2><span id="jdk8-de-gai-zao-sheng-ji-chong-yao">JDK8的改造升级（重要）</span><a href="#jdk8-de-gai-zao-sheng-ji-chong-yao" class="header-anchor">#</a></h2>
<p>在`JDK8中，它进行了以下重要改进：</p>
<ol>
<li>
<p>取消分段锁机制<code>（Segment）</code>，进一步降低冲突概率; 使用桶的概念。</p>
<p>其内部虽然仍然有 <code>Segment</code> 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构 上的用处。</p>
<p>因为不再使用 <code>Segment</code>，初始化操作大大简化，修改为 <code>lazy-load</code> 形式，这样可以有效避免 初始开销</p>
</li>
<li>
<p>size()方法做了优化，表达范围变大。原来<code>map</code>原有的<code>size</code>方法最大只能表达2的31次方减一，现在额外提供<code>mappingCount</code>方法，最大表示为2的63次方减一</p>
</li>
<li>
<p>使用 <code>Unsafe</code>、<code>LongAdder</code> 之类底层手段，进行极端情况的优化。使用 <code>CAS</code> 等操作，在特定场景进行无锁并发操作。 即get使用volatile读， 而put则使用cas进行并发put。</p>
</li>
<li>
<p>类似hashMap引入红黑树解构，同一个哈希槽元素个数超过一定的阙值后，单链表转化成红黑树;</p>
</li>
<li>
<p>支持多线程并发扩容，大大提升扩容速度。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zguoshuaiiii/article/details/78495332">(4条消息) java8中concurrentHashmap的改进_庄国帅哥的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40277163/article/details/122957808">(1条消息) JDK 8 ConcurrentHashMap_黄泥川水猴子的博客-CSDN博客_concurrenthashmap jdk8</a></p>
<h1><span id="concurrentlinkedqueue-he-xin-yuan-li">ConcurrentLinkedQueue核心原理</span><a href="#concurrentlinkedqueue-he-xin-yuan-li" class="header-anchor">#</a></h1>
<p>核心是使用CAS而不是锁来处理链式队列。</p>
<p>比较容易想到的是每次用cas来处理next指针的跟新以及tail指针的指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">                Node&lt;E&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        Node&lt;E&gt; t = tail;</span><br><span class="line">                        <span class="keyword">if</span> (t.casNext(<span class="literal">null</span>, n) &amp;&amp; casTail(t, n)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是缺点在于及时没有并发，也要频繁cas更新tail节点。</p>
<p>实际上只需要用到tail节点的时候再去定位即可。</p>
<p>所以设置了一个HOPS值</p>
<p>当tail节点和实际尾节点的距离大于等于HOPS值，才去定位并cas更新tail节点，否则只更新next指针。</p>
<p><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/1659795490061.png" alt="1659795490061"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">        Node&lt;E&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">            Node&lt;E&gt; t = tail;</span><br><span class="line">            <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">            Node&lt;E&gt; p = t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hops</span> <span class="operator">=</span> <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">                Node&lt;E&gt; next = succ(p);</span><br><span class="line">    		<span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                    <span class="comment">// 需要退出2层for循环，重新定位tail节点了</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                        <span class="keyword">continue</span> retry; </span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, n)) &#123;</span><br><span class="line">                    <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                      更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line"><span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                        casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = succ(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代价是距离越长，入队时定位队尾的时间越长。</p>
<p>但是效率总体上提升了， 因为通过增加对volatile变量的读操作来减少对volatile变量的写操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">hexo-next主题使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-06 23:27:35" itemprop="dateCreated datePublished" datetime="2022-07-06T23:27:35+08:00">2022-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 00:43:33" itemprop="dateModified" datetime="2022-08-13T00:43:33+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">博客搭建</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
 <div class="toc">
<!-- toc -->
<ul>
<li><a href="#tu-pian-zhi-chi-fang-da">图片支持放大</a></li>
<li><a href="#tian-jia-fang-wen-liang">添加访问量</a></li>
<li><a href="#valine-ping-lun-guo-nei-ban">valine评论（国内版）</a></li>
<li><a href="#she-jiao-lian-jie">社交链接</a></li>
<li><a href="#ban-quan">版权</a></li>
<li><a href="#sheng-ji-markdown-xuan-ran-qi-zhi-chi-cha-jian">升级markdown渲染器，支持插件</a></li>
<li><a href="#chao-lian-jie-yan-se-gai-bian">超链接颜色改变</a></li>
<li><a href="#xiu-gai-zuo-ce-cai-dan-lan">修改左侧菜单栏</a></li>
</ul>
<!-- tocstop -->
<p>[toc]用于编辑时目录跳转</p>
<h1><span id="tu-pian-zhi-chi-fang-da">图片支持放大</span><a href="#tu-pian-zhi-chi-fang-da" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wugenqiang/article/details/89057323">https://blog.csdn.net/wugenqiang/article/details/89057323</a><br>
fancybox本地无法使用，会导致加载失败<br>
主要是因为默认配置的cdn我们无法访问<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/Aelous_dp/article/details/107643344">https://blog.csdn.net/Aelous_dp/article/details/107643344</a><br>
需要改为如下：<br>
vendor:<br>
jquery: <a target="_blank" rel="noopener" href="//code.jquery.com/jquery-2.0.3.min.js">//code.jquery.com/jquery-2.0.3.min.js</a><br>
fancybox: <a target="_blank" rel="noopener" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js">//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js</a><br>
fancybox_css: <a target="_blank" rel="noopener" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css</a><br>
主要是本地无法连接他默认配置的那个CDN</p>
<h1><span id="tian-jia-fang-wen-liang">添加访问量</span><a href="#tian-jia-fang-wen-liang" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_34310405/article/details/102665373">https://blog.csdn.net/baidu_34310405/article/details/102665373</a></p>
<h1><span id="valine-ping-lun-guo-nei-ban">valine评论（国内版）</span><a href="#valine-ping-lun-guo-nei-ban" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48927364/article/details/123321038">https://blog.csdn.net/weixin_48927364/article/details/123321038</a><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/blue_zy/article/details/79071414">https://blog.csdn.net/blue_zy/article/details/79071414</a><br>
Valine交流群: 480972291<br>
配置再next的config里的valine:</p>
<p>waline国外版</p>
<h1><span id="she-jiao-lian-jie">社交链接</span><a href="#she-jiao-lian-jie" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44634406/article/details/122777058">https://blog.csdn.net/weixin_44634406/article/details/122777058</a></p>
<p>themes/next下的_config.yml，搜索social</p>
<p>图标库</p>
<p><a target="_blank" rel="noopener" href="http://www.fontawesome.com.cn/faicons/#web-application">http://www.fontawesome.com.cn/faicons/#web-application</a></p>
<p>想要其他的国内软件图标：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44634406/article/details/122777058">https://blog.csdn.net/weixin_44634406/article/details/122777058</a></p>
<p><a target="_blank" rel="noopener" href="https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a">https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a</a></p>
<h1><span id="ban-quan">版权</span><a href="#ban-quan" class="header-anchor">#</a></h1>
<p>hexo next config 中找到creative_commons， 各种设置为true</p>
<p>主config中设置url: ‘<a href="http://breakdawncoder.com/">http://breakdawncoder.com/</a>’</p>
<p>复制黏贴时带版权信息：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33430083/article/details/105626840">(1条消息) 新手如何给Hexo博客在复制时添加版权声明_只是学习学习的博客-CSDN博客</a></p>
<h1><span id="sheng-ji-markdown-xuan-ran-qi-zhi-chi-cha-jian">升级markdown渲染器，支持插件</span><a href="#sheng-ji-markdown-xuan-ran-qi-zhi-chi-cha-jian" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0bfc3029c980">https://www.jianshu.com/p/0bfc3029c980</a></p>
<h1><span id="chao-lian-jie-yan-se-gai-bian">超链接颜色改变</span><a href="#chao-lian-jie-yan-se-gai-bian" class="header-anchor">#</a></h1>
<p>打开 <code>Blog\themes\next\source\css\_common\components\post</code> 路径下的<code>post.styl</code> , 并在底部添加如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span>:<span class="title function_">not</span>(<span class="params">.btn</span>)&#123;</span><br><span class="line">  <span class="attr">color</span>: #6495ED; <span class="comment">//超链接显示颜色</span></span><br><span class="line">  border-<span class="attr">bottom</span>: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">	<span class="attr">color</span>: #0000FF;  <span class="comment">//鼠标移动上去后超链接颜色</span></span><br><span class="line">	font-<span class="attr">weight</span>: bold;</span><br><span class="line">	text-<span class="attr">decoration</span>: underline;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>颜色码链接:</strong> <a target="_blank" rel="noopener" href="https://www.sioe.cn/yingyong/yanse-rgb-16/">RGB颜色值与十六进制颜色码转换工具 (sioe.cn)</a></li>
</ul>
<h1><span id="xiu-gai-zuo-ce-cai-dan-lan">修改左侧菜单栏</span><a href="#xiu-gai-zuo-ce-cai-dan-lan" class="header-anchor">#</a></h1>
<p>themes/next下的_config.yml，查找menu</p>
<p>图标库：<a target="_blank" rel="noopener" href="http://www.fontawesome.com.cn/faicons/#web-application">http://www.fontawesome.com.cn/faicons/#web-application</a></p>
<p>新添加的菜单需要翻译对应的中文，打开theme/next/languages/zh-CN.yml，在menu下设置</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/" class="post-title-link" itemprop="url">java编译优化和语法糖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-06 22:55:46" itemprop="dateCreated datePublished" datetime="2022-07-06T22:55:46+08:00">2022-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 00:50:28" itemprop="dateModified" datetime="2022-08-10T00:50:28+08:00">2022-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/jvm%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">jvm原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#zao-qi-bian-yi-you-hua">早期编译优化</a>
<ul>
<li><a href="#di-yi-bu">第一步：</a>
<ul>
<li><a href="#ci-fa-fen-xi">-------词法分析：</a></li>
<li><a href="#yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan">-------语法分析（注意实际上只是生成一个语法树，还没做语法的校验）：</a></li>
<li><a href="#tian-chong-fu-hao-biao">-------填充符号表：</a></li>
</ul>
</li>
<li><a href="#di-er-bu">第二步：</a>
<ul>
<li><a href="#zhu-jie-chu-li-qi">-------注解处理器：</a></li>
</ul>
</li>
<li><a href="#di-san-bu">第三步：</a>
<ul>
<li><a href="#yu-yi-fen-xi">-------语义分析：</a></li>
<li><a href="#jie-yu-fa-tang">-------解语法糖:</a></li>
<li><a href="#zi-jie-ma-sheng-cheng">-------字节码生成：</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="#java-yu-fa-tang">java语法糖</a>
<ul>
<li><a href="#fan-xing-ca-chu">泛型擦除:</a></li>
<li><a href="#signature">Signature:</a></li>
<li><a href="#zi-dong-zhuang-xiang-chai-xiang-xun-huan">自动装箱拆箱、循环</a></li>
<li><a href="#tiao-jian-bian-yi">条件编译：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wan-qi-bian-yi-you-hua">晚期编译优化</a>
<ul>
<li><a href="#jie-shi-qi-interperter">解释器Interperter</a></li>
<li><a href="#bian-yi-qi">编译器</a></li>
</ul>
</li>
<li><a href="#wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou">晚期优化的一些常见措施(即运行中才会做优化的步骤）</a>
<ul>
<li><a href="#re-dian-dai-ma">----热点代码</a></li>
<li><a href="#rong-yu-fang-wen-xiao-chu">—冗余访问消除:</a></li>
<li><a href="#gong-gong-zi-biao-da-shi-xiao-chu">----公共子表达式消除</a></li>
<li><a href="#shu-zu-bian-jie-jian-cha">—数组边界检查：</a></li>
<li><a href="#yin-shi-yi-chang-chu-li">—隐式异常处理：</a></li>
<li><a href="#fang-fa-nei-lian">----方法内联:</a></li>
<li><a href="#tao-yi-fen-xi">----逃逸分析：</a></li>
<li><a href="#java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie">----java和C++， 即时编译和静态编译的区别：</a></li>
</ul>
</li>
<li><a href="#bian-yi-you-hua-wen-da-ti">编译优化问答题</a>
<ul>
<li><a href="#zao-qi-bian-yi-guo-cheng">早期编译过程</a></li>
<li><a href="#wan-qi-bian-yi-you-hua-1">晚期编译优化</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="zao-qi-bian-yi-you-hua">早期编译优化</span><a href="#zao-qi-bian-yi-you-hua" class="header-anchor">#</a></h1>
<p>编译过程大致分为3类：</p>
<ol>
<li>解析与填充符号表</li>
<li>注解处理</li>
<li>分析与字节码生成</li>
</ol>
<p>源码JavaCompiler里的关键过程：<br>
第一步：</p>
<p><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/da80a1a1a8f52928a88e81bac0766d8a0eeab3ed.png" alt="da80a1a1a8f52928a88e81bac0766d8a0eeab3ed"></p>
<p>第二步语法分析、词法分析</p>
<p><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/e87a2122c8d20662ac01c4a7f8af159ee4c8a865.png" alt="e87a2122c8d20662ac01c4a7f8af159ee4c8a865"><br>
第三步:</p>
<p><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/2fe67bfe0e1f3e543deba464130880231b32df7d.png" alt="2fe67bfe0e1f3e543deba464130880231b32df7d"><br>
第四步：<br>
执行注解处理<br>
<img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/08cce0ef45b40e3db03ec3c0362444eb3dee4a24.png" alt="08cce0ef45b40e3db03ec3c0362444eb3dee4a24"></p>
<p>接着就是语义分析及字节码生成<br>
<img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/19956ec4da3e080289d22e64e04b58e9253e0de0.png" alt="19956ec4da3e080289d22e64e04b58e9253e0de0"></p>
<p>以上的关键点:</p>
<ul>
<li>词法语法解析是第一步，生成符号</li>
<li>注解处理是第二步</li>
<li>然后语法糖、字节码都是第三步的事情。</li>
</ul>
<hr>
<p>上述步骤的详细解释：</p>
<h3><span id="di-yi-bu">第一步：</span><a href="#di-yi-bu" class="header-anchor">#</a></h3>
<h4><span id="ci-fa-fen-xi">-------词法分析：</span><a href="#ci-fa-fen-xi" class="header-anchor">#</a></h4>
<p>就是代码转成token标记。<br>
例如int a=b+2 转成   Int \a=\b+\2  这6个token。</p>
<h4><span id="yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan">-------语法分析（注意实际上只是生成一个语法树，还没做语法的校验）：</span><a href="#yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan" class="header-anchor">#</a></h4>
<p>根据生成的token，构造一个抽象语法树。</p>
<h4><span id="tian-chong-fu-hao-biao">-------填充符号表：</span><a href="#tian-chong-fu-hao-biao" class="header-anchor">#</a></h4>
<p>生成一个符号地址和符号信息构成的表格。<br>
(后面第三步的阶段会用于语义分析中的标注检查，  比如名字的使用是否和说明一致，也会用于产生中间代码）<br>
符号表是目标代码生成时的地址分配的依据</p>
<h3><span id="di-er-bu">第二步：</span><a href="#di-er-bu" class="header-anchor">#</a></h3>
<h4><span id="zhu-jie-chu-li-qi">-------注解处理器：</span><a href="#zhu-jie-chu-li-qi" class="header-anchor">#</a></h4>
<p>注解处理器会扫描抽象语法树中带注解的元素， 并进行语法树的更新。<br>
更新之后我们会重新走回解析与填充的过程，重新处理。<br>
这个处理器是一种插件，我们可以自己不断往其中去添加。</p>
<p>注意，上面这2步只是简单去对源文件做转换， 还不涉及任何语法相关的规则。</p>
<h3><span id="di-san-bu">第三步：</span><a href="#di-san-bu" class="header-anchor">#</a></h3>
<h4><span id="yu-yi-fen-xi">-------语义分析：</span><a href="#yu-yi-fen-xi" class="header-anchor">#</a></h4>
<p>判断语法树是否正确。分为2种检查：</p>
<ol>
<li>
<p>标注检查：   检查变量是否已被声明、 赋值、等式的数据类型是否匹配<br>
标注检查中会进行常量折叠， 把a=1+2折叠成3<br>
标注检查的范围比较小，不会有太多上下文依赖。</p>
</li>
<li>
<p>数据及控制流分析<br>
对程序上下文逻辑更进一步验证<br>
这里会涉及很多交互的上下文交互依赖<br>
比如 带返回值的方法是否全路径都包含了返回、  受检异常是否被外部处理、局部变量使用前是否被赋值。</p>
</li>
</ol>
<p>final 局部变量（或者final参数）和非final局部变量，生成的class文件没有区别。<br>
因为局部变量不会在常量池中持有符号引用， 所以不会有acesses_flasg信息。<br>
所以class文件不知道局部变量是不是final， 因此final局部对运行期没有任何影响， 只会在编译期去校验。</p>
<h4><span id="jie-yu-fa-tang">-------解语法糖:</span><a href="#jie-yu-fa-tang" class="header-anchor">#</a></h4>
<p>虚拟机本身不支持这种语法， 但是会在编译阶段 把这些语法糖转为 普通的语法结构（换句话说做了把语法糖代码变成了普通代码，  例如自动装拆箱，可能就是转成了包装方法的特定调用）</p>
<h4><span id="zi-jie-ma-sheng-cheng">-------字节码生成：</span><a href="#zi-jie-ma-sheng-cheng" class="header-anchor">#</a></h4>
<p>对象的初始化顺序， 实际上会在字节码生成阶段， 收敛到一个<init>方法中。 即init中控制了那些成员、以及构造方法的调用顺序<br>
类初始化同理，也是收敛到一个 <cinit>中<br>
PS： 注意，默认构造器是在填充符号表阶段完成的。<br>
字符串的替换（+操作转成sb） 是在字节码阶段生成的。<br>
完成了对语法树的遍历之后，会把最终的符号表交给ClassWRITE类，设计概念从一个字节码和文件</cinit></init></p>
<hr>
<h2><span id="java-yu-fa-tang">java语法糖</span><a href="#java-yu-fa-tang" class="header-anchor">#</a></h2>
<p>Q: java语法糖属于早期优化还是晚期优化？<br>
A: 属于早期优化。</p>
<h3><span id="fan-xing-ca-chu">泛型擦除:</span><a href="#fan-xing-ca-chu" class="header-anchor">#</a></h3>
<p>java中的泛型只在 程序源码中存在，  在编译后的字节码文件中已经替换为原生类型， 并会插入一些强制转换的代码。<br>
即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">f</span><span class="params">(T  t)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">a</span> <span class="operator">=</span> T.getA();</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">实际上是</span><br><span class="line"></span><br><span class="line">T  <span class="title function_">f</span><span class="params">(Object t)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> （T）t.getA();</span><br><span class="line">    <span class="keyword">return</span> (T)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即只在会方法的入口 和方法的出口处，做强制转换， 而实际上传入的都是原生类型，可以理解为object</p>
<p>神奇的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个编译会报错，认为有2种相同的方法， 因为编译后被擦除了。</p>
<p>然后下面这个例子却是tm能ok的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释:<br>
返回值不参与重载的选择，但是因为返回值作为描述符不一致，以至于可以在一个class文件中共存。<br>
必须用Sun JDK1.6才能编译通过</p>
<h3><span id="signature">Signature:</span><a href="#signature" class="header-anchor">#</a></h3>
<p>用于解决泛型歹来的参数类型的识别问题。<br>
可存储字节码层面的特征签名。<br>
字节码层面：   方法名称、参数顺序、参数类型、 返回值、受检查异常， 这5个决定了1个字节码层面的方法是否唯一。<br>
如果是java语法层面， 则签名只受方法名称、参数顺序、参数类型这3个的影响。</p>
<p>他会保存参数化类型的信息， 即虽然code里都转成了object， 但是其参数化类型还是通过signature保存到了元数据区， 可以通过反射获取参数化类型。</p>
<h3><span id="zi-dong-zhuang-xiang-chai-xiang-xun-huan">自动装箱拆箱、循环</span><a href="#zi-dong-zhuang-xiang-chai-xiang-xun-huan" class="header-anchor">#</a></h3>
<p>自动装箱拆箱:  就是在编译后， 自动把装拆箱的地方加上 Integer.valueOf()  或者  包装类型.intValue()</p>
<p>可变参数：被优化成一个数组<br>
Arrays.asList(“1”,“2”,“3”,“4”)   =&gt;   Arrays.asList(new String[]{ “1”, “2”, “3”, “4”})</p>
<p>带iterator接口的  for循环：<br>
for(String str :   listStr) {<br>
}<br>
被优化成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">Interator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); it.hasNext()) &#123;</span><br><span class="line">    xxx   it.next xxx...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line"><span class="type">Long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br></pre></td></tr></table></figure>
<p>// true, 小于128，用常量池里的常量比较<br>
System.out.println(c == d);<br>
// false,非常量池，用各自不同的地址比较<br>
System.out.println(e == f );<br>
// true， 同1<br>
System.out.println(c == (a+b));<br>
// true， Integer<br>
System.out.println(c.equals(a+b));<br>
// true， 这个为什么==是可以的，是因为Long小于128时，也会用常量池的值吗<br>
System.out.println(g == (a+b));<br>
// false , equals不处理数据转型的关系。<br>
System.out.println(g.equals(a+b));</p>
<h3><span id="tiao-jian-bian-yi">条件编译：</span><a href="#tiao-jian-bian-yi" class="header-anchor">#</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">xxx</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    yyy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被优化成了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure>
<p>因为编译器很明确只能走xxx这个分支。<br>
只能用于if+常量</p>
<p>使用常量与其他带有条件判断能力的语句搭配，则会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个会报错unreachable statement code<br>
<img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/20210719233205601.png" alt="为什么呢？"><br>
因为系统检测到这句代码是永远无法到达的分支，直接给你禁掉了</p>
<h1><span id="wan-qi-bian-yi-you-hua">晚期编译优化</span><a href="#wan-qi-bian-yi-you-hua" class="header-anchor">#</a></h1>
<p>HotSpot中，  <strong>解释器与编译器共存</strong>。<br>
当程序刚启动时，会先马上使用解释器发挥作用。<br>
在程序运行后， 编译器逐步发挥作用，把还没用到的代码逐步编译。<br>
内存资源比较少的情况下，可以用解释器来跑程序，减少编译生成的文件。<br>
如果编译器的优化出现bug，可以通过“逆优化”回退到最初的解释器模式来运行</p>
<h3><span id="jie-shi-qi-interperter">解释器Interperter</span><a href="#jie-shi-qi-interperter" class="header-anchor">#</a></h3>
<h3><span id="bian-yi-qi">编译器</span><a href="#bian-yi-qi" class="header-anchor">#</a></h3>
<p>有两种编译器</p>
<ul>
<li>
<p>Client Compiler ——C1编译器,  更高的编译速度</p>
</li>
<li>
<p>Server Compiler——C2编译器， 更好的编译质量<br>
即选择了-client或者-server时会用到。</p>
</li>
<li>
<p>默认混合模式：  解释器和编译器共存， 即MixedMode。</p>
</li>
</ul>
<p>关于这2种编译器的参数：</p>
<ul>
<li>-Xint参数： 强制使用解释模式</li>
<li>-Xcomp参数： 强制使用编译模式（ 但是如果编译无法进行时，  解释会介入）</li>
</ul>
<hr>
<p>混合模式中， 解释器需要收集性能信息，提供给编译阶段判断和优化， 这个性能信息有点浪费<br>
因此JDK7引入了<strong>分层编译</strong>策略：</p>
<ul>
<li>第0层：  解释执行。  不开启性能监控。</li>
<li>第1层： C1编译，  把字节码编译为本地代码，  进行一些简单优化，   加入性能监控</li>
<li>第2层： C2编译，   启动耗时较长的优化，  根据性能监控信息进行激进优化</li>
</ul>
<hr>
<p>CC和SC编译过程的区别：</p>
<ul>
<li>
<p>client Compiler 编译过程：<br>
前端字节码-》  方法内联/常量传播（基础优化）-》 HIR（高级中间代码）-》 空值检查消除/范围检查消除<br>
-》 后端把HIR转成LLR（低级中间代码）-》 线性扫描算法分配寄存器-》窥孔优化-》机器码生成-》本地代码生成<br>
都是一些不需要运行期信息就能做优化的操作</p>
</li>
<li>
<p>serverCompiler编译过程：<br>
会执行<strong>所有的经典优化动作</strong><br>
会根据cc或者解释器提供的监控信息，进行<strong>激进的优化</strong><br>
寄存器分配器是一个全局图着色分配器</p>
</li>
</ul>
<hr>
<h1><span id="wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou">晚期优化的一些常见措施(即运行中才会做优化的步骤）</span><a href="#wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou" class="header-anchor">#</a></h1>
<h3><span id="re-dian-dai-ma">----热点代码</span><a href="#re-dian-dai-ma" class="header-anchor">#</a></h3>
<ol>
<li>被多次调用的方法。  会触发JIT编译</li>
<li>被多次执行的循环体，  会触发OSR编译（栈上替换）， 发生在方法执行过程中， 所以是在栈上编译并切换方法。</li>
</ol>
<p>HotSpot 使用 计数器的热点探测法确定热点代码。<br>
* 给每个方法建立方法计数器， 在一个周期中如果超过阈值， 就触发JIT编译，编译后替换方法入口。<br>
* 如果一个周期内没超过，则计数器/2（半衰）<br>
* 如果没有触发时， 都是用解释方式 按照字节码内容死板地运行。</p>
<blockquote>
<blockquote>
<p>该计数器的相关参数<br>
-XX:-UserCounterDecay 关闭热度衰减<br>
-XX: CounterHalfLifeTime  设置半衰期-XX:CompileThreshold 设置方法编译阈值</p>
</blockquote>
</blockquote>
<p>回边计数器就是计算循环次数的计数器<br>
* 没有半衰<br>
* 但是当触发OSR编译时，会把计数器降低，避免还在运行时重复触发。<br>
* 会溢出， 并且会把方法计数器也调整到溢出。<br>
*  clint模式和server模式中，  OSR的阈值计算公式不同，   clint= CompileThredshold * osr比率，    server= CompileThredshold * (osr比率 - 解释器监控比率）</p>
<h3><span id="rong-yu-fang-wen-xiao-chu">—冗余访问消除:</span><a href="#rong-yu-fang-wen-xiao-chu" class="header-anchor">#</a></h3>
<p>如果已经拿到了  a.value， 该方法内a.value一定不会变的话， 那么后续用到时就不再从a中取value了<br>
复写传播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y=b.value</span><br><span class="line">z=<span class="type">y</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span> z + y</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = b.<span class="type">value</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="type">y</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span> y + y</span><br></pre></td></tr></table></figure>
<p>无用代码消除：<br>
去掉上面的Y=y</p>
<h3><span id="gong-gong-zi-biao-da-shi-xiao-chu">----公共子表达式消除</span><a href="#gong-gong-zi-biao-da-shi-xiao-chu" class="header-anchor">#</a></h3>
<p>就是对一些比较长的计算公式做化简<br>
a+（a+b）<em>2<br>
会优化成<br>
a</em>3+b*2<br>
尽可能减少计算次数</p>
<h3><span id="shu-zu-bian-jie-jian-cha">—数组边界检查：</span><a href="#shu-zu-bian-jie-jian-cha" class="header-anchor">#</a></h3>
<p>如果能确定某个for循环里的数组取值操作一定不会超出数组范围，那么在做[]取值操作时，不会做数组边界检查。</p>
<h3><span id="yin-shi-yi-chang-chu-li">—隐式异常处理：</span><a href="#yin-shi-yi-chang-chu-li" class="header-anchor">#</a></h3>
<p>if(a == null) {<br>
xxx<br>
}<br>
else{<br>
throw Exception<br>
}<br>
优化成<br>
try {<br>
xxx<br>
} catch(Exception e) {<br>
throw e<br>
}</p>
<p>为什么隐式异常处理不能放在早期优化？<br>
<img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/f25fce1b1f632496074589dad0c260c0f1cc936a.png" alt="f25fce1b1f632496074589dad0c260c0f1cc936a"></p>
<h3><span id="fang-fa-nei-lian">----方法内联:</span><a href="#fang-fa-nei-lian" class="header-anchor">#</a></h3>
<p>不能被继承重写的方法，比如私有、构造器、静态之类的方法，可以直接在早期优化中做内联优化。<br>
而其他会被抽象继承实现的方法在编译器无法做内联，因为他不知道实际是用哪一段代码。</p>
<ul>
<li>final方法并不是非虚方法（为什么呢）</li>
<li>类型继承关系分析CHA：   如果发现虚方法，CHA会查一下当前虚拟机内该方法是否有多个实现， 如果发现只有这一种实现，那么就可以直接内联。</li>
<li>如果后续有其他的class动态加载进来后，该方法有多个实现了，并且被使用到了，那么就会抛弃已编译的内联代码，回退到解释状态执行。</li>
<li>内联缓存：  即使程序中发现该方法有多个实现， 依然对第一个使用的那个方法做内联，除非有其他重写方法被调用（即虽然你定义了，但是你很可能不用，所以我一直使用你的第一个方法，除非你真的用了多种重写方法去跑。</li>
</ul>
<h3><span id="tao-yi-fen-xi">----逃逸分析：</span><a href="#tao-yi-fen-xi" class="header-anchor">#</a></h3>
<p>分析new 出来的对象是否不会逃逸到方法外，  如果确认只在方法内使用，外部不会有人引用他， 那么就会做优化，比如：<br>
* 不把new出来的对象放到堆，而是放到方法栈上，方法结束了对象直接消失。<br>
* 不需要对这种对象做加锁、同步操作了<br>
* 标量替换:   把这个对象里的最小基本类型成员拆出来作为局部变量使用。</p>
<h3><span id="java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie">----java和C++，  即时编译和静态编译的区别：</span><a href="#java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie" class="header-anchor">#</a></h3>
<ol>
<li>即时编译可能会影响用户体验，如果在运行中出现较大影响的延迟的话<br>
2.<br>
java中虚方法比C<ins>要多， 因为做各种内联分析消耗的检查和优化的就越多越大<br>
3.<br>
java中总是要做安全检查， C</ins>中不做，出错了我就直接崩溃了越界了<br>
4.<br>
C<ins>中内存释放让用户控制， 无需后台弄一个垃圾回收器总是去检查和操作<br>
5.<br>
java好处： 即时编译能够以运行期的性能监控进行优化，这个是C</ins>无法做到的。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40925525/article/details/98363179">https://blog.csdn.net/qq_40925525/article/details/98363179</a></p>
<hr>
<h1><span id="bian-yi-you-hua-wen-da-ti">编译优化问答题</span><a href="#bian-yi-you-hua-wen-da-ti" class="header-anchor">#</a></h1>
<p>@[toc]<br>
首先提出一个问题，为什么C++的编译速度会比java慢很多？二者运行程序的速度差异子啊那？  了解了java的早期和晚期过程，就能理解这个问题了。</p>
<p>这里会提15个问题确认是否真的理解，如果完全没这方面的概念，则好好看一下前面的<a href>早期和晚期编译优化读书笔记</a></p>
<h3><span id="zao-qi-bian-yi-guo-cheng">早期编译过程</span><a href="#zao-qi-bian-yi-guo-cheng" class="header-anchor">#</a></h3>
<hr>
<p>Q: java早期编译过程分为哪3步？<br>
A:</p>
<ol>
<li>词法语法解析、填充符号表</li>
<li>注解处理</li>
<li>语义分析与字节码生成。</li>
</ol>
<hr>
<p>Q: 上面的步骤中， <strong>符号表</strong>是干吗的？<br>
A:<br>
符号表是符号地址和符号信息构成的表格。</p>
<ul>
<li>用于后面阶段做语法检查时，从表里取出信息进行对比。</li>
<li>符号表是目标代码生成时的地址分配的依据</li>
</ul>
<hr>
<p>Q: 注解处理器做的什么事情？<br>
A: 注解处理器会扫描抽象语法树中带注解的元素， 并进行语法树的更新。<br>
重点就是他是基于语法树做更新。<br>
更新之后我们会重新走回解析与填充的过程，重新处理。</p>
<p>APT可以用来在编译时扫描和处理注解。<br>
通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来<strong>自动的生成一些代码</strong>，省去了手动编写。 例如@Setter<br>
注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。</p>
<hr>
<hr>
<p>Q: 上面的3个步骤中， 解语法糖是哪一步？<br>
A:<br>
是第三步，在生成字节码的时候才做的语法糖处理。</p>
<hr>
<p>Q: 什么是解语法糖？大概有哪些？<br>
A:</p>
<ul>
<li>虚拟机本身不支持这种语法， 但是会在编译阶段 把这些语法糖转为 普通的语法结构。</li>
<li>包含自动装拆箱、 泛型强转应用。</li>
</ul>
<hr>
<p>Q: 生成字节码class文件的时候， final和非final的局部变量， 会有区别不？<br>
A:<br>
没有区别。<br>
局部变量不会在常量池中持有符号引用， 所以不会有acesses_flasg信息。<br>
** 因此final局部变量在运行期没有任何作用， 只会在编译期去校验。**</p>
<hr>
<p>Q:   a= 1 + 2会在什么阶段进行优化？<br>
A: 会在早期编译过程的语义分析过程中，进行常量折叠， 变成a=3<br>
同理， 字符串+号优化成stringBuilder.append()这个动作也是该阶段优化的。</p>
<hr>
<p>Q:  类对象加载的过程有一堆顺序（具体见<a href="xxx">类初始化顺序</a>，  这个顺序在字节码中体现的吗？还是运行的时候再判断顺序？<br>
A:<br>
字节码中体现的。</p>
<ul>
<li>在字节码生成时，  编译器针对对象new的过程，会生成了一个<init>方法，里面写明了成员、构造方法的调用顺序。</init></li>
<li>类静态成员的调用顺序同理封装在<cinit>中。</cinit></li>
</ul>
<hr>
<h3><span id="wan-qi-bian-yi-you-hua">晚期编译优化</span><a href="#wan-qi-bian-yi-you-hua" class="header-anchor">#</a></h3>
<p>Q:<br>
早期编译优化和晚期编译优化的区别？<br>
A:</p>
<ul>
<li>早期编译优化， 是把 java文件转成字节码，转字节码的过程中做一些简单优化和语法糖处理。</li>
<li>晚期编译优化，是将字节码转机器码执行的过程中，结合一些信息进行动态优化，或者应用上很多的机器码优化措施。</li>
</ul>
<hr>
<p>Q: java程序运行的时候，是直接全部转成优化后的机器码再运行吗？<br>
A:<br>
错误。</p>
<ul>
<li>当程序刚启动时，会先马上使用<strong>解释器</strong>发挥作用，这时候没做太多优化，直接解释执行。</li>
<li>在程序运行后， <strong>编译器</strong>逐步发挥作用，把还没用到的代码逐步编译成机器码。</li>
</ul>
<blockquote>
<blockquote>
<p>注意这里的编译器和之前提到的编译器的区别，一个是编译成字节码，另一个是编译成机器码。</p>
</blockquote>
</blockquote>
<hr>
<hr>
<p>Q: JIT是什么？<br>
A:<br>
为了提高执行速度，便引入了 JIT 技术。<br>
当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。</p>
<hr>
<p>Q: 有两种晚期优化编译器</p>
<ul>
<li>Client Compiler ——C1编译器</li>
<li>Server Compiler——C2编译器<br>
他们二者的区别是什么？</li>
</ul>
<p>A:</p>
<ul>
<li>速度和质量的区别：<br>
C1编译器,  更高的编译速度，编译质量一般。<br>
C2编译器， 更好的编译质量，但是速度慢。</li>
<li>优化特性的区别<br>
C1编译器都是一些不需要运行期信息就能做优化的操作。<br>
C2编译器则会根据解释器提供的监控信息，进行<strong>激进且动态的优化</strong></li>
</ul>
<hr>
<p>Q: java中怎么区分用C1还是C2？<br>
A:<br>
关于这2种编译器的参数：</p>
<ul>
<li>-Xint参数： 强制使用解释模式</li>
<li>-Xcomp参数： 强制使用编译模式（ 但是如果编译无法进行时，  解释会介入）</li>
<li>选择编译模式时，有-client、-server还有MixedMode(混合模式）可以选择</li>
</ul>
<blockquote>
<blockquote>
<p>混合模式中， JDK7引入了<strong>分层编译</strong>策略：<br>
第0层：  解释执行。  不开启性能监控。<br>
第1层： C1编译，  把字节码编译为本地代码，  进行一些简单优化，   加入性能监控<br>
第2层： C2编译，   启动耗时较长的优化，  根据性能监控信息进行激进优化</p>
</blockquote>
</blockquote>
<hr>
<p>Q: 分层优化中，如果正在运行，jvm是怎么知道需要对哪些代码做JIT或者OSR优化？<br>
A:</p>
<ol>
<li>被多次调用的方法。  会触发JIT编译（热点代码计数器）</li>
<li>被多次执行的循环体，  会触发OSR编译（栈上替换）， 发生在方法执行过程中， 所以是在栈上编译并切换方法。（使用回边计数器）</li>
</ol>
<hr>
<p>Q: 哪些方法会在早期优化中做内联，哪些方法会在晚期优化中做内联？<br>
A:</p>
<ul>
<li>不能被继承重写的方法，比如私有、构造器、静态之类的方法，可以直接在早期优化中做内联优化。</li>
<li>其他会被<strong>抽象继承实现的方法</strong>在早期无法做内联，因为他不知道实际是用哪一段代码.</li>
<li>晚期优化中可以根据一些运行信息，判断是否总是只用某个子类方法跑，是的话做一下尝试内联，如果后面来了其他的子类就切回去。</li>
</ul>
<hr>
<p>Q: java数组一般都会自动做边界检查，不满足就抛异常。 什么情况下会优化掉这个自动检查？<br>
A:<br>
运行期，发现传入的参数放到数组中用的时候， 肯定不会超出边界，则会优化掉这个检查动作。</p>
<hr>
<p>看完上面的，就可以给出C++和java编译和运行速度差距的原因了：</p>
<ol>
<li>java即时编译可能会影响用户体验，如果在运行中出现较大影响的延迟的话。</li>
<li>java中虚方法比C++要多， 因为做各种内联分析消耗的检查和优化的就越多越大</li>
<li>java中总是要做安全检查， C++中不做，出错了我就直接崩溃了越界了</li>
<li>C++中内存释放让用户控制， 无需后台弄一个垃圾回收器总是去检查和操作</li>
<li>java好处： 即时编译能够以运行期的性能监控进行优化，这个是C++无法做到的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/home/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/home/">1</a><span class="page-number current">2</span><a class="page-number" href="/home/page/3/">3</a><a class="page-number" href="/home/page/4/">4</a><a class="extend next" rel="next" href="/home/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/182319148" title="Genshin-UID → 182319148"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
