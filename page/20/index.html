<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="破晓的知识屋">
<meta property="og:url" content="http://breakdawncoder.com/page/20/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">计网之应用层详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 21:47:49" itemprop="dateCreated datePublished" datetime="2022-08-24T21:47:49+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-25 00:15:22" itemprop="dateModified" datetime="2022-08-25T00:15:22+08:00">2022-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="计网之应用层详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#1-dns">1 DNS</a>
<ul>
<li><a href="#1-1-yu-ming">1.1 域名</a></li>
<li><a href="#1-2-yu-ming-fu-wu-qi">1.2 域名服务器</a></li>
<li><a href="#1-3-yu-ming-cha-zhao-ji-zhi">1.3 域名查找机制</a>
<ul>
<li><a href="#1-3-1-die-dai-cha-zhao-zui-chang-yong">1.3.1 迭代查找（最常用）</a></li>
<li><a href="#1-3-2-di-gui-cha-zhao-hen-shao">1.3.2 递归查找（很少）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ftp-wen-jian-chuan-song-xie-yi">2 FTP文件传送协议</a>
<ul>
<li><a href="#2-1-wen-jian-shang-chuan-guo-cheng">2.1 文件上传过程</a></li>
<li><a href="#2-2-wen-jian-xia-zai-guo-cheng">2.2 文件下载过程</a></li>
<li><a href="#3-tftp-jian-dan-wen-jian-chuan-song-xie-yi">3 TFTP 简单文件传送协议</a>
<ul>
<li><a href="#3-1-p2p-wen-jian-chuan-shu">3.1 P2P文件传输</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-smtp-dian-zi-you-jian-xie-yi">4 SMTP电子邮件协议</a>
<ul>
<li><a href="#4-1-zu-jian-gou-cheng">4.1 组件构成</a>
<ul>
<li><a href="#4-1-1-yong-hu-dai-li-ua-user-agent">4.1.1 用户代理UA（user agent)</a></li>
<li><a href="#4-1-2-you-jian-fu-wu-qi">4.1.2 邮件服务器</a></li>
<li><a href="#4-1-3-xie-yi">4.1.3 协议</a></li>
</ul>
</li>
<li><a href="#4-2-tong-xin-bu-zou">4.2 通信步骤</a>
<ul>
<li><a href="#4-2-1-lian-jie-jian-li">4.2.1 连接建立</a></li>
<li><a href="#4-2-2-you-jian-chuan-song">4.2.2 邮件传送</a></li>
<li><a href="#4-2-3-lian-jie-shi-fang">4.2.3 连接释放</a></li>
<li><a href="#4-2-4-pop-tui-song-gei-ke-hu-duan-ua">4.2.4 POP推送给客户端UA</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="1-dns">1 DNS</span><a href="#1-dns" class="header-anchor">#</a></h1>
<ul>
<li>全称Domain Name System，  域名系统。</li>
<li>传输层使用UDP协议，端口为53</li>
</ul>
<p>Q: DNS为什么要使用UDP协议呢？<br>
A:<br>
DNS这个东西通信模式相当固定，报文基本上一个包搞定。大多数情况一问一答就结束了。<br>
你三次握手来回3个包呢，人家一来一回就已经结速了，这种时候搞什么TCP？有必要中间连续穿好几次数据保证可靠性么？</p>
<h2><span id="1-1-yu-ming">1.1 域名</span><a href="#1-1-yu-ming" class="header-anchor">#</a></h2>
<ul>
<li>
<p>域名由 “标号.标号.标号”组成<br>
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Rk1b92vm-1613753140851)(en-resource://database/2048:1)]</p>
</li>
<li>
<p>标号由字母和“-”组成。</p>
</li>
<li>
<p>标号不超过63个字符</p>
</li>
<li>
<p>总域名（标号之和）不能超过255</p>
</li>
<li>
<p>分为根、顶级、二级、三级<br>
<img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004639910.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>顶级域名分类：</p>
<ol>
<li>国家顶级域名nTLD: 例如cn\us</li>
<li>通用顶级域名gTLD:例如com\net\gov</li>
<li>基础建设顶级域（arpa）<br>
4.测试顶级域</li>
</ol>
</li>
<li>
<p>域名和ip可以是多对多的关系， 即1个域名可以对应多个ip（分布式多活）， 1个ip也可以被绑定成不同的域名。</p>
</li>
</ul>
<h2><span id="1-2-yu-ming-fu-wu-qi">1.2 域名服务器</span><a href="#1-2-yu-ming-fu-wu-qi" class="header-anchor">#</a></h2>
<ul>
<li>每个域名和ip的对应关系都会存在域名服务器中。</li>
<li>DNS采用分区的方式，解决域名服务器过多的问题，每个域名服务器管理一个区。</li>
<li>分布式部署，C/S模式<br>
<img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004730567.png" alt="在这里插入图片描述"></li>
</ul>
<h2><span id="1-3-yu-ming-cha-zhao-ji-zhi">1.3 域名查找机制</span><a href="#1-3-yu-ming-cha-zhao-ji-zhi" class="header-anchor">#</a></h2>
<h3><span id="1-3-1-die-dai-cha-zhao-zui-chang-yong">1.3.1 迭代查找（最常用）</span><a href="#1-3-1-die-dai-cha-zhao-zui-chang-yong" class="header-anchor">#</a></h3>
<p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004747600.png" alt="在这里插入图片描述"></p>
<ol>
<li>查找域名时，会先根据缓存，再根据本机host文件</li>
<li>当本地都没有，就会启动dns域名查找机制。</li>
<li>迭代查找记住就是会以本地DNS服务器为关键节点， 先去根域名寻求顶级域名服务器的ip</li>
<li>再去顶级域名却寻二级域的位置， 最后再去权威DNS服务器查找最终位置。</li>
</ol>
<ul>
<li>注意像根域名服务器的位置一般也会做缓存，所以1、2、3这几步一般也是不用重复去做的，很可能查询一个陌生的域名时，直接在本地DNS那边定位到了4那一步。</li>
</ul>
<h3><span id="1-3-2-di-gui-cha-zhao-hen-shao">1.3.2 递归查找（很少）</span><a href="#1-3-2-di-gui-cha-zhao-hen-shao" class="header-anchor">#</a></h3>
<p>递归其实就是从根域名如果找不到， 则让根域名发起请求向顶级域名查询。<br>
即发起请求的对象变了，这种显然会占用根域名服务器的客户端资源，明显不好。</p>
<h1><span id="2-ftp-wen-jian-chuan-song-xie-yi">2 FTP文件传送协议</span><a href="#2-ftp-wen-jian-chuan-song-xie-yi" class="header-anchor">#</a></h1>
<p>基于TCP传输，可靠性高。</p>
<h2><span id="2-1-wen-jian-shang-chuan-guo-cheng">2.1 文件上传过程</span><a href="#2-1-wen-jian-shang-chuan-guo-cheng" class="header-anchor">#</a></h2>
<p>客户端发送PASV命令<br>
<img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/20210220004800504.png" alt="在这里插入图片描述"></p>
<p>可以看到FTP服务器会给每个连接建立相应独立的控制进程和数据进程。</p>
<h2><span id="2-2-wen-jian-xia-zai-guo-cheng">2.2 文件下载过程</span><a href="#2-2-wen-jian-xia-zai-guo-cheng" class="header-anchor">#</a></h2>
<p>其实就是发送了PORT命令：<br>
PORT h1,h2,h3,h4,p1,p2 (h1-h4是IP地址，p1-p2是端口号)<br>
<img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/2021022000481735.png" alt="在这里插入图片描述"></p>
<p>可以看到下载过程是FTP服务器向对方发起连接</p>
<hr>
<ul>
<li>注意上面发起会话时，会有身份认证的过程，同时也可以配置用户权限。</li>
<li>FTP不适合在2个计算机直接进行共享读写文件（因为会进行资源占用）， 只适合单次的上传和下载。</li>
<li></li>
</ul>
<h2><span id="3-tftp-jian-dan-wen-jian-chuan-song-xie-yi">3 TFTP 简单文件传送协议</span><a href="#3-tftp-jian-dan-wen-jian-chuan-song-xie-yi" class="header-anchor">#</a></h2>
<ul>
<li>使用UDP传输</li>
<li>支持文件传输但是无交互命令</li>
<li>应用层报文按序编号</li>
<li>熟知端口为69</li>
<li>代码轻量，程序占用小</li>
<li>传输过程类似于停止-等待协议:</li>
</ul>
<blockquote>
<blockquote>
<p>单帧滑动-停止等待协议</p>
<ul>
<li>一次只发一帧，1次只收一帧，并确认占有信道后才继续</li>
<li>发送端：收到ack确认后，才会发下一个，每个都有个定时器</li>
<li>接收端：序号不匹配递增的话都会丢弃。</li>
</ul>
</blockquote>
</blockquote>
<h3><span id="3-1-p2p-wen-jian-chuan-shu">3.1 P2P文件传输</span><a href="#3-1-p2p-wen-jian-chuan-shu" class="header-anchor">#</a></h3>
<p>FTP和TFTP，都可能是有人把文件存在一个集中的服务器上，大家去下载上传。</p>
<p>而P2P则是建立了主机和主机间的直接通信， 不需要依赖中间服务器</p>
<ul>
<li>类似于别人直接从你电脑的目录上下载文件而不是从百度网盘里下载</li>
</ul>
<h1><span id="4-smtp-dian-zi-you-jian-xie-yi">4 SMTP电子邮件协议</span><a href="#4-smtp-dian-zi-you-jian-xie-yi" class="header-anchor">#</a></h1>
<h2><span id="4-1-zu-jian-gou-cheng">4.1 组件构成</span><a href="#4-1-zu-jian-gou-cheng" class="header-anchor">#</a></h2>
<h3><span id="4-1-1-yong-hu-dai-li-ua-user-agent">4.1.1 用户代理UA（user agent)</span><a href="#4-1-1-yong-hu-dai-li-ua-user-agent" class="header-anchor">#</a></h3>
<p>其实就是邮件客户端，类似于foxmail、outlook、qq邮箱等exe程序，</p>
<h3><span id="4-1-2-you-jian-fu-wu-qi">4.1.2 邮件服务器</span><a href="#4-1-2-you-jian-fu-wu-qi" class="header-anchor">#</a></h3>
<ul>
<li>功能： 发送和接收邮件，报告邮件的传送情况</li>
<li>具备C/S工作模式：  发送邮件时是一个客户端，接收邮件时是一个服务端</li>
<li>不同邮件提供商有自己的服务器，但是他们之间可以互相通信。</li>
</ul>
<h3><span id="4-1-3-xie-yi">4.1.3 协议</span><a href="#4-1-3-xie-yi" class="header-anchor">#</a></h3>
<p>使用SMTP接收协议和POP读取服务完成整套邮件系统协议。</p>
<h2><span id="4-2-tong-xin-bu-zou">4.2 通信步骤</span><a href="#4-2-tong-xin-bu-zou" class="header-anchor">#</a></h2>
<h3><span id="4-2-1-lian-jie-jian-li">4.2.1 连接建立</span><a href="#4-2-1-lian-jie-jian-li" class="header-anchor">#</a></h3>
<ul>
<li>用户使用UA发送邮件到自己UA所属的邮件服务器</li>
<li>服务器定期扫描，发现有新的未发送邮件</li>
<li>向目的端服务器试图建立连接</li>
</ul>
<h3><span id="4-2-2-you-jian-chuan-song">4.2.2 邮件传送</span><a href="#4-2-2-you-jian-chuan-song" class="header-anchor">#</a></h3>
<ol>
<li>发送端发送MAIL命令</li>
<li>接收端回答“250 OK”，即准备好接收</li>
<li>发送端发送多个&quot;RCPT+ 收件人&quot;的命令， 以向对方确认是否可以接收</li>
<li>接收端逐一应答“250 ok”或者“550 no such user”</li>
<li>获得ok应答后，使用DATA命令发送邮件内容</li>
<li>接收端回复 354 xxx end xxx., 告知邮件接收结束</li>
</ol>
<h3><span id="4-2-3-lian-jie-shi-fang">4.2.3 连接释放</span><a href="#4-2-3-lian-jie-shi-fang" class="header-anchor">#</a></h3>
<p>发送端发送QUIT命令<br>
接收端返回221同意释放连接</p>
<h3><span id="4-2-4-pop-tui-song-gei-ke-hu-duan-ua">4.2.4 POP推送给客户端UA</span><a href="#4-2-4-pop-tui-song-gei-ke-hu-duan-ua" class="header-anchor">#</a></h3>
<p>注意前面3步只是完成了从发送者到 接收者所属邮件服务器的步骤，还没有到接收者本地的邮箱应用。<br>
接收者客户端会通过POP协议定期去拉取邮件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">数据库基本名词和概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-24 20:47:49 / 修改时间：00:22:36" itemprop="dateCreated datePublished" datetime="2022-08-24T20:47:49+08:00">2022-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/" class="post-meta-item leancloud_visitors" data-flag-title="数据库基本名词和概念" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#mysql-fu-wu-qi-xiang-ying-yuan-li-dc40bbcdffcfae8017e64a957a15a800a640516e-images-e6-95-b0-e6-8d-ae-e5-ba-93-e5-9f-ba-e6-9c-ac-e5-90-8d-e8-af-8d-e5-92-8c-e6-a6-82-e5-bf-b5-dc40bbcdffcfae8017e64a957a15a800a640516e-png">mysql服务器响应原理<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/dc40bbcdffcfae8017e64a957a15a800a640516e.png" alt="dc40bbcdffcfae8017e64a957a15a800a640516e"></a></li>
<li><a href="#shi-wu-acid">事务ACID</a></li>
<li><a href="#3-chong-du-wen-ti">3种读问题</a></li>
<li><a href="#4-chong-ge-chi-ji-bie">4种隔离级别</a></li>
<li><a href="#shu-ju-ku-3-chong-wan-zheng-xing-yue-shu">数据库3种完整性约束</a></li>
<li><a href="#4-chong-fan-shi">4种范式</a></li>
<li><a href="#cun-chu-yin-qing-bi-jiao">存储引擎比较</a>
<ul>
<li><a href="#cun-chu-yin-qing-de-bi-jiao-innodb">存储引擎的比较InnoDB</a></li>
<li><a href="#myisam">MyISAM</a></li>
<li><a href="#qi-ta-yin-qing">其他引擎</a></li>
<li><a href="#q-bu-tong-chang-jing-xia-de-cun-chu-yin-qing-xuan-ze">Q: 不同场景下的存储引擎选择</a></li>
<li><a href="#q-mysql5-7-he-8-0-de-qu-bie">Q： mysql5.7和8.0的区别</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="mysql-fu-wu-qi-xiang-ying-yuan-li">mysql服务器响应原理<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/dc40bbcdffcfae8017e64a957a15a800a640516e.png" alt="dc40bbcdffcfae8017e64a957a15a800a640516e"></span><a href="#mysql-fu-wu-qi-xiang-ying-yuan-li" class="header-anchor">#</a></h1>
<hr>
<h1><span id="shi-wu-acid">事务ACID</span><a href="#shi-wu-acid" class="header-anchor">#</a></h1>
<ul>
<li>A是 atomicity原子性,     事务内的行为一次性执行完，要么就回退</li>
<li>C是consistency一致性    有a+b=c的限制条件，然后a变化的同时，b也必须跟着变化</li>
<li>I是isolation隔离性   事务隔离，即事务的中间执行过程，对另外一个事务不可见。</li>
<li>D是durability持久性  提交i成功后，修改不会改变，也会被记录。</li>
</ul>
<p>不同的存储引擎支持不同的事务处理<br>
不支持事务的话，性能会高，但是可靠性就差。</p>
<h1><span id="3-chong-du-wen-ti">3种读问题</span><a href="#3-chong-du-wen-ti" class="header-anchor">#</a></h1>
<ul>
<li>脏读：数据被更新了，但是还没提交， 然后另一个事务读到了更新后的数据，结果事务回滚了，导致读的数据其实是脏数据，</li>
<li>不可重复读：  1个事务要读2次数据（注意是单条数据），结果第一次读和第二次读数据不一致了。<br>
换个说法：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。（主要是update触发）</li>
<li>幻读： 1个事务按照某搜索条件读了2次 数据，发现2次的记录数不一致，可能多了或者少了记录（注意是多条记录的情况， 不可重复读只针对单条数据的内容变化）（主要是insert、delete触发）<br>
换个说法，就是你发现数据莫名奇妙多了一条：<br>
第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行</li>
</ul>
<h1><span id="4-chong-ge-chi-ji-bie">4种隔离级别</span><a href="#4-chong-ge-chi-ji-bie" class="header-anchor">#</a></h1>
<p>简易记法： RU\RC\RR\SE<br>
第一个R是read， U是uncommit， C是uncommit， R是repeated， SE是顺序</p>
<ul>
<li>Read Uncommited  最低隔离级别。 写的时候可以被读取。 3个读问题都无法避免。<br>
如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据<br>
注意，RU级别，是有写锁的，并不是什么都没做</li>
<li>Read Committed  大部分数据库的默认隔离级别。 只有在事务提交后，另一个事务才能看到同一笔数据更新后的结果。</li>
</ul>
<p>允许其他事务继续访问该行数据，但是<strong>未提交的写事务</strong>将会禁止其他事务访问该行，会对该写锁一直保持直到到事务提交。</p>
<p>区别就是写的时候，未提交的事务会禁止，相当于写的过程会让读不可见。</p>
<p>能解决脏读， RC隔离级别保证了对读取到的记录加锁(记录锁)</p>
<ul>
<li>
<p>Repeateable Read 保证同一笔数据在事务中，必须是相同的，不会让他变化。<br>
能避免不可重复度和脏读，   “可能”避免幻读<br>
RR隔离级别保证对读取到的记录加锁(记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入(间隙锁)。</p>
</li>
<li>
<p>Serializable  所有事务都必须依次顺序执行。 都能解决<br>
所有的读操作都是当前读，读加读锁(S锁)，写加写锁(X锁)。在该隔离级别下，读写冲突，因此并发性能急剧下降，在MySQL/InnoDB中不建议使用。</p>
</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/2486676b1dd91f04b79a37922663c2aada317781.png" alt="2486676b1dd91f04b79a37922663c2aada317781"></p>
<h1><span id="shu-ju-ku-3-chong-wan-zheng-xing-yue-shu">数据库3种完整性约束</span><a href="#shu-ju-ku-3-chong-wan-zheng-xing-yue-shu" class="header-anchor">#</a></h1>
<ul>
<li>域完整性（值约束）：域完整性是保证数据库字段取值的合理性</li>
<li>实体完整性（主键约束）：指关系的主关键字不能重复也不能取“空值&quot;。</li>
<li>参照完整性（外键约束）： 主关键字与外部关键字引用的约束条件。</li>
</ul>
<h1><span id="4-chong-fan-shi">4种范式</span><a href="#4-chong-fan-shi" class="header-anchor">#</a></h1>
<ol>
<li>第一范式比较简单，属性不可拆分。电话号码一个字段可以分为手机号码和座机号码两个字段。</li>
<li>第二范式不难理解，非主属性对候选键完全依赖，不能存在部分依赖。 即主键唯一时，能确定这个非主属性值。<br>
候选键只有一个主属性时则一定符合第二范式。<br>
候选键包含多个主属性时，可能出现不符合第二范式的情况，</li>
<li>第三范式去除冗余，非主属性只能存在一个表中，不应该存在多个表中，要去除无意义的数据冗余。</li>
<li>BC范式则不应存在关键字决定关键字的情况。也就是在关联关系表中，一个表有多个属性构成复合的候选键，主属性直接不应该有互相依赖。工号和身份证号是相互依赖。</li>
<li>第四范式，对于候选键只能存在不超过1个多值属性。要求把同一表内的多对多关系删除。</li>
</ol>
<p>简易版：</p>
<ul>
<li>第一范式：不可拆</li>
<li>第二范式：多个主键时，不能只用到1个主键。</li>
<li>第三范式：非主键属性不能冗余，最好集中到一个表</li>
<li>第四范式：不常问， 好象是1个主键只能对应一个属性值，不要多对多，到时候就说我也不太理解，很少用到吧。</li>
</ul>
<h1><span id="cun-chu-yin-qing-bi-jiao">存储引擎比较</span><a href="#cun-chu-yin-qing-bi-jiao" class="header-anchor">#</a></h1>
<h2><span id="cun-chu-yin-qing-de-bi-jiao-innodb">存储引擎的比较InnoDB</span><a href="#cun-chu-yin-qing-de-bi-jiao-innodb" class="header-anchor">#</a></h2>
<p>这是mysql的默认事务型引擎</p>
<p>用于处理短期事务（不常回滚的），但本质上还是事务型的存储引擎<br>
数据存储在tablespace中（一堆又innoDB管理的文件，我们看不懂的那种文件）<br>
使用MVCC支持高并发，实现4个隔离级别，  有间隙锁<br>
使用聚簇索引</p>
<h2><span id="myisam">MyISAM</span><a href="#myisam" class="header-anchor">#</a></h2>
<p>MYSQL5.1之前，是默认的存储引擎<br>
不支持事务和行级锁！也就是说不支持修复！<br>
表存在2个文件中： 数据文件和索引文件<br>
只能针对表加锁，不能针对行<br>
有修复操作，但是用于修复表的错误（而不是回滚这种操作)<br>
支持全文索引<br>
如果表导入数据后不再更新，可以用MyISAM压缩表， 而且解压开销不大。</p>
<h2><span id="qi-ta-yin-qing">其他引擎</span><a href="#qi-ta-yin-qing" class="header-anchor">#</a></h2>
<p>Archive： 只支持insert和select、压缩写、支持行级锁、不是事务引擎<br>
blackhole： 会丢弃所有插入的数据，但是会记录日志。（一般用于数据备份、日志审计）<br>
csv：把csv文件当作mysql表。不支持索引<br>
Federated： 是访问mysql的一个代理引擎。本质还是连接mysql。默认禁用<br>
memory引擎：  希望快速访问不存盘， 重启后丢失也无所谓，可以i用这个，类似于H2内存数据库。<br>
用作缓存非常不错。<br>
NDB集群引擎： 分布式mysql集群</p>
<h2><span id="q-bu-tong-chang-jing-xia-de-cun-chu-yin-qing-xuan-ze">Q: 不同场景下的存储引擎选择</span><a href="#q-bu-tong-chang-jing-xia-de-cun-chu-yin-qing-xuan-ze" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>日志记录：  要求插入快，可使用myisam</li>
<li>读多写少： InnoDB， 避免崩溃恢复问题。</li>
<li>订单处理： 事务时必须的，innoDB</li>
<li>电子公告牌：多数应用只有几个表保存数据，核心表的压力很大</li>
<li>大数据量： 数据仓库， infobright、NDB或者hive哈哈</li>
</ul>
<hr>
<h2><span id="q-mysql5-7-he-8-0-de-qu-bie">Q： mysql5.7和8.0的区别</span><a href="#q-mysql5-7-he-8-0-de-qu-bie" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>新增INVISIBLE和VISIBLE语法， 以支持隐藏索引的功能，用于调试</li>
<li>MySQL 8 开始，数据库的缺省编码将改为 utf8mb4</li>
<li>支持用命令 SET PERSIST进行配置的修改，而不是登录后台修改。</li>
<li>新增窗口函数，支持先生成一个排序的窗口表，再做rank<br>
<img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%92%8C%E6%A6%82%E5%BF%B5/4678c23a55172ed1d7db48f6a8f6765f97e66e74.png" alt="4678c23a55172ed1d7db48f6a8f6765f97e66e74"></li>
<li>更安全，支持SQL角色设置和权限设置</li>
</ul>
<p>更详细的：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7259a2f0e95a">MySQL5.7.X用的好好的，为什么要用MySQL8.0</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">计网之传输层（TCP/IP）详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 01:47:49" itemprop="dateCreated datePublished" datetime="2022-08-24T01:47:49+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-25 00:12:52" itemprop="dateModified" datetime="2022-08-25T00:12:52+08:00">2022-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="计网之传输层（TCP/IP）详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#1-chuan-shu-ceng-he-wang-luo-ceng-de-qu-bie">1 传输层和网络层的区别：</a>
<ul>
<li><a href="#1-1-fu-ze-dui-xiang-de-bu-tong">1.1 负责对象的不同</a></li>
<li><a href="#1-2-xiao-yan-shang-de-bu-tong">1.2 校验上的不同</a></li>
</ul>
</li>
<li><a href="#2-duan-kou-hao">2 端口号</a>
<ul>
<li><a href="#2-1-duan-kou-hao-de-yi-yi">2.1 端口号的意义</a></li>
<li><a href="#2-2-duan-kou-hao-fan-wei">2.2 端口号范围</a></li>
</ul>
</li>
<li><a href="#3-tcp">3 TCP</a>
<ul>
<li><a href="#3-1-tcp-shou-bu">3.1 TCP首部</a>
<ul>
<li><a href="#q-jiang-yi-xia-tcp-bao-wen-du-you-sha-ke-yi-bu-an-shun-xu-jiang">Q: 讲一下TCP报文都有啥，可以不按顺序讲</a></li>
</ul>
</li>
<li><a href="#3-2-hua-dong-chuang-kou">3.2 滑动窗口</a>
<ul>
<li><a href="#3-2-1-fa-song-duan-chuang-kou">3.2.1发送端窗口</a></li>
<li><a href="#3-2-2-jie-shou-duan-chuang-kou">3.2.2 接收端窗口</a></li>
<li><a href="#3-2-3-jian-chi-ding-shi-qi">3.2.3 坚持定时器</a></li>
<li><a href="#3-2-4-hu-tu-chuang-kou">3.2.4 糊涂窗口</a></li>
</ul>
</li>
<li><a href="#3-3-tcp-lian-jie-liu-cheng">3.3 TCP连接流程</a>
<ul>
<li><a href="#3-3-1-wo-shou-he-hui-shou-liu-cheng">3.3.1 握手和挥手流程</a>
<ul>
<li><a href="#wei-shi-me-jian-li-yao-3-ci-wo-shou">为什么建立要3次握手？</a></li>
<li><a href="#wei-shi-me-jie-shu-lian-jie-yao-4-ci-hui-shou">为什么结束连接要4次挥手？</a></li>
<li><a href="#neng-fou-hui-shou-3-ci">能否挥手3次</a></li>
<li><a href="#si-ci-hui-shou-zhong-de-time-wait-zhuang-tai-zuo-yong">四次挥手中的TIME_WAIT状态作用？</a></li>
<li><a href="#liang-bian-tong-shi-xiang-hu-jian-li-lian-jie-hui-fa-sheng-shi-me">两边同时相互建立连接会发生什么？</a></li>
<li><a href="#liang-bian-tong-shi-guan-bi-lian-jie-hui-fa-sheng-shi-me">两边同时关闭连接会发生什么</a></li>
</ul>
</li>
<li><a href="#3-3-4-jiao-hu-shu-ju">3.3.4 交互数据</a>
<ul>
<li><a href="#nagle-suan-fa">nagle算法</a></li>
<li><a href="#q-shi-me-shi-tcp-nian-bao">Q: 什么是TCP粘包？</a></li>
<li><a href="#q-zao-cheng-nian-bao-de-yuan-yin-shi-shi-me">Q: 造成粘包的原因是什么？</a></li>
<li><a href="#q-shi-me-shi-hou-xu-yao-chu-li-nian-bao-xian-xiang">Q:什么时候需要处理粘包现象？</a></li>
<li><a href="#q-ru-he-chu-li-nian-bao-xian-xiang">Q: 如何处理粘包现象？</a></li>
<li><a href="#q-udp-hui-bu-hui-chan-sheng-nian-bao-wen-ti-ni">Q：UDP会不会产生粘包问题呢？</a></li>
</ul>
</li>
<li><a href="#3-3-5-yi-chang-qing-kuang">3.3.5 异常情况</a></li>
</ul>
</li>
<li><a href="#3-4-yong-sai-bi-mian-ji-zhi">3.4 拥塞避免机制</a>
<ul>
<li><a href="#q-jian-li-lian-jie-hou-mei-ci-fa-song-de-bao-wen-shu-liang-shi-gu-ding-de-ma-ji-mei-ci-du-fa-1-tiao-huo-zhe-10-tiao">Q: 建立连接后，每次发送的报文数量是固定的吗？即每次都发1条或者10条？</a></li>
<li><a href="#q-man-qi-dong-guo-cheng-zhong-na-me-fa-song-shu-liang-yong-sai-chuang-kou-shi-me-shi-hou-bu-zai-bei-zeng-shi-wu-xian-bei-zeng-ma">Q: 慢启动过程中，那么发送数量（拥塞窗口）什么时候不再倍增？是无限倍增吗？</a></li>
<li><a href="#q-na-me-dang-jin-ru-yong-sai-bi-mian-mei-ci-1-shi-shi-me-shi-hou-cai-hui-bu-zai-ji-xu-jia">Q:那么，当进入拥塞避免，每次+1时，什么时候才会不再继续加？</a></li>
<li><a href="#q-shang-mian-ti-dao-liao-chao-shi-na-me-tcp-ke-hu-duan-shi-zen-me-pan-duan-bao-wen-fa-song-chao-shi-de-ni">Q: 上面提到了超时， 那么TCP客户端是怎么判断报文发送超时的呢？</a></li>
<li><a href="#q-shang-mian-ti-dao-de-chao-shi-shi-jian-rto-shi-zen-me-lai-de-wan-yi-she-de-tai-da-ke-neng-dao-zhi-hen-chi-cai-neng-fan-ying-guo-lai-she-de-tai-xiao-ze-ke-neng-dao-zhi-mei-tiao-du-chao-shi">Q:上面提到的超时时间RTO是怎么来的？万一设得太大可能导致很迟才能反应过来， 设得太小则可能导致每条都超时</a></li>
<li><a href="#q-ru-guo-fa-sheng-chong-chuan-que-huan-shi-mei-you-shou-dao-ack-na-me-zui-xin-de-rtt-yang-ben-ying-gai-zen-me-suan-ji-ni-du-shou-bu-dao-zui-xin-de-ack-liao-rtt-nan-dao-qu-chao-shi-shi-jian-ma">Q: 如果发生重传，却还是没有收到ack，那么最新的RTT样本应该怎么算？即你都收不到最新的ack了， RTT难道取超时时间吗？</a></li>
<li><a href="#q-shang-mian-ti-dao-de-ack-chao-shi-pan-duan-hui-bu-hui-tai-jiu-liao-jia-ru-zhi-shi-fa-de-shi-hou-diu-liao-zhong-jian-bu-fen-bao-wen-er-yi-dan-da-bu-fen-bao-wen-ack-huan-neng-zheng-chang-fan-hui-ye-yao-yi-zhi-deng-chao-shi-ma">Q: 上面提到的ACK超时判断会不会太久了？ 假如只是发的时候丢了中间部分报文而已， 但大部分报文ACK还能正常返回，也要一直等超时吗？</a></li>
<li><a href="#q-qian-mian-chao-shi-chong-chuan-de-shi-hou-shi-bian-cheng-cong-1-kai-shi-man-qi-dong-wei-shi-me-zhe-ge-kuai-chong-chuan-que-shi-cong-ssthreshold-2-kai-shi-bing-qie-zou-yong-sai-bi-mian-wei-shi-me-hui-you-zhe-ge-qu-bie">Q: 前面“超时重传”的时候，是变成从1开始慢启动， 为什么这个“快重传”却是从ssthreshold/2开始，并且走拥塞避免？ 为什么会有这个区别？</a></li>
<li><a href="#q-wei-sha-fa-song-di-duo-liao-shu-ju-jiu-hui-bu-fen-diu-shi-zhe-ge-shi-zen-me-ge-yuan-li">Q: 为啥发送地多了，数据就会部分丢失？这个是怎么个原理？</a></li>
<li><a href="#q-tcp-chu-liao-shang-mian-de-chong-chuan-ding-shi-qi-hao-xiang-huan-you-ge-jian-chi-ding-shi-qi-qu-bie-shi-sha">Q: TCP除了上面的重传定时器， 好象还有个坚持定时器？区别是啥？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-udp">4 UDP</a>
<ul>
<li><a href="#4-1-tcp-he-udp-de-qu-bie">4.1 TCP和UDP的区别：</a></li>
<li><a href="#4-2-udp-de-yi-xie-te-dian">4.2 UDP的一些特点</a></li>
<li><a href="#4-3-udp-de-ying-yong">4.3 UDP的应用</a></li>
<li><a href="#q-udp-ke-yi-shi-xian-ke-kao-chuan-shu-ma">Q: UDP可以实现可靠传输吗？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="1-chuan-shu-ceng-he-wang-luo-ceng-de-qu-bie">1 传输层和网络层的区别：</span><a href="#1-chuan-shu-ceng-he-wang-luo-ceng-de-qu-bie" class="header-anchor">#</a></h1>
<h2><span id="1-1-fu-ze-dui-xiang-de-bu-tong">1.1 负责对象的不同</span><a href="#1-1-fu-ze-dui-xiang-de-bu-tong" class="header-anchor">#</a></h2>
<ul>
<li>传输层负责建立进程间的通信（即只关心进程A和进程B的消息传递，不考虑底下的东西）</li>
<li>网络层负责建立主机间的通信（即只关心主机A怎么发给主机B）</li>
</ul>
<blockquote>
<blockquote>
<p>同理链路层就是物理上相邻的2个机器如何通信，物理层是电路上的通信</p>
</blockquote>
</blockquote>
<h2><span id="1-2-xiao-yan-shang-de-bu-tong">1.2 校验上的不同</span><a href="#1-2-xiao-yan-shang-de-bu-tong" class="header-anchor">#</a></h2>
<ul>
<li>传输层会对数据和首部一起做校验</li>
<li>网络层只对首部做校验，数据报部分不会关心。</li>
</ul>
<h1><span id="2-duan-kou-hao">2 端口号</span><a href="#2-duan-kou-hao" class="header-anchor">#</a></h1>
<p>端口号是传输层重要的概念。</p>
<h2><span id="2-1-duan-kou-hao-de-yi-yi">2.1 端口号的意义</span><a href="#2-1-duan-kou-hao-de-yi-yi" class="header-anchor">#</a></h2>
<p>① 为进程适应不同操作系统提供一个复用和分用的软件</p>
<blockquote>
<blockquote>
<p>复用：发送方不同进程都用同一种协议传输，目的端口号承担了这个工作<br>
分用：接收方把IP报文组装交付时，通过端口号确认交付给谁</p>
<p>② 端口是进程的重要交互地址。<br>
即由端口确定交给主机上的哪个进程。<br>
③ 只具有本地意义，只对本机有效</p>
</blockquote>
</blockquote>
<h2><span id="2-2-duan-kou-hao-fan-wei">2.2 端口号范围</span><a href="#2-2-duan-kou-hao-fan-wei" class="header-anchor">#</a></h2>
<p>端口号共16位，因此最大为65535</p>
<ul>
<li>
<p>服务器端口号（做listen用的端口号）有2类：</p>
<ol>
<li>熟知端口号：0~1023</li>
</ol>
<blockquote>
<blockquote>
<p>熟知端口号有以下：<br>
HTTP:80<br>
HTTPS:443<br>
DNS:53<br>
FTP:21<br>
TFTP:69<br>
SNMP:161<br>
TELNET:23<br>
SMTP:25</p>
</blockquote>
</blockquote>
<ol start="2">
<li>注册端口号: 1024~49151，也叫系统端口号。有许多服务绑定于这些端口。</li>
<li>动态和/或私有端口：49152~65535，理论上，不应为监听服务分配这些端口，一般是用于客户端的短暂端口号。</li>
</ol>
</li>
<li>
<p>UDP和TCP有各自的专属端口号，因此不会重复和干扰。</p>
</li>
</ul>
<h1><span id="3-tcp">3 TCP</span><a href="#3-tcp" class="header-anchor">#</a></h1>
<p>TCP全称<br>
Transmission Control Protocol， 即传输控制协议。</p>
<p>基于套接字传输<br>
套接字：IP+端口号</p>
<p>tcp的可靠性如下：</p>
<ol>
<li>数据被分隔成很多份合适的块来发送</li>
<li>有超时重传机制</li>
<li>会校验首部和数据内容。</li>
<li>会对收到的数据报文做排序，按顺序组装上交<br>
5.会丢弃重复的数据<br>
6.提供流量控制，发送主机不会一下子发送太快<br>
7.每次传输都有序号和ack应答，全双工。</li>
</ol>
<h2><span id="3-1-tcp-shou-bu">3.1 TCP首部</span><a href="#3-1-tcp-shou-bu" class="header-anchor">#</a></h2>
<table>
<thead>
<tr>
<th>位数</th>
<th>含义</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>源端口</td>
<td>因此端口号最多16位</td>
</tr>
<tr>
<td>16</td>
<td>目的端口</td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>报文序号</td>
<td>该报文的序号</td>
</tr>
<tr>
<td>32</td>
<td>确认号</td>
<td>期望收到的下一个报文序号。如果确认号位N，说明N-1都已经收到</td>
</tr>
<tr>
<td>4</td>
<td>数据偏移</td>
<td>数据部分的起始位置，可以理解为首部长度。单位是4字节。</td>
</tr>
<tr>
<td>6</td>
<td>保留位</td>
<td>没用，全部置成0</td>
</tr>
<tr>
<td>1</td>
<td>URG紧急指针标志</td>
<td>是否存在紧急数据</td>
</tr>
<tr>
<td>1</td>
<td>ACK标志</td>
<td>是否是确认报文</td>
</tr>
<tr>
<td>1</td>
<td>PSH推送标志</td>
<td>是否需要尽快上交进程</td>
</tr>
<tr>
<td>1</td>
<td>RST复位标志</td>
<td>是否需要重建连接</td>
</tr>
<tr>
<td>1</td>
<td>SYN同步建立连接标志</td>
<td>是不是连接建立期间的报文</td>
</tr>
<tr>
<td>1</td>
<td>FIN终止标志</td>
<td>是否是终止连接期间的报文</td>
</tr>
<tr>
<td>16</td>
<td>窗口</td>
<td>收到ack前对方可发送回来的数据量</td>
</tr>
<tr>
<td>16</td>
<td>校验和</td>
<td>校验首部+数据+伪首部（伪首部指携带了ip的首部）</td>
</tr>
<tr>
<td>16</td>
<td>紧急指针位置</td>
<td>紧急数据放在末尾，需要给出紧急数据的长度，便可推断位置</td>
</tr>
<tr>
<td>0-320</td>
<td>可变选项</td>
<td>一些TCP选项，例如 最大报文长度、时间戳等。最长40字节</td>
</tr>
<tr>
<td>?</td>
<td>填充位</td>
<td>保证首部长度为4字节整数倍</td>
</tr>
</tbody>
</table>
<p>从上面可以看到：</p>
<ol>
<li>TCP报文中不包含ip信息，只包含端口信息。</li>
<li>校验和中使用到了伪首部来做校验，即实际上是有ip信息被处理后包含在校验和中了。</li>
<li>TCP首部最小长度为20字节，最大长度为60字节，取决于可变选项。</li>
<li>首部长度必定是4字节整数倍，不足会填充，因为数据偏移里的单位设置是4字节。</li>
</ol>
<hr>
<h3><span id="q-jiang-yi-xia-tcp-bao-wen-du-you-sha-ke-yi-bu-an-shun-xu-jiang">Q:  讲一下TCP报文都有啥，可以不按顺序讲</span><a href="#q-jiang-yi-xia-tcp-bao-wen-du-you-sha-ke-yi-bu-an-shun-xu-jiang" class="header-anchor">#</a></h3>
<p>A:</p>
<ol>
<li>首先是首部长度（数据偏移），确定读到哪</li>
<li>重要的源端口 目的端口</li>
<li>TCP 可靠性机制关键的一些数字：<br>
报文号、ACK号、窗口、 校验和</li>
<li>建连接、关连接用的标记<br>
一堆标记（SYNC、FIN、RST之类的）</li>
<li>其他无关紧要的紧急指针位置、可变选项，填充位</li>
</ol>
<h2><span id="3-2-hua-dong-chuang-kou">3.2 滑动窗口</span><a href="#3-2-hua-dong-chuang-kou" class="header-anchor">#</a></h2>
<p>在TCP的发送端和接收端，有一个窗口的概念，直接用图片的方式简单明了回忆一下：</p>
<h3><span id="3-2-1-fa-song-duan-chuang-kou">3.2.1发送端窗口</span><a href="#3-2-1-fa-song-duan-chuang-kou" class="header-anchor">#</a></h3>
<p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011330509.png" alt="在这里插入图片描述"></p>
<hr>
<h3><span id="3-2-2-jie-shou-duan-chuang-kou">3.2.2 接收端窗口</span><a href="#3-2-2-jie-shou-duan-chuang-kou" class="header-anchor">#</a></h3>
<p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011340404.png" alt="在这里插入图片描述"></p>
<p>这里可以看到接收端一次性接收的缓存是有限的，所以进程出现问题迟迟没有接收数据，那么会在ack里告知还能发多少份。<br>
这个叫通告窗口，即告知接收端还能收几份数据（TCP报文里的窗口位就是这个）</p>
<h3><span id="3-2-3-jian-chi-ding-shi-qi">3.2.3 坚持定时器</span><a href="#3-2-3-jian-chi-ding-shi-qi" class="header-anchor">#</a></h3>
<p>如果接收端的接收缓存用完，导致返回的ack报文里提示窗口为0，则发送端无法发送数据，此时会启动坚持定时器：<br>
每隔5s发送1个字节的小报文，来查看对方窗口响应。当窗口不再为0，则结束坚持定时器</p>
<h3><span id="3-2-4-hu-tu-chuang-kou">3.2.4 糊涂窗口</span><a href="#3-2-4-hu-tu-chuang-kou" class="header-anchor">#</a></h3>
<p>上面提到的坚持定时器机制里，导致了每次只发一小点数据。<br>
避免措施：<br>
1. 接收方设定一个最小窗口阈值，不通告小窗口<br>
2. 发送方设定一个最小窗口阈值，每次发送满一定长度的报文<br>
3. 发送手头所有数据切不接收ack</p>
<h2><span id="3-3-tcp-lian-jie-liu-cheng">3.3 TCP连接流程</span><a href="#3-3-tcp-lian-jie-liu-cheng" class="header-anchor">#</a></h2>
<p>TCP通过三次握手建立连接，四次挥手结束连接</p>
<h3><span id="3-3-1-wo-shou-he-hui-shou-liu-cheng">3.3.1 握手和挥手流程</span><a href="#3-3-1-wo-shou-he-hui-shou-liu-cheng" class="header-anchor">#</a></h3>
<p>把这个图牢记于心就不会有问题：<br>
<img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011409757.png" alt="在这里插入图片描述"></p>
<p>CLOSED状态：建立连接前的初始状态即关闭状态在建立连接前，先从CLOSED状态变成LISTEN状态（监听状态，表示可以传信号了）</p>
<ol>
<li>当客户首先发送SYN后，客户变成SYN_SENT状态。</li>
<li>当服务器接收到SYN后，服务器变成了SYN_REVD状态。</li>
<li>当服务器传给客户一个SYN和ACK后，变成了ESTABLISHED状态（表述开始进行数据传输）</li>
<li>当服务器接受到客户传来的ACK后，也变成ESTABLISHED状态。</li>
<li>当客户发送FIN（主动关闭）后，客户变成了FIN_WAIT1状态。服务器收到FIN后，执行被动关6. 闭，服务器变成了CLOSEWAIT状态。</li>
<li>服务器先发送ACK，客户收到ACK后变成FIN_WAIT2状态。</li>
<li>过了一段时间，服务器才发送FIN，这时候服务器变成LAST_ACK状态客户收到FIN后，变成了TIME_WAIT状态，同时发送ACK，进行2MSL等待。之后2者一起变为CLOSED状态</li>
</ol>
<hr>
<h4><span id="wei-shi-me-jian-li-yao-3-ci-wo-shou">为什么建立要3次握手？</span><a href="#wei-shi-me-jian-li-yao-3-ci-wo-shou" class="header-anchor">#</a></h4>
<p>建立握手3次原因：一方接收到syn报文后，需向对方回应一个ack。三次握手中，第一个是sync报文，第二个是ack、sync报文合在一起，第三个ack报文。这样就都回应了ack，需要3次。<br>
关键在于最后一次需要一个对 接收端sync的ack响应。</p>
<hr>
<h4><span id="wei-shi-me-jie-shu-lian-jie-yao-4-ci-hui-shou">为什么结束连接要4次挥手？</span><a href="#wei-shi-me-jie-shu-lian-jie-yao-4-ci-hui-shou" class="header-anchor">#</a></h4>
<p>TCP中发送端发送fin后，就会将自己关闭。<br>
但是接收端一方接收到fin报文后，数据可能还没发送完成。<br>
所以需要先发完ack，再发fin，所以这里会多一次挥手。 最后ack是对fin的确认</p>
<hr>
<h4><span id="neng-fou-hui-shou-3-ci">能否挥手3次</span><a href="#neng-fou-hui-shou-3-ci" class="header-anchor">#</a></h4>
<p><strong>能</strong>。收到第一个fin报文后，它可能刚好没有数据要传输了，fin和ack报文一起回应，对方再回应ack，总共三次，挥手完毕。实际中抓报文，有很多这样的情况。</p>
<hr>
<h4><span id="si-ci-hui-shou-zhong-de-time-wait-zhuang-tai-zuo-yong">四次挥手中的TIME_WAIT状态作用？</span><a href="#si-ci-hui-shou-zhong-de-time-wait-zhuang-tai-zuo-yong" class="header-anchor">#</a></h4>
<p>A:</p>
<p>1.若最后一步客户发出的ACK丢失了，那么服务器将重发FIN，所以必须维持TIME_WAIT状态到可能的第二次重发FIN的时间。</p>
<p>2.为了避免在终止连接后再次重新建立新连接时，收到之前那次连接“迷路”的分组，要维持一个TIME_WAIT状态以便吸收掉迷路的分组。</p>
<hr>
<h4><span id="liang-bian-tong-shi-xiang-hu-jian-li-lian-jie-hui-fa-sheng-shi-me">两边同时相互建立连接会发生什么？</span><a href="#liang-bian-tong-shi-xiang-hu-jian-li-lian-jie-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4>
<p>2边同时发送SYNC<br>
2边同时收到后， 就会发现自己在还没收到SYNC-ACK的情况下收到了新的SYNC，说明发生了&quot;同时打开&quot;的情况。<br>
此时他会直接发送ack，并且不再等待sync-ack响应了，直接进入ESTABLISHED状态。所以此时仅需2次握手（当然整体上看是4次，一边各2次）</p>
<h4><span id="liang-bian-tong-shi-guan-bi-lian-jie-hui-fa-sheng-shi-me">两边同时关闭连接会发生什么</span><a href="#liang-bian-tong-shi-guan-bi-lian-jie-hui-fa-sheng-shi-me" class="header-anchor">#</a></h4>
<p>当2者发生同时关闭，即同时发出FIN时，会进入CLOSING状态，收到相互的ACK后进入TIME_WAIT状态. 即此时需2次挥手（整体上看是4次）</p>
<h3><span id="3-3-4-jiao-hu-shu-ju">3.3.4 交互数据</span><a href="#3-3-4-jiao-hu-shu-ju" class="header-anchor">#</a></h3>
<p><img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/20210218011424408.png" alt="在这里插入图片描述"></p>
<p>每一个交互按键都会产生一个数据分组，每次从客户传到服务器的是一个字节的按键。而Rlogin需要远程系统回显客户键入的字符，这样就会产生4个报文段：<br>
（1）来自客户的交互按键<br>
（2）来自服务器的按键确认<br>
（3）来自服务器的按键回显<br>
（4）来自客户的按键回显确认</p>
<ul>
<li>
<h4><span id="nagle-suan-fa">nagle算法</span><a href="#nagle-suan-fa" class="header-anchor">#</a></h4>
<p>当数据交互很快时， 可能会有很多小分组。<br>
开启nagle后，会把小分组做合并一起发送。</p>
</li>
</ul>
<hr>
<h4><span id="q-shi-me-shi-tcp-nian-bao">Q: 什么是TCP粘包？</span><a href="#q-shi-me-shi-tcp-nian-bao" class="header-anchor">#</a></h4>
<p>A:<br>
TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包<br>
从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾<br>
出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<hr>
<h4><span id="q-zao-cheng-nian-bao-de-yuan-yin-shi-shi-me">Q: 造成粘包的原因是什么？</span><a href="#q-zao-cheng-nian-bao-de-yuan-yin-shi-shi-me" class="header-anchor">#</a></h4>
<p>A:<br>
发送方原因： 开启了nagle算法<br>
接收方原因：如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包</p>
<hr>
<h4><span id="q-shi-me-shi-hou-xu-yao-chu-li-nian-bao-xian-xiang">Q:什么时候需要处理粘包现象？</span><a href="#q-shi-me-shi-hou-xu-yao-chu-li-nian-bao-xian-xiang" class="header-anchor">#</a></h4>
<p>A:<br>
如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象<br>
如果多个分组毫不相干，甚至是并列关系，导致应用层取出时无法识别各份数据，那么这个时候就一定要处理粘包现象了</p>
<hr>
<h4><span id="q-ru-he-chu-li-nian-bao-xian-xiang">Q: 如何处理粘包现象？</span><a href="#q-ru-he-chu-li-nian-bao-xian-xiang" class="header-anchor">#</a></h4>
<p>A:</p>
<ol>
<li>发送方<br>
对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</li>
<li>接收方<br>
接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</li>
<li>应用层<br>
解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</li>
</ol>
<ul>
<li>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束</li>
<li>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置</li>
</ul>
<hr>
<h4><span id="q-udp-hui-bu-hui-chan-sheng-nian-bao-wen-ti-ni">Q：UDP会不会产生粘包问题呢？</span><a href="#q-udp-hui-bu-hui-chan-sheng-nian-bao-wen-ti-ni" class="header-anchor">#</a></h4>
<p>A:<br>
UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。<br>
举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<h3><span id="3-3-5-yi-chang-qing-kuang">3.3.5 异常情况</span><a href="#3-3-5-yi-chang-qing-kuang" class="header-anchor">#</a></h3>
<ul>
<li>
<p>异常情况时，会把报文里的复位表示RST置为1。有3种情况会发送复位报文<br>
①端口不存在<br>
②进程异常终止<br>
③客户端异常退出， 服务器没有收到任何fin，此时称为TCP<strong>半打开</strong>状态。如果TCP配置了心跳，则可以检测</p>
</li>
<li>
<p>半关闭<br>
TCP的半关连接是指：TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据。</p>
</li>
<li>
<p>半连接<br>
三次握手中，主动发起握手的一方不发最后一次ACK，使得服务器端阻塞在SYN_RECV状态半连接攻击（SYN攻击）：会耗尽服务器资源，使得真正的请求无法建立连接。</p>
</li>
</ul>
<h2><span id="3-4-yong-sai-bi-mian-ji-zhi">3.4 拥塞避免机制</span><a href="#3-4-yong-sai-bi-mian-ji-zhi" class="header-anchor">#</a></h2>
<p>这块概念很多很乱，我按问题整理了一下，一步步来<br>
TCP的拥塞避免等机制对于初学者来说还是比较复杂的，工作中如果开发时偏应用层，那么大部分时候就会摸不到这个机制，感受也就没那么深了。<br>
但如果你的开发过程涉及数据传输，一直在重传、超时之类的方案里有困惑的话，不妨重新学一学可靠性最精致的TCP协议。</p>
<p>所以这里我抛去死记硬背的那堆概念，用10个连续的问题来学习这个机制，注意看的时候先自己思考一下如果是自己，会怎么设计，再去看实际的TCP设计，来理解它的精妙之处。</p>
<hr>
<h3><span id="q-jian-li-lian-jie-hou-mei-ci-fa-song-de-bao-wen-shu-liang-shi-gu-ding-de-ma-ji-mei-ci-du-fa-1-tiao-huo-zhe-10-tiao">Q: 建立连接后，每次发送的报文数量是固定的吗？即每次都发1条或者10条？</span><a href="#q-jian-li-lian-jie-hou-mei-ci-fa-song-de-bao-wen-shu-liang-shi-gu-ding-de-ma-ji-mei-ci-du-fa-1-tiao-huo-zhe-10-tiao" class="header-anchor">#</a></h3>
<p>A:<br>
不是。<br>
建立连接后，会先只发1条， 然后发2条，接着再发4条，逐步增加。<br>
这个过程叫 <strong>“慢启动”</strong>。<br>
这个1、2、4递增的数量被称之为 <strong>拥塞窗口</strong> cwnd</p>
<p>可以理解为TCP希望刚开始，可以大胆点，不断加数量。但为了保险期间还是从1条还是倍增。</p>
<hr>
<h3><span id="q-man-qi-dong-guo-cheng-zhong-na-me-fa-song-shu-liang-yong-sai-chuang-kou-shi-me-shi-hou-bu-zai-bei-zeng-shi-wu-xian-bei-zeng-ma">Q: 慢启动过程中，那么发送数量（拥塞窗口）什么时候不再倍增？是无限倍增吗？</span><a href="#q-man-qi-dong-guo-cheng-zhong-na-me-fa-song-shu-liang-yong-sai-chuang-kou-shi-me-shi-hou-bu-zai-bei-zeng-shi-wu-xian-bei-zeng-ma" class="header-anchor">#</a></h3>
<p>A:<br>
不会无限倍增。<br>
当到达<strong>慢启动门限ssthreshold</strong>时，会变成每次都增加1条。<br>
这个过程叫<strong>拥塞避免过程</strong>， 也有叫他拥塞避免算法的</p>
<p>可以理解为tcp感觉到有风险了，于是开始慢慢地、小心翼翼地1条1条地添加发送条数。</p>
<hr>
<h3><span id="q-na-me-dang-jin-ru-yong-sai-bi-mian-mei-ci-1-shi-shi-me-shi-hou-cai-hui-bu-zai-ji-xu-jia">Q:那么，当进入拥塞避免，每次+1时，什么时候才会不再继续加？</span><a href="#q-na-me-dang-jin-ru-yong-sai-bi-mian-mei-ci-1-shi-shi-me-shi-hou-cai-hui-bu-zai-ji-xu-jia" class="header-anchor">#</a></h3>
<p>A:<br>
随着每次发送的数量越发越多， 最终会超出带宽限制，于是就会有某条报文发生超时。<br>
有可能是发的中途丢了， 亦或者是返回的数据全阻塞住了，一条都回不来。</p>
<p>当发送端检测到发生超时时，就会让 <strong>慢启动门限ssthreshold = 当前拥塞窗口cwnd/2</strong><br>
接着<strong>cwnd 重新置为1</strong>，从新开始 慢启动算法。</p>
<p>这样的好处在于可以检测到每次发送的上限，动态调整发送窗口。<br>
上面的过程叫做 <strong>超时重传</strong>。<br>
注意发生超时重传时， cwnd会重置成1。</p>
<hr>
<h3><span id="q-shang-mian-ti-dao-liao-chao-shi-na-me-tcp-ke-hu-duan-shi-zen-me-pan-duan-bao-wen-fa-song-chao-shi-de-ni">Q: 上面提到了超时， 那么TCP客户端是怎么判断报文发送超时的呢？</span><a href="#q-shang-mian-ti-dao-liao-chao-shi-na-me-tcp-ke-hu-duan-shi-zen-me-pan-duan-bao-wen-fa-song-chao-shi-de-ni" class="header-anchor">#</a></h3>
<p>A:<br>
每次发送数据包的时候， 都会有一个相应的计时器，一旦超过 RTO(超时时间） 而没有收到 ACK， TCP就会重发该数据包。<br>
没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除。</p>
<hr>
<h3><span id="q-shang-mian-ti-dao-de-chao-shi-shi-jian-rto-shi-zen-me-lai-de-wan-yi-she-de-tai-da-ke-neng-dao-zhi-hen-chi-cai-neng-fan-ying-guo-lai-she-de-tai-xiao-ze-ke-neng-dao-zhi-mei-tiao-du-chao-shi">Q:上面提到的超时时间RTO是怎么来的？万一设得太大可能导致很迟才能反应过来， 设得太小则可能导致每条都超时</span><a href="#q-shang-mian-ti-dao-de-chao-shi-shi-jian-rto-shi-zen-me-lai-de-wan-yi-she-de-tai-da-ke-neng-dao-zhi-hen-chi-cai-neng-fan-ying-guo-lai-she-de-tai-xiao-ze-ke-neng-dao-zhi-mei-tiao-du-chao-shi" class="header-anchor">#</a></h3>
<p>A:<br>
通过“每次报文的往返时间样本”和“之前样本的偏差值”<strong>动态计算</strong>出来的。</p>
<ul>
<li>RTT ： 报文往返时间（指从发送到收到ack的时间）。每个报文发出后都有个定时器，收到后都会计算出一个RTT样本</li>
</ul>
<hr>
<ul>
<li>RTTs： 加权平均往返时间，类似于一个估算的往返时间，实时在变。<br>
RTTs = （1-a) * RTTs + a * RTT最新样本<br>
即每次得到RTT样本后， ?都会使用a这个占比去更新RTTs。</li>
</ul>
<hr>
<ul>
<li>RTTd: ?RTT偏差加权平均值（就是用来计算超时时间应该比RTT多多少）<br>
RTTd = (1 - b) * RTTd + b*RTTs - RTT最新样本<br>
即每次会用新的RTTs以b的占比去更新一下RTTd，并减去RTT样本</li>
</ul>
<hr>
<ul>
<li>RTO ： 超时重传时间<br>
等于平均往返时间 加上 4倍偏差值<br>
RTO = RTTs + 4*RTTd?</li>
</ul>
<hr>
<h3><span id="q-ru-guo-fa-sheng-chong-chuan-que-huan-shi-mei-you-shou-dao-ack-na-me-zui-xin-de-rtt-yang-ben-ying-gai-zen-me-suan-ji-ni-du-shou-bu-dao-zui-xin-de-ack-liao-rtt-nan-dao-qu-chao-shi-shi-jian-ma">Q: 如果发生重传，却还是没有收到ack，那么最新的RTT样本应该怎么算？即你都收不到最新的ack了， RTT难道取超时时间吗？</span><a href="#q-ru-guo-fa-sheng-chong-chuan-que-huan-shi-mei-you-shou-dao-ack-na-me-zui-xin-de-rtt-yang-ben-ying-gai-zen-me-suan-ji-ni-du-shou-bu-dao-zui-xin-de-ack-liao-rtt-nan-dao-qu-chao-shi-shi-jian-ma" class="header-anchor">#</a></h3>
<p>A:<br>
会使用karn算法： 发生重传时，不更新这次的RTT样。选用后面收到的ack<br>
修正karn： 为了避免发生重传后，实际RTT都变慢了，导致一下子所有请求都超时， 会在发生重传时，把RTO假大1倍。</p>
<hr>
<h3><span id="q-shang-mian-ti-dao-de-ack-chao-shi-pan-duan-hui-bu-hui-tai-jiu-liao-jia-ru-zhi-shi-fa-de-shi-hou-diu-liao-zhong-jian-bu-fen-bao-wen-er-yi-dan-da-bu-fen-bao-wen-ack-huan-neng-zheng-chang-fan-hui-ye-yao-yi-zhi-deng-chao-shi-ma">Q: 上面提到的ACK超时判断会不会太久了？ 假如只是发的时候丢了中间部分报文而已， 但大部分报文ACK还能正常返回，也要一直等超时吗？</span><a href="#q-shang-mian-ti-dao-de-ack-chao-shi-pan-duan-hui-bu-hui-tai-jiu-liao-jia-ru-zhi-shi-fa-de-shi-hou-diu-liao-zhong-jian-bu-fen-bao-wen-er-yi-dan-da-bu-fen-bao-wen-ack-huan-neng-zheng-chang-fan-hui-ye-yao-yi-zhi-deng-chao-shi-ma" class="header-anchor">#</a></h3>
<p>A:<br>
如果能正常接收其他报文的ACK， 只是中间的部分报文丢了， 则有另一个办法。</p>
<p>接收端有一个冗余确认机制：</p>
<ol>
<li>发送端A 发送 1、2、3、4、5四条</li>
<li>但是B接收端只收到1、2、4、5，而3因为网络拥塞丢了。</li>
<li>于是B会发送ack=3而不是ack=5 给A。 <strong>这就是冗余确认机制，只发送缺失那部分的ack，后面的4和5都不管。</strong></li>
<li>A收到ack=3后， 继续发送3、4、5、6、7， 结果3还是丢了。</li>
<li>于是B又发送ack=3。</li>
</ol>
<p>当A发现连续3次收到了ack=3时，就会觉察到不对劲，我都发3次了你还是说没收到，可你又能正常返回其他ACK给我，是不是我发的太多了？</p>
<p>上面这个判断3次的重传算法叫“快重传”。</p>
<p>于是A会马上进入 “快速恢复”。<br>
和之前类似，慢启动门限ssthreshold = 当前拥塞窗口cwnd/2<br>
但是！！  新的拥塞窗口cwnd会设置成ssthreshold/2，  而不是1。<br>
而且不会走慢启动倍增的那种，而是走拥塞避免， 逐步+1的那种。<br>
<img src="/images/%E8%AE%A1%E7%BD%91%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/1638808791348065758.png" alt="image.png"></p>
<hr>
<h3><span id="q-qian-mian-chao-shi-chong-chuan-de-shi-hou-shi-bian-cheng-cong-1-kai-shi-man-qi-dong-wei-shi-me-zhe-ge-kuai-chong-chuan-que-shi-cong-ssthreshold-2-kai-shi-bing-qie-zou-yong-sai-bi-mian-wei-shi-me-hui-you-zhe-ge-qu-bie">Q: 前面“超时重传”的时候，是变成从1开始慢启动， 为什么这个“快重传”却是从ssthreshold/2开始，并且走拥塞避免？ 为什么会有这个区别？</span><a href="#q-qian-mian-chao-shi-chong-chuan-de-shi-hou-shi-bian-cheng-cong-1-kai-shi-man-qi-dong-wei-shi-me-zhe-ge-kuai-chong-chuan-que-shi-cong-ssthreshold-2-kai-shi-bing-qie-zou-yong-sai-bi-mian-wei-shi-me-hui-you-zhe-ge-qu-bie" class="header-anchor">#</a></h3>
<p>A:<br>
因为前面发生超时重传时，  是比较严重的情况， 超时时间内一个ACK都没收到。就好像来回数据都凭空消失了。</p>
<p>而快速重传发生时， 还是能收到部分ack的， 只是丢失了部分数据， 说明拥塞没那么严重，于是可以大胆一点将cwnd削减到1/4， 而不是直接从1开始。</p>
<p>到了这里，基本就能理清楚超时重传和快重传的区别了，重点是理解这2个区别是怎么来的。后面再补几个问题，避免你和其他概念搞混，但不会说得太深，具体需要你自己去扩展学习了。</p>
<h3><span id="q-wei-sha-fa-song-di-duo-liao-shu-ju-jiu-hui-bu-fen-diu-shi-zhe-ge-shi-zen-me-ge-yuan-li">Q: 为啥发送地多了，数据就会部分丢失？这个是怎么个原理？</span><a href="#q-wei-sha-fa-song-di-duo-liao-shu-ju-jiu-hui-bu-fen-diu-shi-zhe-ge-shi-zen-me-ge-yuan-li" class="header-anchor">#</a></h3>
<p>A:<br>
路由器有缓存，IP分组接收过多时就会耗尽空间，丢弃数据。详细可以看路由器的数据转发原理。</p>
<hr>
<h3><span id="q-tcp-chu-liao-shang-mian-de-chong-chuan-ding-shi-qi-hao-xiang-huan-you-ge-jian-chi-ding-shi-qi-qu-bie-shi-sha">Q: TCP除了上面的重传定时器， 好象还有个坚持定时器？区别是啥？</span><a href="#q-tcp-chu-liao-shang-mian-de-chong-chuan-ding-shi-qi-hao-xiang-huan-you-ge-jian-chi-ding-shi-qi-qu-bie-shi-sha" class="header-anchor">#</a></h3>
<p>A:<br>
坚持定时器和超时、网络拥塞没有关系， 和通告窗口即对端的接收能力有关。<br>
简单来说， 就是对方的传输层缓冲区（接收端窗口）满了，告诉你别发了，我吃不下了，于是返回通告窗口为0。<br>
但你想知道啥时候可以发，于是就启动一个坚持定时器，每隔5s发送1个字节的小报文，小小地试探下。当通告窗口不为0了，就重新开始发。</p>
<h1><span id="4-udp">4 UDP</span><a href="#4-udp" class="header-anchor">#</a></h1>
<p>网络层的多播和广播机制，需要依赖传输层的UDP。</p>
<h2><span id="4-1-tcp-he-udp-de-qu-bie">4.1 TCP和UDP的区别：</span><a href="#4-1-tcp-he-udp-de-qu-bie" class="header-anchor">#</a></h2>
<ul>
<li>TCP有连接， UDP无连接</li>
<li>TCP可靠， UDP不可靠，发出去不管了。也没有拥塞控制等机制。 不过UDP会做数据正确性校验。</li>
<li>UDP会一次性交付一个完整报文，不会做拆分，TCP可能会有小的分组。</li>
<li>UDP首部比较简单， 只有源端口、目的端口、报文长度、校验和、填充位。</li>
</ul>
<h2><span id="4-2-udp-de-yi-xie-te-dian">4.2 UDP的一些特点</span><a href="#4-2-udp-de-yi-xie-te-dian" class="header-anchor">#</a></h2>
<ul>
<li>
<p>每次调用程序里多播的接口时，都会产生1个UDP消息，没有那种可以复用的UDP连接。</p>
</li>
<li>
<p>UDP数据报的最大长度，和应用程序可读写的数据报最大长度有关，和TCP/IP内核有关。<br>
当数据报长度大于程序可读写长度，会引发 数据截断。所以udp数据的长度必须要控制好，毕竟他无法根据MTU做分片。</p>
</li>
<li>
<p>怎么确认MTU多大？<br>
可以用taceroute命令检测MTU， 本质上是把TCP报文设置成不分片，然后逐步增大，直到发生了ICMP不可达的报错。</p>
</li>
<li>
<p>如果一次性发送了6个UDP数据报， 并且在链路层有6次ARP请求， 接收端收到6个UDP后，只会发送一个ARP响应。</p>
</li>
<li>
<p>UDP一般用于本地小范围通信， 所以差错其实相比TCP还小一点。</p>
</li>
</ul>
<h2><span id="4-3-udp-de-ying-yong">4.3 UDP的应用</span><a href="#4-3-udp-de-ying-yong" class="header-anchor">#</a></h2>
<p>TFTP（小文件传输）<br>
DNS（域名解析）<br>
SNMP(简单网络管理协议）<br>
IGMP<br>
BOOTP（无盘系统引导）<br>
RTP(实时传输协议)<br>
多媒体应用</p>
<hr>
<h2><span id="q-udp-ke-yi-shi-xian-ke-kao-chuan-shu-ma">Q: UDP可以实现可靠传输吗？</span><a href="#q-udp-ke-yi-shi-xian-ke-kao-chuan-shu-ma" class="header-anchor">#</a></h2>
<p>A:<br>
可以实现，但必须在应用层做改造。</p>
<ol>
<li>添加seq/ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>添加超时重传机制。</li>
</ol>
<ul>
<li>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
</li>
<li>
<p>目前有多种开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">计网之网络层（IP协议）详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 00:47:49" itemprop="dateCreated datePublished" datetime="2022-08-24T00:47:49+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-25 00:06:15" itemprop="dateModified" datetime="2022-08-25T00:06:15+08:00">2022-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="计网之网络层（IP协议）详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#1-ip-di-zhi">1.IP地址</a>
<ul>
<li><a href="#1-1-fen-lei-biao-shi-fa">1.1 分类表示法：</a>
<ul>
<li><a href="#1-1-2-fen-lei-biao-shi-di-zhi-de-qi-ta-shuo-ming">1.1.2 分类表示地址的其他说明</a></li>
</ul>
</li>
<li><a href="#1-2-wu-fen-lei-bian-zhi-cidr">1.2 无分类编址CIDR</a></li>
</ul>
</li>
<li><a href="#2-ip-shu-ju-bao-wen-ge-shi">2 IP数据报文格式</a>
<ul>
<li><a href="#q-ip-bao-wen-li-you-shi-me-ke-yi-bu-an-shun-xu-huo-zhe-zi-jie-lai-jiang-yi-jiang">Q: IP报文里有什么？可以不按顺序或者字节来讲一讲</a></li>
</ul>
</li>
<li><a href="#3-lu-you-gai-nian">3.路由概念</a>
<ul>
<li><a href="#3-1-lu-you-biao">3.1 路由表</a></li>
<li><a href="#3-2-lu-you-wang-luo-pi-pei">3.2 路由网络匹配</a></li>
<li><a href="#3-3-arp-jie-xi">3.3 ARP解析</a></li>
<li><a href="#3-4-rarp-ni-di-zhi-jie-xi-xie-yi">3.4 RARP逆地址解析协议</a></li>
</ul>
</li>
<li><a href="#4-icmp-xie-yi">4 ICMP协议</a></li>
<li><a href="#5-dhcp-xie-yi">5 DHCP协议</a></li>
<li><a href="#6-lu-you-biao-de-zui-you-xia-yi-tiao-di-zhi-ru-he-ji-suan">6.路由表的最优下一跳地址如何计算？</a>
<ul>
<li><a href="#6-1-rip-xie-yi">6.1 RIP协议</a></li>
<li><a href="#6-2-ospf-xie-yi">6.2 OSPF协议</a></li>
<li><a href="#6-3-bgp-xie-yi">6.3 BGP协议</a></li>
<li><a href="#q-rip-xie-yi-xia-lu-you-biao-shi-me-shi-hou-geng-xin">Q: RIP协议下路由表什么时候更新？</a></li>
<li><a href="#q-lu-you-zhong-du-shi-shi-me">Q: 路由中毒是什么？</a></li>
<li><a href="#q-shou-dao-zhong-du-lu-you-de-lu-you-qi-hui-zen-me-zuo">Q: 收到中毒路由的路由器会怎么做？</a></li>
</ul>
</li>
<li><a href="#7-duo-bo">7 多播</a>
<ul>
<li><a href="#7-1-igmp-xie-yi">7.1 IGMP协议</a></li>
<li><a href="#7-2-mospf-duo-bo-lu-you-xuan-ze-xie-yi">7.2 MOSPF多播路由选择协议</a></li>
</ul>
</li>
<li><a href="#8-qi-ta-wang-luo-ceng-gai-nian">8 其他网络层概念</a>
<ul>
<li><a href="#8-1-vpn">8.1 VPN</a></li>
<li><a href="#8-2-nat">8.2 NAT</a></li>
<li><a href="#8-3-yi-dong-ip">8.3 移动IP</a></li>
</ul>
</li>
<li><a href="#9-chang-jian-wang-luo-ceng-ming-ling">9 常见网络层命令</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="1-ip-di-zhi">1.IP地址</span><a href="#1-ip-di-zhi" class="header-anchor">#</a></h1>
<h2><span id="1-1-fen-lei-biao-shi-fa">1.1 分类表示法：</span><a href="#1-1-fen-lei-biao-shi-fa" class="header-anchor">#</a></h2>
<p>分类表示法已经不常用了。</p>
<ul>
<li>A类地址：<br>
格式为<br>
1[7位网络号][24位主机号]<br>
网络号全0指本网络<br>
网络号全1用于环回地址（127.0.0.1）<br>
主机号全0时指本住机所在网络<br>
全1时指本网络所有主机（广播地址）<br>
因此A类地址实际可选范围为1.x.x.x ~ 126.x.x.x</li>
</ul>
<hr>
<ul>
<li>B类地址<br>
格式为<br>
10[14位网络号][16位主机号]<br>
网络号不可全0，但可以全1<br>
范围为128.x.x.x~191.x.x.x</li>
</ul>
<hr>
<ul>
<li>C类地址<br>
格式为<br>
110[21位网络号][8位主机号]<br>
网络号不可全0<br>
范围为192.x.x.x~223.x.x.x</li>
</ul>
<hr>
<ul>
<li>D类地址（多播地址）<br>
格式为<br>
1110[28位多播地址]<br>
范围为224.x.x.x~239.x.x.x<br>
因此看到224以上的ip要注意</li>
</ul>
<hr>
<ul>
<li>E类地址<br>
格式为11110[保留]<br>
用于实验用，因此看到240以上的认定不是正常节点ip</li>
</ul>
<h3><span id="1-1-2-fen-lei-biao-shi-di-zhi-de-qi-ta-shuo-ming">1.1.2 分类表示地址的其他说明</span><a href="#1-1-2-fen-lei-biao-shi-di-zhi-de-qi-ta-shuo-ming" class="header-anchor">#</a></h3>
<ul>
<li>
<p>网络号全0，但主机号非全0的某个ip就是指本网络的某个主机</p>
</li>
<li>
<p>网络号不为全1，但主机号为1的ip，则指某个网络的广播地址</p>
</li>
<li>
<p>全0，指本网络的本主机</p>
</li>
<li>
<p>全1，指本网络的广播地址</p>
</li>
<li>
<p>环回地址，指127.0.0.1，在同一台主机上进行网络传输</p>
</li>
<li>
<p>私有地址，指不会参与路由器转发的地址,， 只会参与本局域网，发给本局域网的交换机：<br>
A类： 10.0.0.0-10.25.255.255<br>
B类： 172.16.0.0-172.31.0.0<br>
C类： 192.168.0.0-192.168.255.255</p>
</li>
</ul>
<h2><span id="1-2-wu-fen-lei-bian-zhi-cidr">1.2 无分类编址CIDR</span><a href="#1-2-wu-fen-lei-bian-zhi-cidr" class="header-anchor">#</a></h2>
<p>Classless Inter-Domain Routing 无类型域间选路</p>
<ul>
<li>CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet路由器的负担。</li>
<li>该编址用于子网划分，子网号和上面提到的网络号是不同的。</li>
<li>IP地址 ::= {&lt;网络号&gt;， &lt;子网号&gt;， &lt;主机号&gt;}</li>
</ul>
<p>CIDR有三种编址方式：</p>
<ul>
<li>128.14.35.7/20  ， 完整ip加子网位数</li>
<li>10.0.0.0/10 -&gt; 10/10， 可省略末尾的0</li>
<li>00010100*， 即用星号代替子网后的主机号</li>
</ul>
<p>对于CIDR编址<br>
子网号的全0和全1没有特殊含义，但不可设置成全0或者全1。<br>
主机号的全0指本网络， 全1指广播。（网络号仍然遵从ABCD地址的规则）</p>
<ul>
<li>子网掩码：<br>
值1的位置指该ip中该位置是网络号和子网号区域<br>
值0的位置指该ip中该位置是主机号区域。<br>
例子：111111100000000…， 那么前面8个1就是网络号+子网号，后面都代表了主机号</li>
<li>路由寻址时，一般先比较网络号，再比较子网号，再比较主机。<br>
子网掩码可以简化先比网络再比子网的过程。</li>
</ul>
<h1><span id="2-ip-shu-ju-bao-wen-ge-shi">2 IP数据报文格式</span><a href="#2-ip-shu-ju-bao-wen-ge-shi" class="header-anchor">#</a></h1>
<p>IP报文的首部至少有20个字节（160位），首部如下：</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>含义</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>版本</td>
<td>IPV4或者IPV6</td>
</tr>
<tr>
<td>4</td>
<td>首部长度</td>
<td>单位是字（4字节</td>
</tr>
<tr>
<td>8</td>
<td>区分服务</td>
<td>设置服务的时延、吞吐量、可靠性，一般不用</td>
</tr>
<tr>
<td>16</td>
<td>IP报文总长度</td>
<td>单位字节</td>
</tr>
<tr>
<td>16</td>
<td>报文标识</td>
<td>用于分片后的同报文组装。相同报文的不同分片，该值相同</td>
</tr>
<tr>
<td>3</td>
<td>分片标志</td>
<td>判断是否可分片或者是否是分配最后一个</td>
</tr>
<tr>
<td>13</td>
<td>片偏移</td>
<td>用于按顺序组装同报文的分片</td>
</tr>
<tr>
<td>8</td>
<td>生存时间TTL</td>
<td>该报文最大跳数，每经过一次转发就减一</td>
</tr>
<tr>
<td>8</td>
<td>协议类型</td>
<td>ICMP/IGMP/TCP/UDP</td>
</tr>
<tr>
<td>16</td>
<td>首部校验和</td>
<td>用于和首部做校验，看首部是否正确</td>
</tr>
<tr>
<td>32</td>
<td>源IP地址</td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>目的IP地址</td>
<td></td>
</tr>
<tr>
<td>？</td>
<td>任选项</td>
<td>很少被使用，最多40字节</td>
</tr>
</tbody>
</table>
<p>上面可以看到IP报文的以下限制：</p>
<ol>
<li>首部长度字段可以看出首部长度最多可以位60字节，所以任选项最多40字节</li>
<li>报文总长度最大为65535， 但是由于MTU的限制（链路层防冲突机制导致的），一般都要做分片， 分片后就会用上分片标识和片偏移了。</li>
</ol>
<hr>
<h2><span id="q-ip-bao-wen-li-you-shi-me-ke-yi-bu-an-shun-xu-huo-zhe-zi-jie-lai-jiang-yi-jiang">Q: IP报文里有什么？可以不按顺序或者字节来讲一讲</span><a href="#q-ip-bao-wen-li-you-shi-me-ke-yi-bu-an-shun-xu-huo-zhe-zi-jie-lai-jiang-yi-jiang" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>首先要知道报文多长，  首部长度+报文长度</li>
<li>为了校验首部，还需要校验首部和</li>
<li>很重要的源ip 目的ip<br>
那么如何确定ip类型？这就需要 ipv版本，来确认是ip4还是ip6。</li>
<li>ip支持分片，那么就需要<br>
分片id、是否是最后分片标记、分片偏移</li>
<li>协议类型（icmp、igmp）</li>
<li>TTL生存</li>
<li>其他任选项（40字节）</li>
</ul>
<h1><span id="3-lu-you-gai-nian">3.路由概念</span><a href="#3-lu-you-gai-nian" class="header-anchor">#</a></h1>
<ul>
<li>路由器可分隔广播域，指的是不同网络号的地址，路由器不会转发广播报文</li>
</ul>
<blockquote>
<blockquote>
<p>Hub集线器在同一个冲突域通信无法分割；交换机在同一个广播域通信，可分割冲突域；路由器实现不同广播域间通信，可分隔广播域。</p>
</blockquote>
</blockquote>
<ul>
<li>IP报文在传输中不会被改变，但是链路层报文的mac地址会不断变化。</li>
<li>当2个主机在不同的子网时，必须要借助路由才能通信</li>
</ul>
<h2><span id="3-1-lu-you-biao">3.1 路由表</span><a href="#3-1-lu-you-biao" class="header-anchor">#</a></h2>
<p>假设某个路由器在N1网络，他的路由表如下：</p>
<table>
<thead>
<tr>
<th>目的网络</th>
<th>下一跳地址</th>
<th>解释</th>
<th>到目的网络距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>0.0.0.0</td>
<td>假设目的网络就是路由器所在网络，说明可以直接交付给本网络的主机了，不用再转发，所以地址为全0</td>
<td>0</td>
</tr>
<tr>
<td>N2</td>
<td>R2</td>
<td>如果为N2，则会发给R2路由</td>
<td>4</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>R1默认路由</td>
<td>如果路由表找不到目的网络，则会默认转给R1处理，0.0.0.0是默认转发网络的标识</td>
<td>？</td>
</tr>
<tr>
<td>特定IP地址</td>
<td>R3</td>
<td>这种特定地址的选择是管理员配置的</td>
<td>3</td>
</tr>
</tbody>
</table>
<ul>
<li>特定IP地址的子网掩码为全1，所以一般都是x.x.x.x/32</li>
<li>DNS服务器一般会配置在路由表中的特定IP地址</li>
<li>未知网络在路由表里的目的网络被写为0.0.0.0， 如果么有，则就是未设置默认路由</li>
<li>路由器不会转发私有地址。</li>
<li>距离指的是跨越路由器的数量，而不是实际长度单位</li>
</ul>
<h2><span id="3-2-lu-you-wang-luo-pi-pei">3.2 路由网络匹配</span><a href="#3-2-lu-you-wang-luo-pi-pei" class="header-anchor">#</a></h2>
<p>如果路由表中的目的网络由很多，怎么确定IP和路由表中的目的网络是匹配的？<br>
使用 最长前缀匹配， 即前缀匹配得最多的就是目的网络。<br>
优化算法可用二叉线索树来确认最长前缀。</p>
<hr>
<p>Q： 为什么要用二叉线索树来 判断最长匹配前缀？ 字典树不可以吗？<br>
A:</p>
<h2><span id="3-3-arp-jie-xi">3.3 ARP解析</span><a href="#3-3-arp-jie-xi" class="header-anchor">#</a></h2>
<p>全称Address Resolution Protocol，地址解析协议。</p>
<p>从主机发给路由， 或者路由发给路由时，底层还是得封装一层mac地址然后往下交给交换机。<br>
那么ip和mac地址的对应关系， 是怎么得知的？<br>
答案就是ARP协议</p>
<p>本质就是当mac缓存表里没有ip和mac的对应关系时， 主机或者路由会广播ARP报文， 对应ip方向的交换机会把报文发送回来，这时候就直到mac地址和ip的对饮关系了。</p>
<ul>
<li>arp -a可以检查ARP告诉缓存</li>
<li>ARP缓存有超时时间</li>
<li>目的主机不存在时，会反复发送，有个超期期限的存在。</li>
<li>主机发送ARP查找自己的Mac地址称为“免费ARP&quot;</li>
<li>发送给某1主机的arp请求被中间路由器接收了，则称为“ARP代理”， 发送者不管不管你是中间路由还是目的ip主机，只知道这个ip需要发给这个mac。</li>
</ul>
<h2><span id="3-4-rarp-ni-di-zhi-jie-xi-xie-yi">3.4 RARP逆地址解析协议</span><a href="#3-4-rarp-ni-di-zhi-jie-xi-xie-yi" class="header-anchor">#</a></h2>
<p>由mac地址反取ip。<br>
因为ip不存在，无法直接转给给路由。所以会比ARP难。<br>
过程：<br>
1）将源设备和目标设备的MAC地址字段都设为发送者的MAC地址和IP地址，发送主机发送一个本地的RARP广播，能够到达网络上的所有设备，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；<br>
? 2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；<br>
? 3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；如果不存在，RARP服务器对此不做任何的响应；<br>
? 4） 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
<h1><span id="4-icmp-xie-yi">4 ICMP协议</span><a href="#4-icmp-xie-yi" class="header-anchor">#</a></h1>
<p>全称Internet control message protocl，网络控制报文协议<br>
他会包装在IP的数据报文中，并把首部的协议类型改成ICMP那个数字。</p>
<p>首部总共8个字节，分别为<br>
2字节的ICMP类型<br>
2字节的ICMP报文代码（类似错误码）<br>
4字节的校验和<br>
后面就是数据部分了。</p>
<p>常见的2种用途：</p>
<ol>
<li>发送网络层之间的差错报告，例如：
<ul>
<li>源点抑制——发送网络拥塞</li>
<li>终点不可达——无法找到对应ip交付地点</li>
<li>时间超时——报文种的TTL降为0，或者分片一直没收集完</li>
<li>参数错误——首部中字段有错</li>
<li>路由改变（重定向）——　主机把数据发给了路由器R2，但是路由器R2发现主机自己本来就可以直达了，于是发给主机该消息，告诉他你要更新路由表了。</li>
</ul>
</li>
</ol>
<p>差错报告有以下其他特点：<br>
* ICMP自身出错时，不会再发ICMP差错报文<br>
* 如果是报文分配后发生错误，则只会发1次，而不会每个分片发一次<br>
* 不针对多播，不针对127.0.0.1、0.0.0.0等特殊的地址发送差错报文，不可广播（避免广播风暴）</p>
<p>​</p>
<ol start="2">
<li>发送一些询问报文，例如：
<ul>
<li>回送请求和应答——例如ping命令就是借助ICMP</li>
<li>超时报文——traceroute就是用这个，把TTL从1慢慢增加，发好多份，通过TTL为0时的差错报告，定位跟踪路上有哪些路由</li>
<li>时间戳请求——同步时间</li>
</ul>
</li>
</ol>
<h1><span id="5-dhcp-xie-yi">5 DHCP协议</span><a href="#5-dhcp-xie-yi" class="header-anchor">#</a></h1>
<p>全称Dynamic Host Configuration Protocol， 动态主机配置协议</p>
<p>当某个局域网内新增了一台主机，这个主机的ip是怎么生成的呢？这就会用到DHCP协议</p>
<p>主机所在网内会有一台DCHP服务器。<br>
当新主机加入时，发生如下之事：</p>
<ol>
<li>主机先“广播”自己，告诉大家“我来了，谁给我一个IP地址”（他一开始不知道DHCP在哪）</li>
<li>DCHP服务器收到后，会分配一个IP地址，但因为不知道发给谁，所以也只能“广播”，告诉大家“我这有个ip，刚才谁要的，自己来领一下”</li>
<li>主机收到DHCP广播的报文后，就能知道自己的ip和dhcp服务器位置了。于是给DCHP服务器发送请求，告诉他“我收到了你发来的ip了”</li>
<li>DCHP收到后，确认了他的信息，并加入到DHCP本地的数据库中，后面分配新ip时就会排除掉这个ip了。</li>
</ol>
<p>有以下几个注意点：</p>
<ol>
<li>如果有多个主机同时应答了DHCP的广播， 则会选择最先到达的做分配。</li>
<li>分配的ip是临时的</li>
</ol>
<p><strong>DCHP可以认为是基于UDP的应用层协议，但本质是为了寻求新主机的动态ip地址</strong></p>
<h1><span id="6-lu-you-biao-de-zui-you-xia-yi-tiao-di-zhi-ru-he-ji-suan">6.路由表的最优下一跳地址如何计算？</span><a href="#6-lu-you-biao-de-zui-you-xia-yi-tiao-di-zhi-ru-he-ji-suan" class="header-anchor">#</a></h1>
<p>可以理解为 在一个复杂的拓扑图下， 怎么选择最优的一个路由做目的地址的下一跳。<br>
有2种方式：</p>
<h2><span id="6-1-rip-xie-yi">6.1 RIP协议</span><a href="#6-1-rip-xie-yi" class="header-anchor">#</a></h2>
<p>全称Routing Information Protocol,路由信息协议<br>
是一种动态路由信息协议。</p>
<ul>
<li>
<p>路由只会和相邻的其他路由交换信息。</p>
</li>
<li>
<p>交换的是路由表的信息，关键在于目的网络和距离</p>
</li>
<li>
<p>之前路由表里知道了表里会存储 到目的网络的距离即跨越路由数量，那么只要拿到周边所有路由的距离表，  看下哪个方向最小， 然后把下一跳地址选为最小的那个路由方向即可。</p>
</li>
<li>
<p>使用UDP广播，把自己的路由报文发给周边的其他路由。</p>
</li>
<li>
<p>当路径不可达时，会导致2个路由之间不断叠加该目的地址的距离，直到16时，会被设置成不可达。</p>
</li>
</ul>
<p>所以RIP本质也是基于UDP的应用层协议，但是目的是为了网络层的最优路由选取。</p>
<h2><span id="6-2-ospf-xie-yi">6.2 OSPF协议</span><a href="#6-2-ospf-xie-yi" class="header-anchor">#</a></h2>
<p>open shortest path first，开放最短路径优先协议<br>
指路由器里有全网的拓扑结构，使用最短路算法计算最优路由<br>
因此路由会把自己的连接情况通过OSPF协议发给所有其他路由，以建立拓扑图。<br>
这个是属于IP层的协议，不借助UDP。</p>
<hr>
<p>RIP和OSPF是自治网络系统AS里的选路措施。<br>
AS里的选路措施被称作IGP（内部网关协议）<br>
1个AS里只会有一种选路措施。</p>
<p>而跨自治系统的协议叫EGP（外部网关协议）<br>
通常使用BGP协议</p>
<hr>
<h2><span id="6-3-bgp-xie-yi">6.3 BGP协议</span><a href="#6-3-bgp-xie-yi" class="header-anchor">#</a></h2>
<p>Border Gateway Protocol边界网关协议</p>
<ul>
<li>每个AS都知道自己为了到达网络N，需要经过哪些AS（相当于知道以AS为节点的拓扑图）</li>
<li>每个AS都有一个BGP发言人,会与其他BGP网络之间交换自身的AS拓扑信息，从而构建全局连通图</li>
<li>使用TCP 179端口工作</li>
</ul>
<hr>
<h2><span id="q-rip-xie-yi-xia-lu-you-biao-shi-me-shi-hou-geng-xin">Q: RIP协议下路由表什么时候更新？</span><a href="#q-rip-xie-yi-xia-lu-you-biao-shi-me-shi-hou-geng-xin" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>正常情况下，路由器会基于更新计时器每30s将路由表发送给邻居路由器，而触发更新是立刻发送路由更新信息</li>
<li>触发更新就是当检测到网络拓扑发生变动时，路由器会立即发送一个更新信息给邻居路由器，并依次产生触发更新通知它们的邻居路由器，此过程就叫触发更新</li>
</ul>
<hr>
<h2><span id="q-lu-you-zhong-du-shi-shi-me">Q:  路由中毒是什么？</span><a href="#q-lu-you-zhong-du-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
路由中毒是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息。 然后再将中毒路由信息发布出去，当相邻的路由器收到该中毒路由就可以通过其度量值是16，说明该路由是无效的。</p>
<p>??因为RIP协议中的度量值其实就是跳数，而RIP协议的跳数最大是15，大于15的目的地被认为是不可达，所以当其度量值为16，就表示这是一个无效路由，这就是所谓的路由中毒，这个数字在限制了网络大小的同时也防止了一个叫做“记数到无穷大”的问题。</p>
<hr>
<h2><span id="q-shou-dao-zhong-du-lu-you-de-lu-you-qi-hui-zen-me-zuo">Q: 收到中毒路由的路由器会怎么做？</span><a href="#q-shou-dao-zhong-du-lu-you-de-lu-you-qi-hui-zen-me-zuo" class="header-anchor">#</a></h2>
<p>A:<br>
收到中毒路由信息的相邻的路由器会发送一个毒性逆转的信息，表示已经收到中毒路由信息。</p>
<p>??那么为什么收到中毒路由的路由器为什么要回复一个毒性逆转的信息？这是因为如果不回复的话，那么发送中毒路由的路由器就会一直以广播的形式发送中毒路由，直到相邻的路由器收到并回复一个毒性逆转的信息。</p>
<h1><span id="7-duo-bo">7 多播</span><a href="#7-duo-bo" class="header-anchor">#</a></h1>
<p>UDP的时候会用到多播</p>
<h2><span id="7-1-igmp-xie-yi">7.1 IGMP协议</span><a href="#7-1-igmp-xie-yi" class="header-anchor">#</a></h2>
<p>internet group message protol，  网络组管理协议<br>
负责收集和解释一个网络中的组成员信息<br>
IGMP协议应用于路由器</p>
<ul>
<li>某主机加入新的多播组时，发送报文，并转发多播的关系给其他相邻主机或者路由</li>
<li>会周期性探寻，确认自身这个主机是否还在多播组内</li>
<li>无法直到总成员数</li>
<li>IGMP属于网络层的协议</li>
</ul>
<h2><span id="7-2-mospf-duo-bo-lu-you-xuan-ze-xie-yi">7.2 MOSPF多播路由选择协议</span><a href="#7-2-mospf-duo-bo-lu-you-xuan-ze-xie-yi" class="header-anchor">#</a></h2>
<p>多播开放最短通路优先（Multicast Open Shortest PathFirst，MOSPF）协议是OSPF协议的扩展<br>
使用多播链路状态路由选择来创建源点基准树。<br>
这个协议需要一个新的链路状态更新分组，把主机的单播地址和组地址或主机负责的地址联系起来，这个分组就称为组成员关系LSA。<br>
此外，这个数可以保存在高速缓存中，以便以后有同样源点/组地址对的分组可以使用它。<br>
多播的其他更详细概念见<a target="_blank" rel="noopener" href="https://blog.csdn.net/williananjhon/article/details/94166311">链接</a></p>
<h1><span id="8-qi-ta-wang-luo-ceng-gai-nian">8 其他网络层概念</span><a href="#8-qi-ta-wang-luo-ceng-gai-nian" class="header-anchor">#</a></h1>
<h2><span id="8-1-vpn">8.1 VPN</span><a href="#8-1-vpn" class="header-anchor">#</a></h2>
<p>需要建立专用通道<br>
当专用A试图向专用B通信时，会先加密，再通过加密隧道发到对方内网，具体报文内容不会和互联网直接接触。</p>
<h2><span id="8-2-nat">8.2 NAT</span><a href="#8-2-nat" class="header-anchor">#</a></h2>
<p>内外网转换用的一个东西， 公网ip和内网ip互转。</p>
<h2><span id="8-3-yi-dong-ip">8.3 移动IP</span><a href="#8-3-yi-dong-ip" class="header-anchor">#</a></h2>
<p>ip从子网A变道子网B。<br>
在本网时，按TCP通信<br>
要漫游到外网时， 注册一个转交地址<br>
本地代理接收地址，开启隧道<br>
数据发送到外网<br>
在外网时，使用代理ip发送数据<br>
回到本地时，会注册并转交之前的地址</p>
<h1><span id="9-chang-jian-wang-luo-ceng-ming-ling">9 常见网络层命令</span><a href="#9-chang-jian-wang-luo-ceng-ming-ling" class="header-anchor">#</a></h1>
<ul>
<li>ifconfig　可显示本机的IP地址</li>
<li>netstat　－ｒ可显示路由表</li>
<li>tcpdump　可显示硬件地址</li>
<li>ping　测试另一个主机是否可达</li>
<li>traceroute　利用ICMP跟踪途径的所有路由</li>
<li>route　命令可查看和修改路由表</li>
<li>gated可查看IGP（内部网关协议）和EGP（外部网关协</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">MYSQL力扣练习题集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-24 00:10:49 / 修改时间：00:18:28" itemprop="dateCreated datePublished" datetime="2022-08-24T00:10:49+08:00">2022-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/" class="post-meta-item leancloud_visitors" data-flag-title="MYSQL力扣练习题集合" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%8A%9B%E6%89%A3%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>limit 1 offset 1 不存在却要求返回null时， 可以用子查询，或者IFNULL(临时表结果或字段， NULL)<br>
子查询是select结果作为字段，例如 select (select xx) 而不是 select xxx from (select xxx)。  当select中的字段结果不存在，会自动返回NULL</p>
<hr>
<p>如果排名问题要去重，记得加 distinct</p>
<hr>
<p>CREATE FUNCTION中<br>
可以set N:=N-1: 进行变量更新。 不能在return中进行更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N :<span class="operator">=</span> N<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">RETURN</span> (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      <span class="keyword">select</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> salary <span class="keyword">from</span> Employee </span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>  </span><br><span class="line">      limit <span class="number">1</span> <span class="keyword">offset</span> N) </span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<hr>
<p>要做排名时给出序号时，有两种方式<br>
简单方式：<br>
利用子查询字段，注意子查询字段的特点等同于摘出一个字段，再做一次额外查询，得到唯一的一个结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  a.score, (</span><br><span class="line">    # 拿a.score重新重新去检索一次表，得到<span class="built_in">count</span>(<span class="keyword">distinct</span> b.score)<span class="operator">+</span><span class="number">1</span>，得到自己的排名</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> b.score)<span class="operator">+</span><span class="number">1</span> <span class="keyword">from</span> Scores b <span class="keyword">where</span>  a.score<span class="operator">&lt;</span>b.score</span><br><span class="line">    ) <span class="keyword">as</span> `rank` </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> Scores a <span class="keyword">order</span> <span class="keyword">by</span> a.score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>但效率太慢。<br>
高速的序号方法：<br>
使用dense_rank() over(order by xxx) 可以得到序号，1 1 2 3 3 4，不会跳序号<br>
其他序号方式：<br>
row_number()  over(order by xxx)     就是简单的12345这种，不考虑重复<br>
rank()  over(order by xxx)   如果重复了，1 1 3 4 4 6</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  score, </span><br><span class="line">(<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) ) <span class="keyword">as</span> `rank` </span><br><span class="line"><span class="keyword">from</span> Scores </span><br></pre></td></tr></table></figure>
<hr>
<p>寻找3个连续出现的数字，如果id是连续的，则可以自联结，即自己和自己join， 构造where <a target="_blank" rel="noopener" href="http://a.id">a.id</a> = b.id-1 and <a target="_blank" rel="noopener" href="http://b.id">b.id</a> = c.id-1 这样的情况。非常好理解</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.num <span class="keyword">as</span> ConsecutiveNums <span class="keyword">from</span> </span><br><span class="line">logs a,logs b, logs c</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">a.id <span class="operator">=</span> b.id<span class="number">-1</span></span><br><span class="line"><span class="keyword">and</span> b.id <span class="operator">=</span> c.id<span class="number">-1</span></span><br><span class="line"><span class="keyword">and</span> a.num <span class="operator">=</span> b.num <span class="keyword">and</span> b.num <span class="operator">=</span> c.num</span><br></pre></td></tr></table></figure>
<hr>
<p>善用自join联结解决一些表内成员互相比较的复杂问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询收入超过他经理的员工名字。</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"> a.name <span class="keyword">as</span> Employee </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Employee  a , Employee  b</span><br><span class="line"><span class="keyword">where</span> b.id <span class="operator">=</span> a.managerId <span class="keyword">and</span> a.salary <span class="operator">&gt;</span> b.salary</span><br></pre></td></tr></table></figure>
<hr>
<p>group分组后， 可以用having进行组内聚合情况的过滤， 剔除不想要的组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找 Person 表中所有重复的电子邮箱。</span><br><span class="line"><span class="keyword">select</span> email <span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> email </span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line"><span class="built_in">count</span>(email) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>表a在 表b中不存在记录， 用left join + where xxx is null 来处理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.name <span class="keyword">as</span> Customers </span><br><span class="line"><span class="keyword">from</span> Customers c  <span class="keyword">left</span> <span class="keyword">join</span>  Orders  o</span><br><span class="line"><span class="keyword">on</span> c.id <span class="operator">=</span> o.CustomerId <span class="keyword">where</span> o.id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<hr>
<p>in 的用法  where a in(1,2,3,4)<br>
或者 where a in (select aaa from xxx)</p>
<p>in也支持二元组形式<br>
where (a,b) in (select aaa,bbb from xxx)</p>
<p>每组最大值的人选的情况，可以用join + in（分组结果）的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查找每个部门中薪资最高的员工，先join，再用in获取符合组+最大值的行</span><br><span class="line">select </span><br><span class="line">b.name as Department , a.name   as Employee ,  a.salary as Salary</span><br><span class="line">from Employee  a </span><br><span class="line">join</span><br><span class="line">Department  b</span><br><span class="line">on a.departmentId  = b.id  </span><br><span class="line"><span class="title function_">and</span> <span class="params">(a.departmentId, a.salary)</span> in (</span><br><span class="line">    select departmentId, max(salary)</span><br><span class="line">    from Employee</span><br><span class="line">    group by departmentId </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<p>找某薪水是组内前几位的情况， 擅用自查询， 即join后， 拿某条记录在where中遍历一遍,  然后根据count(distinct xxx)来确认自己的排名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 找出每个部门获得前三高工资的所有员工</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">b.name <span class="keyword">as</span> Department , a.name   <span class="keyword">as</span> Employee ,  a.salary <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span> Employee  a </span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">Department  b</span><br><span class="line"><span class="keyword">on</span> a.departmentId  <span class="operator">=</span> b.id</span><br><span class="line"># 比自己这行记录salary大， 且在同一组内的数量小于<span class="number">3</span>，则满足前<span class="number">3</span>  </span><br><span class="line"><span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> e.salary) <span class="keyword">from</span> Employee e <span class="keyword">where</span> a.DepartmentId  <span class="operator">=</span> e.DepartmentId  <span class="keyword">and</span> a.salary <span class="operator">&lt;</span> e.salary</span><br><span class="line"> ) <span class="operator">&lt;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>分组后， SUM(IF(x=y,1,0) 可以统计组内x=y的个数<br>
那么SUM(IF(x=y,1,0) ） / COUNT(x)  就能得到组内x=y的比率</li>
<li>ROUND(xxx, 2) 可以保留两位小数。</li>
<li>between的用法： between ‘2013-10-01’ AND ‘2013-10-03’</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 写一段 <span class="keyword">SQL</span> 语句查出?&quot;2013-10-01&quot;?至?&quot;2013-10-03&quot;?期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 banned 为 <span class="keyword">No</span> 的用户，禁止用户即 banned 为 Yes 的用户。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> request_at <span class="keyword">as</span> <span class="keyword">DAY</span>, ROUND(</span><br><span class="line">    <span class="built_in">SUM</span>(IF(status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(status), <span class="number">2</span></span><br><span class="line">) <span class="keyword">as</span> `Cancellation Rate`</span><br><span class="line"> <span class="keyword">from</span> </span><br><span class="line">Trips t, Users u1, Users u2</span><br><span class="line"><span class="keyword">where</span> (t.client_id  <span class="operator">=</span> u1.users_id</span><br><span class="line"><span class="keyword">and</span> t.driver_id <span class="operator">=</span> u2.users_id)</span><br><span class="line"><span class="keyword">and</span> u1.banned <span class="operator">=</span> <span class="string">&#x27;No&#x27;</span> <span class="keyword">and</span> u2.banned <span class="operator">=</span> <span class="string">&#x27;No&#x27;</span> </span><br><span class="line"><span class="keyword">and</span>  request_at <span class="keyword">between</span> <span class="string">&#x27;2013-10-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2013-10-03&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> request_at</span><br></pre></td></tr></table></figure>
<hr>
<p>求3个或3个以上连续id的记录，直接自联结，然后用3个or条件判断<br>
<a target="_blank" rel="noopener" href="http://t1.id">t1.id</a> <a target="_blank" rel="noopener" href="http://t2.id">t2.id</a> <a target="_blank" rel="noopener" href="http://t3.id">t3.id</a><br>
<a target="_blank" rel="noopener" href="http://t2.id">t2.id</a> <a target="_blank" rel="noopener" href="http://t1.id">t1.id</a> <a target="_blank" rel="noopener" href="http://t3.id">t3.id</a><br>
<a target="_blank" rel="noopener" href="http://t2.id">t2.id</a> <a target="_blank" rel="noopener" href="http://t3.id">t3.id</a> <a target="_blank" rel="noopener" href="http://t1.id">t1.id</a><br>
然后取每种连接表的t1即可</p>
<p>注意distinct 可以用于星号<br>
distinct s1.*<br>
也可用于多列  distict s1.a,s1.b,s1.completed</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 找出每行的人数大于或等于 <span class="number">100</span> 且 id 连续的三行或更多行记录。</span><br><span class="line"># 返回按 visit_date 升序排列的结果表</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">distinct</span> s1.id,s1.visit_date , s1.people            </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">Stadium s1, Stadium s2,Stadium s3</span><br><span class="line"><span class="keyword">where</span> s1.people  <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">and</span> s2.people <span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> s3.people <span class="operator">&gt;=</span> <span class="number">100</span> </span><br><span class="line"><span class="keyword">and</span> (</span><br><span class="line">    (s1.id <span class="operator">=</span> s2.id<span class="number">-1</span> <span class="keyword">and</span> s2.id <span class="operator">=</span> s3.id<span class="number">-1</span> ) <span class="keyword">or</span></span><br><span class="line">(s2.id <span class="operator">=</span> s1.id<span class="number">-1</span> <span class="keyword">and</span> s1.id <span class="operator">=</span> s3.id<span class="number">-1</span> ) <span class="keyword">or</span></span><br><span class="line">(s2.id <span class="operator">=</span> s3.id<span class="number">-1</span> <span class="keyword">and</span> s3.id <span class="operator">=</span> s1.id<span class="number">-1</span> )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> s1.id</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">MYSQL常用命令集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 23:47:49" itemprop="dateCreated datePublished" datetime="2022-08-23T23:47:49+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 00:16:36" itemprop="dateModified" datetime="2022-08-24T00:16:36+08:00">2022-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" class="post-meta-item leancloud_visitors" data-flag-title="MYSQL常用命令集合" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#show-ming-ling">SHOW命令</a>
<ul>
<li><a href="#xian-shi-dang-qian-suo-you-de-ke-yong-shu-ju-ku">显示当前所有的可用数据库</a></li>
<li><a href="#xian-shi-dang-qian-shu-ju-ku-nei-ke-yong-biao">显示当前数据库内可用表</a></li>
<li><a href="#xian-shi-mou-ge-biao-zhong-de-suo-you-shu-xing-xin-xi">显示某个表中的所有属性信息</a></li>
</ul>
</li>
<li><a href="#jian-suo-ming-ling">检索命令</a>
<ul>
<li><a href="#jian-suo-dan-ge-lie">检索单个列</a></li>
<li><a href="#jian-suo-duo-ge-lie">检索多个列</a></li>
<li><a href="#jian-suo-suo-you-lie">检索所有列</a></li>
<li><a href="#jian-suo-chu-bu-chong-fu-de-xing">检索出不重复的行</a></li>
<li><a href="#fan-hui-mou-xie-xing">返回某些行</a></li>
</ul>
</li>
<li><a href="#pai-xu-ming-ling">排序命令</a>
<ul>
<li><a href="#an-dan-lie-pai-xu">按单列排序</a></li>
<li><a href="#an-duo-ge-lie-pai-xu">按多个列排序</a></li>
<li><a href="#jiang-xu-pai-xu">降序排序</a></li>
</ul>
</li>
<li><a href="#tiao-jian-cha-xun">条件查询</a>
<ul>
<li><a href="#zhao-chu-price-2-de-ren">找出price=2的人</a></li>
<li><a href="#bu-pi-pei-jian-cha-gei-chu-id-bu-shi-1003-de-ren-zhi-zao-de-chan-pin">不匹配检查： 给出id不是1003的人制造的产品</a></li>
<li><a href="#fan-wei-zhi-jian-cha">范围值检查：</a></li>
<li><a href="#kong-zhi-jian-cha">空值检查</a></li>
<li><a href="#duo-ge-guo-lu-tiao-jian-and-shi-qie-or-shi-huo">多个过滤条件（AND是且， OR是或）</a></li>
<li><a href="#and-he-or-de-zu-he">AND和OR的组合</a></li>
<li><a href="#qu-te-ding-zhi-ji-id-1002-1003-1004-de-zhi-jie-ke">取特定值，即id=1002、1003、1004的值皆可</a></li>
<li><a href="#fou-ding-tiao-jian-not-tiao-jian-ze-qu-bu-man-zu-zhe-ge-tiao-jian-de-xing">否定条件 NOT 条件，  则取不满足这个条件的行</a></li>
</ul>
</li>
<li><a href="#tong-pei-fu">通配符</a>
<ul>
<li><a href="#pei-he-zi-fu-chuan-pi-pei-he-like-shi-yong">配合字符串匹配和LIKE使用</a></li>
<li><a href="#xia-hua-xian-tong-pei-fu-gai-fu-hao-zhi-neng-dai-biao-1-ge-ren-yi-zi-fu">下划线通配符， 该符号只能代表1个任意字符</a></li>
<li><a href="#shi-yong-tong-pei-fu-de-zhu-yi-shi-xiang">使用通配符的注意事项</a></li>
<li><a href="#zheng-ze-biao-da-shi-ban-sui-zhao-regexp-shi-yong">正则表达式，伴随着REGEXP使用</a></li>
</ul>
</li>
<li><a href="#te-shu-udf">特殊UDF</a>
<ul>
<li><a href="#fen-zu-ju-he">分组+聚合</a></li>
<li><a href="#fan-hui-jie-ge-de-ping-jun-zhi">返回价格的平均值</a></li>
<li><a href="#ji-suan-de-shu-liang-bao-gua-null">计算的数量，包括NULL</a></li>
<li><a href="#zhi-ding-bu-tong-yuan-su-de-tong-ji">指定不同元素的统计</a></li>
<li><a href="#fen-chu-5-ge-id-ji-suan-ge-id-dui-ying-chan-pin-de-shu-liang">分出5个id，计算各id对应产品的数量</a></li>
<li><a href="#guo-lu-fen-zu">过滤分组</a></li>
<li><a href="#lie-chu-ju-you-2-ge-yi-shang-jie-ge-wei-10-de-chan-pin">列出具有2个以上价格为10的产品</a></li>
</ul>
</li>
<li><a href="#zi-cha-xun">子查询</a>
<ul>
<li><a href="#zhao-chu-ding-gou-liao-wu-pin-tnt2-de-suo-you-ke-hu-id">找出订购了物品TNT2的所有客户id</a></li>
</ul>
</li>
<li><a href="#ddl">DDL</a>
<ul>
<li><a href="#chuang-jian-biao">创建表：</a></li>
<li><a href="#tian-jia-lie">添加列：</a></li>
<li><a href="#shan-chu-lie">删除列：</a></li>
<li><a href="#shan-chu-biao">删除表：</a></li>
<li><a href="#chong-ming-ming-biao">重命名表：</a></li>
<li><a href="#cha-ru-xing">插入行：</a></li>
<li><a href="#shan-chu-shu-ju">删除数据：</a></li>
<li><a href="#biao-zhong-shan-chu-zhu-jian-wei">表中删除主键为：</a></li>
<li><a href="#biao-zhong-zeng-jia-zhu-jian-wei">表中增加主键为：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="show-ming-ling">SHOW命令</span><a href="#show-ming-ling" class="header-anchor">#</a></h1>
<h2><span id="xian-shi-dang-qian-suo-you-de-ke-yong-shu-ju-ku">显示当前所有的可用数据库</span><a href="#xian-shi-dang-qian-suo-you-de-ke-yong-shu-ju-ku" class="header-anchor">#</a></h2>
<p>SHOW DATABASE;</p>
<hr>
<h2><span id="xian-shi-dang-qian-shu-ju-ku-nei-ke-yong-biao">显示当前数据库内可用表</span><a href="#xian-shi-dang-qian-shu-ju-ku-nei-ke-yong-biao" class="header-anchor">#</a></h2>
<p>SHOW TABLES ;</p>
<hr>
<h2><span id="xian-shi-mou-ge-biao-zhong-de-suo-you-shu-xing-xin-xi">显示某个表中的所有属性信息</span><a href="#xian-shi-mou-ge-biao-zhong-de-suo-you-shu-xing-xin-xi" class="header-anchor">#</a></h2>
<p>SHOW COLUMNS FORM 表名</p>
<p>SHOW STATUS 显示广泛的服务器状态<br>
SHOW CREATE DATABASE/TABLE  显示创建库或表的SQL语句是啥<br>
SHOW GRANTS 显示授权用户<br>
SHOW ERRORS SHOW WARNINGS  显示服务器错误或警告消息</p>
<hr>
<h1><span id="jian-suo-ming-ling">检索命令</span><a href="#jian-suo-ming-ling" class="header-anchor">#</a></h1>
<h2><span id="jian-suo-dan-ge-lie">检索单个列</span><a href="#jian-suo-dan-ge-lie" class="header-anchor">#</a></h2>
<p>SELECT prod_name<br>
FROM products</p>
<hr>
<h2><span id="jian-suo-duo-ge-lie">检索多个列</span><a href="#jian-suo-duo-ge-lie" class="header-anchor">#</a></h2>
<p>SELECT id,name,price<br>
FROM products</p>
<hr>
<h2><span id="jian-suo-suo-you-lie">检索所有列</span><a href="#jian-suo-suo-you-lie" class="header-anchor">#</a></h2>
<p>SELECT *<br>
FROM products</p>
<hr>
<h2><span id="jian-suo-chu-bu-chong-fu-de-xing">检索出不重复的行</span><a href="#jian-suo-chu-bu-chong-fu-de-xing" class="header-anchor">#</a></h2>
<p>SELECT DISTINCT id<br>
FROM products</p>
<hr>
<h2><span id="fan-hui-mou-xie-xing">返回某些行</span><a href="#fan-hui-mou-xie-xing" class="header-anchor">#</a></h2>
<p>SELECT name<br>
FROM products<br>
LIMIT  begin,len  //即开始行，和行数<br>
注意： 行从0开始，  故LIMIT1，返回的是第二行</p>
<hr>
<h1><span id="pai-xu-ming-ling">排序命令</span><a href="#pai-xu-ming-ling" class="header-anchor">#</a></h1>
<h2><span id="an-dan-lie-pai-xu">按单列排序</span><a href="#an-dan-lie-pai-xu" class="header-anchor">#</a></h2>
<p>SELECT name,age<br>
FROM products<br>
ORDER BY age<br>
找出年龄最小的？ 加个LIMIT 1即可</p>
<hr>
<h2><span id="an-duo-ge-lie-pai-xu">按多个列排序</span><a href="#an-duo-ge-lie-pai-xu" class="header-anchor">#</a></h2>
<p>先按price排，再按name排<br>
SELECT id,price,name<br>
FROM products<br>
ORDER BY price, name</p>
<hr>
<h2><span id="jiang-xu-pai-xu">降序排序</span><a href="#jiang-xu-pai-xu" class="header-anchor">#</a></h2>
<p>按price降序排，再按name升序排<br>
SELECT id,price,name<br>
FROM products<br>
ORDER BY price DEC, name</p>
<hr>
<h1><span id="tiao-jian-cha-xun">条件查询</span><a href="#tiao-jian-cha-xun" class="header-anchor">#</a></h1>
<h2><span id="zhao-chu-price-2-de-ren">找出price=2的人</span><a href="#zhao-chu-price-2-de-ren" class="header-anchor">#</a></h2>
<p>SELECT name, price<br>
FROM products<br>
WHERE price = 2<br>
注意： ORDER BY 排序语句应该放在WHERE的后面</p>
<p>SQL做where字符匹配时，不区分大小写。</p>
<hr>
<h2><span id="bu-pi-pei-jian-cha-gei-chu-id-bu-shi-1003-de-ren-zhi-zao-de-chan-pin">不匹配检查： 给出id不是1003的人制造的产品</span><a href="#bu-pi-pei-jian-cha-gei-chu-id-bu-shi-1003-de-ren-zhi-zao-de-chan-pin" class="header-anchor">#</a></h2>
<p>SELECT id,name<br>
FROM products<br>
WHERE id &lt;&gt; 1003;   //或者 id != 1003</p>
<hr>
<h2><span id="fan-wei-zhi-jian-cha">范围值检查：</span><a href="#fan-wei-zhi-jian-cha" class="header-anchor">#</a></h2>
<p>SELECT name,price<br>
FROM products<br>
WHERE price BETWEEN 5 AND 10</p>
<hr>
<h2><span id="kong-zhi-jian-cha">空值检查</span><a href="#kong-zhi-jian-cha" class="header-anchor">#</a></h2>
<p>WHERE price IS NULL</p>
<hr>
<h2><span id="duo-ge-guo-lu-tiao-jian-and-shi-qie-or-shi-huo">多个过滤条件（AND是且， OR是或）</span><a href="#duo-ge-guo-lu-tiao-jian-and-shi-qie-or-shi-huo" class="header-anchor">#</a></h2>
<p>WHERE id=1003 AND price &lt;10 AND age &lt; 18</p>
<hr>
<h2><span id="and-he-or-de-zu-he">AND和OR的组合</span><a href="#and-he-or-de-zu-he" class="header-anchor">#</a></h2>
<p>WHERE id=1002 OR id=1003 AND price&gt;10<br>
根据SQL的规则， AND优先于OR，变成了<br>
WHERE id=1002 OR （id=1003 AND price&gt;10）<br>
所以最好在OR和AND组合时，加上括号<br>
WHERE （id=1002 OR id=1003） AND price&gt;10</p>
<hr>
<h2><span id="qu-te-ding-zhi-ji-id-1002-1003-1004-de-zhi-jie-ke">取特定值，即id=1002、1003、1004的值皆可</span><a href="#qu-te-ding-zhi-ji-id-1002-1003-1004-de-zhi-jie-ke" class="header-anchor">#</a></h2>
<p>WHERE id IN (1002,1003,1004)</p>
<hr>
<h2><span id="fou-ding-tiao-jian-not-tiao-jian-ze-qu-bu-man-zu-zhe-ge-tiao-jian-de-xing">否定条件       NOT 条件，  则取不满足这个条件的行</span><a href="#fou-ding-tiao-jian-not-tiao-jian-ze-qu-bu-man-zu-zhe-ge-tiao-jian-de-xing" class="header-anchor">#</a></h2>
<p>WHERE id NOT IN (1002,1003,1004)</p>
<hr>
<h1><span id="tong-pei-fu">通配符</span><a href="#tong-pei-fu" class="header-anchor">#</a></h1>
<h2><span id="pei-he-zi-fu-chuan-pi-pei-he-like-shi-yong">配合字符串匹配和LIKE使用</span><a href="#pei-he-zi-fu-chuan-pi-pei-he-like-shi-yong" class="header-anchor">#</a></h2>
<p>百分号通配符，查找以jet开头的任何名字<br>
WHERE name LIKE  ‘jet%’<br>
包含有anvil的名字<br>
WHERE name LIKE  ‘%anvil%’<br>
查找以s起头，e结尾的所有名字<br>
WHERE name LIKE ‘s%e’</p>
<hr>
<h2><span id="xia-hua-xian-tong-pei-fu-gai-fu-hao-zhi-neng-dai-biao-1-ge-ren-yi-zi-fu">下划线通配符， 该符号只能代表1个任意字符</span><a href="#xia-hua-xian-tong-pei-fu-gai-fu-hao-zhi-neng-dai-biao-1-ge-ren-yi-zi-fu" class="header-anchor">#</a></h2>
<p>不能匹配0个字符，即该处必须有1个字符<br>
WHERE name LIKE ‘_ton anvil’</p>
<hr>
<h2><span id="shi-yong-tong-pei-fu-de-zhu-yi-shi-xiang">使用通配符的注意事项</span><a href="#shi-yong-tong-pei-fu-de-zhu-yi-shi-xiang" class="header-anchor">#</a></h2>
<p>1.不要过度使用通配符<br>
2.不要把通配符用在搜索模式的开始处<br>
3.注意通配符的位置</p>
<hr>
<h2><span id="zheng-ze-biao-da-shi-ban-sui-zhao-regexp-shi-yong">正则表达式，伴随着REGEXP使用</span><a href="#zheng-ze-biao-da-shi-ban-sui-zhao-regexp-shi-yong" class="header-anchor">#</a></h2>
<p>LIKE匹配的是整个串，REGEXP只要出现了类似的即可，即有子串即可<br>
例如LIKE ‘abc’ ，只能返回abc。<br>
REGEXP ‘abc’， 则可以返回 abcd</p>
<hr>
<p>.可以匹配任意一个字符<br>
WHERE name REGEXP ‘.000’</p>
<hr>
<p>搜索2个串, |类似于或OR<br>
WHERE name REGEXP ‘1000|2000’<br>
注意：  ‘1|2|3 Ton’ 指代的是1或2或3 Ton， 故不要连续用|后又跟字符，而应该用[]</p>
<hr>
<p>匹配几个字符中的一个即可<br>
WHERE name REGEXP ‘[123] TON’<br>
则可返回  1 Ton 和 2 Ton</p>
<hr>
<p>匹配1-9加a-z<br>
WHERE name REGEXP  ‘[1-9] [a-z]’</p>
<hr>
<p>匹配 正则符号模样的特殊字符<br>
用\作为前导<br>
WHERE name REGEXP ‘\.’<br>
则找到匹配.的， 此时.不代表任意字符</p>
<hr>
<p>匹配某个字符的0个或1个<br>
WHERE name REGEXP ‘sticks?’<br>
则可匹配stick或者sticks</p>
<hr>
<p>指定匹配数目 {n}<br>
不少于指定数目的匹配 {n,}<br>
匹配n到m数目的匹配 {n,m}</p>
<hr>
<p>WHERE name REGEXP ‘[[:digit:]]{4}’<br>
则匹配4个任意数字</p>
<hr>
<p>^定位为文本的开始，$定位为文本的结束<br>
注意： ^有另外一个用途，可以用来否定集合[]</p>
<hr>
<h1><span id="te-shu-udf">特殊UDF</span><a href="#te-shu-udf" class="header-anchor">#</a></h1>
<p>在SQL中测试自己写的正则表达式对不对<br>
SELECT ‘hello’ REGEXP ‘abc’<br>
若正确，则返回1，否则返回0。 显然这个例子返回0</p>
<hr>
<p>计算字段<br>
SELECT Concat(name, ‘(’ , country, ‘)’ )</p>
<hr>
<p>则返回的行里的每个值为<br>
LSX(CHINA)<br>
CRISTINA(USA)</p>
<hr>
<p>RTrim(name)可以删除name中多余的右边空格，常可以用在拼接中</p>
<hr>
<p>给计算字段取别名<br>
SELECT Concat(name, ‘(’ , country, ‘)’ ) AS newtitle<br>
则列名叫newtitle</p>
<hr>
<p>执行算数计算<br>
SELECT id, num, price, num*price AS sumProfit<br>
则多返回一个列，叫做总利润</p>
<hr>
<p>测试拼接字段<br>
SELECT 3*2+5,  则返回11<br>
SELECT Now(),  则返回数据库的当前时间</p>
<hr>
<p>数据处理函数<br>
Select name, Upper(name) AS upcase_name       都转为大写</p>
<hr>
<h2><span id="fen-zu-ju-he">分组+聚合</span><a href="#fen-zu-ju-he" class="header-anchor">#</a></h2>
<h2><span id="fan-hui-jie-ge-de-ping-jun-zhi">返回价格的平均值</span><a href="#fan-hui-jie-ge-de-ping-jun-zhi" class="header-anchor">#</a></h2>
<p>SELECT AVG(price) AS avg_price<br>
FROM products<br>
WHERE id = 1003</p>
<hr>
<h2><span id="ji-suan-de-shu-liang-bao-gua-null">计算的数量，包括NULL</span><a href="#ji-suan-de-shu-liang-bao-gua-null" class="header-anchor">#</a></h2>
<p>SELECT COUNT（*） AS num_cust<br>
计算num的数量，不包括NULL<br>
SELECT COUTN（num） AS num_cust<br>
还有MAX,MIN,SUM</p>
<hr>
<h2><span id="zhi-ding-bu-tong-yuan-su-de-tong-ji">指定不同元素的统计</span><a href="#zhi-ding-bu-tong-yuan-su-de-tong-ji" class="header-anchor">#</a></h2>
<p>SELECT AVG（DISTINCT price） AS avg_price</p>
<hr>
<h2><span id="fen-chu-5-ge-id-ji-suan-ge-id-dui-ying-chan-pin-de-shu-liang">分出5个id，计算各id对应产品的数量</span><a href="#fen-chu-5-ge-id-ji-suan-ge-id-dui-ying-chan-pin-de-shu-liang" class="header-anchor">#</a></h2>
<p>SELECT id, COUNT(*) AS id_num<br>
FROM products<br>
GROUP BY id<br>
1.除了聚集计算语句外， SELECT中出现的每个列都必须出现在GROUP BY中<br>
2.GROUP BY 必须出在 ORDER BY 之前</p>
<hr>
<h2><span id="guo-lu-fen-zu">过滤分组</span><a href="#guo-lu-fen-zu" class="header-anchor">#</a></h2>
<p>SELECT id， COUNT(<em>) AD orders<br>
FROM orders<br>
GROUP BY id<br>
HAVING COUNT(</em>) &gt;= 2</p>
<hr>
<h2><span id="lie-chu-ju-you-2-ge-yi-shang-jie-ge-wei-10-de-chan-pin">列出具有2个以上价格为10的产品</span><a href="#lie-chu-ju-you-2-ge-yi-shang-jie-ge-wei-10-de-chan-pin" class="header-anchor">#</a></h2>
<p>SELECT id, COUNT(<em>) AS  num<br>
FROM products<br>
WHERE price &gt;= 10<br>
GROUP BY id<br>
HAVING COUNT(</em>) &gt;=2<br>
顺序：先WHERE过滤， 在COUNT过滤</p>
<blockquote>
<blockquote>
<p>语句使用顺序<br>
SELECT<br>
FROM<br>
WHERE<br>
GROUP BY<br>
HAVING<br>
ORDER BY<br>
LIMIT</p>
</blockquote>
</blockquote>
<h1><span id="zi-cha-xun">子查询</span><a href="#zi-cha-xun" class="header-anchor">#</a></h1>
<h2><span id="zhao-chu-ding-gou-liao-wu-pin-tnt2-de-suo-you-ke-hu-id">找出订购了物品TNT2的所有客户id</span><a href="#zhao-chu-ding-gou-liao-wu-pin-tnt2-de-suo-you-ke-hu-id" class="header-anchor">#</a></h2>
<p>SELECT cus_id<br>
FROM orders<br>
WHERE sail_id IN （SELECT sail_id<br>
FROM orderitem<br>
WHERE prod_id = ‘TNT2’）<br>
即先从产品表中，找到产品id为INT2的所有订单<br>
再从订单表中，找到订单id匹配的所有客户。</p>
<p>检索出上述客户id的所有信息<br>
SELECT cus_name, cus_age<br>
FROM customer<br>
WHERE  cus_id IN (SELECT cus_id<br>
FROM orders<br>
WHERE sail_id IN （SELECT sail_id<br>
FROM orderitem<br>
WHERE prod_id = ‘TNT2’））<br>
显示每个客户的订单总数<br>
SELECT name, state, (SELECT COUNT(*)<br>
FROM orders<br>
WHERE orders.cus_id = cus.cus_id ) AS orders<br>
FROM customers<br>
ORDER BY name<br>
对于customer中的每一个客户id， 都从订单表中进行检索，找出每个id的订单数量。</p>
<h1><span id="ddl">DDL</span><a href="#ddl" class="header-anchor">#</a></h1>
<h2><span id="chuang-jian-biao">创建表：</span><a href="#chuang-jian-biao" class="header-anchor">#</a></h2>
<p>CREATE TABLE 表名<br>
（<br>
列名   数据类型   列属性<br>
……<br>
PRIMARY KEY (主键列1，主键列2……)<br>
）ENGINE=InnoDB</p>
<h2><span id="tian-jia-lie">添加列：</span><a href="#tian-jia-lie" class="header-anchor">#</a></h2>
<p>ALTER TABLE 表名<br>
ADD 列名 数据类型</p>
<h2><span id="shan-chu-lie">删除列：</span><a href="#shan-chu-lie" class="header-anchor">#</a></h2>
<p>ALTER TABLE 表名<br>
DROP COLUMN 列名</p>
<h2><span id="shan-chu-biao">删除表：</span><a href="#shan-chu-biao" class="header-anchor">#</a></h2>
<p>DROP TABLE 表名</p>
<h2><span id="chong-ming-ming-biao">重命名表：</span><a href="#chong-ming-ming-biao" class="header-anchor">#</a></h2>
<p>RENAME TABLE 旧表名 TO 新表名</p>
<h2><span id="cha-ru-xing">插入行：</span><a href="#cha-ru-xing" class="header-anchor">#</a></h2>
<p>INSERT INTO 表名(<br>
列名1<br>
列名2<br>
……<br>
)<br>
VALUES（<br>
数据1<br>
数据2<br>
……<br>
），<br>
（<br>
数据3<br>
数据4<br>
）;<br>
这样就插入了2行</p>
<p>更新数据：<br>
UPDATE 表名<br>
SET  列名1=数据1<br>
列名2=数据2<br>
WHERE 查询条件</p>
<h2><span id="shan-chu-shu-ju">删除数据：</span><a href="#shan-chu-shu-ju" class="header-anchor">#</a></h2>
<p>DELETE FROM 表名<br>
WHERE 查询条件</p>
<h2><span id="biao-zhong-shan-chu-zhu-jian-wei">表中删除主键为：</span><a href="#biao-zhong-shan-chu-zhu-jian-wei" class="header-anchor">#</a></h2>
<p>alert table table_test drop primary key;</p>
<h2><span id="biao-zhong-zeng-jia-zhu-jian-wei">表中增加主键为：</span><a href="#biao-zhong-zeng-jia-zhu-jian-wei" class="header-anchor">#</a></h2>
<p>alert table table_test add primary key(id);</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/" class="post-title-link" itemprop="url">2022-0823</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 23:12:42" itemprop="dateCreated datePublished" datetime="2022-08-23T23:12:42+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 00:09:40" itemprop="dateModified" datetime="2022-08-24T00:09:40+08:00">2022-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">刷题日记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022%E5%B9%B48%E6%9C%88/" itemprop="url" rel="index"><span itemprop="name">2022年8月</span></a>
                </span>
            </span>

          
            <span id="/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/" class="post-meta-item leancloud_visitors" data-flag-title="2022-0823" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BC%96%E7%A8%8B/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/2022-08-23/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#di-yi-ti-shu-xue-gui-lu-ti-mei-xiang-tong">第一题:数学规律题(没想通)</a></li>
<li><a href="#di-er-ti-ju-zhen-qian-zhui-he-ying-yong">第二题:矩阵前缀和应用</a></li>
<li><a href="#di-san-ti-shu-he-di-gui">第三题:树和递归</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="di-yi-ti-shu-xue-gui-lu-ti-mei-xiang-tong">第一题:数学规律题(没想通)</span><a href="#di-yi-ti-shu-xue-gui-lu-ti-mei-xiang-tong" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/transform-to-chessboard/">782. 变为棋盘 - 力扣（LeetCode）</a></p>
<p>看答案也没看懂，主要是没有深入研究规律，没精力了，先放着</p>
<p><img src="/images/2022-08-23/1661270748809.png" alt="1661270748809"></p>
<p><img src="/images/2022-08-23/1661270976714.png" alt="1661270976714"></p>
<h1><span id="di-er-ti-ju-zhen-qian-zhui-he-ying-yong">第二题:矩阵前缀和应用</span><a href="#di-er-ti-ju-zhen-qian-zhui-he-ying-yong" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/O4NDxx/">剑指 Offer II 013. 二维子矩阵的和 - 力扣（LeetCode）</a></p>
<p><img src="/images/2022-08-23/1661270797124.png" alt="1661270797124"></p>
<p>做过好几次了， 维护一个dp[y][x]， 表示（y，x）到(0,0)的矩形和，这个和可以提前遍历一次得到</p>
<p>然后再通过加减矩阵的方式得到结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="type">int</span> ylen;</span><br><span class="line">    <span class="type">int</span> xlen;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        ylen = matrix.length;</span><br><span class="line">        xlen = matrix[<span class="number">0</span>].length;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[ylen][xlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;y&lt;ylen;y++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; xlen; x++) &#123;</span><br><span class="line">                sum += matrix[y][x];</span><br><span class="line">                dp[y][x] = sum + (y-<span class="number">1</span>&gt;=<span class="number">0</span>?dp[y-<span class="number">1</span>][x]:<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(row2, col2) - sum(row2, col1-<span class="number">1</span>) - sum(row1-<span class="number">1</span>, col2) + sum(row1-<span class="number">1</span>, col1-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;<span class="number">0</span> || x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1><span id="di-san-ti-shu-he-di-gui">第三题:树和递归</span><a href="#di-san-ti-shu-he-di-gui" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串 - 力扣（LeetCode）</a></p>
<p><img src="/images/2022-08-23/1661270915678.png" alt="1661270915678"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span> + tree2str(root.left) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span> + tree2str(root.right) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.length() == <span class="number">2</span> &amp;&amp; right.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            left = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            right = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(left.length() != <span class="number">2</span> &amp;&amp; right.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            right = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val + left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/" class="post-title-link" itemprop="url">MYSQL表字段定义和优化建议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 22:47:49" itemprop="dateCreated datePublished" datetime="2022-08-23T22:47:49+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 00:12:29" itemprop="dateModified" datetime="2022-08-24T00:12:29+08:00">2022-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/" class="post-meta-item leancloud_visitors" data-flag-title="MYSQL表字段定义和优化建议" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#xuan-ze-shu-ju-lei-xing-de-yuan-ze">选择数据类型的原则：</a></li>
<li><a href="#zheng-shu-lei-xing">整数类型：</a></li>
<li><a href="#shi-shu-lei-xing-dai-xiao-shu-dian-de-lei-xing">实数类型（带小数点的类型）</a></li>
<li><a href="#zi-fu-chuan-lei-xing">字符串类型</a>
<ul>
<li><a href="#varchar">varchar</a></li>
<li><a href="#char">char</a></li>
<li><a href="#binary-he-varbinary">binary 和varbinary</a></li>
</ul>
</li>
<li><a href="#blob-he-text">BLOB和TEXT</a></li>
<li><a href="#mei-ju-enum">枚举enum</a></li>
<li><a href="#ri-qi-he-shi-jian-lei-xing">日期和时间类型</a>
<ul>
<li><a href="#datetime">DATETIME</a></li>
<li><a href="#timestamp">TIMESTAMP</a></li>
</ul>
</li>
<li><a href="#wei-lei-xing">位类型</a>
<ul>
<li><a href="#bit-n">bit（n)</a></li>
<li><a href="#set">set</a></li>
</ul>
</li>
<li><a href="#zhu-jian-de-xuan-ze">主键的选择</a></li>
<li><a href="#schema-she-ji-shi-de-xian-jing">schema设计时的陷阱</a></li>
<li><a href="#fan-shi-de-kao-liang">范式的考量</a></li>
<li><a href="#cha-xun-de-huan-cun">查询的缓存</a></li>
<li><a href="#alter-table-xing-neng-wen-ti">alter table性能问题</a></li>
<li><a href="#fen-qu-de-xian-zhi">分区的限制</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="xuan-ze-shu-ju-lei-xing-de-yuan-ze">选择数据类型的原则：</span><a href="#xuan-ze-shu-ju-lei-xing-de-yuan-ze" class="header-anchor">#</a></h1>
<ul>
<li>越小越好。 如果后续因为业务需求要alter增大范围， 会很耗时。</li>
<li>简单数据类型， 比如用整数而不是字符串去存ip。</li>
<li>尽量NOT NULL。原因:索引列如果存在null， 会需要一个额外的字节，? ?索引统计也变复杂了。</li>
</ul>
<h1><span id="zheng-shu-lei-xing">整数类型：</span><a href="#zheng-shu-lei-xing" class="header-anchor">#</a></h1>
<ul>
<li>mediumint是24位的， 其他分别是8、16、32、64对应tiny、small、int、big</li>
<li>支持unsigned属性</li>
<li>int(11)不代表用11位存储， 限定只是在客户端工具中只显示11位字符。</li>
</ul>
<h1><span id="shi-shu-lei-xing-dai-xiao-shu-dian-de-lei-xing">实数类型（带小数点的类型）</span><a href="#shi-shu-lei-xing-dai-xiao-shu-dian-de-lei-xing" class="header-anchor">#</a></h1>
<ul>
<li>有时候不一定是为了小数才选实数。  比如选decima而不是bigint是因为decimal可以存储比bigint还要大的数字</li>
<li>float和double就是标准的16、32浮点运算</li>
<li>decimal存储精确的小数和精确计算（精确计算只在mysql5.0之后）</li>
<li>浮点比decimal要的存储空间更小， decimal(18.9）会用掉9个字节（4小数点前+4小数点后+1小数点本身）</li>
<li>只有精确计算才用到decimal， 如果数据太多，为了节省空间， 可以改成用bigint（只要把小数点部分乘10的倍数，去掉小数点即可），毕竟decimal比较耗空间。</li>
</ul>
<h1><span id="zi-fu-chuan-lei-xing">字符串类型</span><a href="#zi-fu-chuan-lei-xing" class="header-anchor">#</a></h1>
<h2><span id="varchar">varchar</span><a href="#varchar" class="header-anchor">#</a></h2>
<ul>
<li>存储可变长字符串。（例外： 用ROW_FORMAT=FIXED创建的话，varchar的空间会固定）</li>
<li>可变长的概念：<br>
char是固定长度的，例如你定义了12，插入了&quot;aa&quot;，后面它会给你补10个空。如果是varchar，那么&quot;aa&quot;就是&quot;aa&quot;不会给你补</li>
<li>varchar(N)代表的N是最大长度</li>
<li>需要1-2个额外字节， 来保存字符串长度<br>
varchar(n）需要的最大存储空间长度=  n + (n&lt;=255?1:2)</li>
<li>2种情况不适合用varchar</li>
</ul>
<ol>
<li>最大长度比平均长度要大</li>
<li>列的更新很少</li>
</ol>
<ul>
<li>varchar(5)相比于varchar(200)的优势：  mysql会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或者操作时会特别糟糕？？ 不懂</li>
</ul>
<h2><span id="char">char</span><a href="#char" class="header-anchor">#</a></h2>
<ul>
<li>char是定长的，因此总是会预留足够的空间</li>
<li>char存储时，会删除字符串末尾的空格。 即’  abc  ‘存入后，会变成’  abc’</li>
<li>char相比varchar的优势： 字符串很短时， 需要的空间比varchar少(varchar需要额外空间存储长度)</li>
</ul>
<h2><span id="binary-he-varbinary">binary 和varbinary</span><a href="#binary-he-varbinary" class="header-anchor">#</a></h2>
<ul>
<li>存储的是二进制字符串（字节码，0x77那种）</li>
<li>binary 采用\0而不是空格来填充</li>
<li>二进制字节码比较的速度比字符快</li>
</ul>
<h1><span id="blob-he-text">BLOB和TEXT</span><a href="#blob-he-text" class="header-anchor">#</a></h1>
<ul>
<li>为了存储超大的数据而设计的字符串类型</li>
<li>mysql把他们当作独立的对象处理，专门使用外部的存储区域来存储， 内部存储指针。</li>
<li>BLOB和TEXT的区别： 一个是二进制，一个带有字符集规则</li>
<li>mysql对这2个类型做排序时， 只对前max_sort_length字节做排序</li>
<li>因此不能将这2个类型的字段做索引</li>
</ul>
<h1><span id="mei-ju-enum">枚举enum</span><a href="#mei-ju-enum" class="header-anchor">#</a></h1>
<p>create table enum_test(e ENUM(‘a’,‘b’,‘c’) NOT NULL)</p>
<ul>
<li>实际上存储的不是’a’这个字符串，而是1\2\3 这类数字</li>
<li>按照定义顺序分配数字</li>
<li>排序时也按照实际数字排序，而不是枚举的字典序</li>
<li>枚举作为主键也优于字符串， 毕竟她本质是数字。但是比数字会差一点。</li>
</ul>
<h1><span id="ri-qi-he-shi-jian-lei-xing">日期和时间类型</span><a href="#ri-qi-he-shi-jian-lei-xing" class="header-anchor">#</a></h1>
<h2><span id="datetime">DATETIME</span><a href="#datetime" class="header-anchor">#</a></h2>
<ul>
<li>从1001到9999年， 精度为秒</li>
<li>与时区无关</li>
<li>使用8个字节存储</li>
</ul>
<h2><span id="timestamp">TIMESTAMP</span><a href="#timestamp" class="header-anchor">#</a></h2>
<ul>
<li>从1970.1.1至今的秒数</li>
<li>只使用4个字节</li>
<li>显示依赖时区，服务端、客户端都需要配置时区，然后timeStamp的展示就会不同。</li>
<li>TIMESTAMP默认为NOT NULL</li>
<li>插入时会自动设置这个列的值为“当前时间”</li>
</ul>
<p>如果想存毫秒怎么办？ 可以使用bigint来存储毫秒级时间戳。</p>
<h1><span id="wei-lei-xing">位类型</span><a href="#wei-lei-xing" class="header-anchor">#</a></h1>
<p>通常用于存储acl权限</p>
<h2><span id="bit-n">bit（n)</span><a href="#bit-n" class="header-anchor">#</a></h2>
<ul>
<li>mysql把bit当作字符串而不是数字类型</li>
<li>存储00111001并且检索时， 得到的ASCII为57的字符串（即’9’)。  在数字上下文场景却是数字57</li>
<li>因为这个特性，慎用bit</li>
</ul>
<h2><span id="set">set</span><a href="#set" class="header-anchor">#</a></h2>
<ul>
<li>如果字段内容就是一堆true或者false的位，可以放到set类型种</li>
<li>替代方式： 用tinyint类型来替代， 就是比太好理解。</li>
</ul>
<hr>
<h1><span id="zhu-jian-de-xuan-ze">主键的选择</span><a href="#zhu-jian-de-xuan-ze" class="header-anchor">#</a></h1>
<ul>
<li>整数是坠好的</li>
<li>enum和set是糟糕的选择。</li>
<li>字符串类型也尽量避免。空间大，检索慢</li>
<li>避免随机生成的主键字符串，原因:</li>
</ul>
<ol>
<li>插入值会随机写到索引的不同位置</li>
<li>select语句会变慢</li>
<li>随机值导致缓存失效( 局部性原理gg）<br>
因此最好不要用string类型的UUID，  而是转为数字。</li>
</ol>
<hr>
<h1><span id="schema-she-ji-shi-de-xian-jing">schema设计时的陷阱</span><a href="#schema-she-ji-shi-de-xian-jing" class="header-anchor">#</a></h1>
<ul>
<li>太长的列且列中有变长的字段， 可能会导致转换成行数据结构时要消耗很大的CPU。（从行缓冲种将编码过的列转成行数据的缘故）</li>
<li>表的关联表太多会有问题。 建议查询最好在12个表内做关联。</li>
<li>防止过度使用枚举。 枚举的缺点:<br>
① 可能会有人搞一个enum(‘-1’,‘0’,‘1’,‘2’)这种误导人的枚举<br>
② 每次要新增枚举必须alter table，会阻塞表</li>
<li>set中的元素如果每次只能出现一个， 应该改成枚举。</li>
<li>mysql会在索引中存储null，但是oracle不会。</li>
<li>尽量不要用null，而是用空字符串、默认值替代，除非没有可以用的默认值，宁愿用null去引起调用方注意</li>
</ul>
<hr>
<h1><span id="fan-shi-de-kao-liang">范式的考量</span><a href="#fan-shi-de-kao-liang" class="header-anchor">#</a></h1>
<p>范式设计： 每个数据一般只会出现一次，没有冗余或者重复数据<br>
反范式： 与范式相反。</p>
<p>范式的优点：</p>
<ul>
<li>更新操作快，因为重复的记录少</li>
<li>表更小，可以更好地放到内存里</li>
<li>很少需要做distinct、groupby， 因此一般都是1对1的关系</li>
</ul>
<p>缺点：<br>
查询时经常需要关联，当关联后的另外一个表需要做条件判断，可能会消耗一定性能</p>
<p>反范式的优缺点和范式正好相反。</p>
<hr>
<h1><span id="cha-xun-de-huan-cun">查询的缓存</span><a href="#cha-xun-de-huan-cun" class="header-anchor">#</a></h1>
<ul>
<li>有时候会弄一个叫缓存表或者汇总表的东西， 避免每次查询所有记录来得到一个区间的结果</li>
<li>计数器表，如果表里只有1行，可能导致并发效率低。 可以弄100行，然后大家更新时随机更新。  统计结果时直接sum即可</li>
</ul>
<hr>
<h1><span id="alter-table-xing-neng-wen-ti">alter table性能问题</span><a href="#alter-table-xing-neng-wen-ti" class="header-anchor">#</a></h1>
<ul>
<li>mysql中，  alter table的原理一般是  用新的结构创建一个新表，然后把数据导入到新表中。</li>
<li>有一些操作可以只修改表的.frm文件来达到修改结构的作用。<br>
比如 alter column修改默认值，  移除列的auto_increment属性， 或者修改enum、set的常量 （可以通过弄一个新表，然后只修改新表的属性，接着进入数据库后端直接替换tablename.frm文件</li>
</ul>
<h1><span id="fen-qu-de-xian-zhi">分区的限制</span><a href="#fen-qu-de-xian-zhi" class="header-anchor">#</a></h1>
<p>MySQL分区的限制</p>
<ul>
<li>
<p>一个表最多只能有1024个分区。</p>
</li>
<li>
<p>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</p>
</li>
<li>
<p>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</p>
</li>
<li>
<p>分区表中无法使用外键约束。</p>
</li>
<li>
<p>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190486/article/details/108758205">分区详细用法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/" class="post-title-link" itemprop="url">MYSQL语句调优手段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-23 00:47:49 / 修改时间：00:30:02" itemprop="dateCreated datePublished" datetime="2022-08-23T00:47:49+08:00">2022-08-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/" class="post-meta-item leancloud_visitors" data-flag-title="MYSQL语句调优手段" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#cha-xun-wei-shi-me-hui-man">查询为什么会慢？</a></li>
<li><a href="#ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun">应用逻辑上处理低效查询</a>
<ul>
<li><a href="#ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju">应用层逻辑上，是不是返回了太多会被自己抛弃的数据</a></li>
<li><a href="#mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu">mysql中，是否在扫描额外的记录</a></li>
</ul>
</li>
<li><a href="#chong-gou-cha-xun-yu-ju">重构查询语句</a>
<ul>
<li><a href="#limit-qie-fen-cha-xun">limit切分查询</a></li>
<li><a href="#guan-lian-cha-xun-join-fen-jie">关联查询（join）分解</a></li>
<li><a href="#you-hua-in-cha-xun">优化In查询</a></li>
<li><a href="#you-hua-union-jia-limit">优化UNION加limit</a></li>
<li><a href="#suo-yin-he-bing-you-hua">索引合并优化</a></li>
<li><a href="#deng-zhi-chuan-di">等值传递</a></li>
<li><a href="#bing-xing-zhi-xing">并行执行？</a></li>
<li><a href="#ha-xi-guan-lian">哈希关联</a></li>
<li><a href="#song-san-suo-yin-sao-miao">松散索引扫描</a></li>
<li><a href="#zui-da-he-zui-xiao-zhi-you-hua">最大和最小值优化</a></li>
<li><a href="#tong-biao-cha-xun-he-geng-xin">同表查询和更新</a></li>
<li><a href="#you-hua-count">优化Count()</a></li>
<li><a href="#guan-lian-cha-xun-you-hua">关联查询优化</a></li>
<li><a href="#group-by-you-hua">Group by优化</a></li>
<li><a href="#you-hua-limit-fen-ye">优化LIMIT分页</a></li>
<li><a href="#ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye">如何知道是否有下一页?分多少页？</a></li>
<li><a href="#you-hua-union">优化UNION</a></li>
<li><a href="#shi-yong-zi-ding-yi-bian-liang-you-hua">使用自定义变量优化</a></li>
<li><a href="#yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua">用特殊关键字控制执行计划</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="cha-xun-wei-shi-me-hui-man">查询为什么会慢？</span><a href="#cha-xun-wei-shi-me-hui-man" class="header-anchor">#</a></h1>
<ul>
<li>查询的生命周期<br>
客户端发送-&gt;服务器接收-&gt;服务器解析sql-&gt;生成执行计划-&gt;执行-&gt;返回结果<br>
其中最耗时的就是执行了。</li>
<li>查询执行时耗费的时间：</li>
</ul>
<ol>
<li>网络</li>
<li>CPU计算</li>
<li>生成统计信息</li>
<li>锁等待</li>
<li>IO操作</li>
</ol>
<h1><span id="ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun">应用逻辑上处理低效查询</span><a href="#ying-yong-luo-ji-shang-chu-li-di-xiao-cha-xun" class="header-anchor">#</a></h1>
<h2><span id="ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju">应用层逻辑上，是不是返回了太多会被自己抛弃的数据</span><a href="#ying-yong-ceng-luo-ji-shang-shi-bu-shi-fan-hui-liao-tai-duo-hui-bei-zi-ji-pao-qi-de-shu-ju" class="header-anchor">#</a></h2>
<p>这个主要和 返回的数据有关</p>
<ul>
<li>sql里写的是返回所有行， 却在代码里只取resultSet的前10行。</li>
<li>sql里写的是返回select *，  代码里却只需要特定几列。</li>
<li>每次查询肯定是相同的结果，却没有做缓存。</li>
</ul>
<h2><span id="mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu">mysql中，是否在扫描额外的记录</span><a href="#mysql-zhong-shi-fou-zai-sao-miao-e-wai-de-ji-lu" class="header-anchor">#</a></h2>
<p>这个主要和查询的过程有关（返回的数据已经优化到最优了)</p>
<ul>
<li>扫描的行数/返回的行数的比值越小越好</li>
<li>EXPLAIN分析中有几个type，从坏到好分别是</li>
</ul>
<ol>
<li>全表扫描All</li>
<li>索引扫描ref</li>
<li>范围扫描</li>
<li>唯一索引查询</li>
<li>常数引用<br>
EXPLANIN里会显示扫描的行数row， 你可以和返回的行数做对比</li>
</ol>
<ul>
<li>mysql中有3种方式来使用where条件，从好到坏分别是</li>
</ul>
<ol>
<li>在索引中直接做where判断来过滤，然后返回底层数据，这个需要在存储引擎层完成</li>
<li>索引覆盖扫描，直接在索引中返回数据，没有走到底层的数据处，这个在服务器层完成即可，不用走到底层存储引擎</li>
<li>先从存储引擎返回数据， 然后再在服务器层做where判断来过滤</li>
</ol>
<ul>
<li>为了减少扫描的行数，常见优化方式：</li>
</ul>
<ol>
<li>使用索引覆盖扫描</li>
<li>使用汇总表（就是每次做一些操作就会触发更新，不要再去重复查询了）</li>
<li>重写复杂查询(联结等）</li>
</ol>
<h1><span id="chong-gou-cha-xun-yu-ju">重构查询语句</span><a href="#chong-gou-cha-xun-yu-ju" class="header-anchor">#</a></h1>
<h2><span id="limit-qie-fen-cha-xun">limit切分查询</span><a href="#limit-qie-fen-cha-xun" class="header-anchor">#</a></h2>
<ul>
<li>指的是用limit等分页手段来切分，分多次执行</li>
<li>适用于一些可能会锁表的大批量操作。</li>
<li>比如删除某10w条数据， 最好先查询+limit 1w，分10次执行，中间间隔一些时间， 避免长时间的锁表。</li>
</ul>
<h2><span id="guan-lian-cha-xun-join-fen-jie">关联查询（join）分解</span><a href="#guan-lian-cha-xun-join-fen-jie" class="header-anchor">#</a></h2>
<ul>
<li>如果一个语句中join多次， 看下能不能在应用层分3个select依次执行，每次取前一次select的结果加入自己的条件中</li>
<li>好处：</li>
</ul>
<ol>
<li>分解后条件变简单了，就有可能利用mysql的缓存。</li>
<li>也因为条件变简单且是单表，可能会利用上索引</li>
<li>减少锁的竞争</li>
<li>每个表相当于只查询了一次， 减少了重复访问。</li>
</ol>
<h2><span id="you-hua-in-cha-xun">优化In查询</span><a href="#you-hua-in-cha-xun" class="header-anchor">#</a></h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> b <span class="keyword">where</span> b.xx<span class="operator">&lt;</span>y)</span><br></pre></td></tr></table></figure>
<p>注意上面并不是先计算in子表返回的内容，然后作为条件去做检查<br>
而是变成一个关联查询</p>
<p>select * from a where exist(select * from b where b.xx&lt;y and <a target="_blank" rel="noopener" href="http://a.id=b.id">a.id=b.id</a>))</p>
<p>会先对file表做全表扫描，然后再进行条件查询。这这会很慢</p>
<ul>
<li>改进：</li>
</ul>
<ol>
<li>用inner join改写成内联</li>
<li>用GROUP_CONCAT生成一个列表，再提供给IN去使用。<br>
P 224-225</li>
</ol>
<h2><span id="you-hua-union-jia-limit">优化UNION加limit</span><a href="#you-hua-union-jia-limit" class="header-anchor">#</a></h2>
<p>（select …） UNION ALL (select …) limit 20<br>
这句话本质上会把需要联合的表全部取出，做合并之后，再limit，如果表很大，limit相当于没有他本该的作用。<br>
可以改成 在内部都加上一个limit来减少union时的量</p>
<h2><span id="suo-yin-he-bing-you-hua">索引合并优化</span><a href="#suo-yin-he-bing-you-hua" class="header-anchor">#</a></h2>
<h2><span id="deng-zhi-chuan-di">等值传递</span><a href="#deng-zhi-chuan-di" class="header-anchor">#</a></h2>
<p>IN（）列表可能会被复制到关联的各个表中， 列表很大就会导致执行变慢</p>
<h2><span id="bing-xing-zhi-xing">并行执行？</span><a href="#bing-xing-zhi-xing" class="header-anchor">#</a></h2>
<p>mysql都是单线程进行查询</p>
<h2><span id="ha-xi-guan-lian">哈希关联</span><a href="#ha-xi-guan-lian" class="header-anchor">#</a></h2>
<ul>
<li>mysql不支持哈希关联， 关联都是通过 嵌套循环关联的。</li>
<li>除非用之前提过的自定义哈希索引部分（弄一个触发器来生成哈希索引）</li>
</ul>
<h2><span id="song-san-suo-yin-sao-miao">松散索引扫描</span><a href="#song-san-suo-yin-sao-miao" class="header-anchor">#</a></h2>
<p>指没有用到第一列索引，却需要用第二列索引时，按照下面的方式去查：<br>
<img src="/images/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/7276f16be3c71df35198c15d8fdcab0a8032bf14.png" alt="7276f16be3c71df35198c15d8fdcab0a8032bf14"><br>
select * from xxx where B = xxx group by A;<br>
添加 group by 字段后，会先根据 A 索引分组后，会在每个 A 的范围内使用索引进行快速查询定位所需要的 B 列，这就叫做松散索引扫描，比新建一个索引的效率会慢 A 的 distinct 倍，但省去了新索引的消耗</p>
<h2><span id="zui-da-he-zui-xiao-zhi-you-hua">最大和最小值优化</span><a href="#zui-da-he-zui-xiao-zhi-you-hua" class="header-anchor">#</a></h2>
<p>如果你MIN（）的是主键，且where中没有用到索引， 那么MYQL就进行全表顺序扫描。<br>
扫描时按理应当满足第一个可行的值时，就是最小值（主键按顺序排列）<br>
但是mysql不支持。<br>
可以用limit 1来优化，不要用MIN或者MAX， 如果你要统计的是主键的值的话。</p>
<h2><span id="tong-biao-cha-xun-he-geng-xin">同表查询和更新</span><a href="#tong-biao-cha-xun-he-geng-xin" class="header-anchor">#</a></h2>
<p>mysql不允许 在同一张表进行查询和更新<br>
<img src="/images/MYSQL%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5/177fdc92efb7933bd40b061f64dc615480e891e7.png" alt="177fdc92efb7933bd40b061f64dc615480e891e7"></p>
<h2><span id="you-hua-count">优化Count()</span><a href="#you-hua-count" class="header-anchor">#</a></h2>
<ul>
<li>count(列或列的表达式) 会过滤掉无值或者null的情况。 而count(*)直接统计所有行数</li>
<li>count(*)的性能好一点， 因为他不用过滤和比较是否为空，可以直接用存储引擎记录的一些信息直接得到。</li>
<li>count(*) 不带where非常快，  如果带了where，就要遍历。</li>
<li>一种优化： 如果统计where id&gt;5， 而id&gt;5很多，&lt;5却很少，可以反向求接，改成<br>
select (select count(<em>) from city) - count(</em>) from t where id &lt; 5。<br>
毕竟不带where的是很快的。</li>
<li>如果对计数要求不是那么精确， 可以用汇总表去处理总和的问题，每隔一段时间更新一次。</li>
<li>注意这种用法<br>
select count(color=‘blue’ OR NULL) AS bule, count(color=‘red’ OR NULL) as red from items;<br>
可以求红色和蓝色的个数并展示在同一行中，无需分组。</li>
</ul>
<h2><span id="guan-lian-cha-xun-you-hua">关联查询优化</span><a href="#guan-lian-cha-xun-you-hua" class="header-anchor">#</a></h2>
<ul>
<li>确保ON或者USING的列上有索引</li>
<li>如果B join A， 那么A上有索引足够了。因为联结是是遍历B的每一行，拿B的joinKey 去A里面搜索，所以真正用到的是A的索引（除非执行计划做了优化）</li>
<li>优化GROUP BY 或者DISTINCT</li>
</ul>
<h2><span id="group-by-you-hua">Group by优化</span><a href="#group-by-you-hua" class="header-anchor">#</a></h2>
<ul>
<li>分组时，要么利用文件要么利用内存做临时表，你可以用优化器的提示去控制用内存还是文件</li>
<li>join后再分组， 分组里的列尽量用join的key，  比如你虽然是要按名字分组并栈式的，但名字和id是一一对应的，所以按id分组并展示名字是ok的</li>
<li>不要用分组去展示非分组列（即不是聚合结果也不是分组列）</li>
<li>分组时，会自动对分组后的结果按分组列排序，消耗一定时间。  如果不希望排序，可以加一个ORDER BY NULL</li>
</ul>
<h2><span id="you-hua-limit-fen-ye">优化LIMIT分页</span><a href="#you-hua-limit-fen-ye" class="header-anchor">#</a></h2>
<ul>
<li>对于“LIMIT 100000,10”     里面存在100000的偏移，而偏移本质上得扫描掉前面的100020条记录。</li>
<li>有3种优化方式：</li>
</ul>
<ol>
<li>构造一个联结临时表，临时表里做索引覆盖查询+limit（即select的只有limit列），然后再拿得到的id做联结，获取你需要的列。</li>
<li>如果确定是某个limit的范围，且为索引，则用where 索引范围来代替</li>
<li>或者where xx&lt;100020 ORDER BY XX DESC LIMIT 20来反向求。</li>
</ol>
<h2><span id="ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye">如何知道是否有下一页?分多少页？</span><a href="#ru-he-zhi-dao-shi-fou-you-xia-yi-ye-fen-duo-shao-ye" class="header-anchor">#</a></h2>
<ol>
<li>LIMIT的时候加上SQL_CALC_FOUND_ROWS。这样会返回除去LIMIT之外的其他行数，相当于剩下还需要的行数。</li>
<li>每次LIMIT X+1， 应用层只拿X行， 如果有多一行，说明还有下一页</li>
<li>每次LIMIT 10X， 然后10X作为缓存，应用层每次取X作为一页展示。</li>
</ol>
<h2><span id="you-hua-union">优化UNION</span><a href="#you-hua-union" class="header-anchor">#</a></h2>
<ul>
<li>UNION的本质是创建并填充临时表</li>
<li>用UNION ALL， 否则会默认加上DISTINCT关键字进行唯一性检查，消耗性能</li>
</ul>
<h2><span id="shi-yong-zi-ding-yi-bian-liang-you-hua">使用自定义变量优化</span><a href="#shi-yong-zi-ding-yi-bian-liang-you-hua" class="header-anchor">#</a></h2>
<p>见6.4自定义变量</p>
<h2><span id="yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua">用特殊关键字控制执行计划</span><a href="#yong-te-shu-guan-jian-zi-kong-zhi-zhi-xing-ji-hua" class="header-anchor">#</a></h2>
<ul>
<li>High_Priority/low_priority<br>
多个语句同时操作一个表时， 可以用这个来控制语句的优先级。</li>
<li>Delayed<br>
对插入和更新操作而言， 他会直接返回响应给客户端，然后把数据缓存下来，等服务器空闲了再去插</li>
<li>Straight_join<br>
可以用这个关键字控制 join顺序，而不是用优化器的join顺序</li>
<li>SQL_small_result<br>
告诉优化器 结果集很小，你可以搞个内存临时表做排序</li>
<li>SQL_big_result<br>
告诉优化器 结果集很大， 可以提早准备磁盘排序而不是等发现不够了采用磁盘。</li>
<li>SQL_CACHE<br>
结果集是否应该缓存。</li>
<li>SQL_CALC_FOUND_ROWS<br>
让返回的结果集包含更多信息（例如limit 10,结果集里却有个总数信息）</li>
<li>For update / Lock in share ode<br>
提示优化器加行锁</li>
<li>Use/ignore/force Index</li>
<li>告诉优化器要不要用索引，如果是force，即使where里没有索引，也会去用索引。 如果是ignore，则就是不用，傲娇</li>
<li>optimizer_search_depth<br>
dfs搜索计划时的最大深度</li>
<li>optimizer_prune_level<br>
根据扫描的行数来决定是否跳过执行计划？</li>
<li>optimizer_switch<br>
选择是否关闭某些优化器特性</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">MYSQL执行和内部优化原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 23:47:49" itemprop="dateCreated datePublished" datetime="2022-08-22T23:47:49+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 00:26:48" itemprop="dateModified" datetime="2022-08-23T00:26:48+08:00">2022-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">SQL数据库</span></a>
                </span>
            </span>

          
            <span id="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="MYSQL执行和内部优化原理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#mysql-zhi-xing-cha-xun-de-guo-cheng">mysql执行查询的过程</a>
<ul>
<li><a href="#yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li">一、客户端发查询请求到服务端之间的原理</a></li>
<li><a href="#er-you-xian-cha-xun-huan-cun">二、优先查询缓存</a></li>
<li><a href="#san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li">三、查询前做语句优化处理</a>
<ul>
<li><a href="#1-yu-fa-jie-xi-qi-he-yu-chu-li">1.语法解析器和预处理</a></li>
<li><a href="#2-cha-xun-you-hua-qi-chong-dian">2.查询优化器(重点）</a>
<ul>
<li><a href="#mysql-de-you-hua-lei-xing">mysql的优化类型</a></li>
</ul>
</li>
<li><a href="#3-shu-ju-he-suo-yin-de-tong-ji-xin-xi">3.数据和索引的统计信息</a></li>
<li><a href="#4-mysql-dui-guan-lian-cha-xun-de-zhi-xing">4.MYSQL对关联查询的执行</a></li>
<li><a href="#5-zhi-xing-shu-you-hua">5. 执行树优化</a></li>
<li><a href="#6-guan-lian-cha-xun-you-hua-qi">6. 关联查询优化器</a></li>
<li><a href="#7-pai-xu-you-hua">7.排序优化</a></li>
</ul>
</li>
<li><a href="#si-zhen-zheng-zhi-xing-cha-xun-ji-hua">四、真正执行查询计划</a></li>
<li><a href="#wu-fan-hui-jie-guo-gei-ke-hu-duan">五、返回结果给客户端</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="mysql-zhi-xing-cha-xun-de-guo-cheng">mysql执行查询的过程</span><a href="#mysql-zhi-xing-cha-xun-de-guo-cheng" class="header-anchor">#</a></h1>
<p><img src="/images/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/d07d12af7b4cd173bb9275fd8ef0e6e6ea2a8aca.png" alt="d07d12af7b4cd173bb9275fd8ef0e6e6ea2a8aca"></p>
<ol>
<li>客户端先发送查询语句给服务器</li>
<li>服务器检查缓存，如果存在则返回</li>
<li>进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划</li>
<li>根据执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端。</li>
</ol>
<p>下面是详解</p>
<h2><span id="yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li">一、客户端发查询请求到服务端之间的原理</span><a href="#yi-ke-hu-duan-fa-cha-xun-qing-qiu-dao-fu-wu-duan-zhi-jian-de-yuan-li" class="header-anchor">#</a></h2>
<ul>
<li>客户端和服务端之间是半双工的， 即一个通道内只能一个在发一个接收， 不能同时互相发互相接收</li>
<li>客户端只会发送一个数据包给服务端，并不会在应用层拆成2个数据包去发（max_allowed_packet可以设置数据包最大长）， 这关系到sql语句不能太长。</li>
<li>服务端返回给客户端可以有多个数据包， 但是客户端必须完整接收，不能接到一半停掉连接或用连接去做其他事（UI界面可以操作，不同的线程）</li>
<li>例如java，如果没设置fetchSize，那么都是一次性把结果读进内存。当你使用resultSet的时候，其实已经全部进来了，而不是一条条从服务端获取。————使用fetch Size边读边处理的坏处： 服务端占用的资源时间变久了。</li>
</ul>
<p><strong>查询mysql服务此时的状态：</strong></p>
<p>使用 <em><strong>show full processlist</strong></em> 命令可以查看mysql服务端某些线程的状态</p>
<ul>
<li>Sleep  正在等待客户端发送新的请求</li>
<li>Query 正在执行查询， 或者发结果发给客户端</li>
<li>Locked  正在等待表锁（注意表锁是服务器层的， 而行锁是存储引擎层的，行锁时状态为query）</li>
<li>Analyzing and statistics  正在生成查询的计划或者收集统计信息</li>
<li>copying to tmp table  临时表操作，一般是正在做group by等操作</li>
<li>sorting result  正在对结果集做排序</li>
<li>sending data 正在服务器线程之间传数据</li>
</ul>
<h2><span id="er-you-xian-cha-xun-huan-cun">二、优先查询缓存</span><a href="#er-you-xian-cha-xun-huan-cun" class="header-anchor">#</a></h2>
<ul>
<li>缓存的查询在sql解析之前进行。</li>
<li>缓存的查找通过一个 对大小写敏感的哈希表实现，即直接比对sql字符串。</li>
<li>因此只要有一个字节不同，都不会匹配中。（毕竟还没开始解析，大小写什么的他也不知道要不要区分）</li>
<li>第7章中有更详细的查询缓存。</li>
</ul>
<h2><span id="san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li">三、查询前做语句优化处理</span><a href="#san-cha-xun-qian-zuo-yu-ju-you-hua-chu-li" class="header-anchor">#</a></h2>
<h3><span id="1-yu-fa-jie-xi-qi-he-yu-chu-li">1.语法解析器和预处理</span><a href="#1-yu-fa-jie-xi-qi-he-yu-chu-li" class="header-anchor">#</a></h3>
<ul>
<li>这里就是把sql做解析， 变成一个解析树。解析时会做mysql语法规则验证。</li>
<li>语法解析器: 检查关键字错误、关键字顺序、引号匹配</li>
<li>预处理：和元数据关联校验， 检查数据表和列是否存在，解析名字和别名。</li>
<li>权限校验</li>
</ul>
<h3><span id="2-cha-xun-you-hua-qi-chong-dian">2.查询优化器(重点）</span><a href="#2-cha-xun-you-hua-qi-chong-dian" class="header-anchor">#</a></h3>
<ul>
<li>mysql可能会生成多种计划， 他会分别计算一个预测成本值，然后选一个成本最小的计划</li>
<li>计算信息来自于 表的页面个数、索引分布、长度、个数、数据行长度</li>
<li>因为多种原因，可能不会选择到最优的计划，有偏差</li>
<li>静态优化和动态优化的区别：<br>
静态优化类似“编译期优化”，只和语句结构有关，和具体值无关<br>
动态优化是在运行中去优化的，需要依赖索引行数、where取值，执行次数可能比静态优化要多。</li>
</ul>
<h4><span id="mysql-de-you-hua-lei-xing">mysql的优化类型</span><a href="#mysql-de-you-hua-lei-xing" class="header-anchor">#</a></h4>
<ul>
<li>关联表（join）的顺序可能会变</li>
<li>outer join可能会变成内连接</li>
<li>优化条件表达式， 例如 5=5 AND a&gt;5被简化成a&gt;5</li>
<li>优化MAX\MIN， 如果是MAX(索引），那么直接拿B+树的第一条或者最后一条即可。</li>
<li>当发现某个查询或者表达式的结果是可以提前计算出来的时候，就会优化成常数</li>
<li>索引覆盖，如果只要返回索引列，就不会走到最底层去。</li>
<li>子查询优化</li>
<li>提前终止查询（例如LIMIT）</li>
<li>等值传播： join中可能把左表的where 拿给右表一起用</li>
<li>IN(1,2,3,4,5,6)这个条件， 并不是简单遍历判断， 会先排序，然后用二分去判断是否存在。</li>
</ul>
<h3><span id="3-shu-ju-he-suo-yin-de-tong-ji-xin-xi">3.数据和索引的统计信息</span><a href="#3-shu-ju-he-suo-yin-de-tong-ji-xin-xi" class="header-anchor">#</a></h3>
<ul>
<li>统计信息是存储引擎去计算的，不同的存储引擎有不同的统计信息</li>
<li>服务器层生成查询计划时，会向存储引擎获取这些信息。</li>
</ul>
<h3><span id="4-mysql-dui-guan-lian-cha-xun-de-zhi-xing">4.MYSQL对关联查询的执行</span><a href="#4-mysql-dui-guan-lian-cha-xun-de-zhi-xing" class="header-anchor">#</a></h3>
<ul>
<li>join查询的本质其实是读取临时表做关联</li>
<li>例如a inner join b on <a target="_blank" rel="noopener" href="http://a.id=b.id">a.id=b.id</a> where a.xx=y</li>
</ul>
<ol>
<li>遍历a的每一行（此时a表本质上是 select * from a where a.xx=y）</li>
<li>在那行中a的id被定下来， 那么就会去获取一个临时表，临时表为（select * from b where <a target="_blank" rel="noopener" href="http://a.id">a.id</a> = id）</li>
<li>接着用这个临时表和a那一行拼接，输出多行。</li>
<li>然后再用这里的结果作为临时表，给更上层的关联去用（嵌套查询的含义）。</li>
</ol>
<ul>
<li>如果是left join，则就是临时表如果为空，则给a那一行拼接一个null。</li>
</ul>
<h3><span id="5-zhi-xing-shu-you-hua">5. 执行树优化</span><a href="#5-zhi-xing-shu-you-hua" class="header-anchor">#</a></h3>
<p><img src="/images/MYSQL%E6%89%A7%E8%A1%8C%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/d8e575f3226ca6bd15ed537fc2af07a297ce5c7a.png" alt="d8e575f3226ca6bd15ed537fc2af07a297ce5c7a"></p>
<h3><span id="6-guan-lian-cha-xun-you-hua-qi">6. 关联查询优化器</span><a href="#6-guan-lian-cha-xun-you-hua-qi" class="header-anchor">#</a></h3>
<ul>
<li>join实际执行的顺序会关系到性能</li>
<li>例如a\b\c三个表关联， 可能先让a和b关联得到的临时表里的记录只有10条， 而如果让a和c先关联，会有10000条， 那么后面的效率就会截然不同</li>
<li>EXPLAIN EXTENDED可以展示关联的顺序</li>
<li>STRAIGHT_JOIN可以手动指定关联顺序</li>
<li>mysql自己会评估搜索一个最优的顺序， 但如果join表太多，则无法搜完所有结果（O(n!))， 那时候就会采用贪心。  是否使用贪心算法的边界值可以根据optimizer_seartch_depth去指定。</li>
</ul>
<h3><span id="7-pai-xu-you-hua">7.排序优化</span><a href="#7-pai-xu-you-hua" class="header-anchor">#</a></h3>
<ul>
<li>如果排序的量小，就用内存快速排序；如果排序的量大，就用文件排序</li>
<li>mysql有2种取排序数据的方式：</li>
</ul>
<ol>
<li>两次传输排序：  先取要排序的字段加行序号，按照字段排序好之后，再根据行索引一条条取读<br>
优点: 排序时占用内存小。<br>
缺点: 排序之后读的过程会很慢，根据行序号取读不是很方便</li>
<li>单次传输排序： 直接把行读出来（行里只有需要用的列，不一定是整行） ，然后排序<br>
优点: 把全部行读出来相当于顺序IO，读取速度快<br>
缺点: 可能会很大导致需要文件排序</li>
</ol>
<ul>
<li>关联查询order by的注意事项<br>
如果order by的列 <em><strong>都</strong></em> 来自关联的 <em><strong>第一张</strong></em>  表，则直接第一张表join的时候就排序了。<br>
除此之外！！ 都是全部join完，再排序！ 就算用了limit，也是全部join+排序后， 再limit的！</li>
</ul>
<h2><span id="si-zhen-zheng-zhi-xing-cha-xun-ji-hua">四、真正执行查询计划</span><a href="#si-zhen-zheng-zhi-xing-cha-xun-ji-hua" class="header-anchor">#</a></h2>
<ul>
<li>执行计划是一个数据结构</li>
</ul>
<h2><span id="wu-fan-hui-jie-guo-gei-ke-hu-duan">五、返回结果给客户端</span><a href="#wu-fan-hui-jie-guo-gei-ke-hu-duan" class="header-anchor">#</a></h2>
<ul>
<li>用tcp封包并逐步传送，而不是全部准备好再发送。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">287</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共364.8k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://breakdawncoder.com/page/20/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "欢迎来访！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://vanr4mln.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
