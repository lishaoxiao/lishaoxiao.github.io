<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="破晓的知识屋">
<meta property="og:url" content="http://breakdawncoder.com/page/9/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">redis基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-22 21:35:12" itemprop="dateCreated datePublished" datetime="2022-09-22T21:35:12+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-24 00:28:08" itemprop="dateModified" datetime="2022-09-24T00:28:08+08:00">2022-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">开源组件原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">微服务组件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6/redis/redis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">redis基础应用</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>482</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型</p>
<hr>
<p>Q: redis有什么好处你知道吗？<br>
A:</p>
<ul>
<li>读写性能好</li>
<li>支持的几种数据结构很好用，满足大部分使用场景</li>
<li>原子性，不用担心并发请求的问题</li>
<li>特性多，支持订阅/发布，过期等</li>
<li>支持持久化（RDB, AOF）</li>
<li>支持分布式，高可靠</li>
</ul>
<hr>
<p>Q: redis读写性能的数据具体有了解过吗？<br>
A:<br>
Redis能读的速度是110000次（即10W+）/s<br>
写的速度是81000次/s （即8W+）</p>
<hr>
<p>Q: redis的使用场景讲几个吧<br>
A:</p>
<ul>
<li>热点数据缓存</li>
<li>限时业务（用expir命令设置key超时，key没了商品就没了）</li>
<li>计数器问题（incrby命令可实现原子性递增）</li>
<li>分布式锁（setnx命令）</li>
<li>延时事件（可设置延时+监听，触发超时事件删除一些问题数据）</li>
<li>排行榜问题（SortedSet）</li>
<li>点赞、好友关系存储（集合支持求交集、并集、差集）</li>
<li>简单队列（list push/pop)</li>
</ul>
<hr>
<p>Redis官网:<a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">容器化部署（docker\K8s)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-22 01:30:12 / 修改时间：00:00:41" itemprop="dateCreated datePublished" datetime="2022-09-22T01:30:12+08:00">2022-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-jiang-yi-xia-ni-dui-xu-ni-hua-de-li-jie-shi-me-shi-xu-ni-hua">Q: 讲一下你对虚拟化的理解？什么是虚拟化？</a></li>
<li><a href="#q-jiang-yi-xia-docker-shi-shi-me">Q: 讲一下docker是什么？</a></li>
<li><a href="#q-docker-shi-na-chong-lei-xing-de-xu-ni-hua">Q: docker是哪种类型的虚拟化？</a></li>
<li><a href="#q-ni-men-wei-shi-me-yao-yong-docker-you-shi-me-hao-chu">Q: 你们为什么要用docker？有什么好处？</a></li>
<li><a href="#q-docker-he-xu-ni-ji-virtual-machine-de-qu-bie">Q: Docker和虚拟机Virtual Machine的区别？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-jiang-yi-xia-ni-dui-xu-ni-hua-de-li-jie-shi-me-shi-xu-ni-hua">Q: 讲一下你对虚拟化的理解？什么是虚拟化？</span><a href="#q-jiang-yi-xia-ni-dui-xu-ni-hua-de-li-jie-shi-me-shi-xu-ni-hua" class="header-anchor">#</a></h1>
<p>A:<br>
虚拟化可以理解为，将一台机器上的各种资源，进行抽象和隔离，方便在一台机器上运行多个进程或者系统，而且他们互相隔离，各自使用各自的资源，不会在逻辑上互相竞争资源。</p>
<p>虚拟机包含硬件和软件虚拟化。我这里只说软件虚拟化，也就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。</p>
<p>经典的有VMWare桌面虚拟、KVM全虚拟化（linux内核模块）、LXC（linux容器，轻量级虚拟化，重点）</p>
<hr>
<h1><span id="q-jiang-yi-xia-docker-shi-shi-me">Q: 讲一下docker是什么？</span><a href="#q-jiang-yi-xia-docker-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
Docker是一个开源的应用容器引擎</p>
<ul>
<li>它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上</li>
<li>发布到机器上之后， 会使用沙箱机制完全虚拟出一个完整的内部环境</li>
<li>容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底</li>
</ul>
<hr>
<h1><span id="q-docker-shi-na-chong-lei-xing-de-xu-ni-hua">Q: docker是哪种类型的虚拟化？</span><a href="#q-docker-shi-na-chong-lei-xing-de-xu-ni-hua" class="header-anchor">#</a></h1>
<p>A:<br>
docker属于操作系统层虚拟化（将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，并没有模拟硬件）， 换句话说，无法改变操作系统的性质。<br>
底层基于LXC（Linux Container，Linux容器）进行轻量化虚拟的实现。</p>
<hr>
<h1><span id="q-ni-men-wei-shi-me-yao-yong-docker-you-shi-me-hao-chu">Q: 你们为什么要用docker？有什么好处？</span><a href="#q-ni-men-wei-shi-me-yao-yong-docker-you-shi-me-hao-chu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>如果资源有限，只有1台机器，但是有3个微服务需要部署，每台部署3个服务进程后， 万一一个进程跑多线程时， 线程池打满了， 结果把cpu全占用， 让另外2个服务一起变慢了。   或者内存疯狂涨，把内存打满了搞挂另外2个进程。<br>
因此引入docker后，每个服务隔离在容器中，使用的线程资源和内存受到独立的限制，就不会互相影响了。</p>
</li>
<li>
<p>当需要部署新的微服务时， 如果没有docker，就需要手动部署，按照指导书一点点搭建，配置参数，很容易错，且容易导致开发环境和生产环境参数不一致。<br>
使用docker后，可以打包docker镜像进行容器部署， 发布的速度也变快了，扩容也变简单了。</p>
</li>
</ol>
<hr>
<h1><span id="q-docker-he-xu-ni-ji-virtual-machine-de-qu-bie">Q: Docker和虚拟机Virtual Machine的区别？</span><a href="#q-docker-he-xu-ni-ji-virtual-machine-de-qu-bie" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>Docker容器不是虚拟机， 只是当初被疯狂宣传为“轻量级虚拟机”</li>
<li>虚拟机必须要自己模拟一个虚拟操作系统guestOs才能运行， 但docker不需要，直接使用linux自身支持的namespace和cgroup实现资源隔离。</li>
<li>云服务提供商通常采用虚拟机技术隔离不同的用户/租户。  而Docker通常用于隔离不同的应用，例如前端，后端以及数据库</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" class="post-title-link" itemprop="url">微服务治理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-22 00:10:12" itemprop="dateCreated datePublished" datetime="2022-09-22T00:10:12+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 23:58:42" itemprop="dateModified" datetime="2022-09-21T23:58:42+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-chu-li-wei-fu-wu-zhi-li-shi-wei-shi-me-da-duo-cai-yong-rpc-er-fei-restful-zuo-fu-wu-jian-diao-yong">Q: 处理微服务治理时，为什么大多采用rpc而非restful做服务间调用？</a></li>
<li><a href="#q-fu-wu-a-diao-yong-fu-wu-b-shi-ru-guo-chao-shi-liao-ying-gai-zen-me-chu-li">Q： 服务A 调用服务B时， 如果超时了， 应该怎么处理？</a></li>
<li><a href="#q-fu-wu-fa-xian-you-na-liang-chong-mo-shi">Q: 服务发现有哪两种模式？</a></li>
<li><a href="#q-zookeeper-zuo-wei-zhu-ce-zhong-xin-you-shi-me-que-dian">Q: zookeeper作为注册中心有什么缺点？</a></li>
<li><a href="#q-you-shi-me-ban-fa-jie-jue-shang-mian-de-wen-ti">Q: 有什么办法解决上面的问题？</a></li>
<li><a href="#q-fu-wu-diao-yong-de-hu-xiang-xun-huan-yi-lai-wen-ti-ru-he-jie-jue-ji-a-fu-wu-qi-dong-yi-lai-b-fu-wu-mou-jie-kou-b-fu-wu-qi-dong-a-fu-wu-mou-jie-kou-de-shi-hou">Q: 服务调用的互相、循环依赖问题如何解决？ 即A服务启动依赖B服务某接口， B服务启动A服务某接口的时候</a></li>
<li><a href="#q-zuo-yi-ge-fu-wu-diao-yong-lian-de-hua-yi-ci-qing-qiu-xu-yao-bao-han-na-xie-xin-xi">Q: 做一个服务调用链的话， 一次请求需要包含哪些信息？</a></li>
<li><a href="#q-diao-yong-lian-gen-zong-you-na-xie-shi-jian-xin-xi-xu-yao-tong-ji">Q: 调用链跟踪有哪些时间信息需要统计？</a></li>
<li><a href="#q-zen-me-zai-jie-shou-he-fa-chu-shi-neng-yong-dao-tong-yi-ge-traceid">Q: 怎么在接收和发出时， 能用到同一个traceId？</a></li>
<li><a href="#q-suo-you-diao-yong-lian-xin-xi-zhi-jie-xie-ru-shu-ju-ku-ma">Q: 所有调用链信息直接写入数据库吗？</a></li>
<li><a href="#q-you-na-xie-shi-xian-fang-shi-dai-ma-ru-he-shi-xian-dui-yu-wei-fu-wu-er-yan">Q: 有哪些实现方式（代码如何实现），对于微服务而言？</a></li>
<li><a href="#q-ru-he-shi-xian-yi-ge-quan-ju-fu-wu-de-ding-shi-ren-wu-guan-li-ru-he-she-ji-ji-ru-guo-ni-men-xi-wang-zuo-ding-shi-ren-wu-de-hua-hui-zen-me-zuo">Q: 如何实现一个全局服务的定时任务管理？如何设计?  即如果你们希望做定时任务的话，会怎么做？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<hr>
<h1><span id="q-chu-li-wei-fu-wu-zhi-li-shi-wei-shi-me-da-duo-cai-yong-rpc-er-fei-restful-zuo-fu-wu-jian-diao-yong">Q: 处理微服务治理时，为什么大多采用rpc而非restful做服务间调用？</span><a href="#q-chu-li-wei-fu-wu-zhi-li-shi-wei-shi-me-da-duo-cai-yong-rpc-er-fei-restful-zuo-fu-wu-jian-diao-yong" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>restful大多基于json做序列化，  相比于直接做二进制序列化，性能较差。 而服务间调用频率往往非常高，必须做到低时延。</li>
<li>常见的rpc框架往往能封装好底层网络通信协议、寻址、序列化问题，  通过一个proto文件即可生成 客户端代码和服务端代码， 大大简化开发工作。</li>
</ol>
<hr>
<h1><span id="q-fu-wu-a-diao-yong-fu-wu-b-shi-ru-guo-chao-shi-liao-ying-gai-zen-me-chu-li">Q：  服务A 调用服务B时， 如果超时了， 应该怎么处理？</span><a href="#q-fu-wu-a-diao-yong-fu-wu-b-shi-ru-guo-chao-shi-liao-ying-gai-zen-me-chu-li" class="header-anchor">#</a></h1>
<p>A:<br>
要分情况。</p>
<ul>
<li>如果是读服务，可以做failover重试， 重试3次才报失败。</li>
<li>如果是写服务， 考虑到幂等性，不应该做重试，直接报错。</li>
<li>如果是耗时较长的接口， 如果超时时间设的太短，则可能因为重试引发雪崩（大量该接口调用都发生连锁超时）， 因此不应该采用重试。</li>
</ul>
<p>常见的超时处理操作和情况：</p>
<ul>
<li>重试——读操作</li>
<li>失败就立刻报错——非幂等的读操作</li>
<li>出现异常直接忽略——用于审计日志写入和读取等不重要的操作</li>
<li>失败自动恢复，定时重发——用于重要消息通知等操作</li>
</ul>
<hr>
<h1><span id="q-fu-wu-fa-xian-you-na-liang-chong-mo-shi">Q:   服务发现有哪两种模式？</span><a href="#q-fu-wu-fa-xian-you-na-liang-chong-mo-shi" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>服务端服务发现模式<br>
提供路由服务route，  由路由服务帮客户端做服务发现和负载均衡调用，  路由服务和注册中心相连接<br>
缺点： 代理中心额外要引入容错性和伸缩性，成本比较大。 且性能上服务也较差。</p>
</li>
<li>
<p>客户端服务发现模式，<br>
客户端和注册中心相连接，  获取发现服务地址，自己处理多地址的负载均衡等策略。</p>
</li>
</ol>
<hr>
<h1><span id="q-zookeeper-zuo-wei-zhu-ce-zhong-xin-you-shi-me-que-dian">Q: zookeeper作为注册中心有什么缺点？</span><a href="#q-zookeeper-zuo-wei-zhu-ce-zhong-xin-you-shi-me-que-dian" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>服务扩容时， 应用启动缓慢</li>
<li>冗余的服务配置项会增加存储压力， 扩大网络开销<br>
原因：<br>
ZK是一个典型的CP系统， 基于ZAB原子广播的强一致性中间件， 写操作存在单点问题，无法通过水平扩容来解决。 当客户端发送写请求时， 集群中的其他节点会优先转发给leader节点， leader节点来做具体的写操作。  只有N/2+1个以上的节点都同步成功， 写才算完成。<br>
服务扩容的时候， tps越高，  服务注册写入效率月底， 导致上游大量请求排队， 服务启动和配置下载变得缓慢。</li>
</ol>
<hr>
<h1><span id="q-you-shi-me-ban-fa-jie-jue-shang-mian-de-wen-ti">Q: 有什么办法解决上面的问题？</span><a href="#q-you-shi-me-ban-fa-jie-jue-shang-mian-de-wen-ti" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>增加zk的observer节点。 因为observer节点不会增加写入开销，但可以分担带宽压力。</li>
<li>注册项精简， 只写入关键配置， 其他配置放到另外的元数据中心，实现配置垂直分离。</li>
<li>去除zk的强一致性，  自研一个最终一致、增量数据返回、去中心化的分布式注册中心。</li>
</ol>
<hr>
<h1><span id="q-fu-wu-diao-yong-de-hu-xiang-xun-huan-yi-lai-wen-ti-ru-he-jie-jue-ji-a-fu-wu-qi-dong-yi-lai-b-fu-wu-mou-jie-kou-b-fu-wu-qi-dong-a-fu-wu-mou-jie-kou-de-shi-hou">Q: 服务调用的互相、循环依赖问题如何解决？ 即A服务启动依赖B服务某接口， B服务启动A服务某接口的时候</span><a href="#q-fu-wu-diao-yong-de-hu-xiang-xun-huan-yi-lai-wen-ti-ru-he-jie-jue-ji-a-fu-wu-qi-dong-yi-lai-b-fu-wu-mou-jie-kou-b-fu-wu-qi-dong-a-fu-wu-mou-jie-kou-de-shi-hou" class="header-anchor">#</a></h1>
<p>A:<br>
尽量避免循环依赖， 调用流上要设计成单项依赖<br>
如果确实存在， 要避免开启强制的check服务开关， 不去校验依赖服务是否通，而是启动后定时轮询。</p>
<hr>
<h1><span id="q-zuo-yi-ge-fu-wu-diao-yong-lian-de-hua-yi-ci-qing-qiu-xu-yao-bao-han-na-xie-xin-xi">Q:   做一个服务调用链的话， 一次请求需要包含哪些信息？</span><a href="#q-zuo-yi-ge-fu-wu-diao-yong-lian-de-hua-yi-ci-qing-qiu-xu-yao-bao-han-na-xie-xin-xi" class="header-anchor">#</a></h1>
<p>A:<br>
traceId， 表示这是哪一次请求的完整跟踪<br>
spanId， 中间某次服务调用的请求/响应过程<br>
parentSpanId， 上一次调用的id， 用于确定请求依赖关系<br>
xxxConetext： 包含更多详细的信息， 例如是否是服务调用/提供方， host、port、接口名，被调用的服务方法名。</p>
<hr>
<h1><span id="q-diao-yong-lian-gen-zong-you-na-xie-shi-jian-xin-xi-xu-yao-tong-ji">Q:  调用链跟踪有哪些时间信息需要统计？</span><a href="#q-diao-yong-lian-gen-zong-you-na-xie-shi-jian-xin-xi-xu-yao-tong-ji" class="header-anchor">#</a></h1>
<p>A:<br>
以一次span为例，  需要记录<br>
Client SendTime 客户端刚发出的时间CS<br>
Server ReciveTime 服务接收请求时间SR<br>
Server Send Time 服务发送响应时间SS<br>
Client Receive Time 客户端接收响应时间CR</p>
<ul>
<li>服务调用耗时= CR - CS</li>
<li>服务处理耗时= SS - SR</li>
<li>网络开销总耗时= 服务调用耗时  - 服务处理耗时</li>
<li>前置网络耗时  =SR-CS</li>
<li>后置网络耗时 = CR - SS</li>
</ul>
<hr>
<h1><span id="q-zen-me-zai-jie-shou-he-fa-chu-shi-neng-yong-dao-tong-yi-ge-traceid">Q: 怎么在接收和发出时， 能用到同一个traceId？</span><a href="#q-zen-me-zai-jie-shou-he-fa-chu-shi-neng-yong-dao-tong-yi-ge-traceid" class="header-anchor">#</a></h1>
<p>A:<br>
使用threadLocal即可， 从该线程中拿到这个traceId变量值，用完销毁。</p>
<hr>
<h1><span id="q-suo-you-diao-yong-lian-xin-xi-zhi-jie-xie-ru-shu-ju-ku-ma">Q: 所有调用链信息直接写入数据库吗？</span><a href="#q-suo-you-diao-yong-lian-xin-xi-zhi-jie-xie-ru-shu-ju-ku-ma" class="header-anchor">#</a></h1>
<p>A:<br>
不可以， 容易对数据库造成较大压力， 应该放入消息队列进行消费， 实现削峰的效果</p>
<hr>
<h1><span id="q-you-na-xie-shi-xian-fang-shi-dai-ma-ru-he-shi-xian-dui-yu-wei-fu-wu-er-yan">Q: 有哪些实现方式（代码如何实现），对于微服务而言？</span><a href="#q-you-na-xie-shi-xian-fang-shi-dai-ma-ru-he-shi-xian-dui-yu-wei-fu-wu-er-yan" class="header-anchor">#</a></h1>
<p>A:<br>
一种看框架本身是否支持相关的filter，继续配置，  例如dubb的filter<br>
或者自己写动态AOP， 例如利用-javaagent 实现动态的jvm增强需求。 实质上利用了jdk1.5引入的Instrumentation接口</p>
<hr>
<h1><span id="q-ru-he-shi-xian-yi-ge-quan-ju-fu-wu-de-ding-shi-ren-wu-guan-li-ru-he-she-ji-ji-ru-guo-ni-men-xi-wang-zuo-ding-shi-ren-wu-de-hua-hui-zen-me-zuo">Q: 如何实现一个全局服务的定时任务管理？如何设计?  即如果你们希望做定时任务的话，会怎么做？</span><a href="#q-ru-he-shi-xian-yi-ge-quan-ju-fu-wu-de-ding-shi-ren-wu-guan-li-ru-he-she-ji-ji-ru-guo-ni-men-xi-wang-zuo-ding-shi-ren-wu-de-hua-hui-zen-me-zuo" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>方案一：<br>
可以借助注册中心实现定时任务管理。</li>
</ul>
<ol>
<li>服务自身维护需要的定时任务接口、定时触发条件。 可以自定义注解设置在接口上。</li>
<li>然后通过注册动作将接口以及接口上的注解发布给注册中心。</li>
<li>注册中心将定时类接口呈现给 注册中心服务的定时任务管理页。</li>
<li>当到达时间， 注册中心调用定时任务接口，触发动作。  如果需要关闭，在管理页直接关闭即可。</li>
<li>当服务的定时任务接口返回了已卸载或者不存在的接口时， 注册中心要删除这个定时任务，不再呈现在页面上。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/xungen/article/details/106873673">一个简单的定时任务调度中心设计方案</a></li>
</ol>
<p>当时我自己服务里没有这种功能的注册中心， 实现起来的接口开发量还是比较大的。</p>
<ul>
<li>方案二：基于数据库锁quartz<br>
当多个server的定时任务到时间时， 先去抢锁表里该任务的悲观锁，如果抢到了就执行， 如果抢不到就等待。当重新拿到锁后，发现该定时任务已经被设置成“完成”，时间也对的上，于是就不再执行了。</li>
</ul>
<p>缺点： 集群特性对于高CPU使用率的任务效果很好，但是对于大量的短任务，各个节点都会抢占数据库锁，这样就出现大量的线程等待资源。这种情况随着节点的增加会越来越严重。<br>
另外，quartz的分布式只是解决了高可用的问题，并没有解决任务分片的问题，还是会有单机处理的极限，即某台机器执行过多的定时任务导致负载暴涨，而其他的机器一直凑巧没抢到。</p>
<ul>
<li>方案三： 引入支持任务分片的分布式任务调度框架</li>
</ul>
<ol>
<li>elastic-job （当当）</li>
<li>TBSchedule（淘宝）</li>
<li>Saturn（唯品会）<br>
默认的分片策略，作业数能被服务器数整除情况下均匀分配：<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/4ef34664a006479928c47313a27a0dc4de910f47.png" alt="4ef34664a006479928c47313a27a0dc4de910f47"><br>
根据哈希的分片策略：</li>
</ol>
<blockquote>
<p>根据作业名的哈希值奇偶数决定采用IP升/降序算法实现分片，作业名的哈希值为奇数则IP升序，作业名的哈希值为偶数则IP降序，通过这种方式用于将不同的作业分片负载均衡至不同的服务器。<br>
如作业名哈希值为偶数，则采用IP降序算法实现分片，这样就避免了采用平均分配算法时IP地址靠后的服务器空闲的问题。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/201911/605783.htm">聊聊分布式定时任务elastic-job作业分片策略</a></p>
<hr>
<p>Q: 有哪些负载均衡算法？<br>
A:</p>
<ul>
<li>
<p>ActiveWeight / LeastActive ：低并发度优先， 统计某时刻的被调用 call 数越小优先级越高。即根据短时间内被调用数获取。需要统计的成本，实现难度比较高，存在耦合。</p>
</li>
<li>
<p>Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。节点少的时候，随机有可能出现连续都随机到一个节点上，导致负载不均衡。</p>
</li>
<li>
<p>RoundRobin ：轮循，按公约后的权重设置轮循比率。<br>
存在慢的提供者累积请求问题，比如：第二台机器性能很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
</li>
<li>
<p>LocalFirst ：本地服务优先获取策略。</p>
</li>
<li>
<p>Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
</ul>
<hr>
<p>Q: 负载均衡时，请求失败怎么办？<br>
A:</p>
<ul>
<li>
<p>Failover ：失败自动切换，当出现失败，重试其它服务器。<br>
通常用于读操作，但重试会带来更长延迟。</p>
</li>
<li>
<p>Failfast ：快速失败，只发起一次调用，失败立即报错。<br>
通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li>
<p>Failsafe ：失败安全，出现异常时，直接忽略。<br>
通常用于写入审计日志等操作。</p>
</li>
<li>
<p>Failback ：失败自动恢复，后台记录失败请求，定时重发。<br>
通常用于消息通知操作。</p>
</li>
<li>
<p>Forking ：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。</p>
</li>
<li>
<p>Broadcast ：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">现网压测系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-21 23:30:12 / 修改时间：23:53:29" itemprop="dateCreated datePublished" datetime="2022-09-21T23:30:12+08:00">2022-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-wei-shi-me-xu-yao-xian-shang-ya-ce">Q: 为什么需要线上压测？</a></li>
<li><a href="#q-quan-lian-lu-ya-ce-he-jie-kou-ya-ce-de-qu-bie">Q: 全链路压测和接口压测的区别？</a></li>
<li><a href="#q-ye-wu-xi-tong-ru-he-qu-fen-ya-ce-liu-liang-ji-pan-duan-na-xie-shi-ya-ce-de-qing-qiu-na-xie-shi-zheng-chang-de-qing-qiu">Q: 业务系统如何区分压测流量？即判断哪些是压测的请求，哪些是正常的请求？</a></li>
<li><a href="#q-zhe-ge-ya-ce-da-biao-de-gai-zao-he-gua-pei-yao-zhong-jian-suo-you-fu-wu-can-yu-ma-gai-zao-cheng-ben-hui-bu-hui-you-dian-da">Q: 这个压测打标的改造和适配要中间所有服务参与吗？ 改造成本会不会有点大？</a></li>
<li><a href="#q-shi-bie-dao-ya-ce-biao-ji-hou-ru-he-bao-zheng-wang-xia-you-fa-qing-qiu-shi-reng-ran-shi-ya-ce-biao-ji-de-xing-shi">Q: 识别到压测标记后， 如何保证往下游发请求时，仍然是压测标记的形式？</a></li>
<li><a href="#q-ru-guo-wo-bu-zai-tong-yi-ge-xian-cheng-zhong-chu-li-he-fa-qing-qiu-zen-me-ban">Q: 如果我不在同一个线程中处理和发请求， 怎么办？</a></li>
<li><a href="#q-ru-guo-wo-de-ya-ce-lian-lu-zhong-bao-han-liao-wai-bu-fu-wu-de-jie-kou-zen-me-ban-li-ru-di-san-fang-zhi-fu-di-san-fang-duan-xin-deng">Q: 如果我的压测链路中 包含了外部服务的接口怎么办？  例如第三方支付、第三方短信等。</a></li>
<li><a href="#q-hui-dui-shu-ju-ku-chan-sheng-ying-xiang-de-ya-ce-qing-qiu-zen-me-ban">Q: 会对数据库产生影响的压测请求怎么办？</a></li>
<li><a href="#q-redis-kafka-deng-zhong-jian-jian-dui-ya-ce-you-shi-me-te-shu-chu-li">Q: redis、kafka等中间件对压测有什么特殊处理？</a></li>
<li><a href="#q-ya-ce-jie-shu-shi-ru-he-bi-mian-dui-shu-ju-ku-ji-xu-chan-sheng-ying-xiang">Q: 压测结束时，如何避免对数据库继续产生影响？</a></li>
<li><a href="#q-ya-ce-shu-ju-zen-me-gou-zao-yi-ge-ge-shou-dong-pin-shu-ju-can-shu-ran-hou-rang-ce-shi-tong-xue-fa-song-ma">Q: 压测数据怎么构造？一个个手动拼数据参数，然后让测试同学发送吗？</a></li>
<li><a href="#q-zen-me-wan-zheng-she-ji-zhe-ge-ya-ce-xi-tong-de-jia-gou-bao-han-na-xie-jiao-se">Q: 怎么完整设计这个压测系统的架构？包含哪些角色</a></li>
<li><a href="#q-zen-me-mo-ni-shi-ji-yong-hu-de-qing-qiu-fa-song-yin-wei-shi-ji-chang-jing-ying-gai-shi-duo-ge-bu-tong-ip-de-yong-hu-fang-wen-jin-lai-cai-dui">Q: 怎么模拟实际用户的请求发送？ 因为实际场景应该是多个不同ip的用户访问进来才对。</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-wei-shi-me-xu-yao-xian-shang-ya-ce">Q: 为什么需要线上压测？</span><a href="#q-wei-shi-me-xu-yao-xian-shang-ya-ce" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>需要在某些活动、大促前，评估机器扩容数量，验证系统能否有效支撑流量峰值。</li>
<li>线下测试环境的机器资源有限， 无法完全模拟现网。 同时很多配置可能配置不相同，如果没对上导致机器数量估计错误，可能引发重大故事。所以必须要在线上做压测。</li>
</ol>
<hr>
<h1><span id="q-quan-lian-lu-ya-ce-he-jie-kou-ya-ce-de-qu-bie">Q: 全链路压测和接口压测的区别？</span><a href="#q-quan-lian-lu-ya-ce-he-jie-kou-ya-ce-de-qu-bie" class="header-anchor">#</a></h1>
<p>A:<br>
在特定的业务场景下，  将相关的链路完整地串联起来同时施压， 尽可能模拟出真实的用户行为。<br>
接口A做接口压测，可能是1w/s的QPS， 但是A和B同时压测，可能因为数据库连接等共享资源，导致实际QPS下降。</p>
<hr>
<h1><span id="q-ye-wu-xi-tong-ru-he-qu-fen-ya-ce-liu-liang-ji-pan-duan-na-xie-shi-ya-ce-de-qing-qiu-na-xie-shi-zheng-chang-de-qing-qiu">Q: 业务系统如何区分压测流量？即判断哪些是压测的请求，哪些是正常的请求？</span><a href="#q-ye-wu-xi-tong-ru-he-qu-fen-ya-ce-liu-liang-ji-pan-duan-na-xie-shi-ya-ce-de-qing-qiu-na-xie-shi-zheng-chang-de-qing-qiu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>url上加上打标参数，  例如  <a target="_blank" rel="noopener" href="http://xx?st=true">http://xx?st=true</a></li>
<li>hearder中打标</li>
</ol>
<hr>
<h1><span id="q-zhe-ge-ya-ce-da-biao-de-gai-zao-he-gua-pei-yao-zhong-jian-suo-you-fu-wu-can-yu-ma-gai-zao-cheng-ben-hui-bu-hui-you-dian-da">Q: 这个压测打标的改造和适配要中间所有服务参与吗？ 改造成本会不会有点大？</span><a href="#q-zhe-ge-ya-ce-da-biao-de-gai-zao-he-gua-pei-yao-zhong-jian-suo-you-fu-wu-can-yu-ma-gai-zao-cheng-ben-hui-bu-hui-you-dian-da" class="header-anchor">#</a></h1>
<p>A:<br>
不需要全部参与。</p>
<p>如果设计过链路跟踪系统， 则每个服务都有中间件团队提供的拦截器，  因此直接通过公共拦截器来做压测标记的识别。</p>
<hr>
<h1><span id="q-shi-bie-dao-ya-ce-biao-ji-hou-ru-he-bao-zheng-wang-xia-you-fa-qing-qiu-shi-reng-ran-shi-ya-ce-biao-ji-de-xing-shi">Q:   识别到压测标记后， 如何保证往下游发请求时，仍然是压测标记的形式？</span><a href="#q-shi-bie-dao-ya-ce-biao-ji-hou-ru-he-bao-zheng-wang-xia-you-fa-qing-qiu-shi-reng-ran-shi-ya-ce-biao-ji-de-xing-shi" class="header-anchor">#</a></h1>
<p>即发请求的时候已经不是同一段拦截器的代码了。 但是也要保证尽可能不改动原有的业务逻辑代码。</p>
<p>A:<br>
如果处理请求和发下游请求是在一个线程中完成的， 那么可以使用threadLocal。<br>
即拦截到请求时， 将压测标记set进threadLocal中。<br>
发送下游请求的代码中，如果能从threadLocal中拿到压测标记，则改造url，设置进往下发的请求中</p>
<hr>
<h1><span id="q-ru-guo-wo-bu-zai-tong-yi-ge-xian-cheng-zhong-chu-li-he-fa-qing-qiu-zen-me-ban">Q: 如果我不在同一个线程中处理和发请求， 怎么办？</span><a href="#q-ru-guo-wo-bu-zai-tong-yi-ge-xian-cheng-zhong-chu-li-he-fa-qing-qiu-zen-me-ban" class="header-anchor">#</a></h1>
<p>即我的业务代码中 做了new Thread或者ExectorPool.submit提交异步请求， 这时候业务逻辑里肯定不会涉及到threadLocal的代码， 而此时压测标记就会丢失了。</p>
<p>threadLocal可以用 InheriableThreadLocal， 这样如果在线程中new新的线程，则标记可以被传递下来。<br>
如果是线程池创建异步请求， 可以用阿里的TransmittableThreadLocal。</p>
<hr>
<h1><span id="q-ru-guo-wo-de-ya-ce-lian-lu-zhong-bao-han-liao-wai-bu-fu-wu-de-jie-kou-zen-me-ban-li-ru-di-san-fang-zhi-fu-di-san-fang-duan-xin-deng">Q: 如果我的压测链路中 包含了外部服务的接口怎么办？  例如第三方支付、第三方短信等。</span><a href="#q-ru-guo-wo-de-ya-ce-lian-lu-zhong-bao-han-liao-wai-bu-fu-wu-de-jie-kou-zen-me-ban-li-ru-di-san-fang-zhi-fu-di-san-fang-duan-xin-deng" class="header-anchor">#</a></h1>
<p>A:<br>
链路跟踪系统中发请求的filter中， 新增MockFilter，   如果判断是压测请求， 则直接返回mock逻辑（不建议部署mock服务， 因为部署mock服务的话，服务器成本又得考虑，不如直接封装到mockFilter代码中）</p>
<hr>
<h1><span id="q-hui-dui-shu-ju-ku-chan-sheng-ying-xiang-de-ya-ce-qing-qiu-zen-me-ban">Q:  会对数据库产生影响的压测请求怎么办？</span><a href="#q-hui-dui-shu-ju-ku-chan-sheng-ying-xiang-de-ya-ce-qing-qiu-zen-me-ban" class="header-anchor">#</a></h1>
<p>如果直接落库，可能会影响正常用户的请求访问， 也可能污染线上数据。<br>
A:<br>
为每个生产库 生成一个影子库， 专门用来存储压测数据。</p>
<p>然后做过分库分表的话， 肯定有数据库的proxy，在proxy里都往压测库插入和读写。<br>
如果没有，就扩展Spring的AbstactRoutngDataSource类， 实现一个动态的数据源，让里面可以根据压测标记进行切换。</p>
<hr>
<h1><span id="q-redis-kafka-deng-zhong-jian-jian-dui-ya-ce-you-shi-me-te-shu-chu-li">Q: redis、kafka等中间件对压测有什么特殊处理？</span><a href="#q-redis-kafka-deng-zhong-jian-jian-dui-ya-ce-you-shi-me-te-shu-chu-li" class="header-anchor">#</a></h1>
<p>A:<br>
除了添加统一特点的压测标记（中间件和业务不是强相关，所以可以进行特定改造）<br>
还要注意缓存的存活时间要设置短一点。</p>
<hr>
<h1><span id="q-ya-ce-jie-shu-shi-ru-he-bi-mian-dui-shu-ju-ku-ji-xu-chan-sheng-ying-xiang">Q: 压测结束时，如何避免对数据库继续产生影响？</span><a href="#q-ya-ce-jie-shu-shi-ru-he-bi-mian-dui-shu-ju-ku-ji-xu-chan-sheng-ying-xiang" class="header-anchor">#</a></h1>
<p>A:<br>
注意不要触发 数据源的init-method方法， 当真正执行压测的时候再建议会话连接。<br>
各种超期时间也要注意设置， 尽快接触压测对组件的影响。</p>
<hr>
<h1><span id="q-ya-ce-shu-ju-zen-me-gou-zao-yi-ge-ge-shou-dong-pin-shu-ju-can-shu-ran-hou-rang-ce-shi-tong-xue-fa-song-ma">Q:  压测数据怎么构造？一个个手动拼数据参数，然后让测试同学发送吗？</span><a href="#q-ya-ce-shu-ju-zen-me-gou-zao-yi-ge-ge-shou-dong-pin-shu-ju-can-shu-ran-hou-rang-ce-shi-tong-xue-fa-song-ma" class="header-anchor">#</a></h1>
<p>A:<br>
不行，如果业务有改动，参数很容易对不上，同时组装过程耗时也会非常久。</p>
<p>建议从线上直接dump最近的请求数据，这样可保证参数没有变化。<br>
同时做一些脱敏和修正处理。</p>
<hr>
<h1><span id="q-zen-me-wan-zheng-she-ji-zhe-ge-ya-ce-xi-tong-de-jia-gou-bao-han-na-xie-jiao-se">Q: 怎么完整设计这个压测系统的架构？包含哪些角色</span><a href="#q-zen-me-wan-zheng-she-ji-zhe-ge-ya-ce-xi-tong-de-jia-gou-bao-han-na-xie-jiao-se" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>压测manager服务， 提供给压测控制者查看和使用的。可以读取mysql数据库获取压测结果情况，或者进行调度指令的下发等。</li>
<li>taskService服务，用于处理调度指令，执行定时调度、即时调度等行为。</li>
<li>Agent  压测请求发送客户端。根据taskService的指令进行发送</li>
<li>DataFactoy，给agent提供脱敏、修改后的压测数据。</li>
<li>MQ， 接收agent压测请求的结果，堆积到队列里提供给DataCollect消费。</li>
<li>DataCollect， 压测结果消费者， 将结果写入到数据库MYSQL。</li>
<li>注册中心，用于管理和注册上面这些服务。</li>
<li>Detecotr， 流量检测和干预器，可以根据情况即时调整agent的发送速率。</li>
</ol>
<p><img src="/images/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/d86556bb34973167a095a19ee41c491e1fbd6b2f.png" alt="压测设计"></p>
<hr>
<h1><span id="q-zen-me-mo-ni-shi-ji-yong-hu-de-qing-qiu-fa-song-yin-wei-shi-ji-chang-jing-ying-gai-shi-duo-ge-bu-tong-ip-de-yong-hu-fang-wen-jin-lai-cai-dui">Q: 怎么模拟实际用户的请求发送？ 因为实际场景应该是多个不同ip的用户访问进来才对。</span><a href="#q-zen-me-mo-ni-shi-ji-yong-hu-de-qing-qiu-fa-song-yin-wei-shi-ji-chang-jing-ying-gai-shi-duo-ge-bu-tong-ip-de-yong-hu-fang-wen-jin-lai-cai-dui" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>apache HttpComponents的httpclient包</li>
<li>Java11的异步httpclient， 支持HTTP/2， 支持用reactive stream。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">高并发/高压场景处理设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-21 22:30:12 / 修改时间：23:50:48" itemprop="dateCreated datePublished" datetime="2022-09-21T22:30:12+08:00">2022-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-tun-tu-liang-tps-shi-shi-me">Q: 吞吐量（TPS）是什么</a></li>
<li><a href="#q-qps-shi-shi-me">Q: QPS是什么</a></li>
<li><a href="#q-qps-he-tps-de-qu-bie">Q: QPS和TPS的区别？</a></li>
<li><a href="#q-tp-shi-shi-me">Q: TP是什么？</a></li>
<li><a href="#q-jie-kou-fang-wen-liang-guo-da-hui-fa-sheng-shi-me">Q: 接口访问量过大会发生什么？</a></li>
<li><a href="#q-ying-dui-gao-bing-fa-da-liu-liang-you-na-xie-chang-jian-shou-duan">Q: 应对高并发、大流量有哪些常见手段？</a></li>
<li><a href="#q-shi-me-shi-liu-liang-de-lou-dou-mo-xing">Q: 什么是流量的漏斗模型？</a></li>
<li><a href="#q-ru-he-zuo-jie-kou-xian-liu">Q: 如何做接口限流？</a></li>
<li><a href="#q-ru-he-she-ji-yi-ge-xian-shi-qiang-gou-de-gong-neng">Q: 如何设计一个限时抢购的功能</a></li>
<li><a href="#q-ru-he-zai-chan-pin-she-ji-shang-jin-xing-xue-feng">Q: 如何在 产品设计上进行削峰？</a></li>
<li><a href="#q-ru-he-bi-mian-gao-bing-fa-xie-de-chang-jing-xia-de-shu-ju-ku-chao-mai-wen-ti">Q: 如何避免高并发写的场景下的数据库超卖问题</a></li>
<li><a href="#q-ru-guo-ku-cun-chong-zu-wu-lun-duo-shao-de-xie-qing-qiu-du-yi-ci-xing-da-gei-shu-ju-ku-ma-he-xian-shi-qiang-gou-bu-tong-bu-kao-lu-xie-shi-bai">Q: 如果库存充足， 无论多少的写请求都一次性打给数据库吗？（和限时抢购不同，不考虑写失败）</a></li>
<li><a href="#q-watch-de-yuan-li-shi-shi-me">Q: WATCH的原理是什么？</a></li>
<li><a href="#q-redis-xie-cheng-gong-na-shi-me-shi-hou-tong-bu-dao-shu-ju-ku-ni">Q: redis写成功，那什么时候同步到数据库呢？</a></li>
<li><a href="#miao-sha-xi-tong-she-ji-ti">秒杀系统设计题</a>
<ul>
<li><a href="#q-she-ji-yi-ge-miao-sha-xi-tong-da-gai-yao-zai-na-xie-ceng-mian-she-ji">Q: 设计一个秒杀系统大概要在哪些层面设计？</a></li>
<li><a href="#q-liu-lan-qi-ceng-ke-yi-zen-me-lan-jie">Q: 浏览器层可以怎么拦截？</a></li>
<li><a href="#q-zhan-dian-ceng-zen-me-fang-hu">Q: 站点层怎么防护？</a></li>
<li><a href="#q-10w-ge-bu-tong-de-uid-tong-shi-da-ru-zhan-dian-ceng-huan-cun-lan-bu-zhu-liao-dao-fu-wu-ceng-liao-zen-me-ban">Q: 10w个不同的uid同时打入，站点层缓存拦不住了，到服务层了，怎么办？</a></li>
<li><a href="#q-xie-dui-lie-man-liao-zen-me-ban">Q: 写队列满了怎么办？</a></li>
<li><a href="#q-miao-sha-hou-wei-zhi-fu-zen-me-ban">Q: 秒杀后未支付，怎么办？</a></li>
<li><a href="#q-xi-tong-zuo-liao-zhu-cong-du-xie-fen-chi-shi-zen-me-bao-zheng-xie-zhi-hou-neng-ma-shang-du-dao-xin-shu-ju">Q: 系统做了主从读写分离时， 怎么保证写之后能马上读到新数据？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="q-tun-tu-liang-tps-shi-shi-me">Q: 吞吐量（TPS）是什么</span><a href="#q-tun-tu-liang-tps-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。<br>
TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）</p>
<ul>
<li>对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数</li>
<li>对于并发系统而言，有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（因为并发执行，很多资源是交叉使用的）</li>
<li>吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致</li>
</ul>
<hr>
<h1><span id="q-qps-shi-shi-me">Q:   QPS是什么</span><a href="#q-qps-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
(Query Per Second)<br>
每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准<br>
在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p>
<hr>
<h1><span id="q-qps-he-tps-de-qu-bie">Q: QPS和TPS的区别？</span><a href="#q-qps-he-tps-de-qu-bie" class="header-anchor">#</a></h1>
<p>A:<br>
QPS是最大吞吐能力。<br>
TPS是针对单个请求的简单事务处理能力判断。更多是针对单个接口而言。</p>
<hr>
<h1><span id="q-tp-shi-shi-me">Q:  TP是什么？</span><a href="#q-tp-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
响应时间是指系统对请求作出响应的时间。是用户感知的时间，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。</p>
<hr>
<h1><span id="q-jie-kou-fang-wen-liang-guo-da-hui-fa-sheng-shi-me">Q:  接口访问量过大会发生什么？</span><a href="#q-jie-kou-fang-wen-liang-guo-da-hui-fa-sheng-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
服务器可能会崩溃。<br>
服务器对于请求都是排队的，负载不大的时候感觉不到，因为都是1秒内处理了。<br>
当请求数量上去后，就开始有感觉了。继续增大的话，队列会占满了，服务器开始丢弃部分请求<br>
继续增大网络请求，操作系统的TCP协议栈也开始丢弃请求，对外表现为服务器网络也连不上了。<br>
继续增大的话，网卡硬件部分开始满速运行，然后就看操作系统驱动和硬件质量了。<br>
另一种说法：</p>
<blockquote>
<p>当访问量大的时候，后端发送给数据库的请求多，数据库并发读取或写入，受系统io影响，服务器磁盘io是固定的，一般受硬盘硬件读写影响，读写越多，io越高，到达上线就会等待，出现io等待，CPU就会等待，内存也会占用不释放，然后越来越多的请求阻塞，恶性循环，系统资源耗尽，系统崩溃，这也是为什么要提高性能，各种做缓存，从cdn到业务层缓存，代码编译缓存，数据库缓存</p>
</blockquote>
<hr>
<h1><span id="q-ying-dui-gao-bing-fa-da-liu-liang-you-na-xie-chang-jian-shou-duan">Q: 应对高并发、大流量有哪些常见手段？</span><a href="#q-ying-dui-gao-bing-fa-da-liu-liang-you-na-xie-chang-jian-shou-duan" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>扩容——提升集群并行处理能力</li>
<li>静态化——静态数据由cdn返回</li>
<li>限流</li>
<li>缓存</li>
<li>队列——当上下游处理能力存在差距时，通过队列形成漏斗，等下游有处理能力时自己来消费。</li>
</ul>
<hr>
<h1><span id="q-shi-me-shi-liu-liang-de-lou-dou-mo-xing">Q: 什么是流量的漏斗模型？</span><a href="#q-shi-me-shi-liu-liang-de-lou-dou-mo-xing" class="header-anchor">#</a></h1>
<p>A:<br>
即流量要经过的系统如同漏斗一样， 访问db应当是最少也最后才到达的地方<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/090537a7721ac40dd4fe69719d1d5bcffd1f4eed.png" alt="090537a7721ac40dd4fe69719d1d5bcffd1f4eed"></p>
<hr>
<h1><span id="q-ru-he-zuo-jie-kou-xian-liu">Q:  如何做接口限流？</span><a href="#q-ru-he-zuo-jie-kou-xian-liu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>对客户端、前端限速，复杂业务操作例如验证码等，或者短时间内限制频繁操作次数上限。</li>
<li>如果自己这个接口是基础接口，被内部调用， 则也要限制内部服务的并发，单纯增加服务A和B的数量，基础服务没跟上，会造成雪崩效应。<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/a2234b6a44085f9193cc95f37579b2e08bc260c1.png" alt="a2234b6a44085f9193cc95f37579b2e08bc260c1"></li>
<li>使用漏桶算法</li>
</ol>
<ul>
<li>不管服务调用多么不稳定，我们只固定进行服务输出，比如每10毫秒接受一次服务调用。既然是一个桶，那就肯定有容量，由于调用的消费速率已经固定，那么当桶的容量堆满了，则只能丢弃了</li>
<li>实现方面，可以先准备一个队列，当做桶的容量，另外通过一个计划线程池（ScheduledExecutorService）来定期从队列中获取并执行请求调用，当然，我们没有限定一次性只能从队里中拿取一个请求，比如可以一次性拿100个请求，然后并发执行</li>
<li>缺点：严格限制的吞吐量，无法响应瞬发性的高峰流量。</li>
</ul>
<ol start="4">
<li>
<p>使用令牌桶算法<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/c6414f5fac5125bfb466e8ac88d122a1e5da66f5.png" alt="c6414f5fac5125bfb466e8ac88d122a1e5da66f5"><br>
生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/9379516.html">令牌桶源码解读</a></p>
</li>
<li>
<p>计数器算法<br>
在单位时间内， 有一个专门的计数器进行计数， 每请求一次计数器就+1，。 单位时间内如果到达阈值，则后续请求进行限流处理。 只有时间临界点到达后，才会重置，新的请求才能访问。</p>
</li>
</ol>
<p>单位时间计数器可以用redis的setnx实现<br>
要在 10 秒内限定 20 个请求，那么可以在 setnx 的时候设置过期时间 10，当请求的 setnx 数量达到 20 的时候即达到了限流效果。<br>
Redis Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。</p>
<p>也可以用redis的zset实现<br>
将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求</p>
<hr>
<h1><span id="q-ru-he-she-ji-yi-ge-xian-shi-qiang-gou-de-gong-neng">Q:  如何设计一个限时抢购的功能</span><a href="#q-ru-he-she-ji-yi-ge-xian-shi-qiang-gou-de-gong-neng" class="header-anchor">#</a></h1>
<p>例如每个商品都有特定的可抢购次数例如10w， 但是如果同时打进来可能直接导致数据库出现较大的负载压力。</p>
<p>A:<br>
应用层代码里用简单的时间片算法， 某一时间内阈值是1000， 时间到了后就拒绝后面用户的抢购，时间点到了后再允许接收。<br>
同时开发一个接口， 支持动态修改其中的各个参数。</p>
<p>另外如果商品数量过多，每个商品都有阈值， 可能总量会超出， 所以要根据商品总量动态调整每个商品的阈值上限。</p>
<hr>
<h1><span id="q-ru-he-zai-chan-pin-she-ji-shang-jin-xing-xue-feng">Q: 如何在 产品设计上进行削峰？</span><a href="#q-ru-he-zai-chan-pin-she-ji-shang-jin-xing-xue-feng" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>高流量活动分时段进行， 例如抢购5000个商品，分5个时间段，每个时间段开放1000个。</li>
<li>答题验证，验证码</li>
</ol>
<hr>
<h1><span id="q-ru-he-bi-mian-gao-bing-fa-xie-de-chang-jing-xia-de-shu-ju-ku-chao-mai-wen-ti">Q:  如何避免高并发写的场景下的数据库超卖问题</span><a href="#q-ru-he-bi-mian-gao-bing-fa-xie-de-chang-jing-xia-de-shu-ju-ku-chao-mai-wen-ti" class="header-anchor">#</a></h1>
<p>A:<br>
在Innodb中使用乐观锁来实现写入。<br>
每次写入前先查出商品剩余量和version<br>
调用update的时候加上where version条件， 如果version发生变化，自然就会update失败，于是进行重试。</p>
<p>虽然还是会占行锁， 但是不会造成请求线程阻塞。</p>
<hr>
<h1><span id="q-ru-guo-ku-cun-chong-zu-wu-lun-duo-shao-de-xie-qing-qiu-du-yi-ci-xing-da-gei-shu-ju-ku-ma-he-xian-shi-qiang-gou-bu-tong-bu-kao-lu-xie-shi-bai">Q: 如果库存充足， 无论多少的写请求都一次性打给数据库吗？（和限时抢购不同，不考虑写失败）</span><a href="#q-ru-guo-ku-cun-chong-zu-wu-lun-duo-shao-de-xie-qing-qiu-du-yi-ci-xing-da-gei-shu-ju-ku-ma-he-xian-shi-qiang-gou-bu-tong-bu-kao-lu-xie-shi-bai" class="header-anchor">#</a></h1>
<p>A:<br>
可以使用redis缓存做库存扣减。</p>
<ol>
<li>客户端调用WATCH + （商品id） 这个命令</li>
<li>调用MULTI命令标记事务块的开始</li>
<li>输入写命令。</li>
<li>调用EXEC进行事务提交<br>
如果商品的缓存值在WATCH后被修改了， 则EXEC会失败， redis之后再重试即可。</li>
</ol>
<hr>
<h1><span id="q-watch-de-yuan-li-shi-shi-me">Q: WATCH的原理是什么？</span><a href="#q-watch-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
redis服务端会 维持一个监听key的客户端链表<br>
当key发生变化之后，  这个key对应的客户端会被标记成REDIS_DIRTY_CAS状态<br>
当接收到后面这个客户端的EXEC请求时，就返回执行失败。</p>
<hr>
<h1><span id="q-redis-xie-cheng-gong-na-shi-me-shi-hou-tong-bu-dao-shu-ju-ku-ni">Q: redis写成功，那什么时候同步到数据库呢？</span><a href="#q-redis-xie-cheng-gong-na-shi-me-shi-hou-tong-bu-dao-shu-ju-ku-ni" class="header-anchor">#</a></h1>
<p>A:<br>
将写成功的消息写入雕铣队列， 通过消息队列来实现削峰，确保写入数据库时的流量可控。</p>
<hr>
<h1><span id="miao-sha-xi-tong-she-ji-ti">秒杀系统设计题</span><a href="#miao-sha-xi-tong-she-ji-ti" class="header-anchor">#</a></h1>
<p>秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据</p>
<h2><span id="q-she-ji-yi-ge-miao-sha-xi-tong-da-gai-yao-zai-na-xie-ceng-mian-she-ji">Q: 设计一个秒杀系统大概要在哪些层面设计？</span><a href="#q-she-ji-yi-ge-miao-sha-xi-tong-da-gai-yao-zai-na-xie-ceng-mian-she-ji" class="header-anchor">#</a></h2>
<p>A:<br>
首先考虑重要优化点：</p>
<ol>
<li>将请求尽可能拦截在上游。 因为实际上写操作不会有那么多。</li>
<li>充分利用缓存。因为大部分失败的人都是读操作。<br>
那么基于这2点，设计下面的架构：</li>
<li>浏览器端，最上层，会执行到一些JS代码</li>
<li>站点层，这一层会访问后端数据，拼html页面返回给浏览器(即和浏览器直接交互的）</li>
<li>服务层，向上游屏蔽底层数据细节，提供数据访问（即直接提供数据查询的服务，这里数据实际读取和返回前台响应分成了2个服务）</li>
<li>数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/5e79cd1be7028e577d625127bddb333d9ef76af1.png" alt="5e79cd1be7028e577d625127bddb333d9ef76af1"><br>
各部分优化措施如下：</li>
</ol>
<ul>
<li>浏览器和APP：做限速</li>
<li>站点层：按照uid做限速，做页面缓存</li>
<li>服务层：按照业务做写请求队列控制流量，做数据缓存</li>
<li>数据层：闲庭信步</li>
</ul>
<hr>
<h2><span id="q-liu-lan-qi-ceng-ke-yi-zen-me-lan-jie">Q: 浏览器层可以怎么拦截？</span><a href="#q-liu-lan-qi-ceng-ke-yi-zen-me-lan-jie" class="header-anchor">#</a></h2>
<p>A:<br>
验证码、 短时间内访问次数限制。 分段销售</p>
<hr>
<h2><span id="q-zhan-dian-ceng-zen-me-fang-hu">Q: 站点层怎么防护？</span><a href="#q-zhan-dian-ceng-zen-me-fang-hu" class="header-anchor">#</a></h2>
<p>A:<br>
站点层根据用户id做请求计数， uid只能5秒通过一次。这样可以避免恶意用户频繁用一个uid绕过客户端限制去下单。<br>
同时补充页面缓存。</p>
<hr>
<h2><span id="q-10w-ge-bu-tong-de-uid-tong-shi-da-ru-zhan-dian-ceng-huan-cun-lan-bu-zhu-liao-dao-fu-wu-ceng-liao-zen-me-ban">Q: 10w个不同的uid同时打入，站点层缓存拦不住了，到服务层了，怎么办？</span><a href="#q-10w-ge-bu-tong-de-uid-tong-shi-da-ru-zhan-dian-ceng-huan-cun-lan-bu-zhu-liao-dao-fu-wu-ceng-liao-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
服务层设计一个请求队列，每次只透有限的写请求去数据层<br>
读请求怎么办？ 用数据缓存。cache缓存动态扩容。 热点发现</p>
<hr>
<h2><span id="q-xie-dui-lie-man-liao-zen-me-ban">Q: 写队列满了怎么办？</span><a href="#q-xie-dui-lie-man-liao-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
最坏的情况下，缓存了若干请求之后，后续请求都直接返回“无票”（队列里已经有100w请求了，都等着，再接受请求也没有意义了）</p>
<hr>
<h2><span id="q-miao-sha-hou-wei-zhi-fu-zen-me-ban">Q: 秒杀后未支付，怎么办？</span><a href="#q-miao-sha-hou-wei-zhi-fu-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
数据库里一个状态，未支付。如果超过时间，例如45分钟，库存会重新会恢复（大家熟知的“回仓”）</p>
<hr>
<h2><span id="q-xi-tong-zuo-liao-zhu-cong-du-xie-fen-chi-shi-zen-me-bao-zheng-xie-zhi-hou-neng-ma-shang-du-dao-xin-shu-ju">Q: 系统做了主从读写分离时， 怎么保证写之后能马上读到新数据？</span><a href="#q-xi-tong-zuo-liao-zhu-cong-du-xie-fen-chi-shi-zen-me-bao-zheng-xie-zhi-hou-neng-ma-shang-du-dao-xin-shu-ju" class="header-anchor">#</a></h2>
<p>A:<br>
用切面的方式做注解<br>
通过注解判断哪些请求走主库，哪些请求走从库<br>
例如有些场景写之后马上就读的概率很高，那就走主库<br>
如果有些场景对读的实时性要求不高，那就从走从库<br>
或者用一些mycat中间件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-20 23:12:42" itemprop="dateCreated datePublished" datetime="2022-09-20T23:12:42+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 00:10:51" itemprop="dateModified" datetime="2022-09-21T00:10:51+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#1-4-de-si-kao-tao-lu">1+4的思考套路</a>
<ul>
<li><a href="#jian-dan-li-zi">简单例子</a>
<ul>
<li><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</a></li>
<li><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</a></li>
<li><a href="#ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</a></li>
<li><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</a></li>
<li><a href="#bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</a></li>
<li><a href="#shi-xian">实现</a></li>
</ul>
</li>
<li><a href="#jin-jie-ban-er-wei-de-dong-tai-gui-hua">进阶版，二维的动态规划</a>
<ul>
<li><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi-1">①在超时的思路上写出一组计算过程的例子</a></li>
<li><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang-1">②在超时例子的基础上，有哪些重复、浪费的地方？</a></li>
<li><a href="#ru-he-ding-yi-dp-shu-zu-1">③如何定义dp数组？</a></li>
<li><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de-1">④状态的变化方向是什么，是怎么变化的</a></li>
<li><a href="#bian-jie-zhuang-tai-shi-shi-me-1">⑤边界状态是什么？</a></li>
<li><a href="#shi-xian-1">实现</a></li>
<li><a href="#nei-cun-yi-chu-chu-li">内存溢出处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#qi-ta-lei-si-ti-mu-lian-xi">其他类似题目练习</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>以后不定期更新一些算法方便自己的思考和总结。</p>
<hr>
<p>平时练习算法题学习算法知识时，经常会发现题解里写着“动态规划”，里面一上来就是一个复杂的dp公式，对于新人来说除了说声<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(144).png" alt="image.png"></p>
<p>剩下就是疑惑，他是怎么想到这个公式的？我能想到吗？这玩意工作中有用吗？<br>
加上“动态规划”这高端的名字，然后就劝退了不少试图去理解他的人。<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(145).png" alt="image.png"></p>
<p>动态规划听起来太吓人，可以换个说法</p>
<p>我在内心更喜欢叫他“状态缓存”<br>
如果是服务开发，相信很熟悉这个词语， 利用缓存来加快一些重复的请求的响应速度。<br>
而这个缓存的特点是 <em><strong>和其他缓存有所关联。</strong></em></p>
<p>比如我们的服务要计算7天内的某金钱总和，计算后要缓存一下。<br>
后来又收到一个请求，要计算8天内的金钱总和<br>
那我们只需要取之前算过的7天内的金钱综合，加上第8天的金钱就行了。</p>
<h1><span id="1-4-de-si-kao-tao-lu">1+4的思考套路</span><a href="#1-4-de-si-kao-tao-lu" class="header-anchor">#</a></h1>
<p>自己针对动态规划总结了一个自己的思考套路，我叫他1组例子4个问题，就叫1+4好了，通过这5个过程，可以站在普通人的角度（就是非acm大佬那种的角度），去理解动态规划是如何被思考出来的</p>
<ul>
<li>在超时的思路上写出一组计算过程的例子</li>
<li>在超时例子的基础上，有哪些重复、浪费的地方？</li>
<li>如何定义dp数组</li>
<li>状态的变化方向是什么，是怎么变化的</li>
<li>边界状态是什么</li>
</ul>
<h2><span id="jian-dan-li-zi">简单例子</span><a href="#jian-dan-li-zi" class="header-anchor">#</a></h2>
<p>以一道简单题为例：<br>
爬楼梯：<br>
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(146).png" alt="image.png"></p>
<p>这时候就要静下心，观察这个解法的例子中是否有重复经历的场景，而这个重复经历的场景就叫状态。<br>
我处理动态规划的题目时， 都会问自己3个问题，一般就能顺利地解决。</p>
<h3><span id="zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</span><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi" class="header-anchor">#</a></h3>
<p>如果我们考虑最简单的解法，  就是从起点开始，每次选择走1步或者走2步，看下能否走到终点，能走到则方法数+1。<br>
但这种方法注定超时（O（n^2)）<br>
但我还是照着这个过程模拟了一下，随便列了几个<br>
1 -&gt;2-&gt; 3-&gt; 4-&gt; 5<br>
1 -&gt;2 -&gt;3-&gt; 5<br>
1-&gt;3-&gt;4-&gt;5<br>
1-&gt;3-&gt;5</p>
<h3><span id="zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</span><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang" class="header-anchor">#</a></h3>
<p>在上面，我发现了重复的地方<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(147).png" alt="image.png"></p>
<p>也就是说<br>
从3到5总共就2种路线，已经在1-&gt;2之后计算过了，我后面从1走到3再往后走时，没必要再去算了。<br>
换言之，当我走到3的时候，其实早就可以知道后面还剩下多少种走法。<br>
发现重复的地方后，就可以开始建立dp公式了。</p>
<h3><span id="ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</span><a href="#ru-he-ding-yi-dp-shu-zu" class="header-anchor">#</a></h3>
<p>定义dp数组，也就是定义上面提到的重复的地方。重新看下之前的那句话<br>
当我走到3的时候，其实早就可以知道后面还剩下多少种走法。<br>
所以dp[3]代表的就是从3往后，有多少种可走的方法。</p>
<h3><span id="zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</span><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de" class="header-anchor">#</a></h3>
<ul>
<li>首先思考状态的变化方向<br>
重新看这句话：</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>当我走到3的时候，其实早就可以知道后面还剩下多少种走法</p>
</blockquote>
</blockquote>
</blockquote>
<p>说明结果取决于往 <em><strong>后面</strong></em> 的状态<br>
因此我们要先计算后面的状态, 即从后往前算</p>
<ul>
<li>接着思考这个后面的状态和当前的状态有什么联系，是怎么变化的</li>
</ul>
<p>这个一般都包含在题目条件中<br>
根据题意，要么走2步，要么走1步，因此每当我走到一层时，下一次就2种状态可以变化。<br>
那么对于第3层而言，他后续有2种走法，走1步或者走2步<br>
那么他的情况就是dp[3] = dp[3+1] + dp{3+2}<br>
如果层数设为i，那么这个变化情况就是<br>
dp[i] = dp[i+1] + dp[i+2]</p>
<h3><span id="bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</span><a href="#bian-jie-zhuang-tai-shi-shi-me" class="header-anchor">#</a></h3>
<p>边界状态就是不需要依赖后面的状态了，直接可以得到结果的状态。<br>
在这里肯定就是最后一层dp[n]， 最后一层默认是一种走法。 dp[n]=1</p>
<h3><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h3>
<p>根据上面的过程，自己便定义了这个状态和变化</p>
<ul>
<li>定义：dp[i] :  代表从第i层往后，有多少种走法</li>
<li>方向和变化：dp[i] =  dp[i+1] + dp[i+2];</li>
<li>边界:  dp[n] = 1<br>
根据这个写代码就很容易了<br>
代码：</li>
</ul>
<pre><code class="language-java">    public int climbStairs(int n) &#123;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n-1] = 1;
        for(int i = n-2; i &gt;=0;i--) &#123;
            dp[i] = dp[i+1] + dp[i+2];
        &#125;
        return dp[0];
    &#125;
</code></pre>
<h2><span id="jin-jie-ban-er-wei-de-dong-tai-gui-hua">进阶版，二维的动态规划</span><a href="#jin-jie-ban-er-wei-de-dong-tai-gui-hua" class="header-anchor">#</a></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/</a></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(148).png" alt="image.png"></p>
<h3><span id="zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</span><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi" class="header-anchor">#</a></h3>
<p>超时的思路肯定是像搜索一样模拟所有的行走过程。<br>
先假设1个steps=5, arrlen=3的情况<br>
随便先列几个。模拟一下不断走的位置。数字指的是当前位置。<br>
0-&gt;1-&gt;2-&gt;1-&gt;0-&gt;0<br>
0-&gt;1-&gt;2-&gt;1-&gt;1-&gt;0<br>
0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0<br>
0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;0<br>
0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0<br>
……</p>
<h3><span id="zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</span><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang" class="header-anchor">#</a></h3>
<p>0-&gt;1-&gt;2-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
0-&gt;1-&gt;2-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;1-&gt;1-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;1-&gt;1-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
0-&gt;0-&gt;1-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;0-&gt;1-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
我发现这部分标粗的部分重复了，<br>
换句话说<br>
当我还剩2步且当前位置为1的时候，后面还有多少种走法，其实早就知道了。</p>
<h3><span id="ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</span><a href="#ru-he-ding-yi-dp-shu-zu" class="header-anchor">#</a></h3>
<p>重新看这句话：</p>
<blockquote>
<blockquote>
<blockquote>
<p>当我还剩2步且当前位置为1的时候，后面还有多少种走法，其实早就知道了。</p>
</blockquote>
</blockquote>
</blockquote>
<p>涉及了2个关键因素: 剩余步数和当前值，所以得用二维数组<br>
因此<br>
dp[realstep][index]<br>
就代表了  剩余步数为step且位置为index时， 后续还剩多少种走法。</p>
<h3><span id="zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</span><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de" class="header-anchor">#</a></h3>
<ul>
<li>先思考变化方向<br>
“当我还剩2步且当前位置为1的时候，<em><strong>后面</strong></em> 还有多少种走法，其实早就知道了。”</li>
</ul>
<p>这个后面是指啥， 后面会怎么变?<br>
后面肯定是步数越来越少的情况， 并且位置会根据规律变化。 所以变化方向是步数变少，位置则按照规定去变。<br>
那么这个固定越来越少的这个“剩余步数”，就是核心的变化方向<br>
我们计算时，可以先计算小的剩余步数的状态， 再去算大的剩余步数。</p>
<ul>
<li>如何变化<br>
根据题意和方向，剩余步数肯定-1，  然后位置有3种选择（减1，不变，加1）， 那么方法就是3种选择的相加<br>
dp[step][index] = dp[step-1][index-1] + dp[step-1][index] + dp[step-1][index+1]</li>
</ul>
<h3><span id="bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</span><a href="#bian-jie-zhuang-tai-shi-shi-me" class="header-anchor">#</a></h3>
<p>剩余步数为0时，只有当前位置为0才是我们最终想要的方案，把值设为1并提供给后面用，其他位置且步数为0时都认为是0。<br>
dp[0][0] = 1；<br>
dp[0][index] = 0；（index&gt;0)</p>
<h3><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h3>
<p>那么最终出来了</p>
<ul>
<li>定义：dp{realstep][index]:    剩余步数为step且位置为index时， 后续还剩多少种走法。</li>
<li>方向和变化：dp[step][index] = dp[step-1][index-1] + dp[step-1][index] + dp[step-1][index+1]</li>
<li>边界:  dp[0][0] = 1；</li>
</ul>
<h3><span id="nei-cun-yi-chu-chu-li">内存溢出处理</span><a href="#nei-cun-yi-chu-chu-li" class="header-anchor">#</a></h3>
<p>不过这题因为是困难题，所以给上面这个公式设立了一个小难度：<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(149).png" alt="image.png"></p>
<p>数组长度非常大，导致如果index的范围我们选择为0~arrLen-1, 那么最大情况dp[500][10^6]注定超时内存范围。<br>
这时候就要去思考index设那么大是不是没必要<br>
一般我们可以自己列这种情况的小例子，例如<br>
step=2, arr=10<br>
然后看下index有没有必要设成0~9，随便走几步<br>
0-&gt;1-&gt;0<br>
0-&gt;1-&gt;0<br>
0-&gt;0-&gt;0<br>
嗯？我发现就3种情况，arr后面那么长不用啦？<br>
于是发现规律：<br>
剩余的步数，必须支撑他返回原点！<br>
也就是说，其实index的最大范围最多就是step/2， 不能再多了，再多肯定回不去了。<br>
于是问题解决。</p>
<h1><span id="qi-ta-lei-si-ti-mu-lian-xi">其他类似题目练习</span><a href="#qi-ta-lei-si-ti-mu-lian-xi" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/">https://leetcode-cn.com/problems/minimum-cost-for-tickets/</a></p>
<hr>
<p>状态压缩的位dp，尽量从0往上更新，往后面看而不是往前面看</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集 - 力扣（LeetCode）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">微服务心跳管理机制设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 23:40:12 / 修改时间：23:25:44" itemprop="dateCreated datePublished" datetime="2022-09-19T23:40:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</a>
<ul>
<li><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</a></li>
<li><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</a></li>
<li><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</a></li>
<li><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</a></li>
</ul>
</li>
<li><a href="#ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</a>
<ul>
<li><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</a></li>
<li><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>笔记来源：<br>
<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/240656">实战：单机如何实现管理百万主机的心跳服务</a></p>
<h1><span id="ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</span><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu" class="header-anchor">#</a></h1>
<h2><span id="1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</span><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi" class="header-anchor">#</a></h2>
<p>全部遍历找超时，O(n)， 百万级别节点消耗非常大，   遍历时可能会因为涉及更新的同步问题， 导致此时无法插入。<br>
如果用单线程，这个过程慢的话会造成阻塞。</p>
<p>实现方式1： LRU+链表+哈希表<br>
① 所有心跳放进一个LRU队列中，保证最新的心跳包在队尾，最老的心跳包在队头。<br>
② 如果某节点有新的心跳包进来， 利用哈希表找到这个节点的链点位置，删除掉，再将新包插入到队尾。<br>
③ 每次心跳检查时， 只要查询队头， 不断将超时的心跳包出队，直到队头的心跳包不超时即可。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/ee76fb4d7bfd65d2190dbadd7760c7f312f74079.png" alt="ee76fb4d7bfd65d2190dbadd7760c7f312f74079"><br>
实现方式2： 时间轮，时间轮的做法见最后</p>
<h2><span id="2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</span><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing" class="header-anchor">#</a></h2>
<p>上面提到的心跳检查都在内存中，  心跳检查节点如果只有1个的话不可靠，而且量级也会很大。<br>
但又不能落盘，这会导致数据库的并发查询压力很大，且数据库自身的可靠性又会成了问题。</p>
<p>解决方式：<br>
分布式处理。<br>
心跳入口网关 根据节点的ip或者节点id做哈希， 确保相同节点的心跳包发往同一个节点。<br>
如果网关发现某个节点挂了，利用哈希一致算法更新发送的节点即可。</p>
<h2><span id="3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</span><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng" class="header-anchor">#</a></h2>
<p>收到心跳后， 涉及心跳的解包，LRU+哈希更新，需要提升处理性能。</p>
<p>①  多线程处理， 同样利用上面的方法做哈希，分配到特定的心跳处理线程，不同线程之间处理的节点信息不会互相干扰。</p>
<blockquote>
<blockquote>
<p>注意点：  缓存队列放到各自的工作线程中。 即push而非pull的方式，尽可能避免N之间的竞争，即只做1+1的竞争。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8.png" alt="68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8"><br>
队列锁采用自旋锁，避免工作线程频繁出现上下文切换（即保证工作线程一直在跑，这个用于高并发场景，高并发场景不能让他停下来的）</p>
</blockquote>
</blockquote>
<p>② 心跳包资源池减少内存释放频率<br>
如果只有10w个节点，那么每次收到心跳请求时，不要反复new新的心跳对象，而是从心跳资源池里取出构造好的对象，把最新时间set进去后再扔给分发线程。</p>
<h2><span id="4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</span><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp" class="header-anchor">#</a></h2>
<p>满足以下条件的话选择UDP:</p>
<ol>
<li>心跳包报文长度内容信息量很少，基本小于MTU， 不需要利用TCP自带的分包机制。</li>
<li>超时判断时间允许偶然一次的不可靠丢包（即偶尔丢一次并不影响）</li>
</ol>
<p>这种情况用UDP在网内发到心跳服务即可。<br>
不需要TCP那样的高消耗。</p>
<h1><span id="ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</span><a href="#ling-yi-ge-fang-shi-shi-jian-lun" class="header-anchor">#</a></h1>
<p>参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0f0fec47a0ad">TimingWheel 时间轮详解</a></p>
<p>时间轮本质：</p>
<ol>
<li>弄一个数组（看起来是一个环，实际上是数组）</li>
<li>数组中中每个节点又存了一个双向链表，用于存放实际的任务（用链表是为了方便插入）</li>
<li>任务具体放数组中的哪个位置？  根据 超期时间取余决定他的实际存放位置。</li>
<li>如果数组的节点中有任务，会把本身的超期时间带着一起扔进一个 队列中</li>
<li>队列每次取队头数据， 如果时间没到队头节点指定的延迟时间，就阻塞，直到时间到达，取出里面的任务逐个执行。</li>
<li>如果任务的定时时间超过整个环的时间？  则新增一个时间轮，时间比这个更长，因此队列里可能会多插入一个节点，节点中会标识我是小时间轮还是大时间轮的。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/2e95b497a970bc8baad42f25d6dee04d0241a079.png" alt="2e95b497a970bc8baad42f25d6dee04d0241a079"></li>
</ol>
<hr>
<p>其他的延时队列怎么做的?<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/woniu211111/article/details/109302412">延时队列实现的几种姿势</a></p>
<hr>
<h2><span id="q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</span><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>有一个优先队列， 放入的任务会根据是否快要超期进行排序， 马上就要超期的会放在队头。</li>
<li>当使用take方法取数据时，看一下队头任务，如果时间到了就返回。</li>
<li>如果时间还没到</li>
</ol>
<ul>
<li>首先看一下是否已经有线程在等待这个任务了，如果是的话，使用锁的condition机制做await等待。</li>
<li>如果没有线程正在等待，就计算还差多少时间， 然后用 LockSupport.parkNanos()让这个调用take方法的线程等待特定时间。</li>
</ul>
<ol start="4">
<li>注意等待期间，会释放锁，因此这期间可以正常offer和take。</li>
<li>当时间到了后，这个线程肯定能取走数据了。  取完后，顺便看一下队列里还有没有数据，如果有， 调用condition.signal()，通知那堆正在等待的线程， 你们可以试着竞争一下取数据了。</li>
<li>另外每当有新的任务offer时，如果发现最新入队的数据就是马上要超期的数据， 也会立刻通知等待的各位马上苏醒竞争（因为之前等待的线程认为自己还要睡一会才会有数据）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/105716205">Java阻塞延迟队列DelayQueue原理及使用</a></p>
<hr>
<h2><span id="q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</span><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A:<br>
java的delayQueue本质上是用堆（优先队列）实现的。<br>
接收任务后， 直接把任务放进优先队列中， 按照超期时间确定堆位置。  每次poll时如果发现堆顶没到时间就阻塞，直到时间到了再poll。<br>
取出来检查后，再加上时间扔回队列。</p>
<p>坏处： 插入和删除的复杂度是O(logn)。</p>
<p>而时间轮并不会把任务扔进 queue中，而是把时间轮的槽扔进queue中。  因此整个延迟队列实际上时针对槽的，不需要堆，按先入先出取数据和插槽即可，O(1)的复杂度。  而后面扔进来的任务，都是往槽里的双向链表塞进去而已。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">服务缓存设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 23:10:12 / 修改时间：23:26:01" itemprop="dateCreated datePublished" datetime="2022-09-19T23:10:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ben-di-huan-cun">本地缓存</a>
<ul>
<li><a href="#q-shi-me-shi-ben-di-huan-cun">Q: 什么是本地缓存？</a></li>
<li><a href="#q-you-na-xie-ben-di-huan-cun-chan-pin">Q: 有哪些本地缓存产品？</a></li>
<li><a href="#q-ben-di-huan-cun-you-shi-me-que-dian">Q: 本地缓存有什么缺点？</a></li>
<li><a href="#q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi">Q: 本地缓存有哪些更新方式？</a></li>
<li><a href="#q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang">Q: 被动更新本地缓存有什么要注意的地方？</a></li>
<li><a href="#q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu">Q: 什么是off-heap技术？有什么好处</a></li>
<li><a href="#q-zen-me-shi-yong-off-heap">Q: 怎么使用off-heap？</a></li>
<li><a href="#q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma">Q: directByteBuffer的内存什么时候会被释放？ 需要自己写C++代码释放吗？</a></li>
</ul>
</li>
<li><a href="#fen-bu-shi-huan-cun">分布式缓存</a>
<ul>
<li><a href="#q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de">Q: 一致性哈希是做什么的？</a></li>
<li><a href="#q-fen-cao-suan-fa-shi-shi-me">Q: 分槽算法是什么？</a></li>
<li><a href="#q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi">Q: 缓存穿透是什么?解决方式是？</a></li>
<li><a href="#q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng">Q: 要是分布式缓存发生雪崩了怎么办，要怎么防止发生</a></li>
<li><a href="#q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue">Q: 几十万的用户同时访问某个数据，但这个数据正好缓存里没有，导致十几万的请求打到数据库上，这种情况叫做什么？怎么解决？</a></li>
<li><a href="#q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai">Q: 缓存过多时，如何进行筛选和淘汰？</a></li>
</ul>
</li>
<li><a href="#huan-cun-re-dian">缓存热点</a>
<ul>
<li><a href="#q-shi-me-shi-re-dian-key-wen-ti">Q: 什么是热点Key问题？</a></li>
<li><a href="#q-ru-he-fa-xian-re-dian">Q: 如何发现热点？</a></li>
<li><a href="#q-ru-he-jie-jue-re-dian-wen-ti">Q: 如何解决热点问题？</a></li>
<li><a href="#q-ru-he-shan-chu-re-dian">Q: 如何删除热点？</a></li>
<li><a href="#q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong">Q: 如何利用redis 实现秒杀系统？</a></li>
</ul>
</li>
<li><a href="#shu-ju-yi-zhi-xing">数据一致性</a>
<ul>
<li><a href="#q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti">Q: 当需要删除数据时， 如果我先删缓存，再删数据库，可能会有什么问题？</a></li>
<li><a href="#q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me">Q: 网络通信正常、命令正常的情况下， 先删库 ，再删缓存， 还是有可能造成脏数据， 知道为什么么？</a></li>
<li><a href="#q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao">Q: 如果删了库之后， 再删缓存的途中，网络临时不通怎么办？那缓存也有可能一直脏着了。</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="ben-di-huan-cun">本地缓存</span><a href="#ben-di-huan-cun" class="header-anchor">#</a></h1>
<h2><span id="q-shi-me-shi-ben-di-huan-cun">Q:  什么是本地缓存？</span><a href="#q-shi-me-shi-ben-di-huan-cun" class="header-anchor">#</a></h2>
<p>A:<br>
即在客户端、应用端进行本地缓存， 或在jvm中缓存或在程序的堆外缓存。中间没有跨网络的开销</p>
<hr>
<h2><span id="q-you-na-xie-ben-di-huan-cun-chan-pin">Q: 有哪些本地缓存产品？</span><a href="#q-you-na-xie-ben-di-huan-cun-chan-pin" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>Ehcache(Hibernate的二级缓存就用的这个）</li>
<li>GuavaCache（轻量，易用，有丰富的被动更新机制）</li>
<li>MapDb(支持堆外内存）</li>
</ul>
<hr>
<h2><span id="q-ben-di-huan-cun-you-shi-me-que-dian">Q: 本地缓存有什么缺点？</span><a href="#q-ben-di-huan-cun-you-shi-me-que-dian" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>本地缓存会占用jvm有限的内存资源</li>
<li>高潮gc次数过快可能会导致贤者时间（stopworld）的延长。</li>
<li>只在本地缓存， 容易引发数据不同步。</li>
</ul>
<hr>
<h2><span id="q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi">Q: 本地缓存有哪些更新方式？</span><a href="#q-ben-di-huan-cun-you-na-xie-geng-xin-fang-shi" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>被动更新<br>
通过自己设置的超时时间， 超期后就自动进行更新，更新就是去重新发请求获取。。</li>
<li>主动更新<br>
数据发生变更，主动通过消息队列的方式同步给订阅的应用（适用于内部服务配置订阅），应用进行更新。</li>
</ul>
<hr>
<h2><span id="q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang">Q: 被动更新本地缓存有什么要注意的地方？</span><a href="#q-bei-dong-geng-xin-ben-di-huan-cun-you-shi-me-yao-zhu-yi-de-di-fang" class="header-anchor">#</a></h2>
<p>A:<br>
如果同时失效的缓存很多，  需要控制更新时的线程必须只有1个， 如果支持同时触发多个线程进行请求更新，可能导致大量请求打到分布式缓存上引发雪崩。<br>
两种方式：</p>
<ol>
<li>expireAfterWrite，   各超期的缓存起线程准备发请求时，需要先抢到锁，抢到了才能发，否则就阻塞（对性能要求不高可以选这个）</li>
<li>refreshAfterWrite，  也是抢锁，区别是如果抢不到，就返回旧值，等下次超期再抢。 （ 数据实时性要求不高的情况下可以选择这个）</li>
</ol>
<hr>
<h2><span id="q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu">Q: 什么是off-heap技术？有什么好处</span><a href="#q-shi-me-shi-off-heap-ji-zhu-you-shi-me-hao-chu" class="header-anchor">#</a></h2>
<p>A:<br>
堆外内存技术， 将数据存在jvm外的操作系统内存上，避免和原jvm进程互相干扰，因此也不会参与垃圾收集器gc。<br>
好处：</p>
<ul>
<li>减少gc次数</li>
<li>扩展和使用更大的内存空间</li>
<li>省去了物理内存和heap进程内存之间的数据复制步骤，类似于零拷贝了。</li>
</ul>
<hr>
<h2><span id="q-zen-me-shi-yong-off-heap">Q: 怎么使用off-heap？</span><a href="#q-zen-me-shi-yong-off-heap" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>NIO有个ByteBuffer.allocateDirect(int capacity)方法， 可以生成一个DirectByteBuffer实例</li>
<li>根据参数capacity的值，它会在物理内存中分配一块固定大小的直接字节缓冲区。</li>
<li>本质上是调用sum.misc.unsafe里实现的native方法进行内存分配操作。</li>
<li>可用-XX：MaxDirectMemorySize限制总的最大堆外申请大小，避免申请过多。</li>
</ul>
<hr>
<h2><span id="q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma">Q: directByteBuffer的内存什么时候会被释放？ 需要自己写C++代码释放吗？</span><a href="#q-directbytebuffer-de-nei-cun-shi-me-shi-hou-hui-bei-shi-fang-xu-yao-zi-ji-xie-c-dai-ma-shi-fang-ma" class="header-anchor">#</a></h2>
<p>A:<br>
不需要。   directByteBuffer在jvm中仍然是段引用，只不过buffer数据存到堆外了。 当这个buffer引用被回收了， 那么buffer背后的堆外内存也会被回收。</p>
<h1><span id="fen-bu-shi-huan-cun">分布式缓存</span><a href="#fen-bu-shi-huan-cun" class="header-anchor">#</a></h1>
<hr>
<h2><span id="q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de">Q:  一致性哈希是做什么的？</span><a href="#q-yi-zhi-xing-ha-xi-shi-zuo-shi-me-de" class="header-anchor">#</a></h2>
<p>A:<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42046105/article/details/92802476">https://blog.csdn.net/qq_42046105/article/details/92802476</a><br>
普通的哈希表算法一般都是计算出哈希值后，通过取余操作将 key 值映射到不同的服务器上<br>
但是当服务器数量发生变化时，取余操作的除数发生变化，所有 key 所映射的服务器几乎都会改变，这对分布式缓存系统来说是不可以接收的。<br>
一致性哈希算法能尽可能减少了服务器数量变化所导致的缓存迁移。</p>
<p>以分布式缓存场景为例，分析一下一致性哈希算法环的原理。<br>
首先将缓存服务器（ ip + 端口号）进行哈希，映射成环上的一个节点，计算出缓存数据 key 值的 hash key，同样映射到环上，并顺时针选取最近的一个服务器节点作为该缓存应该存储的服务器。具体实现见后续的章节。</p>
<p><img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/b64d1b6633bdfe624e578751aadc21f0ea591b65.png" alt="b64d1b6633bdfe624e578751aadc21f0ea591b65"><br>
服务器 B 宕机下线，服务器 B 中存储的缓存数据要进行迁移，但由于一致性哈希环的存在，只需要迁移key 值为1的数据，其他的数据的存储服务器不会发生变化。这也是一致性哈希算法比取余映射算法出色的地方。<br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/9aac123b97d816fed485a1c96c572f008eb025b1.png" alt="9aac123b97d816fed485a1c96c572f008eb025b1"></p>
<p>现实情况下，服务器在一致性哈希环上的位置不可能分布的这么均匀，导致了每个节点实际占据环上的区间大小不一。</p>
<p>这种情况下，可以增加虚节点来解决。通过增加虚节点（即A节点实际对应好几个虚节点），使得每个节点在环上所“管辖”的区域更加均匀。</p>
<p>这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。</p>
<hr>
<h2><span id="q-fen-cao-suan-fa-shi-shi-me">Q: 分槽算法是什么？</span><a href="#q-fen-cao-suan-fa-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
在redis官方给出的集群方案中，数据的分配是按照槽位来进行分配的，每一个数据的键被哈希函数映射到一个槽位，redis-3.0.0规定一共有16384个槽位，当然这个可以根据用户的喜好进行配置。当用户put或者是get一个数据的时候，首先会查找这个数据对应的槽位是多少，然后查找对应的节点，然后才把数据放入这个节点。这样就做到了把数据均匀的分配到集群中的每一个节点上，从而做到了每一个节点的负载均衡，充分发挥了集群的威力。</p>
<p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽</p>
<ul>
<li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</li>
<li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；<br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/5bf0eef7aafe6e5eeb4da6d74b7ba2fa37bbefa2.png" alt="5bf0eef7aafe6e5eeb4da6d74b7ba2fa37bbefa2"><br>
<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4163916a2a8a">一致性哈希和分槽算法</a></li>
</ul>
<hr>
<h2><span id="q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi">Q: 缓存穿透是什么?解决方式是？</span><a href="#q-huan-cun-chuan-tou-shi-shi-me-jie-jue-fang-shi-shi" class="header-anchor">#</a></h2>
<p>A:<br>
大量不存在的请求攻入，反复去查询数据库<br>
对于不存在的数据，可以用布隆过滤器（对1个值做多个不同的哈希，放入不同的位图位置里，  后面计算的时候，看下是否有1个位置没满足，没满足就一定不存在）</p>
<hr>
<p>Q:  缓存中的布隆过滤器是什么？</p>
<p>A:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fouy_yun/article/details/81075432">回答1</a><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38080318/article/details/106207978?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control404&amp;depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-2.control40">回答2</a><br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1663600837395.png" alt="1663600837395"></p>
<hr>
<hr>
<h2><span id="q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng">Q: 要是分布式缓存发生雪崩了怎么办，要怎么防止发生</span><a href="#q-yao-shi-fen-bu-shi-huan-cun-fa-sheng-xue-beng-liao-zen-me-ban-yao-zen-me-fang-zhi-fa-sheng" class="header-anchor">#</a></h2>
<p>A:<br>
缓存雪崩可能是因为数据未加载到缓存中，或者一大堆缓存在同一时间大面积的失效过期，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</p>
<p>解决方式：</p>
<ul>
<li>
<p>缓存失效可以通过加锁或队列来控制读取数据库的访问的线程数量，比如对某个key值运行一个线程访问数据库，其他线程等待</p>
</li>
<li>
<p>不同的key，设置不同的过期时间，让失效的时间点尽量均匀或者随机，避免一下子大面积失效。</p>
</li>
<li>
<p>做二级缓存，a1失效时候，访问a2，a1失效的时间设置为短期，a2为长期</p>
</li>
</ul>
<hr>
<h2><span id="q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue">Q: 几十万的用户同时访问某个数据，但这个数据正好缓存里没有，导致十几万的请求打到数据库上，这种情况叫做什么？怎么解决？</span><a href="#q-ji-shi-wan-de-yong-hu-tong-shi-fang-wen-mou-ge-shu-ju-dan-zhe-ge-shu-ju-zheng-hao-huan-cun-li-mei-you-dao-zhi-shi-ji-wan-de-qing-qiu-da-dao-shu-ju-ku-shang-zhe-chong-qing-kuang-jiao-zuo-shi-me-zen-me-jie-jue" class="header-anchor">#</a></h2>
<p>A:<br>
这种情况叫做  ”缓存击穿“。</p>
<ol>
<li>延长热点数据的缓存超期时间。 提前预置热点缓存。</li>
<li>接口限流、降级、队列。</li>
</ol>
<hr>
<h2><span id="q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai">Q: 缓存过多时，如何进行筛选和淘汰？</span><a href="#q-huan-cun-guo-duo-shi-ru-he-jin-xing-shai-xuan-he-tao-tai" class="header-anchor">#</a></h2>
<p>A:</p>
<p>没啥人用的数据占用了很多内存，叫缓存污染</p>
<p>Redis共支持八种淘汰策略。</p>
<ul>
<li>第一类： 不淘汰</li>
</ul>
<ol>
<li>noeviction<br>
如果满了，新的写请求就报错</li>
</ol>
<ul>
<li>第二类：淘汰部分过期数据<br>
当缓存满却收到新的写请求时，从会过期数据中选一个淘汰。</li>
</ul>
<ol start="2">
<li>volatile-random 随机删除过期数据中的某一个</li>
<li>volatile-ttl： 越早过期的数据，越优先被删除</li>
<li>volatile-lru：局部最近最少使用（即过期数据中一直没被用过的，优先删）。<br>
特点是会从集合中随机选N个，从N个里选一个LRU最小的删除。<br>
好处：Redis不用维护一个巨大的链表，也不用操作链表，进而提升性能</li>
<li>volatile-lfu：<br>
增加了访问次数<br>
先在过期集合中判断访问次数，再判断LRU时间、</li>
</ol>
<ul>
<li>第三类：全部数据可能都被淘汰</li>
</ul>
<ol start="6">
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>allkeys-lfu<br>
和volatile的处理一样，区别是 ”所有缓存“ 而非”部分过期缓存“</li>
</ol>
<h1><span id="huan-cun-re-dian">缓存热点</span><a href="#huan-cun-re-dian" class="header-anchor">#</a></h1>
<h2><span id="q-shi-me-shi-re-dian-key-wen-ti">Q: 什么是热点Key问题？</span><a href="#q-shi-me-shi-re-dian-key-wen-ti" class="header-anchor">#</a></h2>
<p>A:<br>
热点问题产生的原因大致有以下两种：</p>
<p>用户消费的数据远大于生产的数据（热卖商品、热点新闻、热点评论、明星直播）。<br>
在日常工作生活中一些突发的的事件，被大量刊发、浏览的热点新闻、热点评论、明星直播等，这些典型的读多写少的场景会产生热点问题。<br>
危害：</p>
<ul>
<li>请求分片集中，超过单Server的性能极限。</li>
<li>在服务端读数据进行访问时，往往会对数据进行分片切分，此过程中会在某一主机Server上对相应的Key进行访问，当访问超过Server极限时，就会导致热点Key问题的产生。</li>
<li>流量集中，达到物理网卡上限。</li>
<li>请求过多，缓存分片服务被打垮。</li>
<li>DB击穿，引起业务雪崩。</li>
</ul>
<hr>
<h2><span id="q-ru-he-fa-xian-re-dian">Q:  如何发现热点？</span><a href="#q-ru-he-fa-xian-re-dian" class="header-anchor">#</a></h2>
<ol>
<li>最简单的方式，是提前配置热点key，需要运营人员提供相关数据。</li>
<li>或者搭建有自身业务特点的热点自动发现平台， 通过分析日志得到热点key，及时更新热点保护。</li>
<li>client-&gt;Proxy-&gt;redis的proxy层做收集上报，其实类似于上面的自动发现收集。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/liu15835467265liu/article/details/103746821/">发现动态热点数据</a><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/cxy_19891109/article/details/87480515">秒杀系统之发现动态热点数据</a></li>
<li>redis自身有个monitor命令， 可以抓取收到的命令，收集上报热点key。</li>
</ol>
<hr>
<h2><span id="q-ru-he-jie-jue-re-dian-wen-ti">Q: 如何解决热点问题？</span><a href="#q-ru-he-jie-jue-re-dian-wen-ti" class="header-anchor">#</a></h2>
<p>识别到热点后就是处理策略了。</p>
<ol>
<li>升级为本地缓存，也就是redis前置服务增加jvm内部缓存，只针对部分热点key。</li>
<li>紧急扩容redis缓存（但是扩容需要过程，还涉及预热同步主节点数据问题）</li>
<li>拆分key分散到更多其它缓存节点避免单节点瓶颈**（redis单节点一般10w qps）**， 即单独对这个热点key添加新的分片算法，分到其他本不属于的redis上。</li>
</ol>
<p>换句话说， 根本解决方式就是及时进行缓存的扩容。 有种办法是重写redis的访问机制，将slave节点也用上，实现读写分离。<br>
redis有个客户端lettuce，可以开启cluster模式下的读写分离， 水平扩容slave节点来无限延申系统容量。<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/11250789.html">热点Key问题的发现与解决</a></p>
<hr>
<h2><span id="q-ru-he-shan-chu-re-dian">Q: 如何删除热点？</span><a href="#q-ru-he-shan-chu-re-dian" class="header-anchor">#</a></h2>
<p>A:<br>
然后就是删除的问题，，保证最终一致性即可，如果是本地缓存可以用MQ广播消息+超时过期的策略，当然还有些极端情况的不一致可以考虑延迟双删和binlog异步刷新</p>
<hr>
<h2><span id="q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong">Q: 如何利用redis 实现秒杀系统？</span><a href="#q-ru-he-li-yong-redis-shi-xian-miao-sha-xi-tong" class="header-anchor">#</a></h2>
<p>A:<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/11250753.html">使用Redis搭建电商秒杀系统</a></p>
<hr>
<hr>
<hr>
<h1><span id="shu-ju-yi-zhi-xing">数据一致性</span><a href="#shu-ju-yi-zhi-xing" class="header-anchor">#</a></h1>
<h2><span id="q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti">Q: 当需要删除数据时， 如果我先删缓存，再删数据库，可能会有什么问题？</span><a href="#q-dang-xu-yao-shan-chu-shu-ju-shi-ru-guo-wo-xian-shan-huan-cun-zai-shan-shu-ju-ku-ke-neng-hui-you-shi-me-wen-ti" class="header-anchor">#</a></h2>
<p>A:<br>
删完缓存，业务代码准备去删数据库时， 另一个请求打到redis这，发现不存在，于是另一个处理线程去数据库中取出了数据，并加载到了缓存中。<br>
这导致了缓存删除了个寂寞。</p>
<p>核心原因是因为业务代码的 删库和读-加载操作是支持并发执行的。</p>
<ul>
<li>因此应该先删数据库， 再删缓存，  这样能确保不会把脏数据重新加载到内存中</li>
</ul>
<hr>
<h2><span id="q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me">Q:  网络通信正常、命令正常的情况下， 先删库 ，再删缓存， 还是有可能造成脏数据， 知道为什么么？</span><a href="#q-wang-luo-tong-xin-zheng-chang-ming-ling-zheng-chang-de-qing-kuang-xia-xian-shan-ku-zai-shan-huan-cun-huan-shi-you-ke-neng-zao-cheng-zang-shu-ju-zhi-dao-wei-shi-me-me" class="header-anchor">#</a></h2>
<p>A:<br>
这种情况一般是”读缓存过期“导致的。</p>
<p>即正好某个key的读缓存过期，被删除。<br>
然后查询请求过来， 决定查库并加载到缓存中。<br>
此时又正好发来一个删除请求， 删库+删缓存，  然后又被上面的请求给重新加载了。</p>
<p>但是一般不考虑， 因为 正好过期+ 正好删除请求 +  ”先删库-&gt;查询缓存-&gt;删缓存-&gt;加载缓存的顺序“    这种概率是非常低的。</p>
<hr>
<h2><span id="q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao">Q: 如果删了库之后， 再删缓存的途中，网络临时不通怎么办？那缓存也有可能一直脏着了。</span><a href="#q-ru-guo-shan-liao-ku-zhi-hou-zai-shan-huan-cun-de-tu-zhong-wang-luo-lin-shi-bu-tong-zen-me-ban-na-huan-cun-ye-you-ke-neng-yi-zhi-zang-zhao-liao" class="header-anchor">#</a></h2>
<p>A:<br>
失败的话，放入一个消息队列。 搞一个定时线程定期取消息队列中的消息进行处理。<br>
为了减少业务代码耦合， 弄一个独立的缓存更新程序， 专门从binlog中拿更新消息进行同步。<br>
<img src="/images/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/f94f82af9a27192d3240215b4ce5f13b785f87b1.png" alt="f94f82af9a27192d3240215b4ce5f13b785f87b1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">分布式存储和事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 22:32:12 / 修改时间：23:17:54" itemprop="dateCreated datePublished" datetime="2022-09-19T22:32:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-cap-fen-bie-zhi-shi-me">Q: CAP分别指什么？</a></li>
<li><a href="#q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma">Q: 为什么说CAP无法同时满足？ 能讲清楚3种情况吗？</a></li>
<li><a href="#q-base-jie-jue-fang-an-shi-shi-me">Q: BASE解决方案是什么？</a></li>
<li><a href="#q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me">Q: 分布式事务种的2PC是什么？</a></li>
<li><a href="#q-3pc-you-shi-shi-me">Q: 3PC又是什么？</a></li>
<li><a href="#q-tcc-you-shi-shi-me">Q: TCC又是什么？</a></li>
<li><a href="#q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue">Q:数据库主从复制的延时问题如何解决？</a></li>
<li><a href="#q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian">Q：讲一下分布式锁的实现？</a></li>
<li><a href="#q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo">Q: 详细讲讲如何用数据库实现锁？</a></li>
<li><a href="#q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de">Q: redis的红锁是什么？解决什么问题的？</a></li>
<li><a href="#q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng">Q: 如何实现分布式的负载均衡？</a></li>
<li><a href="#q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan">Q: 主备数据库如何实现主备切换？</a></li>
<li><a href="#q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi">Q： 如何防止上面的主备切换过程中的新数据丢失？</a></li>
<li><a href="#q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao">Q: 如何防止主备切换时的数据不同步？ 和上面的数据丢失不同， 这里指的是master节点已经收到数据， 但是还没有往备节点同步时就挂掉了</a></li>
<li><a href="#q-ru-he-sheng-cheng-fen-bu-shi-id">Q: 如何生成分布式ID？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-cap-fen-bie-zhi-shi-me">Q:  CAP分别指什么？</span><a href="#q-cap-fen-bie-zhi-shi-me" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>C  一致性Consistency ——    多台节点之间数据一致 （响应准确度）</p>
</li>
<li>
<p>A  可用性Availability ——    能快速响应结果，没有延迟或者等待  （响应速度，不需要等待）</p>
</li>
<li>
<p>P   分区容错性PartitionTolerance——  如果有一部分节点挂了， 其他区节点还能提供服务 （ 时刻能响应，不会挂）</p>
</li>
</ul>
<hr>
<h1><span id="q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma">Q: 为什么说CAP无法同时满足？ 能讲清楚3种情况吗？</span><a href="#q-wei-shi-me-shuo-cap-wu-fa-tong-shi-man-zu-neng-jiang-qing-chu-3-chong-qing-kuang-ma" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>CA 无P :<br>
不支持分区处理请求，  则仅1个节点， 或者全部是时刻联通， 1个挂了，则认为系统不可用。<br>
意味着分布式系统的意义不存在。无法扩展。违背初衷<br>
传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p>
</li>
<li>
<p>CP 无A：<br>
没有可用性。<br>
意味着我会尽可能保证数据同步，  不同步的话我就不返回。<br>
如果有节点挂了，就用另外正在同步的节点做。<br>
例子： redis、hbase 这类和业务实时性强相关较弱的分布式数据库<br>
他们要保证一致性，但不一定要马上能返回结果，</p>
</li>
<li>
<p>AP 无C<br>
缺失一致性。<br>
就是因为节点同步延迟， 你看到的可能和别人的页面不一样，但是至少会马上给你结果。<br>
一般用于不重要的广告、 网页推送、推荐之类的功能。</p>
</li>
</ul>
<p>举个例子：<br>
<img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/c06e14ad98f2204d0498aa5833018c5d8374a45c.png" alt="c06e14ad98f2204d0498aa5833018c5d8374a45c"><br>
以这个图为例<br>
如果必须满足P<br>
则当DB1和DB0的网络通信断开（需要1分钟才能恢复）<br>
N2仍旧要能够返回结果。<br>
这时候一致性和可用性无法同时满足<br>
如果要求有一致性，则必须等待1分钟才会恢复， 则无法立刻响应结果<br>
如果要求可用性， 则必须立刻返回结果，  那么无法保证DB0和DB1是一致的。</p>
<hr>
<h1><span id="q-base-jie-jue-fang-an-shi-shi-me">Q: BASE解决方案是什么？</span><a href="#q-base-jie-jue-fang-an-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<ul>
<li>基本可用（Basically Available）<br>
指系统故障时，能保障核心功能可用，接口性能适当降低</li>
<li>软状态（Soft state）<br>
允许存在中间状态，例如支付中、同步中， 也就是允许数据延时</li>
<li>最终一致（Eventually Consistent）<br>
经过一段时间后，所有节点数据都将会达到一致。如订单的&quot;支付中&quot;状态，最终会变 为“支付成功”或者&quot;支付失败&quot;，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li>
</ul>
<hr>
<h1><span id="q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me">Q: 分布式事务种的2PC是什么？</span><a href="#q-fen-bu-shi-shi-wu-chong-de-2pc-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
2PC（ two-phase commit protocol）<br>
两阶段提交</p>
<ul>
<li>第一阶段：请求/表决阶段（点击放大）<br>
问一下这些参与节点&quot;这件事你们能不能处理成功了&quot;，参与者节点打开本地数据库事务，完成后并不会立马提交数据库本地事务，而是先向Coordinator报告说：“我这边可以处理了/我这边不能处理”</li>
<li>第二阶段：提交/执行阶段（正常流程）<br>
所有参与者节点都向协调者报告说“我这边可以处理”，协调者向所有参与者节点发送“全局提交确认通知（global_commit）”，参与者节点就会完成自身本地数据库事务的提交，并最终将提交结果回复“ack”消息给Coordinator，然后Coordinator就会向调用方返回分布式事务处理完成的结果。</li>
<li>第二阶段：提交/执行阶段（异常流程）<br>
参与者节点向协调者节点反馈“Vote_Abort”的消息。此时分布式事务协调者节点就会向所有的参与者节点发起事务回滚的消息（“global_rollback”），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。<br>
缺点：性能（阻塞等待）、协调者故障、</li>
</ul>
<hr>
<h1><span id="q-3pc-you-shi-shi-me">Q:  3PC又是什么？</span><a href="#q-3pc-you-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
在两阶段提交的基础上增加了CanCommit阶段 并引入了超时机制 ，一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。</p>
<p>第一阶段：CanCommit阶段（确认、检查各节点状态）<br>
第二阶段：PreCommit阶段（事务预提交，有执行节点的超时机制）<br>
第三阶段：DoCommit阶段（同样引入超时）</p>
<hr>
<h1><span id="q-tcc-you-shi-shi-me">Q: TCC又是什么？</span><a href="#q-tcc-you-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:</p>
<p>补偿事务TCC协议 （Try-Confirm-Cancel）<br>
有3个阶段   Try、confirm、cancel</p>
<ul>
<li>Try阶段：主要是对业务系统做检测及资源预留。</li>
<li>Confirm阶段：确认执行业务操作。</li>
<li>Cancel阶段：取消执行业务操作。</li>
</ul>
<blockquote>
<blockquote>
<p>2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p>
</blockquote>
</blockquote>
<p>TCC的不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p>
<hr>
<h1><span id="q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue">Q:数据库主从复制的延时问题如何解决？</span><a href="#q-shu-ju-ku-zhu-cong-fu-zhi-de-yan-shi-wen-ti-ru-he-jie-jue" class="header-anchor">#</a></h1>
<p>A:<br>
分情况讨论</p>
<ul>
<li>如果是写操作太多，导致binlog过多，以至于主库写和从库写都很慢——那么可以通过水平扩容的方式，打散写请求。  或者用高版本mysql支持并行binlog复制</li>
<li>过大的事务，导致主从延时——拆分大事务语句到若干小事务中，这样能够进行及时提交，减小主从复制延时</li>
<li>对大表进行alter table操作，导致了表会重新生成并进行迁移。——避免业务高峰执行表修改操作，尽量安排在业务低峰期执行</li>
<li>从库机器规格、配置和主库不一致。 ——从库有时候规格应该比主库配置要高。</li>
<li>数据库的表缺少主键或者合适索引，导致更新时的主从复制延时。  —— 去检查表结构，保证每个表都有显式自增主键，并协助用户建立合适索引</li>
<li>从库的查询请求过多，导致性能下降——增加从库数量，打散从库的查询请求。</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92077345">https://zhuanlan.zhihu.com/p/92077345</a></p>
<hr>
<h1><span id="q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian">Q：讲一下分布式锁的实现？</span><a href="#q-jiang-yi-xia-fen-bu-shi-suo-de-shi-xian" class="header-anchor">#</a></h1>
<p>A:<br>
分布式锁实现</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhiwei549/article/details/80692278">https://blog.csdn.net/wuzhiwei549/article/details/80692278</a></p>
<ul>
<li>从理解的难易程度角度（从低到高）</li>
</ul>
<p>数据库（最简单） &gt; 缓存 &gt; Zookeeper</p>
<ul>
<li>从实现的复杂性角度（从低到高）</li>
</ul>
<p>Zookeeper &gt;= 缓存 &gt; 数据库</p>
<ul>
<li>从性能角度（从高到低）</li>
</ul>
<p>缓存（最快） &gt; Zookeeper &gt;= 数据库</p>
<ul>
<li>从可靠性角度（从高到低）</li>
</ul>
<p>Zookeeper（最可靠） &gt; 缓存（怕主节点突然挂了，导致锁失效） &gt; 数据库（无失效时间，挂了就gg）</p>
<hr>
<h1><span id="q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo">Q: 详细讲讲如何用数据库实现锁？</span><a href="#q-xiang-xi-jiang-jiang-ru-he-yong-shu-ju-ku-shi-xian-suo" class="header-anchor">#</a></h1>
<p>A:<br>
有个locker表<br>
分别有4个字典</p>
<ul>
<li>锁名</li>
<li>持有锁的机器id</li>
<li>version</li>
<li>超时时间</li>
</ul>
<p>先查出这个锁名所在的行数据<br>
判断这个锁的id是否为空。<br>
如果不为空，且机器id也不是自己，说明被人持有了，返回false。<br>
如果为空， 则会尝试去更新， 使用   update 机器id where lockname=‘xxx’ and  <strong>version = 刚才拿到的version+1</strong><br>
如果update返回的结果不为0，说明更新成功， 返回true，持有锁成功。<br>
如果update结果为0， 说明抢锁失败， 因为version被人改了，导致where条件不成立，没更新任何一条</p>
<p>抢到锁的人完成自己的事务操作后， 释放锁，即把锁id清理即可。<br>
没抢到的人自己选择等一段时间再获取，或者频繁查询。</p>
<p>利用的行锁和MVCC的特性实现。<br>
图片如下：<br>
<img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/0e3326d72b41e735c84aec1ebb1b23f34149834b.png" alt="locker锁表"></p>
<hr>
<h1><span id="q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de">Q: redis的红锁是什么？解决什么问题的？</span><a href="#q-redis-de-hong-suo-shi-shi-me-jie-jue-shi-me-wen-ti-de" class="header-anchor">#</a></h1>
<p>A:<br>
解决的问题：<br>
Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点；master故障，发生故障转移，slave节点升级为master节点，导致锁丢失。</p>
<p>如何解决：</p>
<ol>
<li>获取当前时间（单位是毫秒）。</li>
<li>轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</li>
<li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>
<li>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li>
<li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</li>
</ol>
<hr>
<h1><span id="q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng">Q: 如何实现分布式的负载均衡？</span><a href="#q-ru-he-shi-xian-fen-bu-shi-de-fu-zai-jun-heng" class="header-anchor">#</a></h1>
<p>A:</p>
<p>nginx的负载均衡方式<br>
反向代理，作为代理服务器进行请求转发。<br>
轮询： 指定1个服务器ip列表， 依次按顺序分配<br>
weight权重： 根据指定权重， 分配的概率会变高（和服务器不同性能相关）<br>
ip哈希算法：  让特定ip都导向同一个服务器（避免不同服务器频繁获取某个用户信息）<br>
fair响应时间算法：  根据响应时间，动态调整分配优先级<br>
url哈希： 类似ip哈希，根据url哈希，一般是某个服务器会做特定接口缓存的情况。</p>
<hr>
<h1><span id="q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan">Q:  主备数据库如何实现主备切换？</span><a href="#q-zhu-bei-shu-ju-ku-ru-he-shi-xian-zhu-bei-qie-huan" class="header-anchor">#</a></h1>
<p>A:<br>
两种方式</p>
<ol>
<li>配置中心实现。 当监控系统发现异常后， 运维人员手动修改配置中心的数据源信息。  shark支持了基于zk的配置中心客户端。</li>
<li>给主备节点部署keepalive程序。  需要主备机器配置虚拟ip（类似于浮动ip),支持机器进行ip切换。<br>
运行过程中，  master和slave机器上的keepalived程序会互相发心跳，确认对方是否存货。 一旦master实例出现异常， 主节点的keeplive会自杀， 同时slave节点开始接管这个虚拟ip。</li>
</ol>
<hr>
<h1><span id="q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi">Q： 如何防止上面的主备切换过程中的新数据丢失？</span><a href="#q-ru-he-fang-zhi-shang-mian-de-zhu-bei-qie-huan-guo-cheng-zhong-de-xin-shu-ju-diu-shi" class="header-anchor">#</a></h1>
<p>A:<br>
数据优先插入到缓存服务，再通过消息队列插入到数据库， 如果主节点挂了，可以通过failover机制重发，当切换成功后，就能插入到更新后的master节点上了（ 前提是failover的总时间大于主备切换的时间）</p>
<hr>
<h1><span id="q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao">Q: 如何防止主备切换时的数据不同步？ 和上面的数据丢失不同， 这里指的是master节点已经收到数据， 但是还没有往备节点同步时就挂掉了</span><a href="#q-ru-he-fang-zhi-zhu-bei-qie-huan-shi-de-shu-ju-bu-tong-bu-he-shang-mian-de-shu-ju-diu-shi-bu-tong-zhe-li-zhi-de-shi-master-jie-dian-yi-jing-shou-dao-shu-ju-dan-shi-huan-mei-you-wang-bei-jie-dian-tong-bu-shi-jiu-gua-diao-liao" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>方法1： 如果要求数据强一致， 可以开启半同步复制模式， 即事务提交到master时，master会先发binlog给slave，当slave响应成功后，master才会完成这个事务。 （TPS较高场景不适合该模式）</p>
</li>
<li>
<p>方法2： 就是上面提到的缓存机制，先缓存，再落库。 然后再依靠 GTID（全局事务id）来保证主备数据的最终一致性。</p>
</li>
</ul>
<p>GTID即全局事务ID (global transaction identifier), 其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GTID最初由google实现，官方MySQL在5.6才加入该功能。mysql主从结构在一主一从情况下对于GTID来说就没有优势了，而对于2台主以上的结构优势异常明显，可以在数据不丢失的情况下切换新主<br>
<img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/5e695f9c56a67777bdb1727f6c2f805f16b0140c.png" alt="5e695f9c56a67777bdb1727f6c2f805f16b0140c"><br>
如图, Server1(Master)崩溃，根据从上show slave status获得Master_log_File/Read_Master_Log_Pos的值，Server2(Slave)已经跟上了主，Server3(Slave)没有跟上主。这时要是把Server2提升为主，Server3变成Server2的从。这时在Server3上执行change的时候需要做一些计算。</p>
<p>这个问题在5.6的GTID出现后，就显得非常的简单。由于同一事务的GTID在所有节点上的值一致，那么<strong>根据Server3当前停止点的GTID就能定位到Server2上的GTID</strong>。甚至由于MASTER_AUTO_POSITION功能的出现，我们都不需要知道GTID的具体值，直接使用CHANGE MASTER TO MASTER_HOST=‘xxx’, MASTER_AUTO_POSITION命令就可以直接完成failover的工作。</p>
<hr>
<h1><span id="q-ru-he-sheng-cheng-fen-bu-shi-id">Q: 如何生成分布式ID？</span><a href="#q-ru-he-sheng-cheng-fen-bu-shi-id" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>UUID<br>
UUID.randomUUID()<br>
UUID有5个版本，第一个版本比较好理解<br>
基于时间戳、随机数、机器MAC地址（java中改成ip地址）生成UUID<br>
随机性过强，不连续</li>
<li>数据库自增ID<br>
需要一个单独的MySQL实例用来生成ID，给id字段加上auto_increment关键字，自动id，只不过可能会不连续（可能挂掉）</li>
<li>数据库多主模式<br>
设置两个Mysql实例都能单独的生产自增ID<br>
2个实例的自增大小相同，但是起始值不同，就能保证隔开了<br>
不方便扩容</li>
<li>号段模式<br>
从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存<br>
多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。<br>
主流</li>
<li>Redis<br>
利用redis的 incr命令实现ID的原子性自增<br>
RDB备份可能导致id重复<br>
AOF备份可能导致重启时间过长</li>
<li>雪花算法Snowflake<br>
Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型<br>
序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107939861">9种分布式ID生成方式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">消息队列设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 21:30:12 / 修改时间：23:12:48" itemprop="dateCreated datePublished" datetime="2022-09-19T21:30:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me">Q: 消息队列的作用是什么？</a></li>
<li><a href="#q-xiao-xi-dui-lie-du-you-shi-me-que-dian">Q: 消息队列都有什么缺点？</a></li>
<li><a href="#q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian">Q: Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</a></li>
<li><a href="#q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling">Q: 如何保证消息队列的高可用？不会因为1台消息队列服务挂掉导致服务失灵？</a></li>
<li><a href="#q-zen-me-zhi-dao-leader-diao-xian">Q: 怎么知道leader掉线？</a></li>
<li><a href="#q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei">Q: 如何保证消息不会被重复消费？</a></li>
<li><a href="#q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de">Q: 是如何保证消息消费时一定是幂等的？</a></li>
<li><a href="#q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei">Q: 消息队列 mq 怎么保证顺序消费？</a></li>
<li><a href="#q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi">Q: 如何保证消息的可靠性传输，不会丢失？</a></li>
<li><a href="#q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya">Q:消息队列满了, 发生阻塞积压怎么办？例如突然流量峰值， 几百万消息持续积压？</a></li>
<li><a href="#q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu">Q: 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me">Q: 消息队列的作用是什么？</span><a href="#q-xiao-xi-dui-lie-de-zuo-yong-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>
<p>解耦：<br>
通过一个MQ，发布和订阅模型（Pub/Sub模型），系统A就和其它系统彻底解耦。<br>
需要考虑一下负责的系统中，是否有类似的场景，就是一个系统或者一个模块，调用了多个系统，互相之间的调用很复杂，维护起来很麻烦。（新增、删除接口都是要两边互相适配）<br>
但是其实这个调用是不需要同步调用接口的（不需要等待返回），如果用MQ给他异步化解耦，也是可以的，这个时候可以考虑在自己的项目中，是不是可以运用这个MQ来进行系统的解耦。</p>
</li>
<li>
<p>异步：<br>
加快接口的返回。</p>
</li>
<li>
<p>削峰<br>
就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。</p>
</li>
</ul>
<hr>
<h1><span id="q-xiao-xi-dui-lie-du-you-shi-me-que-dian">Q: 消息队列都有什么缺点？</span><a href="#q-xiao-xi-dui-lie-du-you-shi-me-que-dian" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>系统可用性降低： MQ挂掉的话很危险</li>
<li>系统复杂性提高：要考虑消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性</li>
<li>一致性问题：存在关联的消息，被不同消费者消费，如果另一个消费者执行失败，如何感知和回退？</li>
</ul>
<hr>
<h1><span id="q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian">Q: Kafka、activeMQ、RibbitMQ、RocketMQ都有什么优缺点？</span><a href="#q-kafka-activemq-ribbitmq-rocketmq-du-you-shi-me-you-que-dian" class="header-anchor">#</a></h1>
<p>A:<br>
列出一个表格<br>
<img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/63e89c47a42f0a17c97a8a2a303e4aeabd0a6de1.png" alt="63e89c47a42f0a17c97a8a2a303e4aeabd0a6de1"></p>
<p>简单记忆rabitMq和kafka的区别</p>
<ol>
<li>kafka高吞吐，适合大数据量的实时计算、日志采集。 但rabitMq的时延更小。</li>
<li>rabitMq基于主从， kafka则支持分布式（多副本）</li>
<li>rabitQq基于erlang开发， kafka用scala开发。</li>
</ol>
<hr>
<h1><span id="q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling">Q: 如何保证消息队列的高可用？不会因为1台消息队列服务挂掉导致服务失灵？</span><a href="#q-ru-he-bao-zheng-xiao-xi-dui-lie-de-gao-ke-yong-bu-hui-yin-wei-1-tai-xiao-xi-dui-lie-fu-wu-gua-diao-dao-zhi-fu-wu-shi-ling" class="header-anchor">#</a></h1>
<p>A:<br>
只讲一下kafka的</p>
<p>每个partition属于多台机器。<br>
有一个是leader节点<br>
leader会把数据同步到另外2台机器。<br>
如果leader挂了，则消费者选择读取 这个partition的另外2台机器</p>
<p>假设其中的一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此kafka会自动感知leader已经宕机，同时将其它的follower给选举出来，作为新的leader，并向外提供服务支持。<br>
<img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/45e7b2c323914c2bcc4ed65a2d3d872471f920ed.png" alt="45e7b2c323914c2bcc4ed65a2d3d872471f920ed"></p>
<hr>
<h1><span id="q-zen-me-zhi-dao-leader-diao-xian">Q: 怎么知道leader掉线？</span><a href="#q-zen-me-zhi-dao-leader-diao-xian" class="header-anchor">#</a></h1>
<p>A:<br>
对于Kafka而言，定义一个Broker是否“活着”包含两个条件：</p>
<p>一是它必须维护与ZooKeeper的session（这个通过ZooKeeper的Heartbeat机制来实现）。<br>
二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。<br>
Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除</p>
<p>更详细的解释，包括如何感知掉线（ack、zk-session）、如何选举<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingyunzong/p/9004703.html">Kafka学习之路 （三）Kafka的高可用</a></p>
<hr>
<h1><span id="q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei">Q: 如何保证消息不会被重复消费？</span><a href="#q-ru-he-bao-zheng-xiao-xi-bu-hui-bei-chong-fu-xiao-fei" class="header-anchor">#</a></h1>
<p>A: 需要消息消费者保证幂等性， 同样的消息，消费2次，结果是一样的。</p>
<p>幂等性是什么？通俗点说：幂等性就是一个数据，或者一个请求，以相同的内容和方式给你执行多次，得保证对应的数据不会改变，并且不能出错，这就是幂等性。（这样才能做到发送者搞重试或者多发问题）</p>
<hr>
<h1><span id="q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de">Q: 是如何保证消息消费时一定是幂等的？</span><a href="#q-shi-ru-he-bao-zheng-xiao-xi-xiao-fei-shi-yi-ding-shi-mi-deng-de" class="header-anchor">#</a></h1>
<p>A:<br>
需要应用服务器消费消息时是幂等的， 注意<strong>消息队列不保证幂等</strong>。<br>
消费中如果是insert相关，且只会insert1次的，通过主键判断，避免重插（消费端）<br>
消费端业可以加一个redis， 以缓存消费过的记录， 重复消费可以通过redis识别，并且redis是临时缓存，不会占用太多资源。</p>
<hr>
<h1><span id="q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei">Q: 消息队列 mq 怎么保证顺序消费？</span><a href="#q-xiao-xi-dui-lie-mq-zen-me-bao-zheng-shun-xu-xiao-fei" class="header-anchor">#</a></h1>
<p>A:<br>
abbitmq 中， 每个消费者对应一个队列<br>
kafka中， 每个消费者对应一个 partition。 partion中是有序的。</p>
<p>即kafka能保证塞入partion时是有序的<br>
因此你要求有序的那堆请求，要有相同的key映射到同一个partion</p>
<p>同时消费者处理的时候，也要按照核心key在内存中分配给不同的线程（内存线程使用加锁队列去获取消息）， 避免多线程处理的时候出现混乱<br>
<img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1/e536b0c4b51e6b9230a6f586b3cb7c65fc9f23d9.png" alt="e536b0c4b51e6b9230a6f586b3cb7c65fc9f23d9"></p>
<hr>
<h1><span id="q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi">Q: 如何保证消息的可靠性传输，不会丢失？</span><a href="#q-ru-he-bao-zheng-xiao-xi-de-ke-kao-xing-chuan-shu-bu-hui-diu-shi" class="header-anchor">#</a></h1>
<p>A:<br>
生产者发送到 MQ的时候丢了： 生产者使用ack机制，如果超时没收到，就回调nack接口做重发</p>
<p>MQ没发给消费者： 消息持久化，如果MQ挂了，还可以从磁盘中恢复重发。（ack应该在存盘后再发给生产者）</p>
<p>消费端没收到数据或者消费者挂了：<br>
关闭MQ的自动ack， 在消费者的代码逻辑里自己实现ack机制，保证是自己处理完成后才发ack，而不是收到了就发ack。<br>
对于kafka来说， 消费者的ack其实就是offset。 offset不能自动发，要自己实现。</p>
<hr>
<h1><span id="q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya">Q:消息队列满了, 发生阻塞积压怎么办？例如突然流量峰值， 几百万消息持续积压？</span><a href="#q-xiao-xi-dui-lie-man-liao-fa-sheng-zu-sai-ji-ya-zen-me-ban-li-ru-tu-ran-liu-liang-feng-zhi-ji-bai-wan-xiao-xi-chi-xu-ji-ya" class="header-anchor">#</a></h1>
<p>A:<br>
运维根据告警信息， 对queue资源和consumer资源都临时进行紧急进行人工扩容。</p>
<hr>
<h1><span id="q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu">Q: 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？</span><a href="#q-ru-guo-rang-ni-xie-yi-ge-xiao-xi-dui-lie-gai-ru-he-jin-xing-jia-gou-she-ji-shuo-yi-xia-ni-de-si-lu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>首先MQ得支持可伸缩性<br>
那就需要快速扩容，就可以增加吞吐量和容量，可以设计一个分布式的系统，参考kafka的设计理念，broker - &gt; topic -&gt; partition，每个partition放一台机器，那就存一部分数据，如果现在资源不够了，可以给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多的数据，提高更高的吞吐量</p>
</li>
<li>
<p>其次得考虑一下这个MQ的数据要不要落地磁盘？也就是需不需要保证消息持久化，因为这样可以保证数据的不丢失，那落地盘的时候怎么落？顺序写，这样没有磁盘随机读写的寻址开销，磁盘顺序读的性能是很高的，这就是kafka的思路。</p>
</li>
<li>
<p>其次需要考虑MQ的可用性？这个可以具体到我们上面提到的消息队列保证高可用，提出了多副本 ，leader 和follower模式，当一个leader宕机的时候，马上选取一个follower作为新的leader对外提供服务。</p>
</li>
<li>
<p>需不需要支持数据0丢失？可以参考kafka零丢失方案</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">254</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共346.2k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://breakdawncoder.com/page/9/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
