<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"breakdawncoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="破晓的知识屋">
<meta property="og:url" content="http://breakdawncoder.com/page/2/index.html">
<meta property="og:site_name" content="破晓的知识屋">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://breakdawncoder.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>破晓的知识屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">破晓的知识屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>知识索引地图</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最新发布</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">redis发布和订阅</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-22 23:16:12 / 修改时间：23:28:06" itemprop="dateCreated datePublished" datetime="2022-09-22T23:16:12+08:00">2022-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/redis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">redis基础应用</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>595</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-pin-dao-ding-yue-de-yuan-li-shi-zen-me-yang-de-di-ceng-jie-gou-shi-shi-me">Q: 频道订阅的原理是怎么样的？底层结构是什么？</a></li>
<li><a href="#q-mo-shi-ding-yue-ni-you-shi-zen-me-zuo-de">Q: 模式订阅呢？又是怎么做的</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>发布/订阅， 就是指客户端用subscribe订阅某个频道或者模式（模式就是带通配符的频道集合），  当服务端redis发布消息的时候， 发消息给订阅了的客户端。</p>
<ul>
<li>
<p>执行subscribe命令客户端会进入订阅状态，处于此状态下客户端不能使用除subscribe、unsubscribe、psubscribe和punsubscribe这四个属于&quot;发布/订阅&quot;之外的命令，否则会报错。</p>
</li>
<li>
<p>模式订阅是psubscribe 命令，可以同时psubscribe 多个模式<br>
<img src="/images/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/7c4ba17345ace77b60d7a177936b7545e4854f9a.png" alt="7c4ba17345ace77b60d7a177936b7545e4854f9a"></p>
</li>
</ul>
<p>模式订阅的示意图：<br>
<img src="/images/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/00e18168099bcb14a3411be7b039b67e713d0489.png" alt="00e18168099bcb14a3411be7b039b67e713d0489"></p>
<p>Q: 发布的消息会持久化嘛？<br>
A: 不会，因此可靠性不佳。 而且客户端订阅时，不会收到之前发布过的消息</p>
<hr>
<h1><span id="q-pin-dao-ding-yue-de-yuan-li-shi-zen-me-yang-de-di-ceng-jie-gou-shi-shi-me">Q: 频道订阅的原理是怎么样的？底层结构是什么？</span><a href="#q-pin-dao-ding-yue-de-yuan-li-shi-zen-me-yang-de-di-ceng-jie-gou-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
底层结构是字典+链表<br>
<img src="/images/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/ebd8d1addb675d6acffcb6925667757c36de7323.png" alt="ebd8d1addb675d6acffcb6925667757c36de7323"></p>
<p>客户端订阅后， redis会把客户端的连接信息放到这个频道的链表上。<br>
redis发布时，根据字典找到链表，然后逐个发送。</p>
<hr>
<h1><span id="q-mo-shi-ding-yue-ni-you-shi-zen-me-zuo-de">Q: 模式订阅呢？又是怎么做的</span><a href="#q-mo-shi-ding-yue-ni-you-shi-zen-me-zuo-de" class="header-anchor">#</a></h1>
<p>A:客户端做模式订阅时，会放到另一个链表上pubsubPattern，就不是字典了<br>
<img src="/images/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/681657383aed243f3bc7d6238bd8c772dbeca81a.png" alt="681657383aed243f3bc7d6238bd8c772dbeca81a"></p>
<p>链表里每个节点是   “1个客户端+1个模式”<br>
当发布一个消息时， 除了频道字典里的发布，  还会去这个pubsubPattern里遍历，找到所有匹配的模式的客户端，然后发送。</p>
<p>注意模式是不存在字典的，所以如果真的订阅了很多相同的毛模式，<strong>是会重复发送的。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis-stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis-stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">redis-stream消息队列详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-22 22:46:12 / 修改时间：23:28:23" itemprop="dateCreated datePublished" datetime="2022-09-22T22:46:12+08:00">2022-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/redis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">redis基础应用</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis-stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis-stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-stream-zhong-ju-you-na-xie-jie-gou">Q: stream中具有哪些结构？</a></li>
<li><a href="#stream-jian-dan-ming-ling">stream简单命令</a></li>
<li><a href="#q-stream-sheng-cheng-de-xiao-xi-id-shi-yi-lai-shi-jian-chuo-de-ru-guo-ji-qi-yin-wei-shi-jian-fa-xian-bu-tong-bu-jue-ding-hui-tui-shi-zhong-ke-neng-dao-zhi-chu-xian-yi-yang-de-xiao-xi-id-zen-me-ban">Q: stream生成的消息id是依赖时间戳的，如果机器因为时间发现不同步，决定回退时钟，可能导致出现一样的消息id，怎么办？</a></li>
<li><a href="#q-mou-ge-xiao-fei-zhe-xiao-fei-liao-xiao-xi-dan-shi-xiao-fei-de-guo-cheng-zhong-gua-diao-liao-zai-chong-qi-zhong-zhe-shi-hou-xiao-xi-hui-diu-shi-ma">Q： 某个消费者消费了消息， 但是消费的过程中挂掉了 ，在重启中，这时候消息会丢失吗？</a></li>
<li><a href="#q-ru-guo-xiao-fei-zhe-bu-shi-chong-qi-er-shi-zheng-ge-ji-qi-bei-ti-chu-liao-ni-huo-zhe-chang-shi-jian-gua-diao">Q: 如果消费者不是重启，而是整个机器被剔除了呢？或者长时间挂掉</a></li>
<li><a href="#q-ru-guo-zhe-ge-xiao-xi-ben-shen-jiu-you-wen-ti-wu-lun-shui-xiao-fei-du-hui-bao-cuo-dao-zhi-mei-you-ack-zen-me-ban">Q: 如果这个消息本身就有问题， 无论谁消费都会报错，导致没有ack，怎么办？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>redis5.0增加了一个结构  stream<br>
是具备一些可靠性机制的消息队列实现</p>
<h1><span id="q-stream-zhong-ju-you-na-xie-jie-gou">Q: stream中具有哪些结构？</span><a href="#q-stream-zhong-ju-you-na-xie-jie-gou" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>消费组——Consumergroup<br>
1个消费组可以有多个消费者，消费者在一个消费组里抢消息。</li>
<li>游标id——last_deliverer_id<br>
记录当前这个消费组被读取到哪了。<br>
每有一个消费者读取了一条消息， 组的这个游标就+1</li>
<li>未接收响应的消息里pending_ids<br>
记录了已经被消费，但是还没调用XACK进行响应的消息。<br>
是相比list消息队列的重要可靠性提升成员。</li>
<li>消息id——每个消息独一无的身份<br>
时间戳+序号</li>
<li>消息内容<br>
<img src="/images/redis-stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/8efce808fdd905c339f52f6afa33abba45d7a400.png" alt="8efce808fdd905c339f52f6afa33abba45d7a400"></li>
</ol>
<hr>
<h1><span id="stream-jian-dan-ming-ling">stream简单命令</span><a href="#stream-jian-dan-ming-ling" class="header-anchor">#</a></h1>
<p>详细：<br>
<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-stream.html">Redis Stream</a></p>
<ul>
<li>XADD 添加消息</li>
<li>XDEL 直接删除</li>
<li>XREAD 消费，支持阻塞，且消费后会进入pending</li>
<li>XACK</li>
<li>XGROUP CREATE - 创建消费者组</li>
<li>XREADGROUP GROUP - 读取消费者组中的消息</li>
</ul>
<hr>
<h1><span id="q-stream-sheng-cheng-de-xiao-xi-id-shi-yi-lai-shi-jian-chuo-de-ru-guo-ji-qi-yin-wei-shi-jian-fa-xian-bu-tong-bu-jue-ding-hui-tui-shi-zhong-ke-neng-dao-zhi-chu-xian-yi-yang-de-xiao-xi-id-zen-me-ban">Q: stream生成的消息id是依赖时间戳的，如果机器因为时间发现不同步，决定回退时钟，可能导致出现一样的消息id，怎么办？</span><a href="#q-stream-sheng-cheng-de-xiao-xi-id-shi-yi-lai-shi-jian-chuo-de-ru-guo-ji-qi-yin-wei-shi-jian-fa-xian-bu-tong-bu-jue-ding-hui-tui-shi-zhong-ke-neng-dao-zhi-chu-xian-yi-yang-de-xiao-xi-id-zen-me-ban" class="header-anchor">#</a></h1>
<p>A:<br>
会维护一个latest_generated_id，即上一次生成的消息id。<br>
当她发现这次的时间戳， 比之前的消息id的时间要小， 说明发生了时间回退<br>
这时候他仍会沿用上一次消息id的时间戳，只是在选后上去+1。<br>
<img src="/images/redis-stream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/db5affdc81c9d08b0dc6b7fb9e6948e5afdaf5a3.png" alt="db5affdc81c9d08b0dc6b7fb9e6948e5afdaf5a3"></p>
<hr>
<h1><span id="q-mou-ge-xiao-fei-zhe-xiao-fei-liao-xiao-xi-dan-shi-xiao-fei-de-guo-cheng-zhong-gua-diao-liao-zai-chong-qi-zhong-zhe-shi-hou-xiao-xi-hui-diu-shi-ma">Q： 某个消费者消费了消息， 但是消费的过程中挂掉了 ，在重启中，这时候消息会丢失吗？</span><a href="#q-mou-ge-xiao-fei-zhe-xiao-fei-liao-xiao-xi-dan-shi-xiao-fei-de-guo-cheng-zhong-gua-diao-liao-zai-chong-qi-zhong-zhe-shi-hou-xiao-xi-hui-diu-shi-ma" class="header-anchor">#</a></h1>
<p>A:<br>
stream有个pending列表，存放已经被消费走，但是没收到ACK响应的消息。<br>
pending列表中会记录这个消息被谁消费了。<br>
如果重启的消费者上限后，来取消息时，会先从这个pending里取消息， 这样就可以保证拿到消息不丢了。</p>
<hr>
<h1><span id="q-ru-guo-xiao-fei-zhe-bu-shi-chong-qi-er-shi-zheng-ge-ji-qi-bei-ti-chu-liao-ni-huo-zhe-chang-shi-jian-gua-diao">Q: 如果消费者不是重启，而是整个机器被剔除了呢？或者长时间挂掉</span><a href="#q-ru-guo-xiao-fei-zhe-bu-shi-chong-qi-er-shi-zheng-ge-ji-qi-bei-ti-chu-liao-ni-huo-zhe-chang-shi-jian-gua-diao" class="header-anchor">#</a></h1>
<p>A:<br>
XPENDING 命令可以查看pending消息的未被读取时长。<br>
如果超过一定时间， 可以用XCLAIM命令进行转移， 把超过时间的消息转移给另一个消费者的pending列表处理。<br>
这个需要自己写定时线程检查。</p>
<hr>
<h1><span id="q-ru-guo-zhe-ge-xiao-xi-ben-shen-jiu-you-wen-ti-wu-lun-shui-xiao-fei-du-hui-bao-cuo-dao-zhi-mei-you-ack-zen-me-ban">Q: 如果这个消息本身就有问题， 无论谁消费都会报错，导致没有ack，怎么办？</span><a href="#q-ru-guo-zhe-ge-xiao-xi-ben-shen-jiu-you-wen-ti-wu-lun-shui-xiao-fei-du-hui-bao-cuo-dao-zhi-mei-you-ack-zen-me-ban" class="header-anchor">#</a></h1>
<p>A:<br>
pending消息还有个属性是被读取次数。<br>
如果发现被读取次数超过一定上限， 说明有问题，于是调用XDEL删除问题消息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">redis常见数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-22 21:46:12 / 修改时间：23:28:18" itemprop="dateCreated datePublished" datetime="2022-09-22T21:46:12+08:00">2022-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/redis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">redis基础应用</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#string-zi-fu-chuan">String字符串</a>
<ul>
<li><a href="#q-redis-string-de-key-ke-yi-shi-zhong-wen-ma">Q: redis-string的key可以是中文吗？</a></li>
<li><a href="#q-na-me-redis-string-de-value-ke-yi-cun-zhong-wen-ma-shi-me-yang-zi-de-yao-bu-yao-zhi-ding-bian-ma">Q: 那么redis string的value可以存中文吗？什么样子的？要不要指定编码？</a></li>
<li><a href="#q-redis-string-de-yong-tu-sui-bian-shuo-ji-ge">Q: redis-string的用途随便说几个</a></li>
<li><a href="#q-string-de-di-ceng-shi-xian-you-liao-jie-ma-he-c-yu-yan-de-zi-fu-chuan-you-shi-me-qu-bie">Q: string的底层实现有了解吗？和C语言的字符串有什么区别？</a></li>
</ul>
</li>
<li><a href="#list-lie-biao">List列表</a>
<ul>
<li><a href="#q-yong-redis-de-list-ke-yi-shi-xian-na-xie-shu-ju-jie-gou-zen-me-shi-xian">Q: 用redis的list可以实现哪些数据结构？怎么实现？</a></li>
<li><a href="#q-xiao-fei-zhe-xiao-xi-dui-lie-neng-she-zhi-chao-shi-ma">Q: 消费者消息队列能设置超时吗？</a></li>
<li><a href="#q-list-li-de-cun-chu-jie-gou-shi-shi-me">Q: list里的存储结构是什么？</a></li>
</ul>
</li>
<li><a href="#set-ji-he">Set集合</a>
<ul>
<li><a href="#q-wei-shi-me-biao-qian-ke-yi-yong-set-lai-zuo-er-bu-yong-list">Q: 为什么标签可以用set来做？而不用list</a></li>
</ul>
</li>
<li><a href="#hash-san-lie">Hash散列</a>
<ul>
<li><a href="#q-hash-cun-chu-you-shi-me-xian-zhi">Q: hash存储有什么限制？</a></li>
<li><a href="#q-redis-ru-he-jie-jue-ha-xi-chong-tu-de">Q: redis如何解决哈希冲突的？</a></li>
<li><a href="#q-san-lie-biao-rong-liang-bu-zu-zen-me-ban">Q: 散列表容量不足怎么办？</a></li>
</ul>
</li>
<li><a href="#zset-you-xu-ji-he">Zset有序集合</a>
<ul>
<li><a href="#q-zset-de-yuan-li-shi-shi-me">Q: zset的原理是什么？</a></li>
<li><a href="#q-redis-3-0-li-zset-you-shi-me-gai-bian">Q: redis 3.0里zset有什么改变？</a></li>
</ul>
</li>
<li><a href="#hyperloglogs-ji-shu-tong-ji">HyperLogLogs基数统计</a>
<ul>
<li><a href="#q-ji-shu-yong-lai-jie-jue-shi-me-wen-ti">Q: 基数用来解决什么问题？</a></li>
</ul>
</li>
<li><a href="#bitmap-wei-cun-chu">BitMap 位存储</a></li>
<li><a href="#geospatial-di-li-xin-xi">geospatial 地理信息</a></li>
<li><a href="#stream">stream</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="string-zi-fu-chuan">String字符串</span><a href="#string-zi-fu-chuan" class="header-anchor">#</a></h1>
<p>string 不是简单的字符串的意思<br>
而是key -&gt;  value(string)<br>
即value是一个string ，可以用一个key去对应到，key也可以理解成变量名。</p>
<ul>
<li>
<p>这个string可以当成数字使用。<br>
set count 1<br>
incr count // count+1<br>
incrby count 100 // count+100<br>
但是当你get count的时候，得到的是string的count<br>
<img src="/images/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/23ec1c8f14dda8d7d967db125bf3b0d3b12c6182.png" alt="23ec1c8f14dda8d7d967db125bf3b0d3b12c6182"></p>
</li>
<li>
<p>也可以是，jpg图片或者序列化的对象。<br>
<strong>因此string本质上是二进制安全的，不会因为编码不同发生变化</strong></p>
</li>
</ul>
<hr>
<h2><span id="q-redis-string-de-key-ke-yi-shi-zhong-wen-ma">Q: redis-string的key可以是中文吗？</span><a href="#q-redis-string-de-key-ke-yi-shi-zhong-wen-ma" class="header-anchor">#</a></h2>
<p>A:<br>
key可以是中文，不过redis在存储的时候会将key进行序列化，在redis中存储的是字节码。</p>
<p>不推荐使用中文Key，内耗更大并且出现乱码的可能性也是有的。编码字节存储等都是不一样的占用空间。</p>
<hr>
<h2><span id="q-na-me-redis-string-de-value-ke-yi-cun-zhong-wen-ma-shi-me-yang-zi-de-yao-bu-yao-zhi-ding-bian-ma">Q: 那么redis string的value可以存中文吗？什么样子的？要不要指定编码？</span><a href="#q-na-me-redis-string-de-value-ke-yi-cun-zhong-wen-ma-shi-me-yang-zi-de-yao-bu-yao-zhi-ding-bian-ma" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>在保存到redis中时以utf8的编码方式保存的，实际上时等价于正常的这种十六进制字符串</li>
<li>默认看到的是乱码\xe4\xb8\xaa\xe4\xba\xba\xe8\xb5\x9b</li>
<li>启动cli时多加一个参数就行了，redis-cli --raw这种方式，就可以查看中文了</li>
</ul>
<hr>
<h2><span id="q-redis-string-de-yong-tu-sui-bian-shuo-ji-ge">Q: redis-string的用途随便说几个</span><a href="#q-redis-string-de-yong-tu-sui-bian-shuo-ji-ge" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>缓存。把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力</li>
<li>计数器，单节点redis的计数是同步的，不用担心并发问题。调用incr等方法即可</li>
<li>session缓存</li>
</ul>
<hr>
<h2><span id="q-string-de-di-ceng-shi-xian-you-liao-jie-ma-he-c-yu-yan-de-zi-fu-chuan-you-shi-me-qu-bie">Q: string的底层实现有了解吗？和C语言的字符串有什么区别？</span><a href="#q-string-de-di-ceng-shi-xian-you-liao-jie-ma-he-c-yu-yan-de-zi-fu-chuan-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A:<br>
redis的字符串类型是由一种叫做简单动态字符串(SDS)的数据类型来实现<br>
其实就是多了当前长度和剩余容量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len;          <span class="comment">//buf中已占用空间的长度</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">free</span>;        <span class="comment">//buf中剩余空间的长度</span></span><br><span class="line">  <span class="type">char</span> buf[];    <span class="comment">//数据空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDC和C语言字符串的区别：</p>
<ol>
<li>SDS保存了字符串的长度，而C语言不保存，C语言只能遍历找到第一个\0的结束符才能确定字符串的长度</li>
<li>修改SDS，会检查空间是否足够，不足会先扩展空间，防止缓冲区溢出，C字符串不会检查</li>
<li>SDS的预分配空间机制，可以减少为字符串重新分配空间的次数</li>
</ol>
<blockquote>
<p>备注：重新分配空间方式，小于1M的数据 翻倍+1，例如：13K+13K+1，如果大于1M，每次多分配1M，例如：10M+1M+1,如果字符串变短，并不会立即缩短，而是采用惰性空间释放，有专门的API可以释放多余空间</p>
</blockquote>
<h1><span id="list-lie-biao">List列表</span><a href="#list-lie-biao" class="header-anchor">#</a></h1>
<ul>
<li>list的本质就是一个双端链表！</li>
<li>用于消息排队、最新消息更新、 消息消费队列</li>
</ul>
<h2><span id="q-yong-redis-de-list-ke-yi-shi-xian-na-xie-shu-ju-jie-gou-zen-me-shi-xian">Q: 用redis的list可以实现哪些数据结构？怎么实现？</span><a href="#q-yong-redis-de-list-ke-yi-shi-xian-na-xie-shu-ju-jie-gou-zen-me-shi-xian" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>栈：lpush + lpop (只在一个方向上做push和pop）</li>
<li>队列：lpush + rpop（一个方向入， 一个方向出）</li>
<li>有限集合：lpush + ltrim（trim是截断，这样可以限制长度）</li>
<li>阻塞的消费者消息队列：lpush+brpop(b就是block的意思，没有就阻塞）</li>
</ul>
<hr>
<h2><span id="q-xiao-fei-zhe-xiao-xi-dui-lie-neng-she-zhi-chao-shi-ma">Q: 消费者消息队列能设置超时吗？</span><a href="#q-xiao-fei-zhe-xiao-xi-dui-lie-neng-she-zhi-chao-shi-ma" class="header-anchor">#</a></h2>
<p>A:<br>
可以的<br>
BLPOP key1 [key2 ] timeout</p>
<hr>
<h2><span id="q-list-li-de-cun-chu-jie-gou-shi-shi-me">Q: list里的存储结构是什么？</span><a href="#q-list-li-de-cun-chu-jie-gou-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
链表。 链表里存的是string。</p>
<hr>
<h1><span id="set-ji-he">Set集合</span><a href="#set-ji-he" class="header-anchor">#</a></h1>
<ul>
<li>set本质上就是实现了一个哈希表， 以至于不能在这个set成员中放入相同的key</li>
<li>除了简单的sadd、smember外，还有很多求交集的关键方法。</li>
</ul>
<p>**</p>
<h2><span id="q-wei-shi-me-biao-qian-ke-yi-yong-set-lai-zuo-er-bu-yong-list">Q: 为什么标签可以用set来做？而不用list</span><a href="#q-wei-shi-me-biao-qian-ke-yi-yong-set-lai-zuo-er-bu-yong-list" class="header-anchor">#</a></h2>
<p>A:<br>
因为set允许任意的增删， 而list只能对前后操作。 标签可能会被随时增加删除。<br>
因此被某某某点赞/取消的系统也可以用redis的set做缓存</p>
<hr>
<h1><span id="hash-san-lie">Hash散列</span><a href="#hash-san-lie" class="header-anchor">#</a></h1>
<ul>
<li>和set的区别， 就是key-value， 而set里只有key</li>
<li>命令都是hset、hget、hxxx等</li>
</ul>
<h2><span id="q-hash-cun-chu-you-shi-me-xian-zhi">Q: hash存储有什么限制？</span><a href="#q-hash-cun-chu-you-shi-me-xian-zhi" class="header-anchor">#</a></h2>
<p>A:</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对数量小于512个</li>
</ul>
<hr>
<h2><span id="q-redis-ru-he-jie-jue-ha-xi-chong-tu-de">Q: redis如何解决哈希冲突的？</span><a href="#q-redis-ru-he-jie-jue-ha-xi-chong-tu-de" class="header-anchor">#</a></h2>
<p>A:<br>
链表法（挂链法），后入的放到最前面</p>
<hr>
<h2><span id="q-san-lie-biao-rong-liang-bu-zu-zen-me-ban">Q: 散列表容量不足怎么办？</span><a href="#q-san-lie-biao-rong-liang-bu-zu-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
容量不足时的rehash：<br>
键值数据量变动时，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<ul>
<li>如果是扩充，新数组的空间大小为 大于2*used的2的n次方，比如：used=5,则去大于10的<strong>第一个2的n次方</strong>，为16</li>
<li>如果是缩小，新数组的空间大小为第一个不大于used的2的n次方，比如：used=5,则新大小为4<br>
即永远2的n次方<br>
Q:</li>
</ul>
<hr>
<h1><span id="zset-you-xu-ji-he">Zset有序集合</span><a href="#zset-you-xu-ji-he" class="header-anchor">#</a></h1>
<ul>
<li>
<p>zset不是java中的treeMap。<br>
treeMap是根据key进行排序<br>
而zset是根据scope排序， ke是唯一的， key对应的scope不是唯一的。</p>
</li>
<li>
<p>关键命令： 可以用ZRANGE拿到前几个。</p>
</li>
</ul>
<hr>
<h2><span id="q-zset-de-yuan-li-shi-shi-me">Q: zset的原理是什么？</span><a href="#q-zset-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h2>
<p>A:<br>
底层分别使用ziplist（压缩链表）和skiplist（跳表）实现。</p>
<p>当zset满足以下两个条件的时候，使用ziplist：</p>
<ol>
<li>保存的元素少于128个</li>
<li>保存的所有元素大小都小于64字节<br>
不满足这两个条件则使用skiplist。<br>
（注意：这两个数值是可以通过redis.conf的zset-max-ziplist-entries 和 zset-max-ziplist-value选项 进行修改。）处。</li>
</ol>
<hr>
<ol start="2">
<li>跳表：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/QGhurt/article/details/108447960">skiplist实现原理</a></li>
</ol>
<ul>
<li>插入时，随机一个层数，然后找到那一层的对应位置插入，并更新前后节点</li>
<li>get时，先从最高层找，比要找的大时，再去下一层。</li>
<li>随机时不是完全随机，会根据当前分布情况，修改概率p，并设置某一层的最大限制，防止比别的层过多。<br>
<img src="/images/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/b148147baa7475ed77e0525aa6fb624c7f822861.png" alt="b148147baa7475ed77e0525aa6fb624c7f822861"></li>
</ul>
<hr>
<h2><span id="q-redis-3-0-li-zset-you-shi-me-gai-bian">Q: redis 3.0里zset有什么改变？</span><a href="#q-redis-3-0-li-zset-you-shi-me-gai-bian" class="header-anchor">#</a></h2>
<p>A:<br>
zset的底层实现变成了quicklist。</p>
<ul>
<li>quicklist宏观上是一个双向链表，因此，它具有一个双向链表的有点，进行插入或删除操作时非常方便，虽然复杂度为O(n)，但是不需要内存的复制，提高了效率，而且访问两端元素复杂度为O(1)。</li>
<li>quicklist微观上是一片片entry节点，每一片entry节点内存连续且顺序存储，可以通过二分查找以 log2(n)log2(n) 的复杂度进行定位。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/men_wen/article/details/70229375">快速列表(quicklist)源码解读</a></li>
</ul>
<hr>
<h1><span id="hyperloglogs-ji-shu-tong-ji">HyperLogLogs基数统计</span><a href="#hyperloglogs-ji-shu-tong-ji" class="header-anchor">#</a></h1>
<h2><span id="q-ji-shu-yong-lai-jie-jue-shi-me-wen-ti">Q: 基数用来解决什么问题？</span><a href="#q-ji-shu-yong-lai-jie-jue-shi-me-wen-ti" class="header-anchor">#</a></h2>
<p>A:<br>
解决海量计数问题，  例如每天访问的ip数量， 如果真的存每个ip，会很大。<br>
而基数利用位运算来统计， 限制死了每个键的内存大小， 虽然有一定误差（即位冲突的情况），但是在海量的情况下不影响粗略统计。<br>
<img src="/images/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4c43aab1de89a220066b3d858353d798100969b3.png" alt="4c43aab1de89a220066b3d858353d798100969b3"></p>
<hr>
<p>基数每个键占用的内容都是 12K，理论存储近似接近 2^64 个值， 因为位冲突问题可能会偏少。</p>
<hr>
<h1><span id="bitmap-wei-cun-chu">BitMap 位存储</span><a href="#bitmap-wei-cun-chu" class="header-anchor">#</a></h1>
<p>用于统计 ”是“或者”否“的 这种一堆人的状态<br>
比如是否在线的缓存， 可以用bitmap。</p>
<p>如果存储一年的打卡状态需要多少内存呢？<br>
365 天 = 365 bit 1字节 = 8bit 46 个字节左右，非常节省内存</p>
<hr>
<h1><span id="geospatial-di-li-xin-xi">geospatial 地理信息</span><a href="#geospatial-di-li-xin-xi" class="header-anchor">#</a></h1>
<p>求解一些经纬度信息的。略</p>
<h1><span id="stream">stream</span><a href="#stream" class="header-anchor">#</a></h1>
<p>是一种更可靠的消息队列实现，redis5.0后实现的。<br>
具体见后面的stream详解</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">redis基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-22 21:35:12 / 修改时间：23:27:58" itemprop="dateCreated datePublished" datetime="2022-09-22T21:35:12+08:00">2022-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/redis/redis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">redis基础应用</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/redis/redis%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>482</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型</p>
<hr>
<p>Q: redis有什么好处你知道吗？<br>
A:</p>
<ul>
<li>读写性能好</li>
<li>支持的几种数据结构很好用，满足大部分使用场景</li>
<li>原子性，不用担心并发请求的问题</li>
<li>特性多，支持订阅/发布，过期等</li>
<li>支持持久化（RDB, AOF）</li>
<li>支持分布式，高可靠</li>
</ul>
<hr>
<p>Q: redis读写性能的数据具体有了解过吗？<br>
A:<br>
Redis能读的速度是110000次（即10W+）/s<br>
写的速度是81000次/s （即8W+）</p>
<hr>
<p>Q: redis的使用场景讲几个吧<br>
A:</p>
<ul>
<li>热点数据缓存</li>
<li>限时业务（用expir命令设置key超时，key没了商品就没了）</li>
<li>计数器问题（incrby命令可实现原子性递增）</li>
<li>分布式锁（setnx命令）</li>
<li>延时事件（可设置延时+监听，触发超时事件删除一些问题数据）</li>
<li>排行榜问题（SortedSet）</li>
<li>点赞、好友关系存储（集合支持求交集、并集、差集）</li>
<li>简单队列（list push/pop)</li>
</ul>
<hr>
<p>Redis官网:<a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">容器化部署（docker\K8s)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-22 01:30:12 / 修改时间：00:00:41" itemprop="dateCreated datePublished" datetime="2022-09-22T01:30:12+08:00">2022-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-jiang-yi-xia-ni-dui-xu-ni-hua-de-li-jie-shi-me-shi-xu-ni-hua">Q: 讲一下你对虚拟化的理解？什么是虚拟化？</a></li>
<li><a href="#q-jiang-yi-xia-docker-shi-shi-me">Q: 讲一下docker是什么？</a></li>
<li><a href="#q-docker-shi-na-chong-lei-xing-de-xu-ni-hua">Q: docker是哪种类型的虚拟化？</a></li>
<li><a href="#q-ni-men-wei-shi-me-yao-yong-docker-you-shi-me-hao-chu">Q: 你们为什么要用docker？有什么好处？</a></li>
<li><a href="#q-docker-he-xu-ni-ji-virtual-machine-de-qu-bie">Q: Docker和虚拟机Virtual Machine的区别？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-jiang-yi-xia-ni-dui-xu-ni-hua-de-li-jie-shi-me-shi-xu-ni-hua">Q: 讲一下你对虚拟化的理解？什么是虚拟化？</span><a href="#q-jiang-yi-xia-ni-dui-xu-ni-hua-de-li-jie-shi-me-shi-xu-ni-hua" class="header-anchor">#</a></h1>
<p>A:<br>
虚拟化可以理解为，将一台机器上的各种资源，进行抽象和隔离，方便在一台机器上运行多个进程或者系统，而且他们互相隔离，各自使用各自的资源，不会在逻辑上互相竞争资源。</p>
<p>虚拟机包含硬件和软件虚拟化。我这里只说软件虚拟化，也就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。</p>
<p>经典的有VMWare桌面虚拟、KVM全虚拟化（linux内核模块）、LXC（linux容器，轻量级虚拟化，重点）</p>
<hr>
<h1><span id="q-jiang-yi-xia-docker-shi-shi-me">Q: 讲一下docker是什么？</span><a href="#q-jiang-yi-xia-docker-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
Docker是一个开源的应用容器引擎</p>
<ul>
<li>它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上</li>
<li>发布到机器上之后， 会使用沙箱机制完全虚拟出一个完整的内部环境</li>
<li>容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底</li>
</ul>
<hr>
<h1><span id="q-docker-shi-na-chong-lei-xing-de-xu-ni-hua">Q: docker是哪种类型的虚拟化？</span><a href="#q-docker-shi-na-chong-lei-xing-de-xu-ni-hua" class="header-anchor">#</a></h1>
<p>A:<br>
docker属于操作系统层虚拟化（将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，并没有模拟硬件）， 换句话说，无法改变操作系统的性质。<br>
底层基于LXC（Linux Container，Linux容器）进行轻量化虚拟的实现。</p>
<hr>
<h1><span id="q-ni-men-wei-shi-me-yao-yong-docker-you-shi-me-hao-chu">Q: 你们为什么要用docker？有什么好处？</span><a href="#q-ni-men-wei-shi-me-yao-yong-docker-you-shi-me-hao-chu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>如果资源有限，只有1台机器，但是有3个微服务需要部署，每台部署3个服务进程后， 万一一个进程跑多线程时， 线程池打满了， 结果把cpu全占用， 让另外2个服务一起变慢了。   或者内存疯狂涨，把内存打满了搞挂另外2个进程。<br>
因此引入docker后，每个服务隔离在容器中，使用的线程资源和内存受到独立的限制，就不会互相影响了。</p>
</li>
<li>
<p>当需要部署新的微服务时， 如果没有docker，就需要手动部署，按照指导书一点点搭建，配置参数，很容易错，且容易导致开发环境和生产环境参数不一致。<br>
使用docker后，可以打包docker镜像进行容器部署， 发布的速度也变快了，扩容也变简单了。</p>
</li>
</ol>
<hr>
<h1><span id="q-docker-he-xu-ni-ji-virtual-machine-de-qu-bie">Q: Docker和虚拟机Virtual Machine的区别？</span><a href="#q-docker-he-xu-ni-ji-virtual-machine-de-qu-bie" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>Docker容器不是虚拟机， 只是当初被疯狂宣传为“轻量级虚拟机”</li>
<li>虚拟机必须要自己模拟一个虚拟操作系统guestOs才能运行， 但docker不需要，直接使用linux自身支持的namespace和cgroup实现资源隔离。</li>
<li>云服务提供商通常采用虚拟机技术隔离不同的用户/租户。  而Docker通常用于隔离不同的应用，例如前端，后端以及数据库</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" class="post-title-link" itemprop="url">微服务治理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-22 00:10:12" itemprop="dateCreated datePublished" datetime="2022-09-22T00:10:12+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 23:58:42" itemprop="dateModified" datetime="2022-09-21T23:58:42+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-chu-li-wei-fu-wu-zhi-li-shi-wei-shi-me-da-duo-cai-yong-rpc-er-fei-restful-zuo-fu-wu-jian-diao-yong">Q: 处理微服务治理时，为什么大多采用rpc而非restful做服务间调用？</a></li>
<li><a href="#q-fu-wu-a-diao-yong-fu-wu-b-shi-ru-guo-chao-shi-liao-ying-gai-zen-me-chu-li">Q： 服务A 调用服务B时， 如果超时了， 应该怎么处理？</a></li>
<li><a href="#q-fu-wu-fa-xian-you-na-liang-chong-mo-shi">Q: 服务发现有哪两种模式？</a></li>
<li><a href="#q-zookeeper-zuo-wei-zhu-ce-zhong-xin-you-shi-me-que-dian">Q: zookeeper作为注册中心有什么缺点？</a></li>
<li><a href="#q-you-shi-me-ban-fa-jie-jue-shang-mian-de-wen-ti">Q: 有什么办法解决上面的问题？</a></li>
<li><a href="#q-fu-wu-diao-yong-de-hu-xiang-xun-huan-yi-lai-wen-ti-ru-he-jie-jue-ji-a-fu-wu-qi-dong-yi-lai-b-fu-wu-mou-jie-kou-b-fu-wu-qi-dong-a-fu-wu-mou-jie-kou-de-shi-hou">Q: 服务调用的互相、循环依赖问题如何解决？ 即A服务启动依赖B服务某接口， B服务启动A服务某接口的时候</a></li>
<li><a href="#q-zuo-yi-ge-fu-wu-diao-yong-lian-de-hua-yi-ci-qing-qiu-xu-yao-bao-han-na-xie-xin-xi">Q: 做一个服务调用链的话， 一次请求需要包含哪些信息？</a></li>
<li><a href="#q-diao-yong-lian-gen-zong-you-na-xie-shi-jian-xin-xi-xu-yao-tong-ji">Q: 调用链跟踪有哪些时间信息需要统计？</a></li>
<li><a href="#q-zen-me-zai-jie-shou-he-fa-chu-shi-neng-yong-dao-tong-yi-ge-traceid">Q: 怎么在接收和发出时， 能用到同一个traceId？</a></li>
<li><a href="#q-suo-you-diao-yong-lian-xin-xi-zhi-jie-xie-ru-shu-ju-ku-ma">Q: 所有调用链信息直接写入数据库吗？</a></li>
<li><a href="#q-you-na-xie-shi-xian-fang-shi-dai-ma-ru-he-shi-xian-dui-yu-wei-fu-wu-er-yan">Q: 有哪些实现方式（代码如何实现），对于微服务而言？</a></li>
<li><a href="#q-ru-he-shi-xian-yi-ge-quan-ju-fu-wu-de-ding-shi-ren-wu-guan-li-ru-he-she-ji-ji-ru-guo-ni-men-xi-wang-zuo-ding-shi-ren-wu-de-hua-hui-zen-me-zuo">Q: 如何实现一个全局服务的定时任务管理？如何设计?  即如果你们希望做定时任务的话，会怎么做？</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<hr>
<h1><span id="q-chu-li-wei-fu-wu-zhi-li-shi-wei-shi-me-da-duo-cai-yong-rpc-er-fei-restful-zuo-fu-wu-jian-diao-yong">Q: 处理微服务治理时，为什么大多采用rpc而非restful做服务间调用？</span><a href="#q-chu-li-wei-fu-wu-zhi-li-shi-wei-shi-me-da-duo-cai-yong-rpc-er-fei-restful-zuo-fu-wu-jian-diao-yong" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>restful大多基于json做序列化，  相比于直接做二进制序列化，性能较差。 而服务间调用频率往往非常高，必须做到低时延。</li>
<li>常见的rpc框架往往能封装好底层网络通信协议、寻址、序列化问题，  通过一个proto文件即可生成 客户端代码和服务端代码， 大大简化开发工作。</li>
</ol>
<hr>
<h1><span id="q-fu-wu-a-diao-yong-fu-wu-b-shi-ru-guo-chao-shi-liao-ying-gai-zen-me-chu-li">Q：  服务A 调用服务B时， 如果超时了， 应该怎么处理？</span><a href="#q-fu-wu-a-diao-yong-fu-wu-b-shi-ru-guo-chao-shi-liao-ying-gai-zen-me-chu-li" class="header-anchor">#</a></h1>
<p>A:<br>
要分情况。</p>
<ul>
<li>如果是读服务，可以做failover重试， 重试3次才报失败。</li>
<li>如果是写服务， 考虑到幂等性，不应该做重试，直接报错。</li>
<li>如果是耗时较长的接口， 如果超时时间设的太短，则可能因为重试引发雪崩（大量该接口调用都发生连锁超时）， 因此不应该采用重试。</li>
</ul>
<p>常见的超时处理操作和情况：</p>
<ul>
<li>重试——读操作</li>
<li>失败就立刻报错——非幂等的读操作</li>
<li>出现异常直接忽略——用于审计日志写入和读取等不重要的操作</li>
<li>失败自动恢复，定时重发——用于重要消息通知等操作</li>
</ul>
<hr>
<h1><span id="q-fu-wu-fa-xian-you-na-liang-chong-mo-shi">Q:   服务发现有哪两种模式？</span><a href="#q-fu-wu-fa-xian-you-na-liang-chong-mo-shi" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>
<p>服务端服务发现模式<br>
提供路由服务route，  由路由服务帮客户端做服务发现和负载均衡调用，  路由服务和注册中心相连接<br>
缺点： 代理中心额外要引入容错性和伸缩性，成本比较大。 且性能上服务也较差。</p>
</li>
<li>
<p>客户端服务发现模式，<br>
客户端和注册中心相连接，  获取发现服务地址，自己处理多地址的负载均衡等策略。</p>
</li>
</ol>
<hr>
<h1><span id="q-zookeeper-zuo-wei-zhu-ce-zhong-xin-you-shi-me-que-dian">Q: zookeeper作为注册中心有什么缺点？</span><a href="#q-zookeeper-zuo-wei-zhu-ce-zhong-xin-you-shi-me-que-dian" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>服务扩容时， 应用启动缓慢</li>
<li>冗余的服务配置项会增加存储压力， 扩大网络开销<br>
原因：<br>
ZK是一个典型的CP系统， 基于ZAB原子广播的强一致性中间件， 写操作存在单点问题，无法通过水平扩容来解决。 当客户端发送写请求时， 集群中的其他节点会优先转发给leader节点， leader节点来做具体的写操作。  只有N/2+1个以上的节点都同步成功， 写才算完成。<br>
服务扩容的时候， tps越高，  服务注册写入效率月底， 导致上游大量请求排队， 服务启动和配置下载变得缓慢。</li>
</ol>
<hr>
<h1><span id="q-you-shi-me-ban-fa-jie-jue-shang-mian-de-wen-ti">Q: 有什么办法解决上面的问题？</span><a href="#q-you-shi-me-ban-fa-jie-jue-shang-mian-de-wen-ti" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>增加zk的observer节点。 因为observer节点不会增加写入开销，但可以分担带宽压力。</li>
<li>注册项精简， 只写入关键配置， 其他配置放到另外的元数据中心，实现配置垂直分离。</li>
<li>去除zk的强一致性，  自研一个最终一致、增量数据返回、去中心化的分布式注册中心。</li>
</ol>
<hr>
<h1><span id="q-fu-wu-diao-yong-de-hu-xiang-xun-huan-yi-lai-wen-ti-ru-he-jie-jue-ji-a-fu-wu-qi-dong-yi-lai-b-fu-wu-mou-jie-kou-b-fu-wu-qi-dong-a-fu-wu-mou-jie-kou-de-shi-hou">Q: 服务调用的互相、循环依赖问题如何解决？ 即A服务启动依赖B服务某接口， B服务启动A服务某接口的时候</span><a href="#q-fu-wu-diao-yong-de-hu-xiang-xun-huan-yi-lai-wen-ti-ru-he-jie-jue-ji-a-fu-wu-qi-dong-yi-lai-b-fu-wu-mou-jie-kou-b-fu-wu-qi-dong-a-fu-wu-mou-jie-kou-de-shi-hou" class="header-anchor">#</a></h1>
<p>A:<br>
尽量避免循环依赖， 调用流上要设计成单项依赖<br>
如果确实存在， 要避免开启强制的check服务开关， 不去校验依赖服务是否通，而是启动后定时轮询。</p>
<hr>
<h1><span id="q-zuo-yi-ge-fu-wu-diao-yong-lian-de-hua-yi-ci-qing-qiu-xu-yao-bao-han-na-xie-xin-xi">Q:   做一个服务调用链的话， 一次请求需要包含哪些信息？</span><a href="#q-zuo-yi-ge-fu-wu-diao-yong-lian-de-hua-yi-ci-qing-qiu-xu-yao-bao-han-na-xie-xin-xi" class="header-anchor">#</a></h1>
<p>A:<br>
traceId， 表示这是哪一次请求的完整跟踪<br>
spanId， 中间某次服务调用的请求/响应过程<br>
parentSpanId， 上一次调用的id， 用于确定请求依赖关系<br>
xxxConetext： 包含更多详细的信息， 例如是否是服务调用/提供方， host、port、接口名，被调用的服务方法名。</p>
<hr>
<h1><span id="q-diao-yong-lian-gen-zong-you-na-xie-shi-jian-xin-xi-xu-yao-tong-ji">Q:  调用链跟踪有哪些时间信息需要统计？</span><a href="#q-diao-yong-lian-gen-zong-you-na-xie-shi-jian-xin-xi-xu-yao-tong-ji" class="header-anchor">#</a></h1>
<p>A:<br>
以一次span为例，  需要记录<br>
Client SendTime 客户端刚发出的时间CS<br>
Server ReciveTime 服务接收请求时间SR<br>
Server Send Time 服务发送响应时间SS<br>
Client Receive Time 客户端接收响应时间CR</p>
<ul>
<li>服务调用耗时= CR - CS</li>
<li>服务处理耗时= SS - SR</li>
<li>网络开销总耗时= 服务调用耗时  - 服务处理耗时</li>
<li>前置网络耗时  =SR-CS</li>
<li>后置网络耗时 = CR - SS</li>
</ul>
<hr>
<h1><span id="q-zen-me-zai-jie-shou-he-fa-chu-shi-neng-yong-dao-tong-yi-ge-traceid">Q: 怎么在接收和发出时， 能用到同一个traceId？</span><a href="#q-zen-me-zai-jie-shou-he-fa-chu-shi-neng-yong-dao-tong-yi-ge-traceid" class="header-anchor">#</a></h1>
<p>A:<br>
使用threadLocal即可， 从该线程中拿到这个traceId变量值，用完销毁。</p>
<hr>
<h1><span id="q-suo-you-diao-yong-lian-xin-xi-zhi-jie-xie-ru-shu-ju-ku-ma">Q: 所有调用链信息直接写入数据库吗？</span><a href="#q-suo-you-diao-yong-lian-xin-xi-zhi-jie-xie-ru-shu-ju-ku-ma" class="header-anchor">#</a></h1>
<p>A:<br>
不可以， 容易对数据库造成较大压力， 应该放入消息队列进行消费， 实现削峰的效果</p>
<hr>
<h1><span id="q-you-na-xie-shi-xian-fang-shi-dai-ma-ru-he-shi-xian-dui-yu-wei-fu-wu-er-yan">Q: 有哪些实现方式（代码如何实现），对于微服务而言？</span><a href="#q-you-na-xie-shi-xian-fang-shi-dai-ma-ru-he-shi-xian-dui-yu-wei-fu-wu-er-yan" class="header-anchor">#</a></h1>
<p>A:<br>
一种看框架本身是否支持相关的filter，继续配置，  例如dubb的filter<br>
或者自己写动态AOP， 例如利用-javaagent 实现动态的jvm增强需求。 实质上利用了jdk1.5引入的Instrumentation接口</p>
<hr>
<h1><span id="q-ru-he-shi-xian-yi-ge-quan-ju-fu-wu-de-ding-shi-ren-wu-guan-li-ru-he-she-ji-ji-ru-guo-ni-men-xi-wang-zuo-ding-shi-ren-wu-de-hua-hui-zen-me-zuo">Q: 如何实现一个全局服务的定时任务管理？如何设计?  即如果你们希望做定时任务的话，会怎么做？</span><a href="#q-ru-he-shi-xian-yi-ge-quan-ju-fu-wu-de-ding-shi-ren-wu-guan-li-ru-he-she-ji-ji-ru-guo-ni-men-xi-wang-zuo-ding-shi-ren-wu-de-hua-hui-zen-me-zuo" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>方案一：<br>
可以借助注册中心实现定时任务管理。</li>
</ul>
<ol>
<li>服务自身维护需要的定时任务接口、定时触发条件。 可以自定义注解设置在接口上。</li>
<li>然后通过注册动作将接口以及接口上的注解发布给注册中心。</li>
<li>注册中心将定时类接口呈现给 注册中心服务的定时任务管理页。</li>
<li>当到达时间， 注册中心调用定时任务接口，触发动作。  如果需要关闭，在管理页直接关闭即可。</li>
<li>当服务的定时任务接口返回了已卸载或者不存在的接口时， 注册中心要删除这个定时任务，不再呈现在页面上。<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/xungen/article/details/106873673">一个简单的定时任务调度中心设计方案</a></li>
</ol>
<p>当时我自己服务里没有这种功能的注册中心， 实现起来的接口开发量还是比较大的。</p>
<ul>
<li>方案二：基于数据库锁quartz<br>
当多个server的定时任务到时间时， 先去抢锁表里该任务的悲观锁，如果抢到了就执行， 如果抢不到就等待。当重新拿到锁后，发现该定时任务已经被设置成“完成”，时间也对的上，于是就不再执行了。</li>
</ul>
<p>缺点： 集群特性对于高CPU使用率的任务效果很好，但是对于大量的短任务，各个节点都会抢占数据库锁，这样就出现大量的线程等待资源。这种情况随着节点的增加会越来越严重。<br>
另外，quartz的分布式只是解决了高可用的问题，并没有解决任务分片的问题，还是会有单机处理的极限，即某台机器执行过多的定时任务导致负载暴涨，而其他的机器一直凑巧没抢到。</p>
<ul>
<li>方案三： 引入支持任务分片的分布式任务调度框架</li>
</ul>
<ol>
<li>elastic-job （当当）</li>
<li>TBSchedule（淘宝）</li>
<li>Saturn（唯品会）<br>
默认的分片策略，作业数能被服务器数整除情况下均匀分配：<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/4ef34664a006479928c47313a27a0dc4de910f47.png" alt="4ef34664a006479928c47313a27a0dc4de910f47"><br>
根据哈希的分片策略：</li>
</ol>
<blockquote>
<p>根据作业名的哈希值奇偶数决定采用IP升/降序算法实现分片，作业名的哈希值为奇数则IP升序，作业名的哈希值为偶数则IP降序，通过这种方式用于将不同的作业分片负载均衡至不同的服务器。<br>
如作业名哈希值为偶数，则采用IP降序算法实现分片，这样就避免了采用平均分配算法时IP地址靠后的服务器空闲的问题。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/201911/605783.htm">聊聊分布式定时任务elastic-job作业分片策略</a></p>
<hr>
<p>Q: 有哪些负载均衡算法？<br>
A:</p>
<ul>
<li>
<p>ActiveWeight / LeastActive ：低并发度优先， 统计某时刻的被调用 call 数越小优先级越高。即根据短时间内被调用数获取。需要统计的成本，实现难度比较高，存在耦合。</p>
</li>
<li>
<p>Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。节点少的时候，随机有可能出现连续都随机到一个节点上，导致负载不均衡。</p>
</li>
<li>
<p>RoundRobin ：轮循，按公约后的权重设置轮循比率。<br>
存在慢的提供者累积请求问题，比如：第二台机器性能很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
</li>
<li>
<p>LocalFirst ：本地服务优先获取策略。</p>
</li>
<li>
<p>Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
</ul>
<hr>
<p>Q: 负载均衡时，请求失败怎么办？<br>
A:</p>
<ul>
<li>
<p>Failover ：失败自动切换，当出现失败，重试其它服务器。<br>
通常用于读操作，但重试会带来更长延迟。</p>
</li>
<li>
<p>Failfast ：快速失败，只发起一次调用，失败立即报错。<br>
通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li>
<p>Failsafe ：失败安全，出现异常时，直接忽略。<br>
通常用于写入审计日志等操作。</p>
</li>
<li>
<p>Failback ：失败自动恢复，后台记录失败请求，定时重发。<br>
通常用于消息通知操作。</p>
</li>
<li>
<p>Forking ：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。</p>
</li>
<li>
<p>Broadcast ：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">现网压测系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-21 23:30:12 / 修改时间：23:53:29" itemprop="dateCreated datePublished" datetime="2022-09-21T23:30:12+08:00">2022-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-wei-shi-me-xu-yao-xian-shang-ya-ce">Q: 为什么需要线上压测？</a></li>
<li><a href="#q-quan-lian-lu-ya-ce-he-jie-kou-ya-ce-de-qu-bie">Q: 全链路压测和接口压测的区别？</a></li>
<li><a href="#q-ye-wu-xi-tong-ru-he-qu-fen-ya-ce-liu-liang-ji-pan-duan-na-xie-shi-ya-ce-de-qing-qiu-na-xie-shi-zheng-chang-de-qing-qiu">Q: 业务系统如何区分压测流量？即判断哪些是压测的请求，哪些是正常的请求？</a></li>
<li><a href="#q-zhe-ge-ya-ce-da-biao-de-gai-zao-he-gua-pei-yao-zhong-jian-suo-you-fu-wu-can-yu-ma-gai-zao-cheng-ben-hui-bu-hui-you-dian-da">Q: 这个压测打标的改造和适配要中间所有服务参与吗？ 改造成本会不会有点大？</a></li>
<li><a href="#q-shi-bie-dao-ya-ce-biao-ji-hou-ru-he-bao-zheng-wang-xia-you-fa-qing-qiu-shi-reng-ran-shi-ya-ce-biao-ji-de-xing-shi">Q: 识别到压测标记后， 如何保证往下游发请求时，仍然是压测标记的形式？</a></li>
<li><a href="#q-ru-guo-wo-bu-zai-tong-yi-ge-xian-cheng-zhong-chu-li-he-fa-qing-qiu-zen-me-ban">Q: 如果我不在同一个线程中处理和发请求， 怎么办？</a></li>
<li><a href="#q-ru-guo-wo-de-ya-ce-lian-lu-zhong-bao-han-liao-wai-bu-fu-wu-de-jie-kou-zen-me-ban-li-ru-di-san-fang-zhi-fu-di-san-fang-duan-xin-deng">Q: 如果我的压测链路中 包含了外部服务的接口怎么办？  例如第三方支付、第三方短信等。</a></li>
<li><a href="#q-hui-dui-shu-ju-ku-chan-sheng-ying-xiang-de-ya-ce-qing-qiu-zen-me-ban">Q: 会对数据库产生影响的压测请求怎么办？</a></li>
<li><a href="#q-redis-kafka-deng-zhong-jian-jian-dui-ya-ce-you-shi-me-te-shu-chu-li">Q: redis、kafka等中间件对压测有什么特殊处理？</a></li>
<li><a href="#q-ya-ce-jie-shu-shi-ru-he-bi-mian-dui-shu-ju-ku-ji-xu-chan-sheng-ying-xiang">Q: 压测结束时，如何避免对数据库继续产生影响？</a></li>
<li><a href="#q-ya-ce-shu-ju-zen-me-gou-zao-yi-ge-ge-shou-dong-pin-shu-ju-can-shu-ran-hou-rang-ce-shi-tong-xue-fa-song-ma">Q: 压测数据怎么构造？一个个手动拼数据参数，然后让测试同学发送吗？</a></li>
<li><a href="#q-zen-me-wan-zheng-she-ji-zhe-ge-ya-ce-xi-tong-de-jia-gou-bao-han-na-xie-jiao-se">Q: 怎么完整设计这个压测系统的架构？包含哪些角色</a></li>
<li><a href="#q-zen-me-mo-ni-shi-ji-yong-hu-de-qing-qiu-fa-song-yin-wei-shi-ji-chang-jing-ying-gai-shi-duo-ge-bu-tong-ip-de-yong-hu-fang-wen-jin-lai-cai-dui">Q: 怎么模拟实际用户的请求发送？ 因为实际场景应该是多个不同ip的用户访问进来才对。</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<h1><span id="q-wei-shi-me-xu-yao-xian-shang-ya-ce">Q: 为什么需要线上压测？</span><a href="#q-wei-shi-me-xu-yao-xian-shang-ya-ce" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>需要在某些活动、大促前，评估机器扩容数量，验证系统能否有效支撑流量峰值。</li>
<li>线下测试环境的机器资源有限， 无法完全模拟现网。 同时很多配置可能配置不相同，如果没对上导致机器数量估计错误，可能引发重大故事。所以必须要在线上做压测。</li>
</ol>
<hr>
<h1><span id="q-quan-lian-lu-ya-ce-he-jie-kou-ya-ce-de-qu-bie">Q: 全链路压测和接口压测的区别？</span><a href="#q-quan-lian-lu-ya-ce-he-jie-kou-ya-ce-de-qu-bie" class="header-anchor">#</a></h1>
<p>A:<br>
在特定的业务场景下，  将相关的链路完整地串联起来同时施压， 尽可能模拟出真实的用户行为。<br>
接口A做接口压测，可能是1w/s的QPS， 但是A和B同时压测，可能因为数据库连接等共享资源，导致实际QPS下降。</p>
<hr>
<h1><span id="q-ye-wu-xi-tong-ru-he-qu-fen-ya-ce-liu-liang-ji-pan-duan-na-xie-shi-ya-ce-de-qing-qiu-na-xie-shi-zheng-chang-de-qing-qiu">Q: 业务系统如何区分压测流量？即判断哪些是压测的请求，哪些是正常的请求？</span><a href="#q-ye-wu-xi-tong-ru-he-qu-fen-ya-ce-liu-liang-ji-pan-duan-na-xie-shi-ya-ce-de-qing-qiu-na-xie-shi-zheng-chang-de-qing-qiu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>url上加上打标参数，  例如  <a target="_blank" rel="noopener" href="http://xx?st=true">http://xx?st=true</a></li>
<li>hearder中打标</li>
</ol>
<hr>
<h1><span id="q-zhe-ge-ya-ce-da-biao-de-gai-zao-he-gua-pei-yao-zhong-jian-suo-you-fu-wu-can-yu-ma-gai-zao-cheng-ben-hui-bu-hui-you-dian-da">Q: 这个压测打标的改造和适配要中间所有服务参与吗？ 改造成本会不会有点大？</span><a href="#q-zhe-ge-ya-ce-da-biao-de-gai-zao-he-gua-pei-yao-zhong-jian-suo-you-fu-wu-can-yu-ma-gai-zao-cheng-ben-hui-bu-hui-you-dian-da" class="header-anchor">#</a></h1>
<p>A:<br>
不需要全部参与。</p>
<p>如果设计过链路跟踪系统， 则每个服务都有中间件团队提供的拦截器，  因此直接通过公共拦截器来做压测标记的识别。</p>
<hr>
<h1><span id="q-shi-bie-dao-ya-ce-biao-ji-hou-ru-he-bao-zheng-wang-xia-you-fa-qing-qiu-shi-reng-ran-shi-ya-ce-biao-ji-de-xing-shi">Q:   识别到压测标记后， 如何保证往下游发请求时，仍然是压测标记的形式？</span><a href="#q-shi-bie-dao-ya-ce-biao-ji-hou-ru-he-bao-zheng-wang-xia-you-fa-qing-qiu-shi-reng-ran-shi-ya-ce-biao-ji-de-xing-shi" class="header-anchor">#</a></h1>
<p>即发请求的时候已经不是同一段拦截器的代码了。 但是也要保证尽可能不改动原有的业务逻辑代码。</p>
<p>A:<br>
如果处理请求和发下游请求是在一个线程中完成的， 那么可以使用threadLocal。<br>
即拦截到请求时， 将压测标记set进threadLocal中。<br>
发送下游请求的代码中，如果能从threadLocal中拿到压测标记，则改造url，设置进往下发的请求中</p>
<hr>
<h1><span id="q-ru-guo-wo-bu-zai-tong-yi-ge-xian-cheng-zhong-chu-li-he-fa-qing-qiu-zen-me-ban">Q: 如果我不在同一个线程中处理和发请求， 怎么办？</span><a href="#q-ru-guo-wo-bu-zai-tong-yi-ge-xian-cheng-zhong-chu-li-he-fa-qing-qiu-zen-me-ban" class="header-anchor">#</a></h1>
<p>即我的业务代码中 做了new Thread或者ExectorPool.submit提交异步请求， 这时候业务逻辑里肯定不会涉及到threadLocal的代码， 而此时压测标记就会丢失了。</p>
<p>threadLocal可以用 InheriableThreadLocal， 这样如果在线程中new新的线程，则标记可以被传递下来。<br>
如果是线程池创建异步请求， 可以用阿里的TransmittableThreadLocal。</p>
<hr>
<h1><span id="q-ru-guo-wo-de-ya-ce-lian-lu-zhong-bao-han-liao-wai-bu-fu-wu-de-jie-kou-zen-me-ban-li-ru-di-san-fang-zhi-fu-di-san-fang-duan-xin-deng">Q: 如果我的压测链路中 包含了外部服务的接口怎么办？  例如第三方支付、第三方短信等。</span><a href="#q-ru-guo-wo-de-ya-ce-lian-lu-zhong-bao-han-liao-wai-bu-fu-wu-de-jie-kou-zen-me-ban-li-ru-di-san-fang-zhi-fu-di-san-fang-duan-xin-deng" class="header-anchor">#</a></h1>
<p>A:<br>
链路跟踪系统中发请求的filter中， 新增MockFilter，   如果判断是压测请求， 则直接返回mock逻辑（不建议部署mock服务， 因为部署mock服务的话，服务器成本又得考虑，不如直接封装到mockFilter代码中）</p>
<hr>
<h1><span id="q-hui-dui-shu-ju-ku-chan-sheng-ying-xiang-de-ya-ce-qing-qiu-zen-me-ban">Q:  会对数据库产生影响的压测请求怎么办？</span><a href="#q-hui-dui-shu-ju-ku-chan-sheng-ying-xiang-de-ya-ce-qing-qiu-zen-me-ban" class="header-anchor">#</a></h1>
<p>如果直接落库，可能会影响正常用户的请求访问， 也可能污染线上数据。<br>
A:<br>
为每个生产库 生成一个影子库， 专门用来存储压测数据。</p>
<p>然后做过分库分表的话， 肯定有数据库的proxy，在proxy里都往压测库插入和读写。<br>
如果没有，就扩展Spring的AbstactRoutngDataSource类， 实现一个动态的数据源，让里面可以根据压测标记进行切换。</p>
<hr>
<h1><span id="q-redis-kafka-deng-zhong-jian-jian-dui-ya-ce-you-shi-me-te-shu-chu-li">Q: redis、kafka等中间件对压测有什么特殊处理？</span><a href="#q-redis-kafka-deng-zhong-jian-jian-dui-ya-ce-you-shi-me-te-shu-chu-li" class="header-anchor">#</a></h1>
<p>A:<br>
除了添加统一特点的压测标记（中间件和业务不是强相关，所以可以进行特定改造）<br>
还要注意缓存的存活时间要设置短一点。</p>
<hr>
<h1><span id="q-ya-ce-jie-shu-shi-ru-he-bi-mian-dui-shu-ju-ku-ji-xu-chan-sheng-ying-xiang">Q: 压测结束时，如何避免对数据库继续产生影响？</span><a href="#q-ya-ce-jie-shu-shi-ru-he-bi-mian-dui-shu-ju-ku-ji-xu-chan-sheng-ying-xiang" class="header-anchor">#</a></h1>
<p>A:<br>
注意不要触发 数据源的init-method方法， 当真正执行压测的时候再建议会话连接。<br>
各种超期时间也要注意设置， 尽快接触压测对组件的影响。</p>
<hr>
<h1><span id="q-ya-ce-shu-ju-zen-me-gou-zao-yi-ge-ge-shou-dong-pin-shu-ju-can-shu-ran-hou-rang-ce-shi-tong-xue-fa-song-ma">Q:  压测数据怎么构造？一个个手动拼数据参数，然后让测试同学发送吗？</span><a href="#q-ya-ce-shu-ju-zen-me-gou-zao-yi-ge-ge-shou-dong-pin-shu-ju-can-shu-ran-hou-rang-ce-shi-tong-xue-fa-song-ma" class="header-anchor">#</a></h1>
<p>A:<br>
不行，如果业务有改动，参数很容易对不上，同时组装过程耗时也会非常久。</p>
<p>建议从线上直接dump最近的请求数据，这样可保证参数没有变化。<br>
同时做一些脱敏和修正处理。</p>
<hr>
<h1><span id="q-zen-me-wan-zheng-she-ji-zhe-ge-ya-ce-xi-tong-de-jia-gou-bao-han-na-xie-jiao-se">Q: 怎么完整设计这个压测系统的架构？包含哪些角色</span><a href="#q-zen-me-wan-zheng-she-ji-zhe-ge-ya-ce-xi-tong-de-jia-gou-bao-han-na-xie-jiao-se" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>压测manager服务， 提供给压测控制者查看和使用的。可以读取mysql数据库获取压测结果情况，或者进行调度指令的下发等。</li>
<li>taskService服务，用于处理调度指令，执行定时调度、即时调度等行为。</li>
<li>Agent  压测请求发送客户端。根据taskService的指令进行发送</li>
<li>DataFactoy，给agent提供脱敏、修改后的压测数据。</li>
<li>MQ， 接收agent压测请求的结果，堆积到队列里提供给DataCollect消费。</li>
<li>DataCollect， 压测结果消费者， 将结果写入到数据库MYSQL。</li>
<li>注册中心，用于管理和注册上面这些服务。</li>
<li>Detecotr， 流量检测和干预器，可以根据情况即时调整agent的发送速率。</li>
</ol>
<p><img src="/images/%E7%8E%B0%E7%BD%91%E5%8E%8B%E6%B5%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/d86556bb34973167a095a19ee41c491e1fbd6b2f.png" alt="压测设计"></p>
<hr>
<h1><span id="q-zen-me-mo-ni-shi-ji-yong-hu-de-qing-qiu-fa-song-yin-wei-shi-ji-chang-jing-ying-gai-shi-duo-ge-bu-tong-ip-de-yong-hu-fang-wen-jin-lai-cai-dui">Q: 怎么模拟实际用户的请求发送？ 因为实际场景应该是多个不同ip的用户访问进来才对。</span><a href="#q-zen-me-mo-ni-shi-ji-yong-hu-de-qing-qiu-fa-song-yin-wei-shi-ji-chang-jing-ying-gai-shi-duo-ge-bu-tong-ip-de-yong-hu-fang-wen-jin-lai-cai-dui" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>apache HttpComponents的httpclient包</li>
<li>Java11的异步httpclient， 支持HTTP/2， 支持用reactive stream。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">高并发/高压场景处理设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-21 22:30:12 / 修改时间：23:50:48" itemprop="dateCreated datePublished" datetime="2022-09-21T22:30:12+08:00">2022-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/21/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#q-tun-tu-liang-tps-shi-shi-me">Q: 吞吐量（TPS）是什么</a></li>
<li><a href="#q-qps-shi-shi-me">Q: QPS是什么</a></li>
<li><a href="#q-qps-he-tps-de-qu-bie">Q: QPS和TPS的区别？</a></li>
<li><a href="#q-tp-shi-shi-me">Q: TP是什么？</a></li>
<li><a href="#q-jie-kou-fang-wen-liang-guo-da-hui-fa-sheng-shi-me">Q: 接口访问量过大会发生什么？</a></li>
<li><a href="#q-ying-dui-gao-bing-fa-da-liu-liang-you-na-xie-chang-jian-shou-duan">Q: 应对高并发、大流量有哪些常见手段？</a></li>
<li><a href="#q-shi-me-shi-liu-liang-de-lou-dou-mo-xing">Q: 什么是流量的漏斗模型？</a></li>
<li><a href="#q-ru-he-zuo-jie-kou-xian-liu">Q: 如何做接口限流？</a></li>
<li><a href="#q-ru-he-she-ji-yi-ge-xian-shi-qiang-gou-de-gong-neng">Q: 如何设计一个限时抢购的功能</a></li>
<li><a href="#q-ru-he-zai-chan-pin-she-ji-shang-jin-xing-xue-feng">Q: 如何在 产品设计上进行削峰？</a></li>
<li><a href="#q-ru-he-bi-mian-gao-bing-fa-xie-de-chang-jing-xia-de-shu-ju-ku-chao-mai-wen-ti">Q: 如何避免高并发写的场景下的数据库超卖问题</a></li>
<li><a href="#q-ru-guo-ku-cun-chong-zu-wu-lun-duo-shao-de-xie-qing-qiu-du-yi-ci-xing-da-gei-shu-ju-ku-ma-he-xian-shi-qiang-gou-bu-tong-bu-kao-lu-xie-shi-bai">Q: 如果库存充足， 无论多少的写请求都一次性打给数据库吗？（和限时抢购不同，不考虑写失败）</a></li>
<li><a href="#q-watch-de-yuan-li-shi-shi-me">Q: WATCH的原理是什么？</a></li>
<li><a href="#q-redis-xie-cheng-gong-na-shi-me-shi-hou-tong-bu-dao-shu-ju-ku-ni">Q: redis写成功，那什么时候同步到数据库呢？</a></li>
<li><a href="#miao-sha-xi-tong-she-ji-ti">秒杀系统设计题</a>
<ul>
<li><a href="#q-she-ji-yi-ge-miao-sha-xi-tong-da-gai-yao-zai-na-xie-ceng-mian-she-ji">Q: 设计一个秒杀系统大概要在哪些层面设计？</a></li>
<li><a href="#q-liu-lan-qi-ceng-ke-yi-zen-me-lan-jie">Q: 浏览器层可以怎么拦截？</a></li>
<li><a href="#q-zhan-dian-ceng-zen-me-fang-hu">Q: 站点层怎么防护？</a></li>
<li><a href="#q-10w-ge-bu-tong-de-uid-tong-shi-da-ru-zhan-dian-ceng-huan-cun-lan-bu-zhu-liao-dao-fu-wu-ceng-liao-zen-me-ban">Q: 10w个不同的uid同时打入，站点层缓存拦不住了，到服务层了，怎么办？</a></li>
<li><a href="#q-xie-dui-lie-man-liao-zen-me-ban">Q: 写队列满了怎么办？</a></li>
<li><a href="#q-miao-sha-hou-wei-zhi-fu-zen-me-ban">Q: 秒杀后未支付，怎么办？</a></li>
<li><a href="#q-xi-tong-zuo-liao-zhu-cong-du-xie-fen-chi-shi-zen-me-bao-zheng-xie-zhi-hou-neng-ma-shang-du-dao-xin-shu-ju">Q: 系统做了主从读写分离时， 怎么保证写之后能马上读到新数据？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<h1><span id="q-tun-tu-liang-tps-shi-shi-me">Q: 吞吐量（TPS）是什么</span><a href="#q-tun-tu-liang-tps-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。<br>
TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）</p>
<ul>
<li>对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数</li>
<li>对于并发系统而言，有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（因为并发执行，很多资源是交叉使用的）</li>
<li>吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致</li>
</ul>
<hr>
<h1><span id="q-qps-shi-shi-me">Q:   QPS是什么</span><a href="#q-qps-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
(Query Per Second)<br>
每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准<br>
在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p>
<hr>
<h1><span id="q-qps-he-tps-de-qu-bie">Q: QPS和TPS的区别？</span><a href="#q-qps-he-tps-de-qu-bie" class="header-anchor">#</a></h1>
<p>A:<br>
QPS是最大吞吐能力。<br>
TPS是针对单个请求的简单事务处理能力判断。更多是针对单个接口而言。</p>
<hr>
<h1><span id="q-tp-shi-shi-me">Q:  TP是什么？</span><a href="#q-tp-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
响应时间是指系统对请求作出响应的时间。是用户感知的时间，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。</p>
<hr>
<h1><span id="q-jie-kou-fang-wen-liang-guo-da-hui-fa-sheng-shi-me">Q:  接口访问量过大会发生什么？</span><a href="#q-jie-kou-fang-wen-liang-guo-da-hui-fa-sheng-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
服务器可能会崩溃。<br>
服务器对于请求都是排队的，负载不大的时候感觉不到，因为都是1秒内处理了。<br>
当请求数量上去后，就开始有感觉了。继续增大的话，队列会占满了，服务器开始丢弃部分请求<br>
继续增大网络请求，操作系统的TCP协议栈也开始丢弃请求，对外表现为服务器网络也连不上了。<br>
继续增大的话，网卡硬件部分开始满速运行，然后就看操作系统驱动和硬件质量了。<br>
另一种说法：</p>
<blockquote>
<p>当访问量大的时候，后端发送给数据库的请求多，数据库并发读取或写入，受系统io影响，服务器磁盘io是固定的，一般受硬盘硬件读写影响，读写越多，io越高，到达上线就会等待，出现io等待，CPU就会等待，内存也会占用不释放，然后越来越多的请求阻塞，恶性循环，系统资源耗尽，系统崩溃，这也是为什么要提高性能，各种做缓存，从cdn到业务层缓存，代码编译缓存，数据库缓存</p>
</blockquote>
<hr>
<h1><span id="q-ying-dui-gao-bing-fa-da-liu-liang-you-na-xie-chang-jian-shou-duan">Q: 应对高并发、大流量有哪些常见手段？</span><a href="#q-ying-dui-gao-bing-fa-da-liu-liang-you-na-xie-chang-jian-shou-duan" class="header-anchor">#</a></h1>
<p>A:</p>
<ul>
<li>扩容——提升集群并行处理能力</li>
<li>静态化——静态数据由cdn返回</li>
<li>限流</li>
<li>缓存</li>
<li>队列——当上下游处理能力存在差距时，通过队列形成漏斗，等下游有处理能力时自己来消费。</li>
</ul>
<hr>
<h1><span id="q-shi-me-shi-liu-liang-de-lou-dou-mo-xing">Q: 什么是流量的漏斗模型？</span><a href="#q-shi-me-shi-liu-liang-de-lou-dou-mo-xing" class="header-anchor">#</a></h1>
<p>A:<br>
即流量要经过的系统如同漏斗一样， 访问db应当是最少也最后才到达的地方<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/090537a7721ac40dd4fe69719d1d5bcffd1f4eed.png" alt="090537a7721ac40dd4fe69719d1d5bcffd1f4eed"></p>
<hr>
<h1><span id="q-ru-he-zuo-jie-kou-xian-liu">Q:  如何做接口限流？</span><a href="#q-ru-he-zuo-jie-kou-xian-liu" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>对客户端、前端限速，复杂业务操作例如验证码等，或者短时间内限制频繁操作次数上限。</li>
<li>如果自己这个接口是基础接口，被内部调用， 则也要限制内部服务的并发，单纯增加服务A和B的数量，基础服务没跟上，会造成雪崩效应。<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/a2234b6a44085f9193cc95f37579b2e08bc260c1.png" alt="a2234b6a44085f9193cc95f37579b2e08bc260c1"></li>
<li>使用漏桶算法</li>
</ol>
<ul>
<li>不管服务调用多么不稳定，我们只固定进行服务输出，比如每10毫秒接受一次服务调用。既然是一个桶，那就肯定有容量，由于调用的消费速率已经固定，那么当桶的容量堆满了，则只能丢弃了</li>
<li>实现方面，可以先准备一个队列，当做桶的容量，另外通过一个计划线程池（ScheduledExecutorService）来定期从队列中获取并执行请求调用，当然，我们没有限定一次性只能从队里中拿取一个请求，比如可以一次性拿100个请求，然后并发执行</li>
<li>缺点：严格限制的吞吐量，无法响应瞬发性的高峰流量。</li>
</ul>
<ol start="4">
<li>
<p>使用令牌桶算法<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/c6414f5fac5125bfb466e8ac88d122a1e5da66f5.png" alt="c6414f5fac5125bfb466e8ac88d122a1e5da66f5"><br>
生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。<br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/9379516.html">令牌桶源码解读</a></p>
</li>
<li>
<p>计数器算法<br>
在单位时间内， 有一个专门的计数器进行计数， 每请求一次计数器就+1，。 单位时间内如果到达阈值，则后续请求进行限流处理。 只有时间临界点到达后，才会重置，新的请求才能访问。</p>
</li>
</ol>
<p>单位时间计数器可以用redis的setnx实现<br>
要在 10 秒内限定 20 个请求，那么可以在 setnx 的时候设置过期时间 10，当请求的 setnx 数量达到 20 的时候即达到了限流效果。<br>
Redis Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。</p>
<p>也可以用redis的zset实现<br>
将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求</p>
<hr>
<h1><span id="q-ru-he-she-ji-yi-ge-xian-shi-qiang-gou-de-gong-neng">Q:  如何设计一个限时抢购的功能</span><a href="#q-ru-he-she-ji-yi-ge-xian-shi-qiang-gou-de-gong-neng" class="header-anchor">#</a></h1>
<p>例如每个商品都有特定的可抢购次数例如10w， 但是如果同时打进来可能直接导致数据库出现较大的负载压力。</p>
<p>A:<br>
应用层代码里用简单的时间片算法， 某一时间内阈值是1000， 时间到了后就拒绝后面用户的抢购，时间点到了后再允许接收。<br>
同时开发一个接口， 支持动态修改其中的各个参数。</p>
<p>另外如果商品数量过多，每个商品都有阈值， 可能总量会超出， 所以要根据商品总量动态调整每个商品的阈值上限。</p>
<hr>
<h1><span id="q-ru-he-zai-chan-pin-she-ji-shang-jin-xing-xue-feng">Q: 如何在 产品设计上进行削峰？</span><a href="#q-ru-he-zai-chan-pin-she-ji-shang-jin-xing-xue-feng" class="header-anchor">#</a></h1>
<p>A:</p>
<ol>
<li>高流量活动分时段进行， 例如抢购5000个商品，分5个时间段，每个时间段开放1000个。</li>
<li>答题验证，验证码</li>
</ol>
<hr>
<h1><span id="q-ru-he-bi-mian-gao-bing-fa-xie-de-chang-jing-xia-de-shu-ju-ku-chao-mai-wen-ti">Q:  如何避免高并发写的场景下的数据库超卖问题</span><a href="#q-ru-he-bi-mian-gao-bing-fa-xie-de-chang-jing-xia-de-shu-ju-ku-chao-mai-wen-ti" class="header-anchor">#</a></h1>
<p>A:<br>
在Innodb中使用乐观锁来实现写入。<br>
每次写入前先查出商品剩余量和version<br>
调用update的时候加上where version条件， 如果version发生变化，自然就会update失败，于是进行重试。</p>
<p>虽然还是会占行锁， 但是不会造成请求线程阻塞。</p>
<hr>
<h1><span id="q-ru-guo-ku-cun-chong-zu-wu-lun-duo-shao-de-xie-qing-qiu-du-yi-ci-xing-da-gei-shu-ju-ku-ma-he-xian-shi-qiang-gou-bu-tong-bu-kao-lu-xie-shi-bai">Q: 如果库存充足， 无论多少的写请求都一次性打给数据库吗？（和限时抢购不同，不考虑写失败）</span><a href="#q-ru-guo-ku-cun-chong-zu-wu-lun-duo-shao-de-xie-qing-qiu-du-yi-ci-xing-da-gei-shu-ju-ku-ma-he-xian-shi-qiang-gou-bu-tong-bu-kao-lu-xie-shi-bai" class="header-anchor">#</a></h1>
<p>A:<br>
可以使用redis缓存做库存扣减。</p>
<ol>
<li>客户端调用WATCH + （商品id） 这个命令</li>
<li>调用MULTI命令标记事务块的开始</li>
<li>输入写命令。</li>
<li>调用EXEC进行事务提交<br>
如果商品的缓存值在WATCH后被修改了， 则EXEC会失败， redis之后再重试即可。</li>
</ol>
<hr>
<h1><span id="q-watch-de-yuan-li-shi-shi-me">Q: WATCH的原理是什么？</span><a href="#q-watch-de-yuan-li-shi-shi-me" class="header-anchor">#</a></h1>
<p>A:<br>
redis服务端会 维持一个监听key的客户端链表<br>
当key发生变化之后，  这个key对应的客户端会被标记成REDIS_DIRTY_CAS状态<br>
当接收到后面这个客户端的EXEC请求时，就返回执行失败。</p>
<hr>
<h1><span id="q-redis-xie-cheng-gong-na-shi-me-shi-hou-tong-bu-dao-shu-ju-ku-ni">Q: redis写成功，那什么时候同步到数据库呢？</span><a href="#q-redis-xie-cheng-gong-na-shi-me-shi-hou-tong-bu-dao-shu-ju-ku-ni" class="header-anchor">#</a></h1>
<p>A:<br>
将写成功的消息写入雕铣队列， 通过消息队列来实现削峰，确保写入数据库时的流量可控。</p>
<hr>
<h1><span id="miao-sha-xi-tong-she-ji-ti">秒杀系统设计题</span><a href="#miao-sha-xi-tong-she-ji-ti" class="header-anchor">#</a></h1>
<p>秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据</p>
<h2><span id="q-she-ji-yi-ge-miao-sha-xi-tong-da-gai-yao-zai-na-xie-ceng-mian-she-ji">Q: 设计一个秒杀系统大概要在哪些层面设计？</span><a href="#q-she-ji-yi-ge-miao-sha-xi-tong-da-gai-yao-zai-na-xie-ceng-mian-she-ji" class="header-anchor">#</a></h2>
<p>A:<br>
首先考虑重要优化点：</p>
<ol>
<li>将请求尽可能拦截在上游。 因为实际上写操作不会有那么多。</li>
<li>充分利用缓存。因为大部分失败的人都是读操作。<br>
那么基于这2点，设计下面的架构：</li>
<li>浏览器端，最上层，会执行到一些JS代码</li>
<li>站点层，这一层会访问后端数据，拼html页面返回给浏览器(即和浏览器直接交互的）</li>
<li>服务层，向上游屏蔽底层数据细节，提供数据访问（即直接提供数据查询的服务，这里数据实际读取和返回前台响应分成了2个服务）</li>
<li>数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）<br>
<img src="/images/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8E%8B%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1/5e79cd1be7028e577d625127bddb333d9ef76af1.png" alt="5e79cd1be7028e577d625127bddb333d9ef76af1"><br>
各部分优化措施如下：</li>
</ol>
<ul>
<li>浏览器和APP：做限速</li>
<li>站点层：按照uid做限速，做页面缓存</li>
<li>服务层：按照业务做写请求队列控制流量，做数据缓存</li>
<li>数据层：闲庭信步</li>
</ul>
<hr>
<h2><span id="q-liu-lan-qi-ceng-ke-yi-zen-me-lan-jie">Q: 浏览器层可以怎么拦截？</span><a href="#q-liu-lan-qi-ceng-ke-yi-zen-me-lan-jie" class="header-anchor">#</a></h2>
<p>A:<br>
验证码、 短时间内访问次数限制。 分段销售</p>
<hr>
<h2><span id="q-zhan-dian-ceng-zen-me-fang-hu">Q: 站点层怎么防护？</span><a href="#q-zhan-dian-ceng-zen-me-fang-hu" class="header-anchor">#</a></h2>
<p>A:<br>
站点层根据用户id做请求计数， uid只能5秒通过一次。这样可以避免恶意用户频繁用一个uid绕过客户端限制去下单。<br>
同时补充页面缓存。</p>
<hr>
<h2><span id="q-10w-ge-bu-tong-de-uid-tong-shi-da-ru-zhan-dian-ceng-huan-cun-lan-bu-zhu-liao-dao-fu-wu-ceng-liao-zen-me-ban">Q: 10w个不同的uid同时打入，站点层缓存拦不住了，到服务层了，怎么办？</span><a href="#q-10w-ge-bu-tong-de-uid-tong-shi-da-ru-zhan-dian-ceng-huan-cun-lan-bu-zhu-liao-dao-fu-wu-ceng-liao-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
服务层设计一个请求队列，每次只透有限的写请求去数据层<br>
读请求怎么办？ 用数据缓存。cache缓存动态扩容。 热点发现</p>
<hr>
<h2><span id="q-xie-dui-lie-man-liao-zen-me-ban">Q: 写队列满了怎么办？</span><a href="#q-xie-dui-lie-man-liao-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
最坏的情况下，缓存了若干请求之后，后续请求都直接返回“无票”（队列里已经有100w请求了，都等着，再接受请求也没有意义了）</p>
<hr>
<h2><span id="q-miao-sha-hou-wei-zhi-fu-zen-me-ban">Q: 秒杀后未支付，怎么办？</span><a href="#q-miao-sha-hou-wei-zhi-fu-zen-me-ban" class="header-anchor">#</a></h2>
<p>A:<br>
数据库里一个状态，未支付。如果超过时间，例如45分钟，库存会重新会恢复（大家熟知的“回仓”）</p>
<hr>
<h2><span id="q-xi-tong-zuo-liao-zhu-cong-du-xie-fen-chi-shi-zen-me-bao-zheng-xie-zhi-hou-neng-ma-shang-du-dao-xin-shu-ju">Q: 系统做了主从读写分离时， 怎么保证写之后能马上读到新数据？</span><a href="#q-xi-tong-zuo-liao-zhu-cong-du-xie-fen-chi-shi-zen-me-bao-zheng-xie-zhi-hou-neng-ma-shang-du-dao-xin-shu-ju" class="header-anchor">#</a></h2>
<p>A:<br>
用切面的方式做注解<br>
通过注解判断哪些请求走主库，哪些请求走从库<br>
例如有些场景写之后马上就读的概率很高，那就走主库<br>
如果有些场景对读的实时性要求不高，那就从走从库<br>
或者用一些mycat中间件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-20 23:12:42" itemprop="dateCreated datePublished" datetime="2022-09-20T23:12:42+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 00:10:51" itemprop="dateModified" datetime="2022-09-21T00:10:51+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">算法大全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/20/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95%E5%A4%A7%E5%85%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#1-4-de-si-kao-tao-lu">1+4的思考套路</a>
<ul>
<li><a href="#jian-dan-li-zi">简单例子</a>
<ul>
<li><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</a></li>
<li><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</a></li>
<li><a href="#ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</a></li>
<li><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</a></li>
<li><a href="#bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</a></li>
<li><a href="#shi-xian">实现</a></li>
</ul>
</li>
<li><a href="#jin-jie-ban-er-wei-de-dong-tai-gui-hua">进阶版，二维的动态规划</a>
<ul>
<li><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi-1">①在超时的思路上写出一组计算过程的例子</a></li>
<li><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang-1">②在超时例子的基础上，有哪些重复、浪费的地方？</a></li>
<li><a href="#ru-he-ding-yi-dp-shu-zu-1">③如何定义dp数组？</a></li>
<li><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de-1">④状态的变化方向是什么，是怎么变化的</a></li>
<li><a href="#bian-jie-zhuang-tai-shi-shi-me-1">⑤边界状态是什么？</a></li>
<li><a href="#shi-xian-1">实现</a></li>
<li><a href="#nei-cun-yi-chu-chu-li">内存溢出处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#qi-ta-lei-si-ti-mu-lian-xi">其他类似题目练习</a></li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<p>以后不定期更新一些算法方便自己的思考和总结。</p>
<hr>
<p>平时练习算法题学习算法知识时，经常会发现题解里写着“动态规划”，里面一上来就是一个复杂的dp公式，对于新人来说除了说声<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(144).png" alt="image.png"></p>
<p>剩下就是疑惑，他是怎么想到这个公式的？我能想到吗？这玩意工作中有用吗？<br>
加上“动态规划”这高端的名字，然后就劝退了不少试图去理解他的人。<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(145).png" alt="image.png"></p>
<p>动态规划听起来太吓人，可以换个说法</p>
<p>我在内心更喜欢叫他“状态缓存”<br>
如果是服务开发，相信很熟悉这个词语， 利用缓存来加快一些重复的请求的响应速度。<br>
而这个缓存的特点是 <em><strong>和其他缓存有所关联。</strong></em></p>
<p>比如我们的服务要计算7天内的某金钱总和，计算后要缓存一下。<br>
后来又收到一个请求，要计算8天内的金钱总和<br>
那我们只需要取之前算过的7天内的金钱综合，加上第8天的金钱就行了。</p>
<h1><span id="1-4-de-si-kao-tao-lu">1+4的思考套路</span><a href="#1-4-de-si-kao-tao-lu" class="header-anchor">#</a></h1>
<p>自己针对动态规划总结了一个自己的思考套路，我叫他1组例子4个问题，就叫1+4好了，通过这5个过程，可以站在普通人的角度（就是非acm大佬那种的角度），去理解动态规划是如何被思考出来的</p>
<ul>
<li>在超时的思路上写出一组计算过程的例子</li>
<li>在超时例子的基础上，有哪些重复、浪费的地方？</li>
<li>如何定义dp数组</li>
<li>状态的变化方向是什么，是怎么变化的</li>
<li>边界状态是什么</li>
</ul>
<h2><span id="jian-dan-li-zi">简单例子</span><a href="#jian-dan-li-zi" class="header-anchor">#</a></h2>
<p>以一道简单题为例：<br>
爬楼梯：<br>
<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(146).png" alt="image.png"></p>
<p>这时候就要静下心，观察这个解法的例子中是否有重复经历的场景，而这个重复经历的场景就叫状态。<br>
我处理动态规划的题目时， 都会问自己3个问题，一般就能顺利地解决。</p>
<h3><span id="zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</span><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi" class="header-anchor">#</a></h3>
<p>如果我们考虑最简单的解法，  就是从起点开始，每次选择走1步或者走2步，看下能否走到终点，能走到则方法数+1。<br>
但这种方法注定超时（O（n^2)）<br>
但我还是照着这个过程模拟了一下，随便列了几个<br>
1 -&gt;2-&gt; 3-&gt; 4-&gt; 5<br>
1 -&gt;2 -&gt;3-&gt; 5<br>
1-&gt;3-&gt;4-&gt;5<br>
1-&gt;3-&gt;5</p>
<h3><span id="zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</span><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang" class="header-anchor">#</a></h3>
<p>在上面，我发现了重复的地方<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(147).png" alt="image.png"></p>
<p>也就是说<br>
从3到5总共就2种路线，已经在1-&gt;2之后计算过了，我后面从1走到3再往后走时，没必要再去算了。<br>
换言之，当我走到3的时候，其实早就可以知道后面还剩下多少种走法。<br>
发现重复的地方后，就可以开始建立dp公式了。</p>
<h3><span id="ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</span><a href="#ru-he-ding-yi-dp-shu-zu" class="header-anchor">#</a></h3>
<p>定义dp数组，也就是定义上面提到的重复的地方。重新看下之前的那句话<br>
当我走到3的时候，其实早就可以知道后面还剩下多少种走法。<br>
所以dp[3]代表的就是从3往后，有多少种可走的方法。</p>
<h3><span id="zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</span><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de" class="header-anchor">#</a></h3>
<ul>
<li>首先思考状态的变化方向<br>
重新看这句话：</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>当我走到3的时候，其实早就可以知道后面还剩下多少种走法</p>
</blockquote>
</blockquote>
</blockquote>
<p>说明结果取决于往 <em><strong>后面</strong></em> 的状态<br>
因此我们要先计算后面的状态, 即从后往前算</p>
<ul>
<li>接着思考这个后面的状态和当前的状态有什么联系，是怎么变化的</li>
</ul>
<p>这个一般都包含在题目条件中<br>
根据题意，要么走2步，要么走1步，因此每当我走到一层时，下一次就2种状态可以变化。<br>
那么对于第3层而言，他后续有2种走法，走1步或者走2步<br>
那么他的情况就是dp[3] = dp[3+1] + dp{3+2}<br>
如果层数设为i，那么这个变化情况就是<br>
dp[i] = dp[i+1] + dp[i+2]</p>
<h3><span id="bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</span><a href="#bian-jie-zhuang-tai-shi-shi-me" class="header-anchor">#</a></h3>
<p>边界状态就是不需要依赖后面的状态了，直接可以得到结果的状态。<br>
在这里肯定就是最后一层dp[n]， 最后一层默认是一种走法。 dp[n]=1</p>
<h3><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h3>
<p>根据上面的过程，自己便定义了这个状态和变化</p>
<ul>
<li>定义：dp[i] :  代表从第i层往后，有多少种走法</li>
<li>方向和变化：dp[i] =  dp[i+1] + dp[i+2];</li>
<li>边界:  dp[n] = 1<br>
根据这个写代码就很容易了<br>
代码：</li>
</ul>
<pre><code class="language-java">    public int climbStairs(int n) &#123;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n-1] = 1;
        for(int i = n-2; i &gt;=0;i--) &#123;
            dp[i] = dp[i+1] + dp[i+2];
        &#125;
        return dp[0];
    &#125;
</code></pre>
<h2><span id="jin-jie-ban-er-wei-de-dong-tai-gui-hua">进阶版，二维的动态规划</span><a href="#jin-jie-ban-er-wei-de-dong-tai-gui-hua" class="header-anchor">#</a></h2>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/</a></p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(148).png" alt="image.png"></p>
<h3><span id="zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi">①在超时的思路上写出一组计算过程的例子</span><a href="#zai-chao-shi-de-si-lu-shang-xie-chu-yi-zu-ji-suan-guo-cheng-de-li-zi" class="header-anchor">#</a></h3>
<p>超时的思路肯定是像搜索一样模拟所有的行走过程。<br>
先假设1个steps=5, arrlen=3的情况<br>
随便先列几个。模拟一下不断走的位置。数字指的是当前位置。<br>
0-&gt;1-&gt;2-&gt;1-&gt;0-&gt;0<br>
0-&gt;1-&gt;2-&gt;1-&gt;1-&gt;0<br>
0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0<br>
0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;0<br>
0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0<br>
……</p>
<h3><span id="zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang">②在超时例子的基础上，有哪些重复、浪费的地方？</span><a href="#zai-chao-shi-li-zi-de-ji-chu-shang-you-na-xie-chong-fu-lang-fei-de-di-fang" class="header-anchor">#</a></h3>
<p>0-&gt;1-&gt;2-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
0-&gt;1-&gt;2-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;1-&gt;1-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;1-&gt;1-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
0-&gt;0-&gt;1-&gt;<em><strong>1-&gt;1-&gt;0</strong></em><br>
0-&gt;0-&gt;1-&gt;<em><strong>1-&gt;0-&gt;0</strong></em><br>
我发现这部分标粗的部分重复了，<br>
换句话说<br>
当我还剩2步且当前位置为1的时候，后面还有多少种走法，其实早就知道了。</p>
<h3><span id="ru-he-ding-yi-dp-shu-zu">③如何定义dp数组？</span><a href="#ru-he-ding-yi-dp-shu-zu" class="header-anchor">#</a></h3>
<p>重新看这句话：</p>
<blockquote>
<blockquote>
<blockquote>
<p>当我还剩2步且当前位置为1的时候，后面还有多少种走法，其实早就知道了。</p>
</blockquote>
</blockquote>
</blockquote>
<p>涉及了2个关键因素: 剩余步数和当前值，所以得用二维数组<br>
因此<br>
dp[realstep][index]<br>
就代表了  剩余步数为step且位置为index时， 后续还剩多少种走法。</p>
<h3><span id="zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de">④状态的变化方向是什么，是怎么变化的</span><a href="#zhuang-tai-de-bian-hua-fang-xiang-shi-shi-me-shi-zen-me-bian-hua-de" class="header-anchor">#</a></h3>
<ul>
<li>先思考变化方向<br>
“当我还剩2步且当前位置为1的时候，<em><strong>后面</strong></em> 还有多少种走法，其实早就知道了。”</li>
</ul>
<p>这个后面是指啥， 后面会怎么变?<br>
后面肯定是步数越来越少的情况， 并且位置会根据规律变化。 所以变化方向是步数变少，位置则按照规定去变。<br>
那么这个固定越来越少的这个“剩余步数”，就是核心的变化方向<br>
我们计算时，可以先计算小的剩余步数的状态， 再去算大的剩余步数。</p>
<ul>
<li>如何变化<br>
根据题意和方向，剩余步数肯定-1，  然后位置有3种选择（减1，不变，加1）， 那么方法就是3种选择的相加<br>
dp[step][index] = dp[step-1][index-1] + dp[step-1][index] + dp[step-1][index+1]</li>
</ul>
<h3><span id="bian-jie-zhuang-tai-shi-shi-me">⑤边界状态是什么？</span><a href="#bian-jie-zhuang-tai-shi-shi-me" class="header-anchor">#</a></h3>
<p>剩余步数为0时，只有当前位置为0才是我们最终想要的方案，把值设为1并提供给后面用，其他位置且步数为0时都认为是0。<br>
dp[0][0] = 1；<br>
dp[0][index] = 0；（index&gt;0)</p>
<h3><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h3>
<p>那么最终出来了</p>
<ul>
<li>定义：dp{realstep][index]:    剩余步数为step且位置为index时， 后续还剩多少种走法。</li>
<li>方向和变化：dp[step][index] = dp[step-1][index-1] + dp[step-1][index] + dp[step-1][index+1]</li>
<li>边界:  dp[0][0] = 1；</li>
</ul>
<h3><span id="nei-cun-yi-chu-chu-li">内存溢出处理</span><a href="#nei-cun-yi-chu-chu-li" class="header-anchor">#</a></h3>
<p>不过这题因为是困难题，所以给上面这个公式设立了一个小难度：<br>
<img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image(149).png" alt="image.png"></p>
<p>数组长度非常大，导致如果index的范围我们选择为0~arrLen-1, 那么最大情况dp[500][10^6]注定超时内存范围。<br>
这时候就要去思考index设那么大是不是没必要<br>
一般我们可以自己列这种情况的小例子，例如<br>
step=2, arr=10<br>
然后看下index有没有必要设成0~9，随便走几步<br>
0-&gt;1-&gt;0<br>
0-&gt;1-&gt;0<br>
0-&gt;0-&gt;0<br>
嗯？我发现就3种情况，arr后面那么长不用啦？<br>
于是发现规律：<br>
剩余的步数，必须支撑他返回原点！<br>
也就是说，其实index的最大范围最多就是step/2， 不能再多了，再多肯定回不去了。<br>
于是问题解决。</p>
<h1><span id="qi-ta-lei-si-ti-mu-lian-xi">其他类似题目练习</span><a href="#qi-ta-lei-si-ti-mu-lian-xi" class="header-anchor">#</a></h1>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/">https://leetcode-cn.com/problems/minimum-cost-for-tickets/</a></p>
<hr>
<p>状态压缩的位dp，尽量从0往上更新，往后面看而不是往前面看</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集 - 力扣（LeetCode）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://breakdawncoder.com/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="破晓的知识屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">微服务心跳管理机制设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">

              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-19 23:40:12 / 修改时间：23:25:44" itemprop="dateCreated datePublished" datetime="2022-09-19T23:40:12+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">后台开发知识</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/19/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">
<!-- toc -->
<ul>
<li><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</a>
<ul>
<li><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</a></li>
<li><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</a></li>
<li><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</a></li>
<li><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</a></li>
</ul>
</li>
<li><a href="#ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</a>
<ul>
<li><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</a></li>
<li><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div> 
<p>[toc]</p>
<hr>
<p>笔记来源：<br>
<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/240656">实战：单机如何实现管理百万主机的心跳服务</a></p>
<h1><span id="ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu">基于LRU实现百万级别的心跳监控服务</span><a href="#ji-yu-lru-shi-xian-bai-wan-ji-bie-de-xin-tiao-jian-kong-fu-wu" class="header-anchor">#</a></h1>
<h2><span id="1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi">1. Q: 百万级别节点，如何快速找到离线的节点？（非数据库存储模式）</span><a href="#1-q-bai-wan-ji-bie-jie-dian-ru-he-kuai-su-zhao-dao-chi-xian-de-jie-dian-fei-shu-ju-ku-cun-chu-mo-shi" class="header-anchor">#</a></h2>
<p>全部遍历找超时，O(n)， 百万级别节点消耗非常大，   遍历时可能会因为涉及更新的同步问题， 导致此时无法插入。<br>
如果用单线程，这个过程慢的话会造成阻塞。</p>
<p>实现方式1： LRU+链表+哈希表<br>
① 所有心跳放进一个LRU队列中，保证最新的心跳包在队尾，最老的心跳包在队头。<br>
② 如果某节点有新的心跳包进来， 利用哈希表找到这个节点的链点位置，删除掉，再将新包插入到队尾。<br>
③ 每次心跳检查时， 只要查询队头， 不断将超时的心跳包出队，直到队头的心跳包不超时即可。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/ee76fb4d7bfd65d2190dbadd7760c7f312f74079.png" alt="ee76fb4d7bfd65d2190dbadd7760c7f312f74079"><br>
实现方式2： 时间轮，时间轮的做法见最后</p>
<h2><span id="2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing">2. Q: 如何保证心跳服务的可靠性？</span><a href="#2-q-ru-he-bao-zheng-xin-tiao-fu-wu-de-ke-kao-xing" class="header-anchor">#</a></h2>
<p>上面提到的心跳检查都在内存中，  心跳检查节点如果只有1个的话不可靠，而且量级也会很大。<br>
但又不能落盘，这会导致数据库的并发查询压力很大，且数据库自身的可靠性又会成了问题。</p>
<p>解决方式：<br>
分布式处理。<br>
心跳入口网关 根据节点的ip或者节点id做哈希， 确保相同节点的心跳包发往同一个节点。<br>
如果网关发现某个节点挂了，利用哈希一致算法更新发送的节点即可。</p>
<h2><span id="3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng">3. Q: 如何提升单个心跳服务节点的心跳接收性能？</span><a href="#3-q-ru-he-ti-sheng-dan-ge-xin-tiao-fu-wu-jie-dian-de-xin-tiao-jie-shou-xing-neng" class="header-anchor">#</a></h2>
<p>收到心跳后， 涉及心跳的解包，LRU+哈希更新，需要提升处理性能。</p>
<p>①  多线程处理， 同样利用上面的方法做哈希，分配到特定的心跳处理线程，不同线程之间处理的节点信息不会互相干扰。</p>
<blockquote>
<blockquote>
<p>注意点：  缓存队列放到各自的工作线程中。 即push而非pull的方式，尽可能避免N之间的竞争，即只做1+1的竞争。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8.png" alt="68d6f3d4595ec0a8c74566349c25dda9fb4bb3f8"><br>
队列锁采用自旋锁，避免工作线程频繁出现上下文切换（即保证工作线程一直在跑，这个用于高并发场景，高并发场景不能让他停下来的）</p>
</blockquote>
</blockquote>
<p>② 心跳包资源池减少内存释放频率<br>
如果只有10w个节点，那么每次收到心跳请求时，不要反复new新的心跳对象，而是从心跳资源池里取出构造好的对象，把最新时间set进去后再扔给分发线程。</p>
<h2><span id="4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp">4. 心跳包选用TCP还是UDP？</span><a href="#4-xin-tiao-bao-xuan-yong-tcp-huan-shi-udp" class="header-anchor">#</a></h2>
<p>满足以下条件的话选择UDP:</p>
<ol>
<li>心跳包报文长度内容信息量很少，基本小于MTU， 不需要利用TCP自带的分包机制。</li>
<li>超时判断时间允许偶然一次的不可靠丢包（即偶尔丢一次并不影响）</li>
</ol>
<p>这种情况用UDP在网内发到心跳服务即可。<br>
不需要TCP那样的高消耗。</p>
<h1><span id="ling-yi-ge-fang-shi-shi-jian-lun">另一个方式：时间轮</span><a href="#ling-yi-ge-fang-shi-shi-jian-lun" class="header-anchor">#</a></h1>
<p>参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0f0fec47a0ad">TimingWheel 时间轮详解</a></p>
<p>时间轮本质：</p>
<ol>
<li>弄一个数组（看起来是一个环，实际上是数组）</li>
<li>数组中中每个节点又存了一个双向链表，用于存放实际的任务（用链表是为了方便插入）</li>
<li>任务具体放数组中的哪个位置？  根据 超期时间取余决定他的实际存放位置。</li>
<li>如果数组的节点中有任务，会把本身的超期时间带着一起扔进一个 队列中</li>
<li>队列每次取队头数据， 如果时间没到队头节点指定的延迟时间，就阻塞，直到时间到达，取出里面的任务逐个执行。</li>
<li>如果任务的定时时间超过整个环的时间？  则新增一个时间轮，时间比这个更长，因此队列里可能会多插入一个节点，节点中会标识我是小时间轮还是大时间轮的。<br>
<img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1/2e95b497a970bc8baad42f25d6dee04d0241a079.png" alt="2e95b497a970bc8baad42f25d6dee04d0241a079"></li>
</ol>
<hr>
<p>其他的延时队列怎么做的?<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/woniu211111/article/details/109302412">延时队列实现的几种姿势</a></p>
<hr>
<h2><span id="q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma">Q: java的DelayQueue类原理知道吗？</span><a href="#q-java-de-delayqueue-lei-yuan-li-zhi-dao-ma" class="header-anchor">#</a></h2>
<p>A:</p>
<ol>
<li>有一个优先队列， 放入的任务会根据是否快要超期进行排序， 马上就要超期的会放在队头。</li>
<li>当使用take方法取数据时，看一下队头任务，如果时间到了就返回。</li>
<li>如果时间还没到</li>
</ol>
<ul>
<li>首先看一下是否已经有线程在等待这个任务了，如果是的话，使用锁的condition机制做await等待。</li>
<li>如果没有线程正在等待，就计算还差多少时间， 然后用 LockSupport.parkNanos()让这个调用take方法的线程等待特定时间。</li>
</ul>
<ol start="4">
<li>注意等待期间，会释放锁，因此这期间可以正常offer和take。</li>
<li>当时间到了后，这个线程肯定能取走数据了。  取完后，顺便看一下队列里还有没有数据，如果有， 调用condition.signal()，通知那堆正在等待的线程， 你们可以试着竞争一下取数据了。</li>
<li>另外每当有新的任务offer时，如果发现最新入队的数据就是马上要超期的数据， 也会立刻通知等待的各位马上苏醒竞争（因为之前等待的线程认为自己还要睡一会才会有数据）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/105716205">Java阻塞延迟队列DelayQueue原理及使用</a></p>
<hr>
<h2><span id="q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie">Q: 时间轮和   java的delayQueue）有什么区别？</span><a href="#q-shi-jian-lun-he-java-de-delayqueue-you-shi-me-qu-bie" class="header-anchor">#</a></h2>
<p>A:<br>
java的delayQueue本质上是用堆（优先队列）实现的。<br>
接收任务后， 直接把任务放进优先队列中， 按照超期时间确定堆位置。  每次poll时如果发现堆顶没到时间就阻塞，直到时间到了再poll。<br>
取出来检查后，再加上时间扔回队列。</p>
<p>坏处： 插入和删除的复杂度是O(logn)。</p>
<p>而时间轮并不会把任务扔进 queue中，而是把时间轮的槽扔进queue中。  因此整个延迟队列实际上时针对槽的，不需要堆，按先入先出取数据和插槽即可，O(1)的复杂度。  而后面扔进来的任务，都是往槽里的双向链表塞进去而已。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://breakdawncoder.com/images/%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0/1660493655011.png" title="Genshin-UID → http:&#x2F;&#x2F;breakdawncoder.com&#x2F;images&#x2F;%E5%8E%9F%E7%A5%9E%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0&#x2F;1660493655011.png"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共290k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
