<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:type" content="website">
<meta property="og:title" content="冲破黎明前的黑暗">
<meta property="og:url" content="http://example.com/home/index.html">
<meta property="og:site_name" content="冲破黎明前的黑暗">
<meta property="og:description" content="君子终日乾乾,夕惕若厉,无咎">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="breakDawn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/home/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>冲破黎明前的黑暗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">冲破黎明前的黑暗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/" class="post-title-link" itemprop="url">java常见容器使用原理（Map\List等)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-07 23:29:15 / 修改时间：23:46:25" itemprop="dateCreated datePublished" datetime="2022-07-07T23:29:15+08:00">2022-07-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/07/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>[toc]</p>
 <div class="toc">

<!-- toc -->

<ul>
<li><a href="#arraylist">ArrayList</a></li>
<li><a href="#copyonwritearraylist-yuan-li">CopyOnWriteArrayList 原理</a><ul>
<li><a href="#wei-shi-me-xu-yao-xie-shi-fu-zhi">为什么需要写时复制？</a></li>
<li><a href="#ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu">如何避免多线程修改的冲突？</a></li>
<li><a href="#ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian">如何保证更新后，数组引用的变动能及时对外呈现？</a></li>
</ul>
</li>
<li><a href="#hashmap-he-xin-yuan-li">HashMap核心原理</a><ul>
<li><a href="#hashmap-wan-zheng-de-put-guo-cheng">hashMap完整的put过程</a></li>
<li><a href="#hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie">hashMap的扩容过程，java7和8扩容的区别</a></li>
<li><a href="#wei-shi-me-java8-yao-gai-cheng-wei-cha-fa">为什么java8要改成尾插法？</a></li>
<li><a href="#sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me">虽然解决了死循环问题， 但java8的hashMap仍然是线程不安全的，为什么？</a></li>
<li><a href="#ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni">具体到底满足什么情况，才会resize扩容呢？</a></li>
<li><a href="#kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni">扩容后，capacity扩容多少倍呢？</a></li>
</ul>
</li>
<li><a href="#concurrenthashmap-he-xin-yuan-li">ConcurrentHashMap 核心原理</a></li>
</ul>
<!-- tocstop -->

</div> 



<h1><span id="arraylist">ArrayList</span><a href="#arraylist" class="header-anchor">#</a></h1><p>Q: 讲一下啊arrayList的扩容原理？<br>A:<br>比较简单，算出新容量后，直接Arrays.copy拷贝到新数组，搞定<br> <img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/c0f46fd3dbc58ac475051f1102dd4c43f80fc8e0.png" alt="c0f46fd3dbc58ac475051f1102dd4c43f80fc8e0"> </p>
<p>扩容容量= 原容量 + (原容量右移1位，即0.5倍)= 1.5倍<br> <img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/395ae953519c9a0a9cba440644a6d8dd4999db66.png" alt="395ae953519c9a0a9cba440644a6d8dd4999db66"> </p>
<hr>
<p>Q: arrayList的初始最大容量是多少？可以更改吗？<br>A:<br>初始容量为10。不可修改<br> <img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/11f8400ec134b045dae9118f28877a284924b1c3.png" alt="11f8400ec134b045dae9118f28877a284924b1c3"> </p>
<h1><span id="copyonwritearraylist-yuan-li">CopyOnWriteArrayList 原理</span><a href="#copyonwritearraylist-yuan-li" class="header-anchor">#</a></h1><p>就是一个写时复制列表</p>
<p>当发生“删除/修改/新增”时，会先新建一个数组，更新后的数据拷贝到数组中</p>
<p>最后再更新到CopyOnWriteArrayList的数组成员引用上。</p>
<h2><span id="wei-shi-me-xu-yao-xie-shi-fu-zhi">为什么需要写时复制？</span><a href="#wei-shi-me-xu-yao-xie-shi-fu-zhi" class="header-anchor">#</a></h2><p>针对多线程环境下，读多写少的情况，如果每个读都加线程同步，太浪费了</p>
<p>因此可以读的时候不加锁</p>
<p>只有写的时候加锁，写完更新</p>
<p>读的时候可能会有点延迟的数据，但不影响。</p>
<h2><span id="ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu">如何避免多线程修改的冲突？</span><a href="#ru-he-bi-mian-duo-xian-cheng-xiu-gai-de-chong-tu" class="header-anchor">#</a></h2><p>加了一个sync锁，修改动作是线程安全的。</p>
<h2><span id="ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian">如何保证更新后，数组引用的变动能及时对外呈现？</span><a href="#ru-he-bao-zheng-geng-xin-hou-shu-zu-yin-yong-de-bian-dong-neng-ji-shi-dui-wai-cheng-xian" class="header-anchor">#</a></h2><p>数组成员设置成volatile</p>
<h1><span id="hashmap-he-xin-yuan-li">HashMap核心原理</span><a href="#hashmap-he-xin-yuan-li" class="header-anchor">#</a></h1><h2><span id="hashmap-wan-zheng-de-put-guo-cheng">hashMap完整的put过程</span><a href="#hashmap-wan-zheng-de-put-guo-cheng" class="header-anchor">#</a></h2><ol>
<li>首先，要获取key的哈希值。<br>如果为空，就统一是0<br>否则，调用对象的.hashCode()方法，接着再与自己的右移16位进行异或，以便充分利用高位信息。</li>
<li>接着判断内部node数组是否为空，如果是，先进行初始化扩容。默认为16。</li>
<li>根据(n-1)&amp;hash值，获取哈希表索引位置。 （&amp;的性能比取余要高,具体讨论见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21070971">CPU取余原理</a>）</li>
<li>哈希表的node数组中，存放的是每组链表的头节点。<br>先检查头节点是否和自己要存放的key完全匹配 （hash值相同，key值相同，先hash再key，是因为hash的判断简单，key的equals判断可能会复杂）<br>如果匹配，得到需要替换的节点。</li>
<li>头节点和自己要放的key不匹配，则判断一下这个头节点是否是红黑树节点，如果是，说明已经升级成红黑树了，调用putTree插入到红黑树中。</li>
<li>如果不是红黑树， 那就是遍历链表，完全匹配就得到需要替换的节点。如果到尾部了，也没匹配的，则插入新节点。</li>
<li>如果前面找到了要替换的节点，则判断一下是否可以替换（是否没要求putIfAbsent，或者value为null），是就替换，不是就结束</li>
<li>如果前面是插入了新节点，非替换， 则要modCount++（方便迭代器确认map是否更新），  同时++size， 然后和扩容阈值做判断， 如果太大，就resize进行扩容<br><img src="/images/java%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%88Map-List%E7%AD%89%EF%BC%89/61d85897f346fb06cb884b84.png" alt="hashMap-put详解"></li>
</ol>
<hr>
<h2><span id="hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie">hashMap的扩容过程，java7和8扩容的区别</span><a href="#hashmap-de-kuo-rong-guo-cheng-java7-he-8-kuo-rong-de-qu-bie" class="header-anchor">#</a></h2><ol>
<li>java7：</li>
</ol>
<ul>
<li>当resize时，新建一个数组newTable</li>
<li>遍历原table中的每个链表和节点，重新hash，找到新的位置放入</li>
<li>放入的方式是头插法，即始终插在链表的头节点。</li>
</ul>
<ol start="2">
<li>java8:</li>
</ol>
<ul>
<li>不再每个点rehash放置，而是最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标. 避免了频繁的哈希计算和搬移过程。</li>
<li>使用尾插法在链表上插入节点</li>
<li>桶内元素超过8个，链表转成红黑树</li>
</ul>
<hr>
<h2><span id="wei-shi-me-java8-yao-gai-cheng-wei-cha-fa">为什么java8要改成尾插法？</span><a href="#wei-shi-me-java8-yao-gai-cheng-wei-cha-fa" class="header-anchor">#</a></h2><p>A:<br>多线程时，java7的map-put可能造成死循环。<br>A线程扩容到那一半， 还处在遍历链表做头插法搬移的过程时，存了2个局部变量，当前链点now指向a， next指向b，正准备搬移（a-&gt;b-&gt;c这样的链表，a是头节点）</p>
<p>B线程则同时完成线程扩容，但是map里都是引用，浅拷贝，** 因为是头插法， 会导致顺序变化**， 原本a-&gt;b-&gt;c 变成了c-&gt;b-&gt;a。<br>因此A恢复时， 链点还是a，next还是b， 于是往下走到了b， 取bbs的next时，已经变成了a， 于是发生了a-&gt;b-&gt;a的循环<br>导致后续操作的next都是错误操作，引发环形指针。</p>
<p>java8里改成尾插法，这样做resize时，a-&gt;b-&gt;c 如果仍然哈希到同一个节点， 顺序是不会发生变化的。</p>
<hr>
<h2><span id="sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me">虽然解决了死循环问题， 但java8的hashMap仍然是线程不安全的，为什么？</span><a href="#sui-ran-jie-jue-liao-si-xun-huan-wen-ti-dan-java8-de-hashmap-reng-ran-shi-xian-cheng-bu-an-quan-de-wei-shi-me" class="header-anchor">#</a></h2><p>A:<br>因为缺乏同步，导致同节点发生哈希碰撞时，if条件的判断都可能是有问题的，导致本该插在链表头节点后面的，结果直接作为链表头覆盖到数组上了。</p>
<hr>
<h2><span id="ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni">具体到底满足什么情况，才会resize扩容呢？</span><a href="#ju-ti-dao-di-man-zu-shi-me-qing-kuang-cai-hui-resize-kuo-rong-ni" class="header-anchor">#</a></h2><p>A:<br>　HashMap负载因子 LoadFactor，默认值为0.75f。<br>　衡量HashMap是否进行Resize的条件如下：<br>　HashMap.Size &gt;= Capacity * LoadFactor</p>
<p>另一种情况。JDK1.8源码中，执行树形化之前，会先检查数组长度，如果长度小于64，则对数组进行扩容，而不是进行树形化</p>
<hr>
<h2><span id="kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni">扩容后，capacity扩容多少倍呢？</span><a href="#kuo-rong-hou-capacity-kuo-rong-duo-shao-bei-ni" class="header-anchor">#</a></h2><p>A:<br>哈希表每次扩容是两倍</p>
<h1><span id="concurrenthashmap-he-xin-yuan-li">ConcurrentHashMap 核心原理</span><a href="#concurrenthashmap-he-xin-yuan-li" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_18300037/article/details/123795776">https://blog.csdn.net/qq_18300037/article/details/123795776</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/every__day/article/details/114293107">https://blog.csdn.net/every__day/article/details/114293107</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">hexo-next主题使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-06 23:27:35 / 修改时间：23:29:45" itemprop="dateCreated datePublished" datetime="2022-07-06T23:27:35+08:00">2022-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">博客搭建</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/06/%E9%9A%8F%E7%AC%94/hexo-next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2><span id="chang-yong-xin-wen-zhang-tou-bu-nei-rong">常用新文章头部内容：</span><a href="#chang-yong-xin-wen-zhang-tou-bu-nei-rong" class="header-anchor">#</a></h2><p>title: java类文件原理<br>date: 2022-05-04 22:25:40<br>tags: java<br>categories:<br>    - [java,java高级原理]<br>typora-root-url: ........</p>
<p>title: 第296场周赛-209名<br>categories:</p>
<ul>
<li><ul>
<li>编程</li>
<li>力扣周赛记录<br>tags: ‘算法’<br>typora-root-url: ../../../<br>date: 2022-06-05 22:12:42</li>
</ul>
</li>
</ul>
<h1><span id="kai-qi-ben-di-fu-wu">开启本地服务</span><a href="#kai-qi-ben-di-fu-wu" class="header-anchor">#</a></h1><p>hexo server<br>hexo s</p>
<h5><span id="xin-jian-wen-zhang">新建文章</span><a href="#xin-jian-wen-zhang" class="header-anchor">#</a></h5><p>hexo new a</p>
<h5><span id="xin-jian-cao-gao">新建草稿</span><a href="#xin-jian-cao-gao" class="header-anchor">#</a></h5><p>hexo new draft b</p>
<h5><span id="fa-bu-cao-gao-cheng-wei-wen-zhang">发布草稿成为文章</span><a href="#fa-bu-cao-gao-cheng-wei-wen-zhang" class="header-anchor">#</a></h5><p>hexo publish b</p>
<h5><span id="fa-bu-guan-yu">发布关于</span><a href="#fa-bu-guan-yu" class="header-anchor">#</a></h5><p>hexo new page c</p>
<h5><span id="sheng-cheng-jing-tai-wen-zhang">生成静态文章</span><a href="#sheng-cheng-jing-tai-wen-zhang" class="header-anchor">#</a></h5><p>hexo generate<br>hexo g</p>
<h5><span id="bu-shu-wen-zhang">部署文章</span><a href="#bu-shu-wen-zhang" class="header-anchor">#</a></h5><p>hexo deploy<br>hexo d</p>
<h1><span id="bei-jing-yin-le">背景音乐：</span><a href="#bei-jing-yin-le" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39800978/article/details/109407258">https://blog.csdn.net/qq_39800978/article/details/109407258</a></p>
<h1><span id="cai-dan-tu-pian-wen-ti">菜单图片问题：</span><a href="#cai-dan-tu-pian-wen-ti" class="header-anchor">#</a></h1><p>需要看css里支持了哪些<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43340547/article/details/120581558">https://blog.csdn.net/qq_43340547/article/details/120581558</a></p>
<p>修改page页默认前缀：<br>F:\Code\Blog\scaffolds\post</p>
<p>typora+hexo插入图片<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yinyoupoet/p/13287385.html">https://www.cnblogs.com/yinyoupoet/p/13287385.html</a><br>hexo的图片只能是根目录下source/images目录<br>因此typora必须放到那个地方<br>且markdown里图片路径必须基于source/images<br>F:/Code/Blog/source/images/${filename}</p>
<h1><span id="zhi-chi-toc-mu-lu">支持toc目录</span><a href="#zhi-chi-toc-mu-lu" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/9489125286/">https://www.pianshen.com/article/9489125286/</a><br> <div class="toc"></p>
<!-- toc -->

<ul>
<li><a href="#tu-pian-zhi-chi-fang-da">图片支持放大</a></li>
<li><a href="#tian-jia-fang-wen-liang">添加访问量</a></li>
<li><a href="#valine-ping-lun-guo-nei-ban">valine评论（国内版）</a></li>
</ul>
<!-- tocstop -->

</div> 
[toc]用于编辑时目录跳转

<h1><span id="tu-pian-zhi-chi-fang-da">图片支持放大</span><a href="#tu-pian-zhi-chi-fang-da" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wugenqiang/article/details/89057323">https://blog.csdn.net/wugenqiang/article/details/89057323</a><br>fancybox本地无法使用，会导致加载失败<br>主要是因为默认配置的cdn我们无法访问<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Aelous_dp/article/details/107643344">https://blog.csdn.net/Aelous_dp/article/details/107643344</a><br>需要改为如下：<br>vendor:<br>  jquery: //code.jquery.com/jquery-2.0.3.min.js<br>  fancybox: //cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js<br>  fancybox_css: //cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.css<br>主要是本地无法连接他默认配置的那个CDN</p>
<h1><span id="tian-jia-fang-wen-liang">添加访问量</span><a href="#tian-jia-fang-wen-liang" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_34310405/article/details/102665373">https://blog.csdn.net/baidu_34310405/article/details/102665373</a></p>
<h1><span id="valine-ping-lun-guo-nei-ban">valine评论（国内版）</span><a href="#valine-ping-lun-guo-nei-ban" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48927364/article/details/123321038">https://blog.csdn.net/weixin_48927364/article/details/123321038</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/blue_zy/article/details/79071414">https://blog.csdn.net/blue_zy/article/details/79071414</a><br>Valine交流群: 480972291<br>配置再next的config里的valine:</p>
<p>waline国外版</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/" class="post-title-link" itemprop="url">java编译优化和语法糖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-06 22:55:46 / 修改时间：22:59:45" itemprop="dateCreated datePublished" datetime="2022-07-06T22:55:46+08:00">2022-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/06/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">

<!-- toc -->

<ul>
<li><a href="#zao-qi-bian-yi-you-hua">早期编译优化</a><ul>
<li><a href="#di-yi-bu">第一步：</a><ul>
<li><a href="#ci-fa-fen-xi">——-词法分析：</a></li>
<li><a href="#yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan">——-语法分析（注意实际上只是生成一个语法树，还没做语法的校验）：</a></li>
<li><a href="#tian-chong-fu-hao-biao">——-填充符号表：</a></li>
</ul>
</li>
<li><a href="#di-er-bu">第二步：</a><ul>
<li><a href="#zhu-jie-chu-li-qi">——-注解处理器：</a></li>
</ul>
</li>
<li><a href="#di-san-bu">第三步：</a><ul>
<li><a href="#yu-yi-fen-xi">——-语义分析：</a></li>
<li><a href="#jie-yu-fa-tang">——-解语法糖:</a></li>
<li><a href="#zi-jie-ma-sheng-cheng">——-字节码生成：</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="#java-yu-fa-tang">java语法糖</a><ul>
<li><a href="#fan-xing-ca-chu">泛型擦除:</a></li>
<li><a href="#signature">Signature:</a></li>
<li><a href="#zi-dong-zhuang-xiang-chai-xiang-xun-huan">自动装箱拆箱、循环</a></li>
<li><a href="#tiao-jian-bian-yi">条件编译：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wan-qi-bian-yi-you-hua">晚期编译优化</a><ul>
<li><a href="#jie-shi-qi-interperter">解释器Interperter</a></li>
<li><a href="#bian-yi-qi">编译器</a></li>
</ul>
</li>
<li><a href="#wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou">晚期优化的一些常见措施(即运行中才会做优化的步骤）</a><ul>
<li><a href="#re-dian-dai-ma">—-热点代码</a></li>
<li><a href="#rong-yu-fang-wen-xiao-chu">—冗余访问消除:</a></li>
<li><a href="#gong-gong-zi-biao-da-shi-xiao-chu">—-公共子表达式消除</a></li>
<li><a href="#shu-zu-bian-jie-jian-cha">—数组边界检查：</a></li>
<li><a href="#yin-shi-yi-chang-chu-li">—隐式异常处理：</a></li>
<li><a href="#fang-fa-nei-lian">—-方法内联:</a></li>
<li><a href="#tao-yi-fen-xi">—-逃逸分析：</a></li>
<li><a href="#java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie">—-java和C++， 即时编译和静态编译的区别：</a></li>
</ul>
</li>
<li><a href="#bian-yi-you-hua-wen-da-ti">编译优化问答题</a><ul>
<li><a href="#zao-qi-bian-yi-guo-cheng">早期编译过程</a></li>
<li><a href="#wan-qi-bian-yi-you-hua-1">晚期编译优化</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div> 

<p>[toc]</p>
<h1><span id="zao-qi-bian-yi-you-hua">早期编译优化</span><a href="#zao-qi-bian-yi-you-hua" class="header-anchor">#</a></h1><p>编译过程大致分为3类：</p>
<ol>
<li>解析与填充符号表</li>
<li>注解处理</li>
<li>分析与字节码生成</li>
</ol>
<p>源码JavaCompiler里的关键过程：<br>第一步：</p>
<p> <img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/da80a1a1a8f52928a88e81bac0766d8a0eeab3ed.png" alt="da80a1a1a8f52928a88e81bac0766d8a0eeab3ed"> </p>
<p>第二步语法分析、词法分析</p>
<p> <img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/e87a2122c8d20662ac01c4a7f8af159ee4c8a865.png" alt="e87a2122c8d20662ac01c4a7f8af159ee4c8a865"><br>第三步:</p>
<p> <img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/2fe67bfe0e1f3e543deba464130880231b32df7d.png" alt="2fe67bfe0e1f3e543deba464130880231b32df7d"><br>第四步：<br>执行注解处理<br> <img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/08cce0ef45b40e3db03ec3c0362444eb3dee4a24.png" alt="08cce0ef45b40e3db03ec3c0362444eb3dee4a24"> </p>
<p>接着就是语义分析及字节码生成<br> <img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/19956ec4da3e080289d22e64e04b58e9253e0de0.png" alt="19956ec4da3e080289d22e64e04b58e9253e0de0"> </p>
<p>以上的关键点:</p>
<ul>
<li>词法语法解析是第一步，生成符号</li>
<li>注解处理是第二步</li>
<li>然后语法糖、字节码都是第三步的事情。</li>
</ul>
<hr>
<p>上述步骤的详细解释：</p>
<h3><span id="di-yi-bu">第一步：</span><a href="#di-yi-bu" class="header-anchor">#</a></h3><h4><span id="ci-fa-fen-xi">——-词法分析：</span><a href="#ci-fa-fen-xi" class="header-anchor">#</a></h4><p>就是代码转成token标记。<br>例如int a=b+2 转成   Int \a=\b+\2  这6个token。</p>
<h4><span id="yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan">——-语法分析（注意实际上只是生成一个语法树，还没做语法的校验）：</span><a href="#yu-fa-fen-xi-zhu-yi-shi-ji-shang-zhi-shi-sheng-cheng-yi-ge-yu-fa-shu-huan-mei-zuo-yu-fa-de-xiao-yan" class="header-anchor">#</a></h4><p>根据生成的token，构造一个抽象语法树。</p>
<h4><span id="tian-chong-fu-hao-biao">——-填充符号表：</span><a href="#tian-chong-fu-hao-biao" class="header-anchor">#</a></h4><p>生成一个符号地址和符号信息构成的表格。<br>(后面第三步的阶段会用于语义分析中的标注检查，  比如名字的使用是否和说明一致，也会用于产生中间代码）<br>符号表是目标代码生成时的地址分配的依据</p>
<h3><span id="di-er-bu">第二步：</span><a href="#di-er-bu" class="header-anchor">#</a></h3><h4><span id="zhu-jie-chu-li-qi">——-注解处理器：</span><a href="#zhu-jie-chu-li-qi" class="header-anchor">#</a></h4><p>注解处理器会扫描抽象语法树中带注解的元素， 并进行语法树的更新。<br>更新之后我们会重新走回解析与填充的过程，重新处理。<br>这个处理器是一种插件，我们可以自己不断往其中去添加。</p>
<p>注意，上面这2步只是简单去对源文件做转换， 还不涉及任何语法相关的规则。</p>
<h3><span id="di-san-bu">第三步：</span><a href="#di-san-bu" class="header-anchor">#</a></h3><h4><span id="yu-yi-fen-xi">——-语义分析：</span><a href="#yu-yi-fen-xi" class="header-anchor">#</a></h4><p>判断语法树是否正确。分为2种检查：</p>
<ol>
<li>标注检查：   检查变量是否已被声明、 赋值、等式的数据类型是否匹配 <pre><code> 标注检查中会进行常量折叠， 把a=1+2折叠成3
  标注检查的范围比较小，不会有太多上下文依赖。
</code></pre>
</li>
<li>数据及控制流分析<br> 对程序上下文逻辑更进一步验证<br>  这里会涉及很多交互的上下文交互依赖<pre><code>比如 带返回值的方法是否全路径都包含了返回、  受检异常是否被外部处理、局部变量使用前是否被赋值。
</code></pre>
</li>
</ol>
<p>final 局部变量（或者final参数）和非final局部变量，生成的class文件没有区别。<br>因为局部变量不会在常量池中持有符号引用， 所以不会有acesses_flasg信息。<br>所以class文件不知道局部变量是不是final， 因此final局部对运行期没有任何影响， 只会在编译期去校验。</p>
<h4><span id="jie-yu-fa-tang">——-解语法糖:</span><a href="#jie-yu-fa-tang" class="header-anchor">#</a></h4><p>虚拟机本身不支持这种语法， 但是会在编译阶段 把这些语法糖转为 普通的语法结构（换句话说做了把语法糖代码变成了普通代码，  例如自动装拆箱，可能就是转成了包装方法的特定调用）</p>
<h4><span id="zi-jie-ma-sheng-cheng">——-字节码生成：</span><a href="#zi-jie-ma-sheng-cheng" class="header-anchor">#</a></h4><p>对象的初始化顺序， 实际上会在字节码生成阶段， 收敛到一个<init>方法中。 即init中控制了那些成员、以及构造方法的调用顺序<br>类初始化同理，也是收敛到一个 <cinit>中<br>PS： 注意，默认构造器是在填充符号表阶段完成的。<br>字符串的替换（+操作转成sb） 是在字节码阶段生成的。<br>完成了对语法树的遍历之后，会把最终的符号表交给ClassWRITE类，设计概念从一个字节码和文件</cinit></init></p>
<hr>
<h2><span id="java-yu-fa-tang">java语法糖</span><a href="#java-yu-fa-tang" class="header-anchor">#</a></h2><p>Q: java语法糖属于早期优化还是晚期优化？<br>A: 属于早期优化。</p>
<h3><span id="fan-xing-ca-chu">泛型擦除:</span><a href="#fan-xing-ca-chu" class="header-anchor">#</a></h3><p>java中的泛型只在 程序源码中存在，  在编译后的字节码文件中已经替换为原生类型， 并会插入一些强制转换的代码。<br>即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">f</span><span class="params">(T  t)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">a</span> <span class="operator">=</span> T.getA();</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">实际上是</span><br><span class="line"></span><br><span class="line">T  <span class="title function_">f</span><span class="params">(Object t)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> （T）t.getA();</span><br><span class="line">    <span class="keyword">return</span> (T)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即只在会方法的入口 和方法的出口处，做强制转换， 而实际上传入的都是原生类型，可以理解为object</p>
<p>神奇的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个编译会报错，认为有2种相同的方法， 因为编译后被擦除了。</p>
<p>然后下面这个例子却是tm能ok的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;inoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释:<br>返回值不参与重载的选择，但是因为返回值作为描述符不一致，以至于可以在一个class文件中共存。<br>必须用Sun JDK1.6才能编译通过</p>
<h3><span id="signature">Signature:</span><a href="#signature" class="header-anchor">#</a></h3><p>用于解决泛型歹来的参数类型的识别问题。<br>可存储字节码层面的特征签名。<br>字节码层面：   方法名称、参数顺序、参数类型、 返回值、受检查异常， 这5个决定了1个字节码层面的方法是否唯一。<br>如果是java语法层面， 则签名只受方法名称、参数顺序、参数类型这3个的影响。</p>
<p>他会保存参数化类型的信息， 即虽然code里都转成了object， 但是其参数化类型还是通过signature保存到了元数据区， 可以通过反射获取参数化类型。</p>
<h3><span id="zi-dong-zhuang-xiang-chai-xiang-xun-huan">自动装箱拆箱、循环</span><a href="#zi-dong-zhuang-xiang-chai-xiang-xun-huan" class="header-anchor">#</a></h3><p>自动装箱拆箱:  就是在编译后， 自动把装拆箱的地方加上 Integer.valueOf()  或者  包装类型.intValue()</p>
<p>可变参数：被优化成一个数组<br>Arrays.asList(“1”,”2”,”3”,”4”)   =&gt;   Arrays.asList(new String[]{ “1”, “2”, “3”, “4”})</p>
<p>带iterator接口的  for循环：<br>for(String str :   listStr) {<br>}<br>被优化成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">Interator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator(); it.hasNext()) &#123;</span><br><span class="line">    xxx   it.next xxx...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line"><span class="type">Long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br></pre></td></tr></table></figure>

<p>// true, 小于128，用常量池里的常量比较<br>System.out.println(c == d);<br>// false,非常量池，用各自不同的地址比较<br>System.out.println(e == f );<br>// true， 同1<br>System.out.println(c == (a+b));<br>// true， Integer<br>System.out.println(c.equals(a+b));<br>// true， 这个为什么==是可以的，是因为Long小于128时，也会用常量池的值吗<br>System.out.println(g == (a+b));<br>// false , equals不处理数据转型的关系。<br>System.out.println(g.equals(a+b));</p>
<h3><span id="tiao-jian-bian-yi">条件编译：</span><a href="#tiao-jian-bian-yi" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">xxx</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    yyy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被优化成了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure>

<p>因为编译器很明确只能走xxx这个分支。<br>只能用于if+常量</p>
<p>使用常量与其他带有条件判断能力的语句搭配，则会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个会报错unreachable statement code<br><img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/20210719233205601.png" alt="为什么呢？"><br>因为系统检测到这句代码是永远无法到达的分支，直接给你禁掉了</p>
<h1><span id="wan-qi-bian-yi-you-hua">晚期编译优化</span><a href="#wan-qi-bian-yi-you-hua" class="header-anchor">#</a></h1><p>HotSpot中，  <strong>解释器与编译器共存</strong>。<br>当程序刚启动时，会先马上使用解释器发挥作用。<br>在程序运行后， 编译器逐步发挥作用，把还没用到的代码逐步编译。<br>内存资源比较少的情况下，可以用解释器来跑程序，减少编译生成的文件。<br>如果编译器的优化出现bug，可以通过“逆优化”回退到最初的解释器模式来运行</p>
<h3><span id="jie-shi-qi-interperter">解释器Interperter</span><a href="#jie-shi-qi-interperter" class="header-anchor">#</a></h3><h3><span id="bian-yi-qi">编译器</span><a href="#bian-yi-qi" class="header-anchor">#</a></h3><p>有两种编译器</p>
<ul>
<li><p>Client Compiler ——C1编译器,  更高的编译速度</p>
</li>
<li><p>Server Compiler——C2编译器， 更好的编译质量<br>即选择了-client或者-server时会用到。</p>
</li>
<li><p>默认混合模式：  解释器和编译器共存， 即MixedMode。  </p>
</li>
</ul>
<p>关于这2种编译器的参数：</p>
<ul>
<li> -Xint参数： 强制使用解释模式</li>
<li>-Xcomp参数： 强制使用编译模式（ 但是如果编译无法进行时，  解释会介入）</li>
</ul>
<hr>
<p>混合模式中， 解释器需要收集性能信息，提供给编译阶段判断和优化， 这个性能信息有点浪费<br>因此JDK7引入了<strong>分层编译</strong>策略：</p>
<ul>
<li>第0层：  解释执行。  不开启性能监控。</li>
<li>第1层： C1编译，  把字节码编译为本地代码，  进行一些简单优化，   加入性能监控</li>
<li>第2层： C2编译，   启动耗时较长的优化，  根据性能监控信息进行激进优化</li>
</ul>
<hr>
<p>CC和SC编译过程的区别：</p>
<ul>
<li>client Compiler 编译过程：<br>前端字节码-》  方法内联/常量传播（基础优化）-》 HIR（高级中间代码）-》 空值检查消除/范围检查消除</li>
</ul>
<p>-》 后端把HIR转成LLR（低级中间代码）-》 线性扫描算法分配寄存器-》窥孔优化-》机器码生成-》本地代码生成<br>都是一些不需要运行期信息就能做优化的操作</p>
<ul>
<li>serverCompiler编译过程：<br>会执行<strong>所有的经典优化动作</strong><br>会根据cc或者解释器提供的监控信息，进行<strong>激进的优化</strong><br>寄存器分配器是一个全局图着色分配器</li>
</ul>
<hr>
<h1><span id="wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou">晚期优化的一些常见措施(即运行中才会做优化的步骤）</span><a href="#wan-qi-you-hua-de-yi-xie-chang-jian-cuo-shi-ji-yun-xing-zhong-cai-hui-zuo-you-hua-de-bu-zou" class="header-anchor">#</a></h1><h3><span id="re-dian-dai-ma">—-热点代码</span><a href="#re-dian-dai-ma" class="header-anchor">#</a></h3><ol>
<li>被多次调用的方法。  会触发JIT编译</li>
<li>被多次执行的循环体，  会触发OSR编译（栈上替换）， 发生在方法执行过程中， 所以是在栈上编译并切换方法。</li>
</ol>
<p>HotSpot 使用 计数器的热点探测法确定热点代码。<br>    * 给每个方法建立方法计数器， 在一个周期中如果超过阈值， 就触发JIT编译，编译后替换方法入口。<br>    * 如果一个周期内没超过，则计数器/2（半衰）<br>    * 如果没有触发时， 都是用解释方式 按照字节码内容死板地运行。</p>
<blockquote>
<blockquote>
<p>该计数器的相关参数<br>-XX:-UserCounterDecay 关闭热度衰减<br>-XX: CounterHalfLifeTime  设置半衰期-XX:CompileThreshold 设置方法编译阈值</p>
</blockquote>
</blockquote>
<p>回边计数器就是计算循环次数的计数器<br>    * 没有半衰<br>    * 但是当触发OSR编译时，会把计数器降低，避免还在运行时重复触发。<br>    * 会溢出， 并且会把方法计数器也调整到溢出。<br>    *  clint模式和server模式中，  OSR的阈值计算公式不同，   clint= CompileThredshold * osr比率，    server= CompileThredshold * (osr比率 - 解释器监控比率）</p>
<h3><span id="rong-yu-fang-wen-xiao-chu">—冗余访问消除:</span><a href="#rong-yu-fang-wen-xiao-chu" class="header-anchor">#</a></h3><p> 如果已经拿到了  a.value， 该方法内a.value一定不会变的话， 那么后续用到时就不再从a中取value了<br>复写传播：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y=b.value</span><br><span class="line">z=<span class="type">y</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span> z + y</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = b.<span class="type">value</span></span><br><span class="line"><span class="variable">y</span> <span class="operator">=</span> <span class="type">y</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span> y + y</span><br></pre></td></tr></table></figure>
<p>无用代码消除：<br>去掉上面的Y=y</p>
<h3><span id="gong-gong-zi-biao-da-shi-xiao-chu">—-公共子表达式消除</span><a href="#gong-gong-zi-biao-da-shi-xiao-chu" class="header-anchor">#</a></h3><p>就是对一些比较长的计算公式做化简<br>a+（a+b）<em>2<br>会优化成<br>a</em>3+b*2<br>尽可能减少计算次数</p>
<h3><span id="shu-zu-bian-jie-jian-cha">—数组边界检查：</span><a href="#shu-zu-bian-jie-jian-cha" class="header-anchor">#</a></h3><p>如果能确定某个for循环里的数组取值操作一定不会超出数组范围，那么在做[]取值操作时，不会做数组边界检查。</p>
<h3><span id="yin-shi-yi-chang-chu-li">—隐式异常处理：</span><a href="#yin-shi-yi-chang-chu-li" class="header-anchor">#</a></h3><p>if(a == null) {<br>    xxx<br>}<br>else{<br>    throw Exception<br>}<br>优化成<br>try {<br>    xxx<br>} catch(Exception e) {<br>    throw e<br>}</p>
<p>为什么隐式异常处理不能放在早期优化？<br> <img src="/images/java%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%92%8C%E8%AF%AD%E6%B3%95%E7%B3%96/f25fce1b1f632496074589dad0c260c0f1cc936a.png" alt="f25fce1b1f632496074589dad0c260c0f1cc936a"> </p>
<h3><span id="fang-fa-nei-lian">—-方法内联:</span><a href="#fang-fa-nei-lian" class="header-anchor">#</a></h3><p>不能被继承重写的方法，比如私有、构造器、静态之类的方法，可以直接在早期优化中做内联优化。<br>而其他会被抽象继承实现的方法在编译器无法做内联，因为他不知道实际是用哪一段代码。</p>
<ul>
<li>final方法并不是非虚方法（为什么呢）</li>
<li>类型继承关系分析CHA：   如果发现虚方法，CHA会查一下当前虚拟机内该方法是否有多个实现， 如果发现只有这一种实现，那么就可以直接内联。</li>
<li>如果后续有其他的class动态加载进来后，该方法有多个实现了，并且被使用到了，那么就会抛弃已编译的内联代码，回退到解释状态执行。</li>
<li>内联缓存：  即使程序中发现该方法有多个实现， 依然对第一个使用的那个方法做内联，除非有其他重写方法被调用（即虽然你定义了，但是你很可能不用，所以我一直使用你的第一个方法，除非你真的用了多种重写方法去跑。</li>
</ul>
<h3><span id="tao-yi-fen-xi">—-逃逸分析：</span><a href="#tao-yi-fen-xi" class="header-anchor">#</a></h3><p>分析new 出来的对象是否不会逃逸到方法外，  如果确认只在方法内使用，外部不会有人引用他， 那么就会做优化，比如：<br>    * 不把new出来的对象放到堆，而是放到方法栈上，方法结束了对象直接消失。<br>    * 不需要对这种对象做加锁、同步操作了<br>    * 标量替换:   把这个对象里的最小基本类型成员拆出来作为局部变量使用。</p>
<h3><span id="java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie">—-java和C++，  即时编译和静态编译的区别：</span><a href="#java-he-c-ji-shi-bian-yi-he-jing-tai-bian-yi-de-qu-bie" class="header-anchor">#</a></h3><ol>
<li> 即时编译可能会影响用户体验，如果在运行中出现较大影响的延迟的话    2.<br>java中虚方法比C++要多， 因为做各种内联分析消耗的检查和优化的就越多越大    3.<br>java中总是要做安全检查， C++中不做，出错了我就直接崩溃了越界了    4.<br>C++中内存释放让用户控制， 无需后台弄一个垃圾回收器总是去检查和操作    5.<br>java好处： 即时编译能够以运行期的性能监控进行优化，这个是C++无法做到的。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40925525/article/details/98363179">https://blog.csdn.net/qq_40925525/article/details/98363179</a></p>
<hr>
<h1><span id="bian-yi-you-hua-wen-da-ti">编译优化问答题</span><a href="#bian-yi-you-hua-wen-da-ti" class="header-anchor">#</a></h1><p>@[toc]<br>首先提出一个问题，为什么C++的编译速度会比java慢很多？二者运行程序的速度差异子啊那？  了解了java的早期和晚期过程，就能理解这个问题了。 </p>
<p>这里会提15个问题确认是否真的理解，如果完全没这方面的概念，则好好看一下前面的<a href>早期和晚期编译优化读书笔记</a></p>
<h3><span id="zao-qi-bian-yi-guo-cheng">早期编译过程</span><a href="#zao-qi-bian-yi-guo-cheng" class="header-anchor">#</a></h3><hr>
<p>Q: java早期编译过程分为哪3步？<br>A:</p>
<ol>
<li>词法语法解析、填充符号表</li>
<li>注解处理</li>
<li>语义分析与字节码生成。</li>
</ol>
<hr>
<p>Q: 上面的步骤中， <strong>符号表</strong>是干吗的？<br>A:<br>符号表是符号地址和符号信息构成的表格。</p>
<ul>
<li>用于后面阶段做语法检查时，从表里取出信息进行对比。</li>
<li>符号表是目标代码生成时的地址分配的依据</li>
</ul>
<hr>
<p>Q: 注解处理器做的什么事情？<br>A: 注解处理器会扫描抽象语法树中带注解的元素， 并进行语法树的更新。<br>重点就是他是基于语法树做更新。<br>更新之后我们会重新走回解析与填充的过程，重新处理。</p>
<p>APT可以用来在编译时扫描和处理注解。<br>通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来<strong>自动的生成一些代码</strong>，省去了手动编写。 例如@Setter<br>注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。</p>
<hr>
<hr>
<p>Q: 上面的3个步骤中， 解语法糖是哪一步？<br>A:<br>是第三步，在生成字节码的时候才做的语法糖处理。</p>
<hr>
<p>Q: 什么是解语法糖？大概有哪些？<br>A:</p>
<ul>
<li>虚拟机本身不支持这种语法， 但是会在编译阶段 把这些语法糖转为 普通的语法结构。</li>
<li>包含自动装拆箱、 泛型强转应用。</li>
</ul>
<hr>
<p>Q: 生成字节码class文件的时候， final和非final的局部变量， 会有区别不？<br>A:<br>没有区别。<br>局部变量不会在常量池中持有符号引用， 所以不会有acesses_flasg信息。<br>** 因此final局部变量在运行期没有任何作用， 只会在编译期去校验。**</p>
<hr>
<p>Q:   a= 1 + 2会在什么阶段进行优化？<br>A: 会在早期编译过程的语义分析过程中，进行常量折叠， 变成a=3<br>同理， 字符串+号优化成stringBuilder.append()这个动作也是该阶段优化的。</p>
<hr>
<p>Q:  类对象加载的过程有一堆顺序（具体见<a href="xxx">类初始化顺序</a>，  这个顺序在字节码中体现的吗？还是运行的时候再判断顺序？<br>A:<br>字节码中体现的。</p>
<ul>
<li>在字节码生成时，  编译器针对对象new的过程，会生成了一个<init>方法，里面写明了成员、构造方法的调用顺序。</init></li>
<li>类静态成员的调用顺序同理封装在<cinit>中。</cinit></li>
</ul>
<hr>
<h3><span id="wan-qi-bian-yi-you-hua">晚期编译优化</span><a href="#wan-qi-bian-yi-you-hua" class="header-anchor">#</a></h3><p>Q:<br>早期编译优化和晚期编译优化的区别？<br>A:</p>
<ul>
<li>早期编译优化， 是把 java文件转成字节码，转字节码的过程中做一些简单优化和语法糖处理。</li>
<li>晚期编译优化，是将字节码转机器码执行的过程中，结合一些信息进行动态优化，或者应用上很多的机器码优化措施。</li>
</ul>
<hr>
<p>Q: java程序运行的时候，是直接全部转成优化后的机器码再运行吗？<br>A:<br>错误。</p>
<ul>
<li>当程序刚启动时，会先马上使用<strong>解释器</strong>发挥作用，这时候没做太多优化，直接解释执行。</li>
<li>在程序运行后， <strong>编译器</strong>逐步发挥作用，把还没用到的代码逐步编译成机器码。<blockquote>
<blockquote>
<p>注意这里的编译器和之前提到的编译器的区别，一个是编译成字节码，另一个是编译成机器码。</p>
</blockquote>
</blockquote>
</li>
</ul>
<hr>
<hr>
<p>Q: JIT是什么？<br>A:<br>为了提高执行速度，便引入了 JIT 技术。<br>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。</p>
<hr>
<p>Q: 有两种晚期优化编译器</p>
<ul>
<li>Client Compiler ——C1编译器</li>
<li>Server Compiler——C2编译器<br>他们二者的区别是什么？</li>
</ul>
<p>A:</p>
<ul>
<li>速度和质量的区别：<br>C1编译器,  更高的编译速度，编译质量一般。<br>C2编译器， 更好的编译质量，但是速度慢。</li>
<li>优化特性的区别<br>C1编译器都是一些不需要运行期信息就能做优化的操作。<br>C2编译器则会根据解释器提供的监控信息，进行<strong>激进且动态的优化</strong></li>
</ul>
<hr>
<p>Q: java中怎么区分用C1还是C2？<br>A:<br>关于这2种编译器的参数：</p>
<ul>
<li> -Xint参数： 强制使用解释模式</li>
<li>-Xcomp参数： 强制使用编译模式（ 但是如果编译无法进行时，  解释会介入）</li>
<li>选择编译模式时，有-client、-server还有MixedMode(混合模式）可以选择<blockquote>
<blockquote>
<p>混合模式中， JDK7引入了<strong>分层编译</strong>策略：<br>第0层：  解释执行。  不开启性能监控。<br>第1层： C1编译，  把字节码编译为本地代码，  进行一些简单优化，   加入性能监控<br>第2层： C2编译，   启动耗时较长的优化，  根据性能监控信息进行激进优化</p>
</blockquote>
</blockquote>
</li>
</ul>
<hr>
<p>Q: 分层优化中，如果正在运行，jvm是怎么知道需要对哪些代码做JIT或者OSR优化？<br>A:</p>
<ol>
<li>被多次调用的方法。  会触发JIT编译（热点代码计数器）</li>
<li>被多次执行的循环体，  会触发OSR编译（栈上替换）， 发生在方法执行过程中， 所以是在栈上编译并切换方法。（使用回边计数器）</li>
</ol>
<hr>
<p>Q: 哪些方法会在早期优化中做内联，哪些方法会在晚期优化中做内联？<br>A:</p>
<ul>
<li>不能被继承重写的方法，比如私有、构造器、静态之类的方法，可以直接在早期优化中做内联优化。</li>
<li>其他会被<strong>抽象继承实现的方法</strong>在早期无法做内联，因为他不知道实际是用哪一段代码.</li>
<li>晚期优化中可以根据一些运行信息，判断是否总是只用某个子类方法跑，是的话做一下尝试内联，如果后面来了其他的子类就切回去。</li>
</ul>
<hr>
<p>Q: java数组一般都会自动做边界检查，不满足就抛异常。 什么情况下会优化掉这个自动检查？<br>A:<br>运行期，发现传入的参数放到数组中用的时候， 肯定不会超出边界，则会优化掉这个检查动作。</p>
<hr>
<p>看完上面的，就可以给出C++和java编译和运行速度差距的原因了：</p>
<ol>
<li>java即时编译可能会影响用户体验，如果在运行中出现较大影响的延迟的话。</li>
<li>java中虚方法比C++要多， 因为做各种内联分析消耗的检查和优化的就越多越大</li>
<li>java中总是要做安全检查， C++中不做，出错了我就直接崩溃了越界了</li>
<li>C++中内存释放让用户控制， 无需后台弄一个垃圾回收器总是去检查和操作</li>
<li>java好处： 即时编译能够以运行期的性能监控进行优化，这个是C++无法做到的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">synchronized关键字原理超级详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-08 21:05:11" itemprop="dateCreated datePublished" datetime="2022-06-08T21:05:11+08:00">2022-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-03 16:36:05" itemprop="dateModified" datetime="2022-07-03T16:36:05+08:00">2022-07-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">

<!-- toc -->

<ul>
<li><a href="#wei-shi-me-shuo-xian-cheng-qie-huan-hui-hen-man">为什么说线程切换会很慢？</a></li>
<li><a href="#dui-xiang-tou-zhong-de-mark-word">对象头中的mark-word</a><ul>
<li><a href="#suo-zhuang-tai-biao-zhi-wei-pian-xiang-suo-biao-ji-wei-2bit-1bit">锁状态标志位 +偏向锁标记位（2bit + 1bit）</a><ul>
<li><a href="#wei-shi-me-wu-suo-pian-xiang-suo-de-biao-zhi-wei-shi-01-er-qing-liang-ji-suo-de-biao-zhi-wei-shi-00">为什么无锁/偏向锁的标志位是01，而轻量级锁的标志位是00？</a></li>
</ul>
</li>
<li><a href="#hashcode-31bit">hashcode（31bit）</a><ul>
<li><a href="#markword-zhong-de-hashcode-shi-na-ge-fang-fa-sheng-cheng-de">markword中的hashcode是哪个方法生成的？</a></li>
<li><a href="#markword-zhong-de-hashcode-shi-shi-me-shi-hou-sheng-cheng">markword中的hashcode是什么时候生成？</a></li>
<li><a href="#hashcode-zai-qi-ta-suo-zhuang-tai-zhong-qu-na-liao">hashcode在其他锁状态中去哪了？</a></li>
</ul>
</li>
<li><a href="#gc-fen-dai-nian-ling-4bit">gc分代年龄（4bit）</a></li>
<li><a href="#cms-free">cms_free</a></li>
</ul>
</li>
<li><a href="#suo-sheng-ji-si-ge-jie-duan-chao-ji-xiang-jie">锁升级四个阶段超级详解</a><ul>
<li><a href="#wu-suo">无锁</a><ul>
<li><a href="#chu-yu-wu-suo-zhuang-tai-de-tiao-jian-huo-zhe-shi-ji-shi-shi-me">处于无锁状态的条件或者时机是什么？</a></li>
<li><a href="#dui-xiang-cong-mei-jin-ru-tong-bu-kuai-wei-shi-me-pian-xiang-suo-biao-zhi-wei-que-shi-1">对象从没进入同步块，为什么偏向锁标志位却是1？</a></li>
</ul>
</li>
<li><a href="#pian-xiang-suo">偏向锁</a><ul>
<li><a href="#wei-shi-me-yao-you-pian-xiang-suo">为什么要有偏向锁？</a></li>
<li><a href="#pian-xiang-suo-de-markword-xiang-jie">偏向锁的markword详解</a><ul>
<li><a href="#markword-zhong-de-dang-qian-xian-cheng-id">markword中的当前线程id</a><ul>
<li><a href="#java-de-xian-cheng-id-shi-yi-ge-long-lei-xing-an-li-shuo-shi-64-wei-dan-wei-shi-me-zhi-lei-de-xian-cheng-id-zhi-you-54-wei">java的线程id是一个long类型， 按理说是64位，但为什么之类的线程id只有54位？</a></li>
<li><a href="#xian-cheng-id-ru-he-xie-ru">线程id如何写入？</a></li>
</ul>
</li>
<li><a href="#ha-xi-code-qu-na-liao">哈希code去哪了</a></li>
<li><a href="#epoch-shi-shi-me">epoch是什么？</a></li>
</ul>
</li>
<li><a href="#pian-xiang-suo-yun-zuo-xiang-jie">偏向锁运作详解</a><ul>
<li><a href="#pian-xiang-suo-shang-suo-shi-ru-he-bi-mian-chong-tu-he-jing-zheng">偏向锁上锁时，如何避免冲突和竞争？</a></li>
<li><a href="#chi-kai-tong-bu-dai-ma-kuai-shi-markword-zhong-de-xian-cheng-id-hui-chong-xin-bian-wei-0-ma">离开同步代码块时， markword中的线程id会重新变为0吗？</a></li>
<li><a href="#pian-xiang-suo-fa-sheng-jing-zheng-shi-de-qie-suo-huo-zhe-sheng-ji-cao-zuo">偏向锁发生竞争时的切锁或者升级操作。</a><ul>
<li><a href="#wei-shi-me-yao-deng-dai-an-quan-dian-cai-neng-zuo-che-xiao-cao-zuo">为什么要等待安全点，才能做撤销操作？</a></li>
<li><a href="#wei-shi-me-yao-xian-tui-hua-cheng-wu-suo-zhuang-tai-zai-shi-tu-jing-zheng-cheng-pian-xiang-suo-bu-neng-zhi-jie-pian-xiang-ma">为什么要先退化成无锁状态，再试图竞争成偏向锁？不能直接偏向吗？</a></li>
<li><a href="#wei-shi-me-yuan-pian-xiang-xian-cheng-zai-tong-bu-dai-ma-kuai-zhong-shi-jiu-bi-xu-sheng-ji-wei-qing-liang-ji-suo-neng-fou-tong-yang-che-xiao-wu-suo-lai-jing-zheng">为什么原偏向线程在同步代码块中时，就必须升级为轻量级锁？能否同样撤销无锁来竞争？</a></li>
</ul>
</li>
<li><a href="#pi-liang-chong-pian-xiang-yi-ji-epoch-de-ying-yong">批量重偏向，以及epoch的应用</a></li>
<li><a href="#pi-liang-che-xiao">批量撤销</a></li>
<li><a href="#pian-xiang-suo-zai-jin-cheng-yi-kai-shi-jiu-qi-yong-liao-ma">偏向锁在进程一开始就启用了吗</a></li>
</ul>
</li>
<li><a href="#pian-xiang-suo-de-chong-yao-yan-bian-li-shi-he-si-kao">偏向锁的重要演变历史和思考</a></li>
</ul>
</li>
<li><a href="#qing-liang-ji-suo">轻量级锁</a><ul>
<li><a href="#yuan-xian-markword-zhong-de-xin-xi-du-qu-na-li-liao">原先markword中的信息都去哪里了？</a></li>
<li><a href="#qing-liang-ji-suo-ru-he-chu-li-xian-cheng-chong-ru-wen-ti">轻量级锁如何处理线程重入问题？</a></li>
<li><a href="#qing-liang-ji-suo-jia-suo-guo-cheng">轻量级锁加锁过程</a></li>
<li><a href="#qing-liang-ji-suo-de-jie-suo-liu-cheng">轻量级锁的解锁流程</a></li>
<li><a href="#zi-xuan-ci-shu-de-shang-xian-yi-ding-shi-10-ci-ma">自旋次数的上限一定是10次吗？</a></li>
</ul>
</li>
<li><a href="#chong-liang-ji-suo">重量级锁</a><ul>
<li><a href="#sheng-ji-wei-chong-liang-ji-suo-de-tiao-jian">升级为重量级锁的条件</a></li>
</ul>
</li>
<li><a href="#markword-qu-na-liao">markword去哪了</a><ul>
<li><a href="#chong-liang-ji-suo-tong-bu-de-yuan-li-tu-jie">重量级锁同步的原理图解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#guan-yu-synchronized-guan-jian-zi-de-si-kao">关于synchronized关键字的思考</a></li>
</ul>
<!-- tocstop -->

</div>

<p>[toc]</p>
<h1><span id="wei-shi-me-shuo-xian-cheng-qie-huan-hui-hen-man">为什么说线程切换会很慢？</span><a href="#wei-shi-me-shuo-xian-cheng-qie-huan-hui-hen-man" class="header-anchor">#</a></h1><p>所谓的用户态和内核态之间的切换仅仅是一方面， 并非全部， 更关键的在于， 多CPU的机器中，<strong>当你切换了线程，意味着线程在原先CPU上的缓存也许不再有用</strong>，  因为当线程重新触发时，可能在另一个CPU上执行了。</p>
<p>正因如此，不建议没事就挂起线程， 让线程自旋会比挂起后切换CPU好很多。</p>
<p>正与基于这一点，才有了后面的sync锁升级机制，理解了为什么要锁升级，才能逐步理解锁升级过程，</p>
<h1><span id="dui-xiang-tou-zhong-de-mark-word">对象头中的mark-word</span><a href="#dui-xiang-tou-zhong-de-mark-word" class="header-anchor">#</a></h1><p>java每个对象的对象头中， 都有32或者64位的mark-word。</p>
<p>mark-word是理解锁升级过程的重要部分，且后面的锁升级过程都会涉及，因此这里会进行一个非常详细的解释。这部分只对一个对象必有的属性做解释（即一般不会随着锁状态变化而消失的属性）。对于各锁状态独有的属性，会在锁升级过程中做详细的解释。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655422124426.png" alt="1655422124426"></p>
<h2><span id="suo-zhuang-tai-biao-zhi-wei-pian-xiang-suo-biao-ji-wei-2bit-1bit">锁状态标志位 +偏向锁标记位（2bit + 1bit）</span><a href="#suo-zhuang-tai-biao-zhi-wei-pian-xiang-suo-biao-ji-wei-2bit-1bit" class="header-anchor">#</a></h2><p>除了markword中的2位锁状态标志位， 其他62位都会随着锁状态标志位的变化而变化。</p>
<p>这里先列出各锁状态标志位代表的当前对象所用锁的情况。后面会详细解释各种锁的含义和运行原理。</p>
<ul>
<li>锁状态标志位为01： 属于无锁或者偏向锁状态。<strong>因此还需要额外的偏向锁标记位1bit来确认是无锁还是偏向锁</strong></li>
<li>锁状态标志位为00： 轻量级锁</li>
<li>锁状态标志位为10： 重量级锁</li>
<li>锁状态标志位为11： 已经被gc标记，即将释放</li>
</ul>
<h3><span id="wei-shi-me-wu-suo-pian-xiang-suo-de-biao-zhi-wei-shi-01-er-qing-liang-ji-suo-de-biao-zhi-wei-shi-00">为什么无锁/偏向锁的标志位是01，而轻量级锁的标志位是00？</span><a href="#wei-shi-me-wu-suo-pian-xiang-suo-de-biao-zhi-wei-shi-01-er-qing-liang-ji-suo-de-biao-zhi-wei-shi-00" class="header-anchor">#</a></h3><p>即按理说，无锁是锁状态的初始情况，为什么标志位不是从00开始？</p>
<p>个人查询到的一个解释，是因为 轻量级锁除了锁标志位外，另外62位都是一个指针地址。</p>
<p>如果将轻量级锁标志位设置为00， 那么在判断标志位为00后， <strong>jvm无需再额外做一次markWord&gt;&gt;2的操作，而是直接将markWord拿来当作地址使用即可！</strong></p>
<p>可以从这里看到jvm的设计者还是非常细节的，并没有随意地定义各状态的标志位</p>
<h2><span id="hashcode-31bit">hashcode（31bit）</span><a href="#hashcode-31bit" class="header-anchor">#</a></h2><p>哈希code很容易理解，将对象存储到一些map或者set里时，都需要hashcode来确认插入位置。</p>
<p>但markword里的hashcode，和我们平时经常覆写的hashCode()还是有区别的。</p>
<h3><span id="markword-zhong-de-hashcode-shi-na-ge-fang-fa-sheng-cheng-de">markword中的hashcode是哪个方法生成的？</span><a href="#markword-zhong-de-hashcode-shi-na-ge-fang-fa-sheng-cheng-de" class="header-anchor">#</a></h3><p>很多人误以为，markword中的hashcode是由我们经常覆写的hashcode（）方法生成的。</p>
<p>实际上， markword中的hashcode只由底层 JDK C++ 源码计算得到（java侧调用方法为 System.identityHashCode() ）， 生成后固化到markword中，</p>
<p>如果你覆写了hashcode()方法， 那么每次都会重新调用<code>hashCode()</code>方法重新计算哈希值。</p>
<p>根本原因是因为你覆写hashcode()之后，该方法中很可能会利用被修改的成员来计算哈希值，所以jvm不敢将其存储到markword中。 </p>
<p>**因此，如果覆写了hashcode（）方法，对象头中就不会生成hashcode，而是每次通过hashcode()方法调用 **</p>
<h3><span id="markword-zhong-de-hashcode-shi-shi-me-shi-hou-sheng-cheng">markword中的hashcode是什么时候生成？</span><a href="#markword-zhong-de-hashcode-shi-shi-me-shi-hou-sheng-cheng" class="header-anchor">#</a></h3><p>很容易误以为会是对象一创建就生成了。</p>
<p>实际上，是采用了<strong>延迟加载技术</strong>，只有在用到的时候才生成。</p>
<p>毕竟有可能对象创建出来使用时，并不需要做哈希的操作。</p>
<h3><span id="hashcode-zai-qi-ta-suo-zhuang-tai-zhong-qu-na-liao">hashcode在其他锁状态中去哪了？</span><a href="#hashcode-zai-qi-ta-suo-zhuang-tai-zhong-qu-na-liao" class="header-anchor">#</a></h3><p>这个问题会在后面锁升级的3个阶段中，解释hashcode的去向。其他的例如分代年龄同理。</p>
<h2><span id="gc-fen-dai-nian-ling-4bit">gc分代年龄（4bit）</span><a href="#gc-fen-dai-nian-ling-4bit" class="header-anchor">#</a></h2><p>在jvm垃圾收集机制中， 决定年轻代什么时候进入老年代的根据之一， 就是确认他的分代年龄是否达到阈值，如下图所示。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655422054870.png" alt="1655422054870"></p>
<p>分代年龄只有4bit可以看出，最大值只能是15。因此我们设置的进入老年代年龄阈值 -XX:MaxTenuringThreshold 最大只能设置15。</p>
<h2><span id="cms-free">cms_free</span><a href="#cms-free" class="header-anchor">#</a></h2><p>在无锁和偏向锁中，还可以看到有1bit的cms_free。</p>
<p> 实际上就是只有CMS收集器用到的。但最新java11中更多用的是G1收集器了，这一位相当于不怎么常用，因此提到的也非常少。</p>
<p>从上述可以看出， 只有锁状态标记位、 hashcode、 分代年龄、cms_free是必有的， 但是从markword最初的示意图来看， hashcode、 分代年龄、cms_free似乎并非一直存在，那么他们去哪了呢？会在后面的锁升级过程进行详细解释。</p>
<h1><span id="suo-sheng-ji-si-ge-jie-duan-chao-ji-xiang-jie">锁升级四个阶段超级详解</span><a href="#suo-sheng-ji-si-ge-jie-duan-chao-ji-xiang-jie" class="header-anchor">#</a></h1><h2><span id="wu-suo">无锁</span><a href="#wu-suo" class="header-anchor">#</a></h2><p>无锁状态的markword如下所示，可以看到上文提到的信息都存在</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655337139035.png" alt="1655337139035"></p>
<h3><span id="chu-yu-wu-suo-zhuang-tai-de-tiao-jian-huo-zhe-shi-ji-shi-shi-me">处于无锁状态的条件或者时机是什么？</span><a href="#chu-yu-wu-suo-zhuang-tai-de-tiao-jian-huo-zhe-shi-ji-shi-shi-me" class="header-anchor">#</a></h3><p>无锁状态用于对象刚创建，<strong>且还未进入过同步代码块的时候</strong></p>
<p>这一点很重要， 意味着如果你没有同步代码块或者同步方法， 那么将是无锁状态。</p>
<h3><span id="dui-xiang-cong-mei-jin-ru-tong-bu-kuai-wei-shi-me-pian-xiang-suo-biao-zhi-wei-que-shi-1">对象从没进入同步块，为什么偏向锁标志位却是1？</span><a href="#dui-xiang-cong-mei-jin-ru-tong-bu-kuai-wei-shi-me-pian-xiang-suo-biao-zhi-wei-que-shi-1" class="header-anchor">#</a></h3><p>上面这个问题说过，没进入同步块， 不会上偏向锁。</p>
<p>但是我们如果用java的jol工具测试打印新对象，会看到低3位是101</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655537149976.png" alt="1655537149976"></p>
<p>这其实是jvm后面加入的一种优化， 对每个新对象，预置了一个<strong>“可偏向状态”</strong>，也叫做<strong>匿名偏向状态</strong>，是对象初始化中，JVM 帮我们做的。 </p>
<p>注意此时 markword中高位是不存在ThreadID的， 都是0， 说明此时并没有线程偏向发生，因此也可以理解成是无锁。</p>
<p>好处在于后续做偏向锁加锁时，无需再去改动偏向锁标记位，只需要对线程id做cas即可。</p>
<h2><span id="pian-xiang-suo">偏向锁</span><a href="#pian-xiang-suo" class="header-anchor">#</a></h2><p>一旦代码第一次进入sync同步方法块，就<strong>可能</strong>从无锁状态进入偏向锁状态。</p>
<p>另外很多人应该都知道， 偏向锁只存储了当前偏向的线程id， 只有线程id不同的才会触发升级。</p>
<p>但这是非常简化的说法， 实际上中间的细节和优化非常之多！这里将为你详细讲述。</p>
<h3><span id="wei-shi-me-yao-you-pian-xiang-suo">为什么要有偏向锁？</span><a href="#wei-shi-me-yao-you-pian-xiang-suo" class="header-anchor">#</a></h3><p>理解这个才能理解偏向锁中的各种设计。   假设我们new出来的对象带有同步代码块方法，但在整个生命周期中只被一个线程访问，那么是否有必要做消耗消耗的竞争动作，甚至引入额外的内存开销？没有必要。 </p>
<p>因此针对的是 <strong>对象有同步方法调用，但是实际不存在竞争的场景</strong></p>
<h3><span id="pian-xiang-suo-de-markword-xiang-jie">偏向锁的markword详解</span><a href="#pian-xiang-suo-de-markword-xiang-jie" class="header-anchor">#</a></h3><p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655534605569.png" alt="1655534605569"></p>
<p>这个markword和无锁对比，  偏向标志位变成了1，   hashcode没了，多了个epoch和线程id。</p>
<h4><span id="markword-zhong-de-dang-qian-xian-cheng-id">markword中的当前线程id</span><a href="#markword-zhong-de-dang-qian-xian-cheng-id" class="header-anchor">#</a></h4><p>这个id就是在进入了对象同步代码块的线程id。</p>
<h5><span id="java-de-xian-cheng-id-shi-yi-ge-long-lei-xing-an-li-shuo-shi-64-wei-dan-wei-shi-me-zhi-lei-de-xian-cheng-id-zhi-you-54-wei">java的线程id是一个long类型， 按理说是64位，但为什么之类的线程id只有54位？</span><a href="#java-de-xian-cheng-id-shi-yi-ge-long-lei-xing-an-li-shuo-shi-64-wei-dan-wei-shi-me-zhi-lei-de-xian-cheng-id-zhi-you-54-wei" class="header-anchor">#</a></h5><p>具体没有找到解释，可能是jvm团队认为54位线程id足够用了，不至于会创建2^54那么多的线程，真的有需要创建这么频繁的程序，也会优先采用线程池池才对</p>
<h5><span id="xian-cheng-id-ru-he-xie-ru">线程id如何写入？</span><a href="#xian-cheng-id-ru-he-xie-ru" class="header-anchor">#</a></h5><p>线程id是直接写入markword吗？ 不对， 一定要注意到这时候是存在同时写的可能的。</p>
<p>因此会<strong>采用CAS的方式进行线程id的写入</strong>。 简而言之， 就是先取原线程id后，再更新线程id，更新后检查一下是否和预期一致，不一致则说明被人改动过，则线程id写入失败，说明存在竞争，升级为轻量级锁。</p>
<h4><span id="ha-xi-code-qu-na-liao">哈希code去哪了</span><a href="#ha-xi-code-qu-na-liao" class="header-anchor">#</a></h4><p>我们注意到无锁时的hashcode不见了。</p>
<p>对于偏向锁而言， <strong>一旦在对象头中设置过hashcode， 那么进入同步块时就不会进入偏向锁状态</strong>，会直接跳到轻量级锁，毕竟偏向锁里没有存放hashcode的地方（下文的轻量级锁和重量级锁则有存储的地方）</p>
<p>因此凡是做过类似hashmap.put(k,v)操作且没覆写hashcode的k对象， 以后加锁时，都会直接略过偏向锁。</p>
<h4><span id="epoch-shi-shi-me">epoch是什么？</span><a href="#epoch-shi-shi-me" class="header-anchor">#</a></h4><p>这个属性很多人叫它“偏向时间戳”， 却鲜有人进行详细解释。</p>
<p>主要是因为它涉及到了偏向锁中非常重要的2个优化（批量重偏向和批量撤销）</p>
<p>对于这个epoch，放到下文的偏向锁解锁过程进行解释。 </p>
<p>你可以先简单理解为，<strong>通过epoch，jvm可以知道这个对象的偏向锁是否过期了，过期的情况下允许直接试图抢占，而不进行撤销偏向锁的操作。</strong></p>
<h3><span id="pian-xiang-suo-yun-zuo-xiang-jie">偏向锁运作详解</span><a href="#pian-xiang-suo-yun-zuo-xiang-jie" class="header-anchor">#</a></h3><h4><span id="pian-xiang-suo-shang-suo-shi-ru-he-bi-mian-chong-tu-he-jing-zheng">偏向锁上锁时，如何避免冲突和竞争？</span><a href="#pian-xiang-suo-shang-suo-shi-ru-he-bi-mian-chong-tu-he-jing-zheng" class="header-anchor">#</a></h4><p>我们知道偏向锁其实就是将线程id设置了进去，但是如果存在冲突怎么办？</p>
<p>因此，jmv会<strong>通过CAS</strong>来设置偏向线程id，一旦设置成功那么这个偏向锁就算挂上了。</p>
<p>后面每次访问时，检查线程id一致，就直接进入同步代码块执行了。</p>
<blockquote>
<p>CAS概念补充： </p>
<p>CAS是一个原子性操作， 调用者需要给定修改变量的期望值 和 最终值  </p>
<p>当内存中该变量的值和期望值相等时，才更新为最终值，   这个相等的比较和更新的操作是原子操作</p>
</blockquote>
<p>对于到偏向锁加锁过程， 其实就是先取出线程id部分， 如果为空， 则进行（期望值：空  ， 最终值：当前线程id）的CAS操作， 如果发现期望值不匹配，就说明被抢先了 。</p>
<h4><span id="chi-kai-tong-bu-dai-ma-kuai-shi-markword-zhong-de-xian-cheng-id-hui-chong-xin-bian-wei-0-ma">离开同步代码块时， markword中的线程id会重新变为0吗？</span><a href="#chi-kai-tong-bu-dai-ma-kuai-shi-markword-zhong-de-xian-cheng-id-hui-chong-xin-bian-wei-0-ma" class="header-anchor">#</a></h4><p>并不会，这个偏向锁线程id会一直挂着， 后面只要识别到id一致，就不用做特殊处理。</p>
<h4><span id="pian-xiang-suo-fa-sheng-jing-zheng-shi-de-qie-suo-huo-zhe-sheng-ji-cao-zuo">偏向锁发生竞争时的切锁或者升级操作。</span><a href="#pian-xiang-suo-fa-sheng-jing-zheng-shi-de-qie-suo-huo-zhe-sheng-ji-cao-zuo" class="header-anchor">#</a></h4><p>但当有其他线程来访问时，之前设置的偏向锁就有问题了，说明存在多线程访问同一个对象的情况。</p>
<p><strong>注意！！！这里并非像很多资料里说的那样， 一旦发生多线程调用， 偏向锁就升级成轻量级锁</strong>，而是做了很多的细节处理，来尽可能避免轻量级锁这种耗费CPU的操作。</p>
<p>首先，jvm考虑到了这种场景：</p>
<p>最开始1h内，都是线程A在调用大量的对象obj， 于是偏向锁一直都是线程A。</p>
<p>后来线程A不跑了， 对象obj的调用交给了线程B，即未来都是线程B来调用。</p>
<p>那么这时候，有必要马上升级轻量级锁吗？ </p>
<p>没必要！因为未来仍然是单线程调用，仅仅是线程不同而已，也许可以尝试仍旧用偏向锁？</p>
<p>于是就有了如下的撤销偏向锁的动作：</p>
<ol>
<li>当线程B发现是偏向锁，且线程id不为自己时，开始撤销操作</li>
<li>首先，线程B会一直等待 对象obj 到达jvm<strong>安全点</strong>。</li>
<li>到达安全点后， 线程B检查线程A是否正处在obj的同步代码块内。</li>
<li>如果线程A正在同步代码块中， 则没得商量了，直接升级为轻量级锁。</li>
<li>如果线程A不在同步代码块中， 那么线程B还有机会， 它先把偏向锁改成无锁状态，然后再用CAS的方式尝试重新竞争，如果能竞争到，那么就会偏向自己。</li>
</ol>
<p>完整过程如下图所示：</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655599370757.png" alt="1655599370757"></p>
<h5><span id="wei-shi-me-yao-deng-dai-an-quan-dian-cai-neng-zuo-che-xiao-cao-zuo">为什么要等待安全点，才能做撤销操作？</span><a href="#wei-shi-me-yao-deng-dai-an-quan-dian-cai-neng-zuo-che-xiao-cao-zuo" class="header-anchor">#</a></h5><p>这是为了保证撤销操作的安全性。否则可能出现jvm正在撤销的时候， 另一个线程又开始对该对象做操作，引发错误。</p>
<h5><span id="wei-shi-me-yao-xian-tui-hua-cheng-wu-suo-zhuang-tai-zai-shi-tu-jing-zheng-cheng-pian-xiang-suo-bu-neng-zhi-jie-pian-xiang-ma">为什么要先退化成无锁状态，再试图竞争成偏向锁？不能直接偏向吗？</span><a href="#wei-shi-me-yao-xian-tui-hua-cheng-wu-suo-zhuang-tai-zai-shi-tu-jing-zheng-cheng-pian-xiang-suo-bu-neng-zhi-jie-pian-xiang-ma" class="header-anchor">#</a></h5><p>因为你无法预测A是否会卷土重来，置成无锁后， A和B可以公平竞争。</p>
<h5><span id="wei-shi-me-yuan-pian-xiang-xian-cheng-zai-tong-bu-dai-ma-kuai-zhong-shi-jiu-bi-xu-sheng-ji-wei-qing-liang-ji-suo-neng-fou-tong-yang-che-xiao-wu-suo-lai-jing-zheng">为什么原偏向线程在同步代码块中时，就必须升级为轻量级锁？能否同样撤销无锁来竞争？</span><a href="#wei-shi-me-yuan-pian-xiang-xian-cheng-zai-tong-bu-dai-ma-kuai-zhong-shi-jiu-bi-xu-sheng-ji-wei-qing-liang-ji-suo-neng-fou-tong-yang-che-xiao-wu-suo-lai-jing-zheng" class="header-anchor">#</a></h5><p>不可以，因为同步代码块还在执行的话，那B线程此时是注定无法立刻得到锁的，注定了它必须升级为轻量级锁，通过轻量级锁中的循环能力来做获取锁的操作。</p>
<h4><span id="pi-liang-chong-pian-xiang-yi-ji-epoch-de-ying-yong">批量重偏向，以及epoch的应用</span><a href="#pi-liang-chong-pian-xiang-yi-ji-epoch-de-ying-yong" class="header-anchor">#</a></h4><p>上文提到，  线程B重新抢偏向锁时，会试图等待安全点，撤销成无锁，再做公平抢占。 这个动作还是比较费时的。</p>
<p>假设有一个场景， 我们new 了30个obj对象， 最初都是由A线程使用，后面通过for循环都由B线程使用，那么会发现在很短的时间内，连续发生了偏向锁撤销为无锁，且未因同步块竞争而发生轻量升级的情况。</p>
<p>那么，jvm猜测此时后面都是类似的情况，于是B线程调用obj对象时，不再撤销了，直接CAS竞争threadId，因为jvm预测A不会来抢了，具体步骤如下所示：</p>
<ol>
<li><p>jvm会在obj对象的<strong>类class对象</strong>中， 定义了一个偏向撤销计数器以及epoch偏向版本。</p>
</li>
<li><p>每当有一个对象被撤销偏向锁， 都会让偏向撤销计数器+1。 </p>
</li>
<li><p>一旦加到20， 则认为出现大规模的锁撤销动作。 于是class类对象中的epoch值+1（但是epoch一般只有2位即0~3）。</p>
</li>
<li><p>接着， jvm会找到所有正处在同步代码块中的obj对象， 让他的epoch等于class类对象的epoch。</p>
</li>
<li><p>其他不在同步代码块中的obj对象，则不修改epoch。</p>
</li>
<li><p>当B线程来访问时，发现obj对象的epoch和class对象的epoch不相等，则不再做撤销动作，直接CAS抢占。  <strong>因为当epoch不等时，这说明该obj对象之前一直没被原主人使用， 但它的兄弟们之前纷纷投降倒戈了， 那我应该直接尝试占用就好，没必要那么谨慎了！</strong></p>
</li>
</ol>
<p>详细过程如下图所示：</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655542634901.png" alt="1655542634901"></p>
<h4><span id="pi-liang-che-xiao">批量撤销</span><a href="#pi-liang-che-xiao" class="header-anchor">#</a></h4><p>但如果短时间内该类的撤销动作超过40个， jvm会认为这个数量太多了， 不保险，数量一多，预测就不准了。</p>
<p>jvm此时会将 obj对象的类class对象中的偏向标记<strong>（注意是类中的偏向锁开启标记，而不是对象头中的偏向锁标记）</strong>设置为禁用偏向锁。  后续该对象的new操作将直接走轻量级锁的逻辑。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655600519145.png" alt="1655600519145"></p>
<h4><span id="pian-xiang-suo-zai-jin-cheng-yi-kai-shi-jiu-qi-yong-liao-ma">偏向锁在进程一开始就启用了吗</span><a href="#pian-xiang-suo-zai-jin-cheng-yi-kai-shi-jiu-qi-yong-liao-ma" class="header-anchor">#</a></h4><p>即使你开启了偏向锁，但是这个偏向锁的启用是有延迟，大概 4s左右。</p>
<p><strong>即java进程启动的4s内，都会直接跳过偏向锁</strong>，有同步代码块时直接使用轻量级锁。</p>
<p>原因是 JVM 初始化的代码有很多地方用到了synchronized，如果直接开启偏向，产生竞争就要有锁升级，会带来额外的性能损耗，jvm团队经过测试和评估， 选择了启动速度最快的方案， 即强制4s内禁用偏向锁，所以就有了这个延迟策略 （当然这个延迟时间也可以通过参数自己调整）</p>
<h3><span id="pian-xiang-suo-de-chong-yao-yan-bian-li-shi-he-si-kao">偏向锁的重要演变历史和思考</span><a href="#pian-xiang-suo-de-chong-yao-yan-bian-li-shi-he-si-kao" class="header-anchor">#</a></h3><p>偏向锁在JDK6引入,  且默认开启偏向锁优化, 可通过JVM参数-XX:-UseBiasedLocking来禁用偏向锁。</p>
<p>jdk的演变过程中， 为偏向锁做了如上所述的批量升级、撤销等诸多动作。</p>
<p>但随着时代发展，发现偏向锁带来的维护、撤销成本， 远大于轻量级锁的少许CAS动作。</p>
<p>官方说明中有这么一段话: since the introduction of biased locking into HotSpot also change the amount of uncontended operations needed for that relation to remain true。</p>
<p>即<strong>随着硬件发展，原子指令成本变化，导致轻量级自旋锁需要的原子指令次数变少(或者cas操作变少 个人理解)，所以自旋锁成本下降，故偏向锁的带来的优势就更小了</strong>。</p>
<p>于是jdk团队<strong>在Jdk15之后， 再次默认关闭了偏向锁</strong>。</p>
<p>也许你会问，那前面学习了那么一堆还有啥意义，都不推荐使用了。</p>
<p>但大部分java应用还是基于jdk8开发的， 并且偏向锁里的思想还是值得借鉴的。</p>
<p>还有就是奥卡姆剃刀原理， 如果增加的内容带来很大的成本，不如大胆的废除掉，接受一点落差，将精力放在提升度更大的地方。</p>
<h2><span id="qing-liang-ji-suo">轻量级锁</span><a href="#qing-liang-ji-suo" class="header-anchor">#</a></h2><p>轻量级锁的markword如下所示，可以看到除了锁状态标记位，其他的都变成了一个栈帧中lockRecord记的地址。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1655603492133.png" alt="1655603492133"></p>
<h3><span id="yuan-xian-markword-zhong-de-xin-xi-du-qu-na-li-liao">原先markword中的信息都去哪里了？</span><a href="#yuan-xian-markword-zhong-de-xin-xi-du-qu-na-li-liao" class="header-anchor">#</a></h3><p>之前提到markword中有分代年龄、cms_free、hashcode等固有属性。</p>
<p>这些信息会被存储到对应线程栈帧中的<strong>lockRecord</strong>中。</p>
<p>lockRecord格式以及存储/交换过程如下：</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656209393501.png" alt="1656209393501"></p>
<p>**另外注意， 当轻量级锁未上锁时， 对象头中的markword存储的还是markword内容，并没有变成指针，只有当上锁过程中，才会变成指针。 **</p>
<p><strong>因此轻量级锁是存在反复的加锁解锁操作的（偏向锁只有在更换偏向线程时才会有类似动作）</strong></p>
<p>解锁过程同理，通过CAS，将对象头替换回去。</p>
<h3><span id="qing-liang-ji-suo-ru-he-chu-li-xian-cheng-chong-ru-wen-ti">轻量级锁如何处理线程重入问题？</span><a href="#qing-liang-ji-suo-ru-he-chu-li-xian-cheng-chong-ru-wen-ti" class="header-anchor">#</a></h3><p>对于同一个线程，如果反复进入同步块，在sync语义上来说是支持重入的（即持有锁的线程可以多次进入锁区域）， 对轻量级锁而言，必须实现这个功能。</p>
<p>因此线程的lockRecord并非单一成员，<strong>他其实是一个lockRecord集合，可以存储多个lockRecord</strong>。</p>
<p>每当线程离开同步块，lockRecord减少1个， 直到这个lockReocrd中包含指针，才会做解锁动作。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656209539382.png" alt="1656209539382"></p>
<h3><span id="qing-liang-ji-suo-jia-suo-guo-cheng">轻量级锁加锁过程</span><a href="#qing-liang-ji-suo-jia-suo-guo-cheng" class="header-anchor">#</a></h3><p>根据上述CAS和重入相关，可以得到进入同步代码块时的加锁过程：</p>
<ol>
<li><p>进入同步块前，检查是否已经储存了lockRecord地址，且地址和自己当前线程一致 。如果已经存了且一致，说明正处于重入操作，走重入逻辑，新增lockRecord</p>
</li>
<li><p>如果未重入，检查lockRecord是否被其他线程占用，如果被其他线程占用，则自旋等待，自旋超限后升级重量级锁</p>
</li>
<li><p>如果未重入，且也没被其他线程占用，则取出lockRecord中存的指针地址，然后再用自己的markword做CAS替换</p>
</li>
<li><p>替换失败，则尝试自旋重新CAS，失败次数达到上限，也一样升级</p>
<p> <img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/62b7cb401e0853156072c623-1656212698507.png" alt="img">  </p>
</li>
</ol>
<h3><span id="qing-liang-ji-suo-de-jie-suo-liu-cheng">轻量级锁的解锁流程</span><a href="#qing-liang-ji-suo-de-jie-suo-liu-cheng" class="header-anchor">#</a></h3><p>根据上面重入的问题，可以得到轻量级锁的退出流程如下：</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656211852407.png" alt="1656211852407"></p>
<h3><span id="zi-xuan-ci-shu-de-shang-xian-yi-ding-shi-10-ci-ma">自旋次数的上限一定是10次吗？</span><a href="#zi-xuan-ci-shu-de-shang-xian-yi-ding-shi-10-ci-ma" class="header-anchor">#</a></h3><p>在JDK 6中对自旋锁的优化，引入了自适应的自旋。</p>
<p>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。</p>
<p>另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了</p>
<h2><span id="chong-liang-ji-suo">重量级锁</span><a href="#chong-liang-ji-suo" class="header-anchor">#</a></h2><p>重量级锁如下：</p>
<p>每个对象会有一个objectMonitor的C++对象生成， 通过地址指向对方，后面的逻辑都是通过C++来实现。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656831726425.png" alt="1656831726425"></p>
<h3><span id="sheng-ji-wei-chong-liang-ji-suo-de-tiao-jian">升级为重量级锁的条件</span><a href="#sheng-ji-wei-chong-liang-ji-suo-de-tiao-jian" class="header-anchor">#</a></h3><ol>
<li><p>从轻量级锁升级为重量级锁的条件：  自旋超过10次 或者达到自适应自旋上限次数</p>
</li>
<li><p>从无锁/偏向锁直接升级为重量级锁的条件：<strong>调用了object.wait()方法，则会直接升级为重量级锁！</strong></p>
<p>第二个条件容易被忽略的</p>
</li>
</ol>
<h2><span id="markword-qu-na-liao">markword去哪了</span><a href="#markword-qu-na-liao" class="header-anchor">#</a></h2><p>对象头中的markwod，和轻量级锁中的处理类似， 被存入了objectMonitor对象的header字段中了。</p>
<h3><span id="chong-liang-ji-suo-tong-bu-de-yuan-li-tu-jie">重量级锁同步的原理图解</span><a href="#chong-liang-ji-suo-tong-bu-de-yuan-li-tu-jie" class="header-anchor">#</a></h3><p>每个对象的重量级锁指向一个独有的objectMonitor</p>
<p>这个对象是C++实现的</p>
<p>里面的东西比较多，内容非常复杂，里面关于cxq、entryList、qmod之间的关系非常复杂，这里只会简单解释部分过程，不一定全部正确或者包含所有细节。</p>
<p>因此特地拿出一句我认为说的很好的话：</p>
<p><strong>“与其费劲心机研究C++实现的objectMonitor，不如去研究使用java实现的AQS原理，二者的核心思想大部分一致，AQS源码在语言上对java人而言更为友好 ，能让你更好理解线程排队、等待、唤醒的各种过程”</strong></p>
<p>但这篇文章毕竟说的是sync关键字，所以还是简要说一下monitor的过程：</p>
<ol>
<li><p>当线程第一次调用monitorEntry执行且是重量级锁的情况下，会先进入cxq队列</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836560641.png" alt="1656836560641"></p>
</li>
<li><p>当涉及锁的频繁竞争且需要阻塞时，需要进入entryList队列中。 </p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836632599.png" alt="1656836632599"></p>
</li>
<li><p>如果线程能CAS竞争到onwer指针，就说明占有同步代码块成功， 如果CAS竞争不到，则block阻塞。</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836734369.png" alt="1656836734369"></p>
</li>
<li><p>monitorExit退出时，会让entryList中block阻塞的线程唤醒重新竞争</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836830029.png" alt="1656836830029"></p>
</li>
<li><p>如果调用了object.wait()方法， onwer线程会进入等待队列（注意，因为竞争失败的线程，不会进入waitSet，waitSet只服务于那些wait()方法引发的线程）</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836839076.png" alt="1656836839076"></p>
</li>
<li><p>当调用的object.notify()或者notifyAll， 等待队列中的线程会根据qmod模式的不同，进入cxq或者进入entryList。</p>
</li>
</ol>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836900003.png" alt="1656836900003"></p>
<p>简要版流程如下：</p>
<p><img src="/images/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/1656836348826.png" alt="1656836348826"></p>
<h1><span id="guan-yu-synchronized-guan-jian-zi-de-si-kao">关于synchronized关键字的思考</span><a href="#guan-yu-synchronized-guan-jian-zi-de-si-kao" class="header-anchor">#</a></h1><p>终于写完了，说点其他的。</p>
<p>众所周知，随着jdk的不断升级， 官方提供的JUC以及衍生同步组件越来越强大， sync与其相比，功能相当少，背后逻辑却异常复杂，甚至因为过于复杂，还在中间对偏向锁的功能进行了默认关闭的操作。</p>
<p>那么这个关键字是否还有存在的必要呢？</p>
<p>首先，很多历史代码以及内部某些jdk代码实现，都还是会依赖这个关键字进行同步处理，没法全部替换成AQS。</p>
<p>另外，不考虑背后升级的复杂逻辑， sync使用起来绝对是比JUC简单很多的， 当你的场景很简单，但确实有同步的问题， 用sync会提升不少开发的效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">volatile和CPU-MESI协议底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-08 07:29:34 / 修改时间：08:02:57" itemprop="dateCreated datePublished" datetime="2022-06-08T07:29:34+08:00">2022-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/08/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>《深入理解Java虚拟机》第二版中，关于volatile的原理，特地先讲述了如下图所示的JMM内存模型：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652969587838877545.png" alt="image.png"><br>它用了8种内存操作，以及多种规则，来告诉你特定情况下线程间的数据会如何同步。<br><strong>然而这个模型实际上已经在JDK5之后的虚拟机规范中被废弃了。</strong><br>最新官方文档中是采用“happens-before”模型来帮助java程序员分析多线程环境下的运行情况。<br>关于happends-before模型的详细解释，建议阅读《java并发编程的艺术》一书的第三章节。<br>本文并不讨论happends-before模型，只讨论底层原理，希望借着理解volatile，去理解一下它和CPU之间的关系。关于这部分内容，网上其实有很多错误的解读，根本原因在于没有从真正底层运行的原理考虑，导致了很多误区的产生。</p>
<p>本文将为你解答一下三大误区问题：</p>
<ol>
<li>MESI缓存一致性，为什么要设置4种状态这么复杂？是否都是同步、阻塞地保证缓存一致？</li>
<li>更新变量后，另一个线程真的永远不可见吗？多线程问题的本质是什么？</li>
<li>volatile保证一致性的真正底层运行逻辑是什么？</li>
</ol>
<p>以上问题，我将从CPU的层面，以超长图解和文字的形式，为你完整呈现。</p>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jmm-nei-cun-mo-xing-he-cpu">JMM内存模型和CPU</a><ul>
<li><a href="#wei-shi-me-xu-yao-zhe-ge-jmm-mo-xing-yong-lai-zuo-shi-me-de">为什么需要这个JMM模型？用来做什么的？</a></li>
<li><a href="#shang-shu-mo-xing-he-bei-hou-cao-zuo-xi-tong-cpu-shi-xian-you-shi-me-guan-xi-gong-zuo-nei-cun-dui-ying-shi-me-zhu-nei-cun-dui-ying-shi-me">上述模型和背后操作系统、CPU实现有什么关系？工作内存对应什么，主内存对应什么？</a></li>
<li><a href="#shi-me-shi-cpu-huan-cun-cpu-huan-cun-chang-shi-me-yang">什么是CPU缓存？CPU缓存长什么样？</a></li>
<li><a href="#2-ge-cpu-tong-shi-geng-xin-shu-ju-shi-you-shi-me-ban-fa-bi-mian-tong-shi-xiu-gai-zhu-cun">2个CPU同时更新数据时，有什么办法避免同时修改主存？</a></li>
</ul>
</li>
<li><a href="#mesi-xie-yi-chao-ji-xiang-jie">MESI协议超级详解</a><ul>
<li><a href="#wei-shi-me-yao-she-ji-du-zhan-zhuang-tai">为什么要设计独占状态？</a></li>
<li><a href="#wei-shi-me-cpu2-dui-a-zhi-de-huo-qu-neng-gou-xiu-gai-cpu1-de-zhuang-tai">为什么CPU2对a值的获取，能够修改CPU1的状态？</a></li>
<li><a href="#xiu-gai-wan-m-zhuang-tai-hou-fa-sheng-liao-shi-me-shi-zhi-jie-tong-bu-hui-nei-cun-ma">修改完M状态后，发生了什么？是直接同步回内存吗？</a></li>
<li><a href="#bu-ke-jian-de-wu-qu-li-zi">不可见的误区例子</a></li>
</ul>
</li>
<li><a href="#chong-tou-xi-you-mesi-bao-zheng-ke-jian-xing-de-xia-wei-shi-me-huan-you-hui-duo-xian-cheng-wen-ti">重头戏：有MESI保证可见性的下，为什么还有会多线程问题？</a><ul>
<li><a href="#cpu1-deng-dai-qi-ta-cpu-qing-kong-huan-cun-de-zu-sai-deng-dai-xing-wei-hui-bu-hui-tai-man-liao">CPU1等待其他CPU清空缓存的阻塞等待行为会不会太慢了？</a></li>
<li><a href="#you-shi-me-ban-fa-neng-jia-kuai-xiang-ying-su-du-invalid-xiao-xi-de-xiang-ying-su-du-ni">有什么办法能加快响应速度Invalid消息的响应速度呢？</a></li>
<li><a href="#duo-xian-cheng-wen-ti-yu-storebuffer-invalid-queue-zhi-jian-de-guan-xi">多线程问题与StoreBuffer、Invalid-Queue之间的关系</a></li>
</ul>
</li>
<li><a href="#volatile-you-shi-ru-he-bi-mian-cpu-geng-xin-yan-chi-wen-ti-de">volatile又是如何避免CPU更新延迟问题的？</a></li>
<li><a href="#tu-jie-zong-jie">图解总结</a></li>
</ul>
<!-- tocstop -->

</div>

<hr>
<p>[toc]</p>
<h1><span id="jmm-nei-cun-mo-xing-he-cpu">JMM内存模型和CPU</span><a href="#jmm-nei-cun-mo-xing-he-cpu" class="header-anchor">#</a></h1><h2><span id="wei-shi-me-xu-yao-zhe-ge-jmm-mo-xing-yong-lai-zuo-shi-me-de">为什么需要这个JMM模型？用来做什么的？</span><a href="#wei-shi-me-xu-yao-zhe-ge-jmm-mo-xing-yong-lai-zuo-shi-me-de" class="header-anchor">#</a></h2><p>这是为了给java开发者提供屏蔽平台差异性的、统一的多线程执行语义<br>不同的操作系统或者不同的CPU，其对多线程并发问题的支持情况是不同的，但jvm尽量在背后将其实现成一套统一的逻辑。<br><strong>即你按照我的关键字操作，就可以像JMM模型里那样运作，不需要关心背后的CPU怎么跑的</strong></p>
<h2><span id="shang-shu-mo-xing-he-bei-hou-cao-zuo-xi-tong-cpu-shi-xian-you-shi-me-guan-xi-gong-zuo-nei-cun-dui-ying-shi-me-zhu-nei-cun-dui-ying-shi-me">上述模型和背后操作系统、CPU实现有什么关系？工作内存对应什么，主内存对应什么？</span><a href="#shang-shu-mo-xing-he-bei-hou-cao-zuo-xi-tong-cpu-shi-xian-you-shi-me-guan-xi-gong-zuo-nei-cun-dui-ying-shi-me-zhu-nei-cun-dui-ying-shi-me" class="header-anchor">#</a></h2><p><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652969950678545272.png" alt="image.png"></p>
<ul>
<li>主内存对应于java堆中的对象实例部分（物理硬件的内存）</li>
<li>工作内存对应于虚拟机栈中的部分区域（ 寄存器，高速缓存， 线程主要访问读写的都是工作内存）</li>
</ul>
<h2><span id="shi-me-shi-cpu-huan-cun-cpu-huan-cun-chang-shi-me-yang">什么是CPU缓存？CPU缓存长什么样？</span><a href="#shi-me-shi-cpu-huan-cun-cpu-huan-cun-chang-shi-me-yang" class="header-anchor">#</a></h2><p>CPU缓存可以理解为一个容量有限的哈希表。<br>将某地址数据根据地址做哈希，映射到缓存的某一行，并且有替换的情况。<br>而划分两列，则是避免一出现hash冲突，就马上淘汰原内容的情况。<br>因此增加了备用列。通过这样一个多行两列的结构，根据内存地址实现了缓存的功能。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652970057734778836.png" alt="image.png"></p>
<h2><span id="2-ge-cpu-tong-shi-geng-xin-shu-ju-shi-you-shi-me-ban-fa-bi-mian-tong-shi-xiu-gai-zhu-cun">2个CPU同时更新数据时，有什么办法避免同时修改主存？</span><a href="#2-ge-cpu-tong-shi-geng-xin-shu-ju-shi-you-shi-me-ban-fa-bi-mian-tong-shi-xiu-gai-zhu-cun" class="header-anchor">#</a></h2><ul>
<li>一种方式是使用总线锁：确保CPU在持有总线锁期间，处理器可以独占任何共享内存。</li>
</ul>
<p>总线锁的代价是开销很大，其他CPU会一直在等待总线释放，读和写操作都无法处理。</p>
<ul>
<li>另一种方式是缓存锁，锁住各自的缓存，并<strong>通过缓存一致性协议MESI来进行和主存的同步。</strong></li>
</ul>
<h1><span id="mesi-xie-yi-chao-ji-xiang-jie">MESI协议超级详解</span><a href="#mesi-xie-yi-chao-ji-xiang-jie" class="header-anchor">#</a></h1><p>画了很多张图，顺便带上很多文字，来解释MESI协议的原理：<br>首先，CPU1和CPU2中的缓存都是空的， 因此缓存状态位是“I”（Invalid）<br>后面会相继提到各个状态的变化。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652970611412999019.png" alt="image.png"></p>
<hr>
<p>此时主存会将a的数据返回给CPU1， 并把CPU1的缓存状态<strong>设置为独占E（Exclude)</strong><br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652970706864127998.png" alt="image.png"></p>
<h2><span id="wei-shi-me-yao-she-ji-du-zhan-zhuang-tai">为什么要设计独占状态？</span><a href="#wei-shi-me-yao-she-ji-du-zhan-zhuang-tai" class="header-anchor">#</a></h2><p>目的是为了<strong>减少不必要的全局同步消息。</strong><br>当这个a变量只有CPU1使用时，无论CPU1怎么修改，也只有CPU1在查看，没必要把信息同步给其他CPU，从而提升了效率， 对于一些不参与竞争的变量来说，非常有用。</p>
<hr>
<p>好，独占的问题搞定，那么当CPU2也读取时，会发生什么？<br>此时就会不再是独占状态了，2个CPU同时被修改为共享状态S（Share）<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652971231021900637.png" alt="image.png"></p>
<h2><span id="wei-shi-me-cpu2-dui-a-zhi-de-huo-qu-neng-gou-xiu-gai-cpu1-de-zhuang-tai">为什么CPU2对a值的获取，能够修改CPU1的状态？</span><a href="#wei-shi-me-cpu2-dui-a-zhi-de-huo-qu-neng-gou-xiu-gai-cpu1-de-zhuang-tai" class="header-anchor">#</a></h2><p>这是因为CPU可以通过总线广播+监听消息来变更状态， 也称嗅探机制。<br><strong>即CPU核心都会经常监听总线上的广播事件，根据事件（消息）类型，来做不同的应对。</strong><br>因此当CPU2更改后，总线会广播read消息，当CPU1收到read消息，并确认这个数据的地址和自己缓存中的地址是一致的时候，就会修改状态为S了。</p>
<hr>
<p>上述问题搞定，再看最关键的<strong>修改缓存</strong>的部分了！</p>
<ol>
<li>当CPU1触发对a变量的修改时，会先发送一个Invalid消息。</li>
<li>CPU1此时会等待不动，停止任何操作，类似于阻塞了，它在等待其他CPU给他回应。</li>
<li>当其他的CPU收到Invalid消息时，会将缓存中的a变量修改为I（Invalid）无效状态</li>
<li>当所有CPU都处理完成时，总线为CPU1返回Invalid ack消息，CPU1才放心的将S状态修改为了M（modify）状态。<br>结合下面的图进行阅读更佳，注意图中的序号：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652971828729412023.png" alt="image.png"><br>很容易想到， 要将其他CPU设置为无效的原因，是为了保证其他CPU后面再次试图取a值时，取到的是最新的，而不是缓存的错误数据。</li>
</ol>
<h2><span id="xiu-gai-wan-m-zhuang-tai-hou-fa-sheng-liao-shi-me-shi-zhi-jie-tong-bu-hui-nei-cun-ma">修改完M状态后，发生了什么？是直接同步回内存吗？</span><a href="#xiu-gai-wan-m-zhuang-tai-hou-fa-sheng-liao-shi-me-shi-zhi-jie-tong-bu-hui-nei-cun-ma" class="header-anchor">#</a></h2><p>不是的！M状态此时就像“独占状态”一样，贪婪地占有这个缓存，后续的修改、读取，都直接读这个缓存，不再走任何总线</p>
<p>其目的和独占状态E一样，都是为了减少非竞争情况下不必要的总线消耗<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652972577879290980.png" alt="image.png"></p>
<hr>
<p>那么什么时候Modify状态会变化呢？<br>当其他的CPU试图获取a值，就会发生变化。其过程与 Exclude独占状态到Share状态 是类似的<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652972743188732799.png" alt="image.png"><br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652972759885249610.png" alt="image.png"></p>
<p>上面的内容给我一种感觉，MESI协议中，一直在给我们传达一个信息：<strong>MESI设置那么多状态，主要是为了避免每次都竞争。竞争只是偶然发生的，我们要尽可能少地乱锁总线！</strong></p>
<h2><span id="bu-ke-jian-de-wu-qu-li-zi">不可见的误区例子</span><a href="#bu-ke-jian-de-wu-qu-li-zi" class="header-anchor">#</a></h2><p>从上面可以看到，当我们修改缓存时，会通过触发对其他缓存的无效化，达到变量对其他线程“可见”的效果。<br>因此，<strong>MESI缓存一致性协议已经实现了缓存的可见性</strong>，<br>下面这种例子中，当flag=true时， 其他CPU通过MESI协议，是能够感知到flag的变化的，因为缓存一定会在那个时刻被设置为无效，从而获取最新的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">               num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//输出结果</span></span><br><span class="line">	<span class="number">1255362997</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="chong-tou-xi-you-mesi-bao-zheng-ke-jian-xing-de-xia-wei-shi-me-huan-you-hui-duo-xian-cheng-wen-ti">重头戏：有MESI保证可见性的下，为什么还有会多线程问题？</span><a href="#chong-tou-xi-you-mesi-bao-zheng-ke-jian-xing-de-xia-wei-shi-me-huan-you-hui-duo-xian-cheng-wen-ti" class="header-anchor">#</a></h1><p>首先可以看这个知乎问题的回答，如果看不懂，可以看我为你整理的详细解释：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/277395220">https://www.zhihu.com/question/277395220</a></p>
<hr>
<p>每个java线程有自己的寄存器。<br>线程寄存器和CPU缓存的关系？</p>
<hr>
<p>上面的MESI协议图中，其实缺少了2个关键的优化，这2个优化点，也成了可见性问题的根源。<br>为了好好讲清楚这2个优化点带来的影响，我特地放到这里才讲述，也将会帮助你大大理解“可见性”问题的本质！</p>
<p>首先我们回到CPU1修改a值时的那张图：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652973240336374790.png" alt="image.png"></p>
<p>里面提到，CPU1会等待所有CPU都将状态位置为I（无效）后，才开始修改状态并更新。那么有个问题：</p>
<h2><span id="cpu1-deng-dai-qi-ta-cpu-qing-kong-huan-cun-de-zu-sai-deng-dai-xing-wei-hui-bu-hui-tai-man-liao">CPU1等待其他CPU清空缓存的阻塞等待行为会不会太慢了？</span><a href="#cpu1-deng-dai-qi-ta-cpu-qing-kong-huan-cun-de-zu-sai-deng-dai-xing-wei-hui-bu-hui-tai-man-liao" class="header-anchor">#</a></h2><p>如果CPU1后面有好几条和a无关的指令（例如b=3,d=e等)，都在为了等待a的更新而不执行，未免太浪费时间了！</p>
<p>因此MESI设计了一个叫做 <strong>“StoreBuffer”</strong> 的东西，它会接收CPU1的修改动作，并由StoreBuffer来触发“阻塞等待-&gt;全部收到-&gt;修改状态M”的动作。<br>而CPU1则继续管自己去执行后续与a无关的指令。<br>因此<strong>StoreBuffer就像是一个异步的“生产者消息队列”。</strong>，如下所示：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652973451807966252.png" alt="image.png"></p>
<p>但是还有个问题，因为是等待所有CPU将a状态改为I，这个修改动作是需要时间的。<br>如果有一个CPU修改的比较慢，可能会导致 StoreBuffer这个生产者队列出现队满的情况，于是继续引发了阻塞。</p>
<h2><span id="you-shi-me-ban-fa-neng-jia-kuai-xiang-ying-su-du-invalid-xiao-xi-de-xiang-ying-su-du-ni">有什么办法能加快响应速度Invalid消息的响应速度呢？</span><a href="#you-shi-me-ban-fa-neng-jia-kuai-xiang-ying-su-du-invalid-xiao-xi-de-xiang-ying-su-du-ni" class="header-anchor">#</a></h2><p>那就是<strong>再引入一个“异步的消费者队列”，名叫Invalid Queue</strong><br>这样其他CPU收到消息时，先别急着处理，而是存到这个Queue中，然后直接返回Invalid消息，这样响应就变快了！ 也就是更新动作，和失效消息的接收，都加了一个队列！<br>如下图所示：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1652973806095977745.png" alt="image.png"></p>
<h2><span id="duo-xian-cheng-wen-ti-yu-storebuffer-invalid-queue-zhi-jian-de-guan-xi">多线程问题与StoreBuffer、Invalid-Queue之间的关系</span><a href="#duo-xian-cheng-wen-ti-yu-storebuffer-invalid-queue-zhi-jian-de-guan-xi" class="header-anchor">#</a></h2><p>终于来到了关键的部分了。<br>从刚才的描述中，可以看到CPU引入了2个异步的队列，来处理数据的更新动作。<br>那么就可能存在赋值的动作被放入异步队列，导致延迟触发的情况。<br>而正是这个延迟放入的动作，可能导致数据延迟修改，<strong>即使没有发生指令重排序。</strong><br>这样干讲比较难懂，还是需要结合代码和图解。<br>首先是这个经典的多线程代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">           a = <span class="number">1</span>;                  <span class="comment">// 1</span></span><br><span class="line">           flag = <span class="literal">true</span>;            <span class="comment">// 2</span></span><br><span class="line">       &#125;</span><br><span class="line">       Public <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (flag != <span class="literal">true</span>) &#123;            <span class="comment">// 3</span></span><br><span class="line">             ;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span>  a * <span class="number">2</span>;     <span class="comment">// 4</span></span><br><span class="line">           …………</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照设想，程序员本是希望有如下的表现：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653490107416809220.png" alt="image.png"><br>但是事与愿违，当reader方法中离开了flag循环时，a的值仍然是初始化值0，导致c的值为0。</p>
<p>那么在了解了刚才的CPU原理后，我们终于可以开始分析这段代码为什么会发生这种问题了：</p>
<ol>
<li><p>当线程writer执行a=1时，CPU要做更新，会通过上面提到的异步机制进行更新。如果这个CPU此时堆积了很多的写操作，会导致a=1这个动作在异步队列中处于等待。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492190388870916.png" alt="image.png"></p>
</li>
<li><p>时间片切换，线程writer切到了另一个CPU上<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492292075803742.png" alt="image.png"><br>注意一个很重要的点：</p>
</li>
</ol>
<p><strong>线程执行指令，并非只在1个CPU上运行，是可以通过时间片轮转切换的。因此CPU和线程并非完全绑定的关系</strong></p>
<ol start="3">
<li>flag=true动作在CPU2上迅速响应，很快完成了缓存一致性<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492398662891252.png" alt="image.png"></li>
</ol>
<p>4.reader线程读到了最新的flag，却没有读到新的a，导致了a还在用旧的值。<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492531372457392.png" alt="image.png"></p>
<p>因此可以看到，<strong>正是CPU之间缓存更新的延迟，导致了多线程不同步问题的发生</strong></p>
<h1><span id="volatile-you-shi-ru-he-bi-mian-cpu-geng-xin-yan-chi-wen-ti-de">volatile又是如何避免CPU更新延迟问题的？</span><a href="#volatile-you-shi-ru-he-bi-mian-cpu-geng-xin-yan-chi-wen-ti-de" class="header-anchor">#</a></h1><p>这里不谈论那让人费解的内存屏障， 只要记住一点：<br><strong>对于volatile变量，一旦更新，不会走CPU异步更新，而是在这个CPU阻塞住，直到写动作完整完成，才会继续下一个指令的运行</strong><br>本质上是利用的#LOCK指令。<br>它的作用就是必须等待该变量的storeBuffer的清空，读取时也必须等待InvalidQueue的清空，才能去做写和读。从而保证不会出现因异步导致的多线程不同步问题</p>
<hr>
<h1><span id="tu-jie-zong-jie">图解总结</span><a href="#tu-jie-zong-jie" class="header-anchor">#</a></h1><p>写文章不容易，学习也不容易，给我点个关注点个赞，未来会持续更新具有思考深度的学习文章。欢迎在华为云社区共同交流和学习。</p>
<p>MESI缓存一致性原理图解如下：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/625af1a7e0b34d1a88113212.png" alt="image.png"></p>
<p>多线程同步问题如下：<br><img src="/images/volatile%E5%92%8CCPU-MESI%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1653492544846491616.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/" class="post-title-link" itemprop="url">第296场周赛-209名-36分钟4题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-05 22:12:42 / 修改时间：22:37:45" itemprop="dateCreated datePublished" datetime="2022-06-05T22:12:42+08:00">2022-06-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">力扣周赛记录</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E7%BC%96%E7%A8%8B/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E8%AE%B0%E5%BD%95/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438529701.png" alt="1654438529701"></p>
 <div class="toc">

<!-- toc -->

<ul>
<li><a href="#zong-jie">总结：</a></li>
<li><a href="#di-yi-ti-jian-dan-bian-li-ti">第一题：简单遍历题</a></li>
<li><a href="#di-er-ti-pai-xu-yu-chu-li">第二题：排序预处理</a></li>
<li><a href="#di-san-ti">第三题</a></li>
<li><a href="#di-si-ti-lian-biao-mo-ni-zui-you-ze-shi-zhan-mo-ni">第四题：链表模拟，最优则是栈模拟</a><ul>
<li><a href="#lian-biao-mo-ni">链表模拟：</a></li>
<li><a href="#shi-yong-zhan-shi-xian-5-fen-zhong-xie-wan">使用栈实现，5分钟写完：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div> 

<p>[toc]</p>
<p>题目简单， 速度不够快。</p>
<h1><span id="zong-jie">总结：</span><a href="#zong-jie" class="header-anchor">#</a></h1><ol>
<li><p>再提升1分钟的速度即可进前200</p>
</li>
<li><p>这种光标左右移动的题目，只划分左右两边的情况，使用双栈会比链表更合适。</p>
</li>
</ol>
<h1><span id="di-yi-ti-jian-dan-bian-li-ti">第一题：简单遍历题</span><a href="#di-yi-ti-jian-dan-bian-li-ti" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438568104.png" alt="1654438568104"></p>
<p>重点在于能否快速理解并迅速编写，用一个递归可以快速搞定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMaxGame</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] newNums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;newNums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            newNums[i] = Math.min(nums[<span class="number">2</span>*i], nums[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNums[i] = Math.max(nums[<span class="number">2</span>*i], nums[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minMaxGame(newNums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1><span id="di-er-ti-pai-xu-yu-chu-li">第二题：排序预处理</span><a href="#di-er-ti-pai-xu-yu-chu-li" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438642853.png" alt="1654438642853"></p>
<p>题目说是子序列（即可以不连在一起），然后要求每个序列内差值尽可能满足小于k。</p>
<p>那很容易想到先排序，再选取即可，就是预处理的思想</p>
<p>可惜这里还是思考的慢了点，用了5分钟才做完</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partitionArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            lastNum = nums[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[i]  - lastNum &gt; k) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            lastNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1><span id="di-san-ti">第三题</span><a href="#di-san-ti" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438926785.png" alt="1654438926785"></p>
<p>这里如果能快速理解不需要考虑相同的整数，无论如何替换都是保证数组中互不相同的话，那就非常简单了，直接使用1个map进行处理即可。</p>
<p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654438971349.png" alt="1654438971349"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] arrayChange(<span class="type">int</span>[] nums, <span class="type">int</span>[][] operations) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numToIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        numToIndexMap.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] op : operations) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> op[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> op[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (numToIndexMap.containsKey(a)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> numToIndexMap.get(a);</span><br><span class="line">            numToIndexMap.remove(a);</span><br><span class="line">            nums[index] = b;</span><br><span class="line">            numToIndexMap.put(b, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1><span id="di-si-ti-lian-biao-mo-ni-zui-you-ze-shi-zhan-mo-ni">第四题：链表模拟，最优则是栈模拟</span><a href="#di-si-ti-lian-biao-mo-ni-zui-you-ze-shi-zhan-mo-ni" class="header-anchor">#</a></h1><p><img src="/images/%E7%AC%AC296%E5%9C%BA%E5%91%A8%E8%B5%9B-209%E5%90%8D-36%E5%88%86%E9%92%9F4%E9%A2%98/1654439021956.png" alt="1654439021956"></p>
<p>想了5分钟，决定模拟一个链表，  很久没写了，写得很慢，每次还得画图。</p>
<h2><span id="lian-biao-mo-ni">链表模拟：</span><a href="#lian-biao-mo-ni" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            Node last;</span><br><span class="line">            Node next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.c = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node cursorNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TextEditor</span><span class="params">()</span> &#123;</span><br><span class="line">            cursorNode = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c:text.toCharArray()) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(c);</span><br><span class="line">                node.last = lastNode;</span><br><span class="line">                node.next = cursorNode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">                cursorNode.last = node;</span><br><span class="line">                lastNode = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteText</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deleCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cursorNode.last != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">deleNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> deleNode.last;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = cursorNode;</span><br><span class="line">                &#125;</span><br><span class="line">                cursorNode.last = lastNode;</span><br><span class="line">                deleCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">cursorLeft</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cursorNode.last != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> cursorNode.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = nextNode;</span><br><span class="line">                    <span class="keyword">if</span> (lastNode.last != <span class="literal">null</span>) &#123;</span><br><span class="line">                        lastNode.last.next = cursorNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cursorNode.last = lastNode.last;</span><br><span class="line">                    cursorNode.next = lastNode;</span><br><span class="line">                    lastNode.last = cursorNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextNode.last = lastNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getLeftStr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getLeftStr</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span>(lastNode != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(lastNode.c);</span><br><span class="line">                lastNode = lastNode.last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">cursorRight</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(cursorNode.next != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> cursorNode.last;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> cursorNode.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    nextNode.last = lastNode;</span><br><span class="line">                    <span class="keyword">if</span> (nextNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        nextNode.next.last = cursorNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cursorNode.next = nextNode.next;</span><br><span class="line">                    cursorNode.last = nextNode;</span><br><span class="line">                    nextNode.next = cursorNode;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    lastNode.next = nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getLeftStr();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor obj = new TextEditor();</span></span><br><span class="line"><span class="comment"> * obj.addText(text);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteText(k);</span></span><br><span class="line"><span class="comment"> * String param_3 = obj.cursorLeft(k);</span></span><br><span class="line"><span class="comment"> * String param_4 = obj.cursorRight(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>关于这一题，更好的做法是用2个栈，因为始终只划分左右两边，且都是相邻移动，不会直接跳转，用2个栈是更合适的一种实现。</p>
<h2><span id="shi-yong-zhan-shi-xian-5-fen-zhong-xie-wan">使用栈实现，5分钟写完：</span><a href="#shi-yong-zhan-shi-xian-5-fen-zhong-xie-wan" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Character&gt; leftStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Character&gt; rightStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TextEditor</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : text.toCharArray()) &#123;</span><br><span class="line">            leftStack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteText</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleCount</span> <span class="operator">=</span> Math.min(k, leftStack.size());</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            leftStack.pop();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">cursorLeft</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; k--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            rightStack.push(leftStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getLeftStr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLeftStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; k--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(leftStack.pop());                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.reverse().toString();</span><br><span class="line">        addText(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">cursorRight</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!rightStack.isEmpty() &amp;&amp; k--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            leftStack.push(rightStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getLeftStr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor obj = new TextEditor();</span></span><br><span class="line"><span class="comment"> * obj.addText(text);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteText(k);</span></span><br><span class="line"><span class="comment"> * String param_3 = obj.cursorLeft(k);</span></span><br><span class="line"><span class="comment"> * String param_4 = obj.cursorRight(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java-class类文件原理详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-05 16:40:27 / 修改时间：16:48:05" itemprop="dateCreated datePublished" datetime="2022-06-05T16:40:27+08:00">2022-06-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重读了一遍《深入理解java虚拟机》， 发现第一遍读类文件相关内容的时候，真的是囫囵吞枣，很多细节都被我跳过了，无论是符号引用的含义，还是属性表的理解，都没有弄懂，当时想着“反正也用不到，跳过吧”，却没注意到他们包含了许多java底层实现的核心原理。</p>
<p><strong>看来经典书籍要多读多总结，是有道理的。</strong></p>
<p>于是在阅读这个章节时，用processorOn做了一副超大的类文件解析图，方便自己通过浏览这个图能马上回忆起class文件的结构以及内部的指令。<br>下面的内容是拆分后的内容，对于每块拆分的内容，会有详细的解释。<br><strong>对于完整大图，我放在文末，需要收藏的可以自取</strong> </p>
<p>好了下面我们开始，文章内容较长，建议收藏一下分时段阅读。</p>
 <div class="toc">

<!-- toc -->

<ul>
<li><a href="#mo-shu-ban-ben-hao">魔数、版本号</a></li>
<li><a href="#chang-liang-chi-chang-liang-chi-ge-shu-duo-ge-chang-liang-xiang">常量池（常量池个数、多个常量项）</a><ul>
<li><a href="#chang-liang-chi-zhong-de-chang-liang-dao-di-shi-gan-ma-de-he-wo-men-li-jie-de-static-final-string-xxx-chang-liang-shi-yi-ge-yi-si-ma">常量池中的常量到底是干嘛的？和我们理解的static final String xxx常量是一个意思吗？</a></li>
<li><a href="#chang-liang-chi-de-suo-yin-ji-shu-wei-shi-me-cong-1-kai-shi-ji-qi-ta-di-fang-yao-shi-yong-chang-liang-chi-de-di-yi-ge-chang-liang-shi-bi-xu-xie-cheng-1-er-bu-shi-0">常量池的索引计数为什么从1开始（即其他地方要使用常量池的第一个常量时，必须写成1而不是0）？</a></li>
</ul>
</li>
<li><a href="#lei-ding-yi-de-di-yi-xing-lei-fang-wen-biao-zhi-ben-lei-fu-lei-shi-xian-jie-kou">类定义的第一行（类访问标志、本类、父类、实现接口）</a><ul>
<li><a href="#wei-shi-me-yao-zhe-yang-duo-zou-yi-ceng-wei-shi-me-bu-neng-zhi-jie-zhi-xiang-yi-ge-zi-fu-chuan-chang-liang">为什么要这样多走一层？为什么不能直接指向一个字符串常量？</a></li>
</ul>
</li>
<li><a href="#zi-duan-biao-zi-duan-shu-liang-ge-zi-duan-xiu-shi-fu-ming-lei-xing-shu-xing">字段表（字段数量，各字段（修饰符、名、类型、属性））</a><ul>
<li><a href="#zi-duan-xiu-shi-fu-zhong-de-synchetics-zhi-de-shi-bian-yi-qi-zi-dong-sheng-cheng-de-zi-duan-zen-me-li-jie-ni-shi-me-qing-kuang-xia-hui-yong-dao">字段修饰符中的synchetics指的是编译器自动生成的字段，怎么理解呢？什么情况下会用到？</a></li>
<li><a href="#shang-mian-ke-yi-kan-dao-mei-ge-zi-duan-xiang-de-zui-hou-bao-han-shu-xing-shu-liang-he-shu-xing-chang-du-na-me-class-zhong-de-shu-xing-he-shang-mian-de-zi-duan-ming-zi-duan-lei-xing-you-shi-me-qu-bie-ni">上面可以看到每个字段项的最后包含属性数量和属性长度，那么class中的属性和上面的“字段名”、“字段类型”有什么区别呢？</a></li>
</ul>
</li>
<li><a href="#fang-fa-biao-fang-fa-shu-liang-fang-fa-xiang-xiu-shi-fu-ming-miao-shu-shu-xing">方法表（方法数量、方法项（修饰符、名、描述、属性））</a><ul>
<li><a href="#fang-fa-xiu-shi-fu-zhong-de-qiao-jie">方法修饰符中的桥接</a></li>
<li><a href="#shu-xing-de-jie-gou">属性的结构</a></li>
<li><a href="#zui-guan-jian-de-code-shu-xing">最关键的Code属性</a><ul>
<li><a href="#cao-zuo-shu-zhan-ju-bu-bian-liang-biao-da-xiao-zhi-ling-ma-shu-liang">操作数栈、局部变量表大小、指令码数量</a></li>
<li><a href="#zhi-ling-ma-jie-du">指令码解读</a><ul>
<li><a href="#shu-ju-ji-suan-yong-de-zhi-ling-ma">数据计算用的指令码</a></li>
<li><a href="#dui-xiang-cao-zuo-de-zhi-ling-ma">对象操作的指令码</a><ul>
<li><a href="#wei-shi-me-dui-xiang-cao-zuo-zhi-ling-ma-zhong-zhi-bao-han-liao-lei-yin-yong-he-ming-cheng-ni-wo-zen-me-zhi-dao-wo-diao-yong-de-shi-na-ge-dui-xiang-de-zi-duan">为什么对象操作指令码中只包含了类引用和名称呢，我怎么知道我调用的是哪个对象的字段？</a></li>
<li><a href="#new-dui-xiang-he-new-shu-zu-yong-de-shi-2-ge-bu-tong-de-zhi-ling-wei-shi-me-yao-you-qu-fen-bu-neng-ba-shu-zu-dang-cheng-yi-ge-java-dui-xiang-ma">new对象和new数组，用的是2个不同的指令，为什么要有区分？不能把数组当成一个java对象吗</a></li>
</ul>
</li>
<li><a href="#cao-zuo-shu-zhan-zhi-ling-pop-deng">操作数栈指令（pop等）</a></li>
<li><a href="#fang-fa-diao-yong-zhi-ling-invokevirtual-deng">方法调用指令（invokevirtual等)</a></li>
</ul>
</li>
<li><a href="#yi-chang-biao-shu-xing">异常表属性</a><ul>
<li><a href="#na-finally-de-cao-zuo-bei-fang-dao-na-liao-catch-cao-zuo-wan-liao-zhi-hou-ta-zen-me-zhi-dao-yao-tiao-zhuan-dao-na-li">那finally的操作被放到哪了？catch操作完了之后，它怎么知道要跳转到哪里？</a></li>
<li><a href="#dui-yu-synchronized-guan-jian-zi-ta-ben-zhi-shi-sheng-cheng-liao-monitorenter-he-monitorexit-liang-ge-zhi-ling-shang-mian-fang-fa-diao-yong-zhi-ling-li-de-zui-hou-2-ge-dan-ru-guo-fa-sheng-liao-yi-chang-na-hui-bu-hui-wu-fa-monitorexit-liao">对于synchronized关键字，它本质是生成了monitorenter和monitorexit两个指令（上面方法调用指令里的最后2个）。但如果发生了异常，那会不会无法monitorexit了？</a></li>
<li><a href="#qian-mian-ti-dao-fang-fa-shu-xing-zhong-yi-jing-you-yi-ge-ming-jiao-exception-de-shu-xing-he-zhe-ge-code-shu-xing-zhong-de-yi-chang-biao-you-shi-me-qu-bie">前面提到方法属性中，已经有一个名叫“Exception”的属性，和这个code属性中的异常表有什么区别？</a></li>
</ul>
</li>
<li><a href="#code-de-kuo-zhan-shu-xing">Code的扩展属性</a></li>
<li><a href="#qi-ta-de-fang-fa-shu-xing">其他的方法属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lei-shu-xing">类属性</a><ul>
<li><a href="#wei-shi-me-nei-bu-lei-shu-xing-zhong-yao-bao-han-su-zhu-lei-de-lei-ming-nan-dao-su-zhu-lei-bu-jiu-shi-ta-ben-shen-ma">为什么内部类属性中，要包含宿主类的类名？难道宿主类，不就是它本身吗？</a></li>
</ul>
</li>
<li><a href="#zui-hou-de-wan-zheng-tu">最后的完整图</a></li>
</ul>
<!-- tocstop -->

</div> 

<p>[toc]</p>
<h1><span id="mo-shu-ban-ben-hao">魔数、版本号</span><a href="#mo-shu-ban-ben-hao" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652269180508772459.png" alt="image.png"></p>
<ul>
<li>每类文件都有一个魔数，用于快速校验文件类型。</li>
<li>对于高低版本号，只要明确java11\java8这种版本是主版本号</li>
<li>永远向下兼容， <strong>即高版本jvm可以读取低版本的class文件， 但是低版本的jvm无法读取高版本的class文件</strong>。</li>
</ul>
<hr>
<h1><span id="chang-liang-chi-chang-liang-chi-ge-shu-duo-ge-chang-liang-xiang">常量池（常量池个数、多个常量项）</span><a href="#chang-liang-chi-chang-liang-chi-ge-shu-duo-ge-chang-liang-xiang" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652269423338180081.png" alt="image.png"><br>大部分文件协议格式中，都会先给定一个某项的数量长度，再决定某项的个数，方便确认遍历几次才结束。常量池的设置也是这个原理。<br><strong>因此学习java的class格式，对我们设计某些文件格式或者协议都是一种不错的借鉴。</strong></p>
<hr>
<h2><span id="chang-liang-chi-zhong-de-chang-liang-dao-di-shi-gan-ma-de-he-wo-men-li-jie-de-static-final-string-xxx-chang-liang-shi-yi-ge-yi-si-ma">常量池中的常量到底是干嘛的？和我们理解的static final String xxx常量是一个意思吗？</span><a href="#chang-liang-chi-zhong-de-chang-liang-dao-di-shi-gan-ma-de-he-wo-men-li-jie-de-static-final-string-xxx-chang-liang-shi-yi-ge-yi-si-ma" class="header-anchor">#</a></h2><p>不对！代码中定义的final类型字符串常量只是一种用途。更重要的一种用途是符号引用。<br>而对符号引用的理解，是对java类文件原理最难也最重要的地方。<br>直接去解释符号引用的话，还是很难理解的，因此我们按下不表，在第4部分“类索引”部分会给出详细解释。</p>
<hr>
<h2><span id="chang-liang-chi-de-suo-yin-ji-shu-wei-shi-me-cong-1-kai-shi-ji-qi-ta-di-fang-yao-shi-yong-chang-liang-chi-de-di-yi-ge-chang-liang-shi-bi-xu-xie-cheng-1-er-bu-shi-0">常量池的索引计数为什么从1开始（即其他地方要使用常量池的第一个常量时，必须写成1而不是0）？</span><a href="#chang-liang-chi-de-suo-yin-ji-shu-wei-shi-me-cong-1-kai-shi-ji-qi-ta-di-fang-yao-shi-yong-chang-liang-chi-de-di-yi-ge-chang-liang-shi-bi-xu-xie-cheng-1-er-bu-shi-0" class="header-anchor">#</a></h2><p>因为要留一个0，表示不引用任何常量</p>
<blockquote>
<blockquote>
<ul>
<li>举例：匿名类就是没有名字的，但是类文件结构中，类名那边总需要填入类名常量索引，因此可以填入0，表示“没有类名”的意思。</li>
<li>再来一个例子：object类，是没有父类的，所以他的父类那一栏填的常量索引也是0</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>对于常量池的作用，后面会有更详细的体现和解释。<h1><span id="lei-ding-yi-de-di-yi-xing-lei-fang-wen-biao-zhi-ben-lei-fu-lei-shi-xian-jie-kou">类定义的第一行（类访问标志、本类、父类、实现接口）</span><a href="#lei-ding-yi-de-di-yi-xing-lei-fang-wen-biao-zhi-ben-lei-fu-lei-shi-xian-jie-kou" class="header-anchor">#</a></h1><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652271151313964089.png" alt="image.png"></li>
</ul>
<p>为什么叫类定义的第一行，因为这就来自我们写每个类时的第一行内容。<br>例如<br>public abstract class A extend B implement C,D<br>这句话对应的所有信息就包含在了上图中，因此我叫他“类定义的第一行”</p>
<hr>
<p>CONSTANT_class_info这个类常量到底是干嘛的？<br>从图上可以看到，他其实就是指向了一个表示类名的字符串常量。<br>这里也可以看到，java文件中的所有名称例如类名、方法名、字段名，都会以Utf_info的形式，存储在常量池中。<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652272385081190034.png" alt="image.png"></p>
<hr>
<h2><span id="wei-shi-me-yao-zhe-yang-duo-zou-yi-ceng-wei-shi-me-bu-neng-zhi-jie-zhi-xiang-yi-ge-zi-fu-chuan-chang-liang">为什么要这样多走一层？为什么不能直接指向一个字符串常量？</span><a href="#wei-shi-me-yao-zhe-yang-duo-zou-yi-ceng-wei-shi-me-bu-neng-zhi-jie-zhi-xiang-yi-ge-zi-fu-chuan-chang-liang" class="header-anchor">#</a></h2><p>这个问题我没找到解释，但可以理解为这是最基础的一层封装。</p>
<p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652271891308501334.png" alt="image.png"></p>
<hr>
<h1><span id="zi-duan-biao-zi-duan-shu-liang-ge-zi-duan-xiu-shi-fu-ming-lei-xing-shu-xing">字段表（字段数量，各字段（修饰符、名、类型、属性））</span><a href="#zi-duan-biao-zi-duan-shu-liang-ge-zi-duan-xiu-shi-fu-ming-lei-xing-shu-xing" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652275768314487190.png" alt="image.png"></p>
<hr>
<p>可以看到，字段名、字段类型分别对应了2个字符串常量。<br>特别注意字段类型使用一个字符串来表示的，而不是一个constant_field_info。<br>那么constant_field_info是干嘛的呢？</p>
<hr>
<h2><span id="zi-duan-xiu-shi-fu-zhong-de-synchetics-zhi-de-shi-bian-yi-qi-zi-dong-sheng-cheng-de-zi-duan-zen-me-li-jie-ni-shi-me-qing-kuang-xia-hui-yong-dao">字段修饰符中的synchetics指的是编译器自动生成的字段，怎么理解呢？什么情况下会用到？</span><a href="#zi-duan-xiu-shi-fu-zhong-de-synchetics-zhi-de-shi-bian-yi-qi-zi-dong-sheng-cheng-de-zi-duan-zen-me-li-jie-ni-shi-me-qing-kuang-xia-hui-yong-dao" class="header-anchor">#</a></h2><p>找到一个简单的例子(<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/228854843">代码出处:知乎-不凋花</a>),用枚举做switch：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foobar</span> &#123;</span><br><span class="line">    FOO,</span><br><span class="line">    BAR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(Foobar var0)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (var0) &#123;</span><br><span class="line">            <span class="keyword">case</span> FOO:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> BAR:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch的原理，我们应该很容易想到，就是做一次顺序检查，那么检查时，肯定程序里需要有一个列表吧，因此上面switch的背后逻辑代码是长这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test$1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] $SwitchMap$Foobar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        $SwitchMap$Foobar = <span class="keyword">new</span> <span class="title class_">int</span>[Foobar.values().length];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $SwitchMap$Foobar[Foobar.FOO.ordinal()] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldError e) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $SwitchMap$Foobar[Foobar.BAR.ordinal()] = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldError e) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有一个“static final int[] $SwitchMap$Foobar;”， 这个静态数组字段，就是编译器帮忙生成的字段，他会被标记成synchetics</p>
<hr>
<h2><span id="shang-mian-ke-yi-kan-dao-mei-ge-zi-duan-xiang-de-zui-hou-bao-han-shu-xing-shu-liang-he-shu-xing-chang-du-na-me-class-zhong-de-shu-xing-he-shang-mian-de-zi-duan-ming-zi-duan-lei-xing-you-shi-me-qu-bie-ni">上面可以看到每个字段项的最后包含属性数量和属性长度，那么class中的属性和上面的“字段名”、“字段类型”有什么区别呢？</span><a href="#shang-mian-ke-yi-kan-dao-mei-ge-zi-duan-xiang-de-zui-hou-bao-han-shu-xing-shu-liang-he-shu-xing-chang-du-na-me-class-zhong-de-shu-xing-he-shang-mian-de-zi-duan-ming-zi-duan-lei-xing-you-shi-me-qu-bie-ni" class="header-anchor">#</a></h2><p>属性是可有可无的，而且提供了高度的“jvm可扩展性”。<br>换言之，在jvm虚拟机规范中，“字段修饰符”、“字段名”、“字段类型”都是必备的，而属性则没有限制。<br><strong>因此我们甚至可以自己实现一个虚拟机，定义新的属性，在class中加上属性项然后自己使用</strong></p>
<p>对于属性作用的更详细理解，可以看后面的方法章节，方法中的属性是比较重要且用得最多的。</p>
<hr>
<p>从字段属性可以看到， 类似于static final int a =10这种常量，就是通过属性里的constant属性来设置的。</p>
<p>有个泛型签名的属性，可能不太好马上理解，后面在方法章节中会一并提到这个属性的作用！</p>
<h1><span id="fang-fa-biao-fang-fa-shu-liang-fang-fa-xiang-xiu-shi-fu-ming-miao-shu-shu-xing">方法表（方法数量、方法项（修饰符、名、描述、属性））</span><a href="#fang-fa-biao-fang-fa-shu-liang-fang-fa-xiang-xiu-shi-fu-ming-miao-shu-shu-xing" class="header-anchor">#</a></h1><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652317738015425066.png" alt="image.png"><br>class文件中，最值得学习的就是常量池和方法表了！</p>
<hr>
<h2><span id="fang-fa-xiu-shi-fu-zhong-de-qiao-jie">方法修饰符中的桥接</span><a href="#fang-fa-xiu-shi-fu-zhong-de-qiao-jie" class="header-anchor">#</a></h2><p>对于方法修饰符，大部分都很好理解，有2个修饰符需要关注：“bridge”和“synthetic”。</p>
<p>其实很多bridge桥接方法本身也是synthetics系统生成的，所以我不太想去区分二者，只要关注他们2个用来做什么。</p>
<p>思考下面这个问题：<br><strong>1. 假设有个非公开的类A，A中有个public方法f()，有个继承自A的公开类B，没有重写f()，那么外部是否可以调用b.f()？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	f() &#123;..&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> extend A&#123;</span><br><span class="line">	<span class="comment">// 不重写任何方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">	<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">   b.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们很容易可以得出b.f()可以调用的结论。<br>但由于B没有重写f(), 所以对于编译后的B.class而言，这意味着不会在class文件中包含f方法。<br>那么当执行f时，通过多态，会定位到A.f()，此时A是非公开的类，权限就会出错，因为不允许直接引用非公开的类的方法，只能间接使用。</p>
<p>如何解决？要修改多态的动态分派校验机制吗？</p>
<p>不需要，<strong>编译器为了方便，直接为我们在B中重写了f()来间接调用父类方法</strong>，类似于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">	super.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话就不用担心外部调用者没有权限使用A.f()了。</p>
<p><strong>2. 有个泛型基类Base&lt;T&gt;，包含一个方法f(T t),  有个子类Sub&lt;String&gt;, 实现了方法f(String s)， 两个f方法的入参并不一致，为什么还多态的机制还能生效？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&lt;T&gt; &#123;</span><br><span class="line">	f(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> extend Base&lt;String&gt;&#123;</span><br><span class="line">	f(String t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这2个方法的入参确实不同， 前者的方法签名是f(Ljava/lang/Object;)V，  后者是f(Ljava/lang/String;)V。 多态（动态分派）的规则也没有变，确实是要求入参一致。<br>因此编译器为Sub类自动生成了一个f(Ljava/lang/Object;)V,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.f((String)o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样多态的机制也能实现了。<br><strong>可以看到这一切都是为了适配多态，同时避免过多的特殊逻辑，因此使用桥接方法，来生成了我们看不到的重写方法</strong></p>
<hr>
<p>从下面可以看到， 方法描述符是一个<strong>包含“入参和返回值”</strong>的描述符<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652355928364525434.png" alt="image.png"></p>
<p>因此，java是允许 <strong>同入参、同方法名、不同返回值</strong>的方法存在于同一个class文件中的。</p>
<p>这是不是有点反常识？这种情况我们好像编写不出来的，编译器不会通过！</p>
<p>其实这也是桥接+自动生成才会有这种情况。<br>前文的泛型例子，用泛型T做入参，会生成一个桥接方法，和父类的匹配。</p>
<p>那么如果泛型T是一个返回值呢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&lt;T&gt; &#123;</span><br><span class="line">	T <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> extend Base&lt;String&gt;&#123;</span><br><span class="line">	String <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么也是一样的道理，桥接了一个父类的f方法，但仅仅是返回值不同而已。所以会出现只有返回值不同的方法。</p>
<hr>
<p>方法表的属性和字段的属性类似， 也是属性数量 + N个属性项。<br>但是方法表属性里的干货就更多了！</p>
<h2><span id="shu-xing-de-jie-gou">属性的结构</span><a href="#shu-xing-de-jie-gou" class="header-anchor">#</a></h2><p>之前字段属性中没提到属性到底长啥样，以方法中的throws异常属性为例，：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652395329500135926.png" alt="image.png"></p>
<p>从这里可以看到，每个属性都有个属性名，和常量不同，区分不同常量用的是1个2字节的数字，而属性则是用一个字符串来表示。<br>这样的区别就是因为常量个数有限，而属性为了扩展性，不能存在数量限制。</p>
<p>另外从这也可以知道， 我们在方法名上写的f() throws IOException 都是存在于异常属性中的。</p>
<hr>
<h2><span id="zui-guan-jian-de-code-shu-xing">最关键的Code属性</span><a href="#zui-guan-jian-de-code-shu-xing" class="header-anchor">#</a></h2><p>Code属性是方法属性中最最最重要的属性。<br>他告诉我们编译器是怎样将我们的文本代码封装成一个class文件的。<br>首先，code属性的属性名就是一个“Code”<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652395457163163025.png" alt="image.png"></p>
<h3><span id="cao-zuo-shu-zhan-ju-bu-bian-liang-biao-da-xiao-zhi-ling-ma-shu-liang">操作数栈、局部变量表大小、指令码数量</span><a href="#cao-zuo-shu-zhan-ju-bu-bian-liang-biao-da-xiao-zhi-ling-ma-shu-liang" class="header-anchor">#</a></h3><p>接着会包含3个重要的内容：max_stack、max_local和code_length<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652395539642165989.png" alt="image.png"><br>从max_stack和max_local我们可以看到，操作数栈和局部变量表的大小，已经在class文件中计算出来了，因此当开辟一个新的栈帧时，jvm便能够知道给这个方法开辟多大的空间，不用担心栈上分配不够的问题。<br><strong>注意，是操作数栈的大小，而不是程序执行的栈的深度，程序可没法感知我们能够递归多少次。</strong></p>
<hr>
<h3><span id="zhi-ling-ma-jie-du">指令码解读</span><a href="#zhi-ling-ma-jie-du" class="header-anchor">#</a></h3><p>code_length代表了我们这个方法在编译后，有多少条字节码指令，而后面紧跟着的，就是对应数量的java字节码指令了。<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652397966852235844.png" alt="image.png"></p>
<p>指令码种类非常多，这里只列举关键的一些信息。</p>
<h4><span id="shu-ju-ji-suan-yong-de-zhi-ling-ma">数据计算用的指令码</span><a href="#shu-ju-ji-suan-yong-de-zhi-ling-ma" class="header-anchor">#</a></h4><p>首先，每种涉及基本数据类型的计算指令，都会在指令最前方，携带一个T，如图：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652396223751707461.png" alt="image.png"><br>里面有句话：<strong>“不是每种数据类型和每个操作都有指令对应（否则数量太多）”</strong><br>这句话怎么理解呢，可以结果图上右侧的表格，从而得知，有些指令是不包含所有类型的，所以可能会借用一些的技巧，比如把byte、short都视为int在操作上去操作。</p>
<h4><span id="dui-xiang-cao-zuo-de-zhi-ling-ma">对象操作的指令码</span><a href="#dui-xiang-cao-zuo-de-zhi-ling-ma" class="header-anchor">#</a></h4><p>另一个类指令码是和对象操作有关，例如：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652396601906806136.png" alt="image.png"><br>可以看到，当试图获取一个类字段时，他指向的是一个class_field_info常量索引，这个常量会提前被放进class文件的常量池中。</p>
<hr>
<h5><span id="wei-shi-me-dui-xiang-cao-zuo-zhi-ling-ma-zhong-zhi-bao-han-liao-lei-yin-yong-he-ming-cheng-ni-wo-zen-me-zhi-dao-wo-diao-yong-de-shi-na-ge-dui-xiang-de-zi-duan">为什么对象操作指令码中只包含了类引用和名称呢，我怎么知道我调用的是哪个对象的字段？</span><a href="#wei-shi-me-dui-xiang-cao-zuo-zhi-ling-ma-zhong-zhi-bao-han-liao-lei-yin-yong-he-ming-cheng-ni-wo-zen-me-zhi-dao-wo-diao-yong-de-shi-na-ge-dui-xiang-de-zi-duan" class="header-anchor">#</a></h5><p>A: 你要调用的对象，已经通过前面提到的操作数栈相关指令，把引用放到了操作数栈的第一个，因此，jvm只要取栈顶对象，然后根据名字进行字段操作即可，后面的方法调用也是一样的道理。</p>
<hr>
<h5><span id="new-dui-xiang-he-new-shu-zu-yong-de-shi-2-ge-bu-tong-de-zhi-ling-wei-shi-me-yao-you-qu-fen-bu-neng-ba-shu-zu-dang-cheng-yi-ge-java-dui-xiang-ma">new对象和new数组，用的是2个不同的指令，为什么要有区分？不能把数组当成一个java对象吗</span><a href="#new-dui-xiang-he-new-shu-zu-yong-de-shi-2-ge-bu-tong-de-zhi-ling-wei-shi-me-yao-you-qu-fen-bu-neng-ba-shu-zu-dang-cheng-yi-ge-java-dui-xiang-ma" class="header-anchor">#</a></h5><p>这要从对象的内存结构，以及类加载机制上去思考。<br>因为数组的对象头，和普通对象的对象头是不一样的。</p>
<ul>
<li>数组的对象头中包含了数组长度，而普通对象没有</li>
<li>new一个数组时，数组中包含的类并不会做类加载。<br>有这么多区别，肯定是新增一个单独针对数组的指令来处理，要简单很多</li>
</ul>
<hr>
<h4><span id="cao-zuo-shu-zhan-zhi-ling-pop-deng">操作数栈指令（pop等）</span><a href="#cao-zuo-shu-zhan-zhi-ling-pop-deng" class="header-anchor">#</a></h4><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652397315515649848.png" alt="image.png"><br>其他指令好理解， 但操作数栈指令有个dup_x指令，例如dup1_1 就是复制栈顶并再放入1个。为什么需要这么一个指令？</p>
<p>其实当我们调用 A a = new A()时，这一句话生成的指令中就包含了dup指令<br>因为当我们new出1个A引用时，它有两件事要做：</p>
<ol>
<li>调用A的构造函数。</li>
<li>把引用地址赋值给a这个局部变量<br>而每件事都会消耗一个A的引用！所以才需要赋值。<br>因此可以看到，<strong>指令码很多时候都是基于操作数栈进行操作的，每操作一个数据或引用，就消耗一个</strong><h4><span id="fang-fa-diao-yong-zhi-ling-invokevirtual-deng">方法调用指令（invokevirtual等)</span><a href="#fang-fa-diao-yong-zhi-ling-invokevirtual-deng" class="header-anchor">#</a></h4><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652397689648709059.png" alt="image.png"><br>对于方法调用指令，和前面的类字段调用有点像，也是一个方法常量，方法常量包含类索引和方法描述索引。<br>对于方法究竟是如何触发调用实现多态的、invokevirtual指令和invokedynamic指令有什么区别，这个内容就更多了，后面我会放到类加载的图解笔记中讲解。<h3><span id="yi-chang-biao-shu-xing">异常表属性</span><a href="#yi-chang-biao-shu-xing" class="header-anchor">#</a></h3>指令码结束后，后面会紧跟着一个异常表。表中的每一行长这样：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398026144920939.png" alt="image.png"><br>是不是恍然大悟，原来try-catch代码的逻辑在这边， 它本质上就是抛异常时，根据try的位置和异常类型，这个异常表中进行查找到对应的catch代码位置，从而实现异常处理。</li>
</ol>
<hr>
<h4><span id="na-finally-de-cao-zuo-bei-fang-dao-na-liao-catch-cao-zuo-wan-liao-zhi-hou-ta-zen-me-zhi-dao-yao-tiao-zhuan-dao-na-li">那finally的操作被放到哪了？catch操作完了之后，它怎么知道要跳转到哪里？</span><a href="#na-finally-de-cao-zuo-bei-fang-dao-na-liao-catch-cao-zuo-wan-liao-zhi-hou-ta-zen-me-zhi-dao-yao-tiao-zhuan-dao-na-li" class="header-anchor">#</a></h4><p>finally模块在java语言中是必须执行的，在编译的时候，通过将finally中代码块分别在try模块的最后和catch模块的最后都复制了一份，通过这样来保证finally的必定执行</p>
<hr>
<h4><span id="dui-yu-synchronized-guan-jian-zi-ta-ben-zhi-shi-sheng-cheng-liao-monitorenter-he-monitorexit-liang-ge-zhi-ling-shang-mian-fang-fa-diao-yong-zhi-ling-li-de-zui-hou-2-ge-dan-ru-guo-fa-sheng-liao-yi-chang-na-hui-bu-hui-wu-fa-monitorexit-liao">对于synchronized关键字，它本质是生成了monitorenter和monitorexit两个指令（上面方法调用指令里的最后2个）。但如果发生了异常，那会不会无法monitorexit了？</span><a href="#dui-yu-synchronized-guan-jian-zi-ta-ben-zhi-shi-sheng-cheng-liao-monitorenter-he-monitorexit-liang-ge-zhi-ling-shang-mian-fang-fa-diao-yong-zhi-ling-li-de-zui-hou-2-ge-dan-ru-guo-fa-sheng-liao-yi-chang-na-hui-bu-hui-wu-fa-monitorexit-liao" class="header-anchor">#</a></h4><p>生成code字节码时，jvm会自动为synchronized生成1个默认的异常表和throw指令，保证中间同步块发生异常时，monitorexit能够正确被指令（类似于放了一个自动生成的try-catch代码，或者在已有的catch操作后添加）。</p>
<hr>
<h4><span id="qian-mian-ti-dao-fang-fa-shu-xing-zhong-yi-jing-you-yi-ge-ming-jiao-exception-de-shu-xing-he-zhe-ge-code-shu-xing-zhong-de-yi-chang-biao-you-shi-me-qu-bie">前面提到方法属性中，已经有一个名叫“Exception”的属性，和这个code属性中的异常表有什么区别？</span><a href="#qian-mian-ti-dao-fang-fa-shu-xing-zhong-yi-jing-you-yi-ge-ming-jiao-exception-de-shu-xing-he-zhe-ge-code-shu-xing-zhong-de-yi-chang-biao-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>上面code<strong>异常表</strong>指的是代码执行时try-catch的逻辑部分<br>而方法中的<strong>exception属性</strong>则是方法名上所声明的throws异常。</p>
<h3><span id="code-de-kuo-zhan-shu-xing">Code的扩展属性</span><a href="#code-de-kuo-zhan-shu-xing" class="header-anchor">#</a></h3><p>在code属性中，竟然还携带了属性，也就是说，是允许“属性中的属性”。毕竟属性的实现是可以完全自定义的，那么自己给自己新增额外特性完全是允许的。<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398314647685943.png" alt="image.png"><br>里面有个属性叫“局部变量描述属性”，长这样：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398431353725133.png" alt="image.png"><br>从这里，你就能明白，为什么你从IDEA里看到反解后的class文件，有时候是var1、var2之类莫名其妙的局部变量，有时候却又能看到完整的变量名了吧？就是通过这个属性决定的。毕竟存储局部变量名的代价还是很高的。</p>
<h3><span id="qi-ta-de-fang-fa-shu-xing">其他的方法属性</span><a href="#qi-ta-de-fang-fa-shu-xing" class="header-anchor">#</a></h3><p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652398713702736921.png" alt="image.png"><br>泛型签名这个属性很迷惑，不是有泛型擦除吗，为什么还需要这个属性？<br><strong>其实泛型签名属性是为了方便反射的。</strong><br>我们通过前面关于桥接的原理，可以知道编译时会发生泛型擦除，方法入参都变成了object。<br>但是反射API可能希望获取泛型信息因此可通过这个扩展属性进行获取。所以会增加这个属性，从而能感知一些泛型属性相关的信息。</p>
<h1><span id="lei-shu-xing">类属性</span><a href="#lei-shu-xing" class="header-anchor">#</a></h1><p>既然方法和字段都有属性，那么类肯定也有属性：<br><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652399133483878712.png" alt="image.png"><br>其他属性都比较好理解或者不重要，重点讲一下内部类属性。<br>通过内部类属性，我们可以看到内部类并不是直接包含在这个class文件中，它其实是生成了另一个class文件，所以才需要一个内部类属性，来确认对应的名字，方便类加载时能找到内部类。</p>
<hr>
<h2><span id="wei-shi-me-nei-bu-lei-shu-xing-zhong-yao-bao-han-su-zhu-lei-de-lei-ming-nan-dao-su-zhu-lei-bu-jiu-shi-ta-ben-shen-ma">为什么内部类属性中，要包含宿主类的类名？难道宿主类，不就是它本身吗？</span><a href="#wei-shi-me-nei-bu-lei-shu-xing-zhong-yao-bao-han-su-zhu-lei-de-lei-ming-nan-dao-su-zhu-lei-bu-jiu-shi-ta-ben-shen-ma" class="header-anchor">#</a></h2><p>因为，内部类中，还可以继续定义内部类</p>
<hr>
<p>另外，从上面的一些属性中可以看到， <strong>很多debug用的调试、展示信息，都会包含在class中</strong><br>因此，当我们希望调试一些环境上执行的程序时，如果想提供最为贴近原代码，那就需要class文件中能有充足的信息，如果想要class文件小，那就去掉，具体怎么去掉或者添加，肯定就是一些编译选项的区别了。</p>
<hr>
<hr>
<h1><span id="zui-hou-de-wan-zheng-tu">最后的完整图</span><a href="#zui-hou-de-wan-zheng-tu" class="header-anchor">#</a></h1><p>好累，终于写完了，感觉能看到最后的人不会太多，但一通详细地分析和解决中间发现的问题，还是收获了不少。<br>最后贴上完整的大图，欢迎保存和收藏。<br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5d1a2d97e4b07c7231731b02">图片在线查看</a><br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5d1a2d97e4b07c7231731b02">https://www.processon.com/view/link/5d1a2d97e4b07c7231731b02</a></p>
<p><img src="/images/java-class%E7%B1%BB%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/5d1a2d97e4b0f7ca49d84a3a.png" alt="完整大图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">jdk动态代理原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-05 16:09:35 / 修改时间：16:17:04" itemprop="dateCreated datePublished" datetime="2022-06-05T16:09:35+08:00">2022-06-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">

<!-- toc -->

<ul>
<li><a href="#jdk-dong-tai-dai-li">jdk动态代理</a></li>
<li><a href="#shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou">实现jdk动态代理时需要哪些步骤？</a></li>
<li><a href="#jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me">JDK动态代理的invoke原理是什么？</a></li>
<li><a href="#wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi">为什么Proxy.newProxyInstance必须要传入一个类加载器？</a></li>
<li><a href="#wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me">为什么jdk动态代理必须依赖一个接口？底层逻辑是什么？</a></li>
<li><a href="#na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni">那么spring里AOP所用的CGLIB为啥不需要接口呢？</a></li>
<li><a href="#na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao">那么CGLIB和jdk动态代理哪个更好？</a></li>
</ul>
<!-- tocstop -->

</div> 

<p>[toc]</p>
<h2><span id="jdk-dong-tai-dai-li">jdk动态代理</span><a href="#jdk-dong-tai-dai-li" class="header-anchor">#</a></h2><h2><span id="shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou">实现jdk动态代理时需要哪些步骤？</span><a href="#shi-xian-jdk-dong-tai-dai-li-shi-xu-yao-na-xie-bu-zou" class="header-anchor">#</a></h2><ol>
<li>有一个目标类Class， 目标类必须implment某个行为接口Inteface</li>
<li>有一个代理类XxxProxy，实现自InvocationHandler接口</li>
<li>代理类必须实现一个invoke方法， invoke方法的入参是  被代理对象（目标对象）、执行方法（method的反射对象）、执行参数<br>通过调用“ 执行方法.invoke(被代理对象，执行参数)” 这个常见的反射操作，  即可执行实际调用方法，然后你可以在这个方法的前后做各种处理或者改造。</li>
<li>使用Proxy.newProxyInstance(被代理类的类加载器， 被代理类的接口， 这个proxy代理对象)生成一个做过绑定的代理对象，能被调用的方法都是行为接口Inteface里的。</li>
</ol>
<hr>
<h2><span id="jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me">JDK动态代理的invoke原理是什么？</span><a href="#jdk-dong-tai-dai-li-de-invoke-yuan-li-shi-shi-me" class="header-anchor">#</a></h2><p>proxy类里面真正的那个代理方法字节码类似如下（这个类就是给被别人调用的代理类，是newProxyxxx（）操作后的那个类，不是invokeHandler类）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Proxy0.class</span><br><span class="line">public final void sayHello(object[] args) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// this.h就是继承了invokeHandler的那个类对象</span><br><span class="line">		this.h.invoke(this, m3, args);</span><br><span class="line">	&#125; catch(Excetion ...) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">static &#123;</span><br><span class="line">	m3 = Class.forname(&quot;那个接口的类名&quot;).getMethod(&quot;sayHello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m3就是通过static初始化阶段生成一个m方法， 然后调用sayHello时，调用invokeHandler.invoke，从而走进他里面实现的那个方法。</p>
<p>Proxy.newProxyInstance()会通过调用sun.misc.ProxyGenerator.generateProxyClass()来生成一个字节码，从而得到一个描述代理类的字节码数组。<br>生成字节码的过程就是根据class文件的格式规范去拼装字节码。</p>
<p>更多源码逻辑见<a target="_blank" rel="noopener" href="https://blog.csdn.net/Trunks2009/article/details/123106582">Proxy源码解析</a></p>
<hr>
<h2><span id="wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi">为什么Proxy.newProxyInstance必须要传入一个类加载器？</span><a href="#wei-shi-me-proxy-newproxyinstance-bi-xu-yao-chuan-ru-yi-ge-lei-jia-zai-qi" class="header-anchor">#</a></h2><p> <img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/48a3a4503f728f9ce9520a2c4820e9a9858c237a.png" alt="48a3a4503f728f9ce9520a2c4820e9a9858c237a"><br>因为他需要创建一个新的proxy类时，必须要基于接口去构造一个新的类对象，后面再使用类对象去反射一个实际代理对象<br> <img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/08a7c84b1abfab8a47fa544fd0de4603c1699e88.png" alt="08a7c84b1abfab8a47fa544fd0de4603c1699e88"> </p>
<hr>
<h2><span id="wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me">为什么jdk动态代理必须依赖一个接口？底层逻辑是什么？</span><a href="#wei-shi-me-jdk-dong-tai-dai-li-bi-xu-yi-lai-yi-ge-jie-kou-di-ceng-luo-ji-shi-shi-me" class="header-anchor">#</a></h2><p>因为真正给用户调用的那个代理对象类XXXProxy$0， 实际上他为了做相关的代理操作（比如将inovkeHnandler作为成员，并调用各种字节码生产方法），需要extends Proxy这个类<br>也就是说他的类结构长这样：<br> <img src="/images/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/5d5edf4370eff2c399096e1fefdd76e9cb7c90ee.png" alt="5d5edf4370eff2c399096e1fefdd76e9cb7c90ee"><br>因为java是单继承，导致父类已经被Proxy占用了，但你有需要对Worker对象做代理封装，并提供这个接口对外提供的方法，因此只能用implements的形式。</p>
<p>另一个更好的解释：</p>
<blockquote>
<blockquote>
<p>Cglib代理实际上是通过继承，也就是生成一个继承被代理对象的类，编译成class文件时还会额外生成一个fastclass文件<br>该文件记录各个method的class索引（类名+方法名+参数），当执行某个方法时，通过计算索引，定位到具体的方法，代理对象执行该方法，然后super调用父类（执行了被代理对象的方法）。<br>生成代理对象时通过fastclass索引机制直接定位到被代理对象的class文件，从而实现反复调用，等于说是class复用，每次都是直接拿被代理对象的class内容执行的。</p>
</blockquote>
</blockquote>
<hr>
<h2><span id="na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni">那么spring里AOP所用的CGLIB为啥不需要接口呢？</span><a href="#na-me-spring-li-aop-suo-yong-de-cglib-wei-sha-bu-xu-yao-jie-kou-ni" class="header-anchor">#</a></h2><p>因为CGLIB是直接继承被代理类做字节码增加的，相当于做了字节码改造。</p>
<p>而jdk动态代理需要继承自Proxy类，利用父类的机制引用invokeHandler+反射的方法，来做代理操作。</p>
<hr>
<h2><span id="na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao">那么CGLIB和jdk动态代理哪个更好？</span><a href="#na-me-cglib-he-jdk-dong-tai-dai-li-na-ge-geng-hao" class="header-anchor">#</a></h2><ol>
<li>性能上比较</li>
</ol>
<ul>
<li>jdk动态代理生成类速度快，调用慢</li>
<li>cglib生成类速度慢，但后续调用快</li>
</ul>
<p>但是实际上JDK的速度在版本升级的时候每次都提高很多性能,而CGLIB仍止步不前.<br>在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eea9a3acbaad">JDK 动态代理和Cglib性能对比</a></p>
<ol start="2">
<li>稳定性上比较</li>
</ol>
<ul>
<li>jdk动态代理Java本身支持，不用担心依赖问题，随着版本稳定升级和优化。</li>
<li>而CGLIB是外部技术，字节码库需要进行更新以保证在新版java上能运行<br>；</li>
</ul>
<ol start="3">
<li>使用上比较<br>jdk动态代理必须依赖接口，CGLIB不需要，在设计不当的历史包袱下<br>如果必须对非接口对象做代理，那么只能用CGLIB临时过度。</li>
</ol>
<p>因此spring实现AOP时，都是优先使用jdk动态代理，如果没有实现接口，才改成CGLIB过度，这也是为什么我们spring里的service类一般都要先定义1个接口，即使你只有1个service实现类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java类加载全过程详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-05 14:16:01 / 修改时间：16:08:18" itemprop="dateCreated datePublished" datetime="2022-06-05T14:16:01+08:00">2022-06-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/05/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="toc">

<!-- toc -->

<ul>
<li><a href="#guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu">关于类初始化的时机和误区</a></li>
<li><a href="#you-wu-dao-de-jia-zai-san-bu-qu">有误导的“加载三部曲”</a></li>
<li><a href="#jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu">加载：不仅仅是读取字节流</a><ul>
<li><a href="#lei-jia-zai-qi">类加载器</a><ul>
<li><a href="#shuang-qin-wei-pai">双亲委派</a><ul>
<li><a href="#shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa">双亲委派的详细执行过程和中间方法</a></li>
<li><a href="#shuang-qin-wei-pai-de-hao-chu">双亲委派的好处</a></li>
<li><a href="#fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban">父加载器中要加载某个类A时，A需要使用子加载器来加载，但是父加载器没有子加载器的代码，怎么办？</a></li>
</ul>
</li>
<li><a href="#osgi-wang-zhuang-lei-jia-zai-qi">OSGI网状类加载器</a><ul>
<li><a href="#wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi">为什么OSGI可以实现热部署，但是双亲委派不可以？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#shu-zu-lei-shi-ru-he-jia-zai-de">数组类是如何加载的？</a></li>
</ul>
</li>
<li><a href="#lian-jie">连接</a><ul>
<li><a href="#yan-zheng">验证</a><ul>
<li><a href="#wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui">文件格式校验（class文件对不对）</a></li>
<li><a href="#yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui">元数据验证（我的父亲对不对）</a><ul>
<li><a href="#yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi">元数据验证中的类解析</a></li>
</ul>
</li>
<li><a href="#zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui">字节码验证（我的指令对不对）</a></li>
<li><a href="#fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui">符号引用验证（我的指令调用的目标对不对）</a><ul>
<li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi">符号引用验证中的字段解析</a></li>
<li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi">符号引用验证中的类方法解析</a></li>
<li><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi">符号引用验证中的接口方法解析</a><ul>
<li><a href="#yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma">疑问1：为什么接口方法还要解析？接口里不是没有代码吗？</a></li>
<li><a href="#yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me">疑问2：为什么要区分类的方法和接口方法？不能用同一种思路去解析么？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#zhun-bei">准备</a><ul>
<li><a href="#lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei">类静态成员默认值的准备</a></li>
<li><a href="#fang-fa-biao-de-zhun-bei">方法表的准备</a><ul>
<li><a href="#chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma">重要问题：interface的接口方法，会有方法表吗？</a></li>
<li><a href="#wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao">为什么接口不能有方法表？</a></li>
<li><a href="#java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie">java的虚表和C++的虚表有什么区别？</a></li>
<li><a href="#java-xu-biao-de-sheng-cheng-guo-cheng">java虚表的生成过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jie-xi">解析</a><ul>
<li><a href="#jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan">解析的误区：并不是一个单纯的阶段</a></li>
<li><a href="#jing-tai-jie-xi">静态解析</a></li>
<li><a href="#jie-xi-he-fen-pai-de-qu-bie">解析和分派的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chu-shi-hua">初始化</a><ul>
<li><a href="#cinit-fang-fa-xi-jie-jie-xi">cinit方法细节解析</a><ul>
<li><a href="#yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de">疑问1：cinit方法中的代码是如何生成的？</a></li>
<li><a href="#yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma">疑问2：cinit类初始化是线程安全的吗？</a></li>
</ul>
</li>
<li><a href="#chu-shi-hua-zhong-de-dong-tai-jie-xi">初始化中的动态解析</a></li>
<li><a href="#kuo-zhan-invoke-dynamic-shi-shi-me">扩展:invoke_dynamic是什么</a><ul>
<li><a href="#dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie">动态语言和静态语言的区别</a></li>
<li><a href="#java-de-methodhandle-yong-fa">java的MethodHandle用法</a></li>
<li><a href="#methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa">methodHandle典型应用场景：如何调用爷爷类的虚方法</a></li>
<li><a href="#java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma">java的methodHandle机制和reflection的反射有什么区别吗？</a></li>
<li><a href="#invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi">invoke_dynamic指令原理。是否涉及动态分派、类加载和解析？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zui-hou-de-wan-zheng-da-tu">最后的完整大图</a></li>
</ul>
<!-- tocstop -->

</div> 

<p>[toc]</p>
<hr>
<h1><span id="guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu">关于类初始化的时机和误区</span><a href="#guan-yu-lei-chu-shi-hua-de-shi-ji-he-wu-qu" class="header-anchor">#</a></h1><p>书籍的第一步部分上来就先讲了类初始化的时机，整理成图片如下：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652581844567633533.png" alt="image.png"><br>看起来非常多，很难记住，很折磨。</p>
<p>个人认为，书籍把这一部分放到章节的最前面不太合理，曾经一度让我把上面的这些事件，理解成了类加载的时机，也不懂这些规则的缘由（根本原因还是此时读者对类加载的理解不够深。）</p>
<p>先贴一下类加载和类初始化的区别：</p>
<ul>
<li>类加载概念：将class文件加载到jvm中并生成class对象，并根据情况做初始化。</li>
<li>类初始化概念：调用类class文件中默认存在的&lt;cinit&gt;类初始化方法。</li>
</ul>
<p>而我们容易产生误解的原因，是因为书中没有这句话：：<strong>所谓的类初始化时机，只是针对cinit类初始化方法的调用，并不是指的类加载时机！</strong></p>
<p>以上图中红色的部分为例：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652582629860693478.png" alt="image.png"><br>这里书籍中没有解释这3个规则的原因，在没理解原理前，强行记忆这3条是没有任何意义的。我认为是作者的失误。</p>
<p>在这里我挑其中一个做补充：<br><strong>“使用类里的static final 常量，不会触发初始化”</strong><br>想要理解这个规则，需要先理解class文件原理。<br>对于类的static final常量字段，它的常量值是存放在字段的constanValue属性中。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652583662013743457.png" alt="image.png"><br>正因为如此，static final常量并不需要通过cinit方法中的指令来完成赋值。<br>所以也就没有必要在这时候调用&lt;cinit&gt;方法了。</p>
<p>因此对于“儿子类调用父类的静态成员，不用对儿子类做类初始化”也是一个道理，儿子类的类静态成员没有被使用到，没必要做cinit。</p>
<p>对于上面的分析，可以浓缩为一句话：<br><strong>“如果我们急需使用static成员，且这个成员的值是要通过cinit方法赋值的，那么我们才做cinit初始化”</strong></p>
<p><strong>新的疑问</strong>：那为什么仅仅是new一个对象时，也一定要做cinit类初始化呢？<br>假设此时我还没用到static成员，那么new一个对象时，是否可以省去cinit，等用到静态成员的时候，再去触发cinit？</p>
<p>这涉及到了类初始化的另一个容易被忽视的点：<strong>“cinit类初始化方法，并不仅仅是做类成员的赋值，其实还可能包含一些初始化行为调用”</strong>，这可以是资源的启动或者加载等类对象必须要用到的内容。</p>
<p>因此在一切可能触发类对象实际行为前，必须触发cinit避免出错。</p>
<p>所以刚才的长篇大论，可以再次进行优化，浓缩为：<br><strong>“当需要用到static成员的初始赋值，或者对类对象进行正式使用时，才会触发cinit类初始化，目的是为了保证类对象或者类成员的正确使用”</strong><br>拿着这一句话，去回看前面的类初始化时机的触发时机和不触发的时机时，相信你就会有更深的理解了，甚至也不需要强行去记忆每一条规则了。 </p>
<hr>
<h1><span id="you-wu-dao-de-jia-zai-san-bu-qu">有误导的“加载三部曲”</span><a href="#you-wu-dao-de-jia-zai-san-bu-qu" class="header-anchor">#</a></h1><p>有一个很经典的回答，叫做<strong>类加载三部曲：加载、连接、初始化</strong><br>好像类加载过程就是这三步按照顺序串行拼装起来的。</p>
<p>实际上这3个过程是存在交叉的！<br>只能说，“最早发生”的时机，是按照这个顺序发生，但是中间加载过程是有很多的，具体后面会结合我画的图以及原理解释进行呈现。</p>
<h1><span id="jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu">加载：不仅仅是读取字节流</span><a href="#jia-zai-bu-jin-jin-shi-du-qu-zi-jie-liu" class="header-anchor">#</a></h1><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652594910504257328.png" alt="image.png"><br>对于加载，很容易只理解成只是“从文件里加载二进制字节到内存”。<br>这个过程显然是必须最先执行的，否则连类的基本信息都获取不到。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595413217848779.png" alt="image.png"><br>可以看到这个过程很灵活，只要你从你能想到的地方拿到字节流即可，任意形式都行。</p>
<p>然而，对于“加载”，除了获取字节流，实际上还包含了“把字节流转成方法区里的数据结构，进行存储defineClass”、“生成一个class对象，存储在堆中”这两步。 </p>
<p>这2步是穿插在连接过程中的。<br>比如字节流转数据结构的过程，必须在确认字节流的正确性之后完成。<br>而生成class对象同理，符合一个class对象的条件时，才能将其在堆中生成。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595269171806676.png" alt="image.png"><br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652595359889871663.png" alt="image.png"></p>
<p>加载过程是由类加载器classloader完成的，在这里对classLoader也顺便做一个详细的分析。</p>
<h2><span id="lei-jia-zai-qi">类加载器</span><a href="#lei-jia-zai-qi" class="header-anchor">#</a></h2><h3><span id="shuang-qin-wei-pai">双亲委派</span><a href="#shuang-qin-wei-pai" class="header-anchor">#</a></h3><p>类加载时的双亲委派模型，反正就记得优先去父类加载器中看类是否能加载。</p>
<p>这个过程和多态方法调用是相反的，多态方法是子类覆写了的话则优先子类调用，类加载则是父加载器能加载则加载。</p>
<p><strong>注意：Bootsrap不是ClassLoader的子类，他是C++编写的。</strong><br>而ExtClassLoader和AppClassLoader都是继承自ClassLoader的</p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/a4c77999a2f8a0d5bc6401d05efeca9cdcecef43.png" alt="a4c77999a2f8a0d5bc6401d05efeca9cdcecef43"></p>
<h4><span id="shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa">双亲委派的详细执行过程和中间方法</span><a href="#shuang-qin-wei-pai-de-xiang-xi-zhi-xing-guo-cheng-he-zhong-jian-fang-fa" class="header-anchor">#</a></h4><p>loaderClass（className）  双亲加载实现（这里会体现先去父亲找，再自己）<strong>注意，jdk1.2之后不提倡覆盖loadClass方法，这个方法可以理解为一个模板方法</strong>。 </p>
<p><strong>但如果确实有需要破坏双亲委派的需求，则可以重写loaderClass方法，解除双亲委派机制</strong></p>
<p>findClass()  如何根据名字，寻找并生成1个class（内部需要借助defineClass）<br>defineClass()  通过这个方法将字节码生成1个class类，基本不用改动。</p>
<p>例如需要根据类目，从某个远端网络加载获取这个类， 而且获取过来的时候还是加密的，需要在findClass里对byte数组做解密，解密完成，再调用defineClass生成class类。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/82757435">https://blog.csdn.net/zzti_erlie/article/details/82757435</a></p>
<h4><span id="shuang-qin-wei-pai-de-hao-chu">双亲委派的好处</span><a href="#shuang-qin-wei-pai-de-hao-chu" class="header-anchor">#</a></h4><p>书中提到的原因就一个： java类随着类加载器，具备了带有优先级的层次关系。<br>保证了例如object类在每个环境里都是同一种，不会出现混乱。</p>
<h4><span id="fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban">父加载器中要加载某个类A时，A需要使用子加载器来加载，但是父加载器没有子加载器的代码，怎么办？</span><a href="#fu-jia-zai-qi-zhong-yao-jia-zai-mou-ge-lei-a-shi-a-xu-yao-shi-yong-zi-jia-zai-qi-lai-jia-zai-dan-shi-fu-jia-zai-qi-mei-you-zi-jia-zai-qi-de-dai-ma-zen-me-ban" class="header-anchor">#</a></h4><p>可以使用线程上下文TCCL机制， 例如java的JNDI服务，JNDI是在启动类加载器里入加载的（JDK1.3的rt.jar)， 但是JNDI会加载很多扩展性很强的新资源类。 </p>
<p>因此可以在JNDI加载类的过程中，从TCCL这个context对象中，拿到set进去的用户加载器，然后进行加载即可。（JDBC、JBI等SPI机制都是如此）</p>
<h3><span id="osgi-wang-zhuang-lei-jia-zai-qi">OSGI网状类加载器</span><a href="#osgi-wang-zhuang-lei-jia-zai-qi" class="header-anchor">#</a></h3><p>OSGI中， 每一个程序模块（bundle）都有一个自己的类加载器，当需要更换一个bundle时，就把bundle连同类加载器一起换掉，实现代码的热替换</p>
<p>它是一个网状的类加载结构，只有java.*以及委派名单的，才会用双亲委派机制，否则都是各种网状的加载。加载过程如下所示：</p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/62408d2e1e08530789333ccd-1651765505820.png" alt="OSGI加载"></p>
<h4><span id="wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi">为什么OSGI可以实现热部署，但是双亲委派不可以？</span><a href="#wei-shi-me-osgi-ke-yi-shi-xian-re-bu-shu-dan-shi-shuang-qin-wei-pai-bu-ke-yi" class="header-anchor">#</a></h4><p>首先，理解双亲委派模型下，不能热部署的原因：<br><strong>如果有新升级的同名类要加入，它只能在新给出的一个加载器去加载， 但是双亲模型限定了必须是先交给父加载器加载，这导致了升级困难，无法让新的加载器去做抢先加载。</strong></p>
<p>OSGi类加载模型则是网络图状的，可以在bundle间互相委托<br>例如bundleA、B都依赖于bundleC，当他们访问bundleC中的类时，就会委托给bundleC的类加载器，由它来查找类；如果它发现还要依赖bundleE中的类，就会再委托给bundleE的类加载器。</p>
<blockquote>
<blockquote>
<p>另一篇文章的解释：</p>
</blockquote>
<ul>
<li>由于类加载机制的原因，导致一个类一旦加载进去就再也无法释放，因此，OSGi引入了基于插件的类加载机制</li>
<li>举例说明：plugin1里有examples.Test1类，而pulgin2里也有examples.Test1类，在载入这两个插件时，两个类是可以同时载入进入到类缓存中，这归功于OSGi实现的插件类加载器(ClassLoader)</li>
<li>我们把“examples.Test”服务的 Service Ranking 属性更改成了 100，那么其他bundle使用这个bundle对应的example类时，就会用优先级最高的类。</li>
<li>在不需要停止服务和其他插件都不用更新的情况下，我们只需要再安装一个更新版本的插件，其所注册的服务就可以自动更新并应用到所有调用该插件的插件中，达到了热部署的目的。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yipsilon/article/details/83369177">OSGi的热部署特性及实现</a></li>
</ul>
</blockquote>
<h2><span id="shu-zu-lei-shi-ru-he-jia-zai-de">数组类是如何加载的？</span><a href="#shu-zu-lei-shi-ru-he-jia-zai-de" class="header-anchor">#</a></h2><p>数组类是由AppClassLoader加载的。<br>数组类打印className时，前面会有个[Lxx类<br>二维数组就是[[Lxxx类<br><strong>数组类的父类型是Object</strong></p>
<p>注意此时加载的是数组类，而数组类里面的对象是不会做自动加载的<br>因此xx类的静态代码并不会被直接调用</p>
<h1><span id="lian-jie">连接</span><a href="#lian-jie" class="header-anchor">#</a></h1><p>连接过程可以说是最难记住的一个过程， 里面包含了各种校验啊之类的，让人摸不清头脑。这里会通过更细致的解释和图解，让你明白连接过程究竟做了什么。<br>首先连接过程分为 验证、准备和解析，<strong>“解析”并不是连接的最后一步，而是在验证过程中实时发生的！</strong>。 下文会为你详细解释为什么。</p>
<h2><span id="yan-zheng">验证</span><a href="#yan-zheng" class="header-anchor">#</a></h2><h3><span id="wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui">文件格式校验（class文件对不对）</span><a href="#wen-jian-ge-shi-xiao-yan-class-wen-jian-dui-bu-dui" class="header-anchor">#</a></h3><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652596406384448149.png" alt="image.png"><br>注意这里的校验，都是一些最简单的校验，相当于无需做太多的语法分析操作等操作， 都是基于class文件格式定义进行的基础校验。</p>
<p>然而如果对加载的文件有充分的自信，来源可靠，那么确实可以省去这个步骤，提升连接效率，因此会有一个-Xverify:none的选项供使用。</p>
<h3><span id="yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui">元数据验证（我的父亲对不对）</span><a href="#yuan-shu-ju-yan-zheng-wo-de-fu-qin-dui-bu-dui" class="header-anchor">#</a></h3><p>这里验证了class文件里面继承特性相关的重要信息，例如继承关系是否合理、是否实现了抽象类或接口的方法<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652596978343390083.png" alt="image.png"></p>
<p>注意，这个元数据验证的过程，<strong>会触发父类或者接口的解析（加载）操作！</strong><br>书上提到了4个解析情况以及流程：</p>
<ul>
<li>类解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析<br>却没有解释这4个解析过程是在哪里发生的。后面我会逐一提到，来真正理解这4个解析过程。<h4><span id="yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi">元数据验证中的类解析</span><a href="#yuan-shu-ju-yan-zheng-zhong-de-lei-jie-xi" class="header-anchor">#</a></h4>还记得class文件中，父类是指向一个constant_class_info吗？这个东西当时看就是一个utf字符串，没什么意义。你没法知道父类究竟有什么方法，是不是抽象类。<br>因此必须拿到父类的类信息，要么是已经在方法区中，要么需要重新加载。<br>而类解析的过程如下：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598263182568128.png" alt="image.png"><br>可以看到这个过程中也会发生加载，甚至好多次加载。</li>
</ul>
<hr>
<h3><span id="zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui">字节码验证（我的指令对不对）</span><a href="#zi-jie-ma-yan-zheng-wo-de-zhi-ling-dui-bu-dui" class="header-anchor">#</a></h3><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598525735605413.png" alt="image.png"><br>这个验证不要和前面的“文件格式验证”搞混了。<br>前面的“元数据验证”都只是针对类、方法、字段等和父类进行确认、校验。<br>但是还没有涉及到每个方法里的code属性。</p>
<p>code属性虽然在编译出来时是正确的，但是无法保证传输过程中被人篡改。<br>如果发生操作操作数栈时，栈里没东西，或者试图在局部变量表边界外写入局部变量，就可能导致不可估量的后果。</p>
<p>因此此刻会进行最基本的指令分析，确认对操作数栈、局部变量表的操作是安全、正确的。</p>
<p>但是，逐个指令分析，会不会太慢了？如果代码很长的话。</p>
<p>还记得class文件的code属性中，还包含了一个stackMapTable属性么，估计很多人都跳过了这个属性。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652598909384718936.png" alt="image.png"><br>这个属性就是用在字节码验证这个过程，可以立即让编译器编译出class时，提前把各位置的情况写入stackMap中，jvm加载时只对这个stackMap做校验确认是对的即可。<br>但代价就是可能不安全了，因为这个stackMap是可以被篡改的。</p>
<h3><span id="fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui">符号引用验证（我的指令调用的目标对不对）</span><a href="#fu-hao-yin-yong-yan-zheng-wo-de-zhi-ling-diao-yong-de-mu-biao-dui-bu-dui" class="header-anchor">#</a></h3><p>注意前面的“字节码验证”是简单的确认，但不会持有过多的其他类的信息。<br>但是方法肯定会涉及对其他类的调用。</p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652599879633278954.png" alt="image.png"></p>
<p>此时就会涉及到符号引用验证，确认自己是否拥有对方方法的访问权限。<br>那么你就需要找到目标类的类信息存放地址，确认方法权限，或者字段权限。<br>于是会在这里触发字段解析、类方法解析或者接口解析！<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652601092434475198.png" alt="image.png"><br>书上只提到了这3个解析过程的流程，却没有详细解释其中的一些缘由，我会做更详细的补充。</p>
<h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi">符号引用验证中的字段解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-zi-duan-jie-xi" class="header-anchor">#</a></h4><p>class中的constant_filed_info终于露出了它的真面目，原来是用在这个地方，即和字段相关的指令会用到它，并通过字段符号引用， 解析到这个字段真正的定义位置。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652601973522659730.png" alt="image.png"><br>像经常遇到的NoSuchFieldError报错，就是在这个过程中爆出来的。<br>而且接口字段的优先级是大于父类的字段的。</p>
<h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi">符号引用验证中的类方法解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-lei-fang-fa-jie-xi" class="header-anchor">#</a></h4><p>当调用方法前，需要先确认对象方法是否有权限访问。那么就必须这个类的信息进行确认。<br><strong>注意：这个过程并不是动态分派的那个过程，此刻并没有触发任何的方法调用！仅仅是确认代码中静态类型的访问权限是否正确之类的！</strong><br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652602585506110322.png" alt="image.png"></p>
<ul>
<li>对类方法做解析的时候，会判断此时是类还是接口。如果是接口，竟然会报“IncompatibleClassChangeError”。</li>
<li>还有如果是抽象类，也会报“AbstractMethodError”，因为正常情况下，你的jvm指令调用的方法，必须是实例化的对象所对应的方法，不可能直接调用抽象类方法的。</li>
</ul>
<h4><span id="fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi">符号引用验证中的接口方法解析</span><a href="#fu-hao-yin-yong-yan-zheng-zhong-de-jie-kou-fang-fa-jie-xi" class="header-anchor">#</a></h4><p>看起来像是将类方法解析中的接口和方法互换了位置。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652603187639739722.png" alt="image.png"></p>
<h5><span id="yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma">疑问1：为什么接口方法还要解析？接口里不是没有代码吗？</span><a href="#yi-wen-1-wei-shi-me-jie-kou-fang-fa-huan-yao-jie-xi-jie-kou-li-bu-shi-mei-you-dai-ma-ma" class="header-anchor">#</a></h5><p>因为接口类里每个interface方法，本身也是一个方法，只不过没有详细的code属性。但方法的访问修饰符之类的都存在，因此验证阶段还是需要进行校验。</p>
<h5><span id="yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me">疑问2：为什么要区分类的方法和接口方法？不能用同一种思路去解析么？</span><a href="#yi-wen-2-wei-shi-me-yao-qu-fen-lei-de-fang-fa-he-jie-kou-fang-fa-bu-neng-yong-tong-yi-chong-si-lu-qu-jie-xi-me" class="header-anchor">#</a></h5><p>我理解的几个原因：</p>
<ol>
<li>向上搜索时的逻辑不同，对于类方法，直接找父类即可， 而接口则需要遍历所有父接口。而且类方法还要考虑抽象类的问题，接口不需要。</li>
<li>类方法和接口方法本身就是两个不同的符号引用， 一个是constant_method_ref，另一个是constant_interface_ref，用2套逻辑没什么毛病</li>
<li>如果硬要问为什么要区分这2个符号引用，明明内容都是类索引+描述符索引？<br>这是因为后面在实际调用方法时，二者有显著区别，具体见下文的“方法表的准备”。</li>
</ol>
<h2><span id="zhun-bei">准备</span><a href="#zhun-bei" class="header-anchor">#</a></h2><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652604139278590043.png" alt="image.png"></p>
<h3><span id="lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei">类静态成员默认值的准备</span><a href="#lei-jing-tai-cheng-yuan-mo-ren-zhi-de-zhun-bei" class="header-anchor">#</a></h3><p>对于准备阶段，大家一般只记得需要对一些非final的类静态成员做默认初始值操作。</p>
<h3><span id="fang-fa-biao-de-zhun-bei">方法表的准备</span><a href="#fang-fa-biao-de-zhun-bei" class="header-anchor">#</a></h3><p>除了这个默认值赋值，还有一个动作，是准备方法表。<br>方法表就是为了多态而生，简化动态分派时频繁的迭代循环带来的不必要消耗：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652604259330823080.png" alt="image.png"><br>通过前面的验证过程，我们已经获知了父类信息。<br>因此可以准备一个方法表，把父类方法堆到最前面，自己的方法堆到后面，后面直接根据索引获取方法调用地址即可！</p>
<h4><span id="chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma">重要问题：interface的接口方法，会有方法表吗？</span><a href="#chong-yao-wen-ti-interface-de-jie-kou-fang-fa-hui-you-fang-fa-biao-ma" class="header-anchor">#</a></h4><p>intefacer接口是不具有方法表的！<br>因此这可能也是jvm特地区分了class_inteface_info和class_method_info这2个常量，以及特地用invoke_inteface和invoke_virtual指令来区分2类方法的调用。因为他们的调用逻辑可能大相径庭。</p>
<h4><span id="wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao">为什么接口不能有方法表？</span><a href="#wei-shi-me-jie-kou-bu-neng-you-fang-fa-biao" class="header-anchor">#</a></h4><p>这是由于Java可以实现多个接口，不同的类可能会实现了多个或者不同的接口，在虚表里该接口所实现方法的索引会不一致。</p>
<p>假设有A、B、C三个接口类</p>
<ul>
<li>类X实现了A、B两个接口，假设A和B接口放在虚表里，那么调用A接口方法我们假设它是在t位置。</li>
<li>类T实现了B、C、A接口，按照实现顺序，先放B的方法，再放A的方法，最后放C的方法。这样调用接口A时，就不一定是t位置了，我们无法直接确定A里面方法的位置，因为一个类可以实现多个接口，而且顺序可以随意更改！</li>
</ul>
<p>这样每次解析的虚表索引都可能会不同，因此不能进行缓存，需要每次都进行重新的解析。<br><strong>因此，接口的方法调用会比普通的子类继承的虚函数调用要慢。</strong></p>
<h4><span id="java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie">java的虚表和C++的虚表有什么区别？</span><a href="#java-de-xu-biao-he-c-de-xu-biao-you-shi-me-qu-bie" class="header-anchor">#</a></h4><p>C++：<br>当编译器遇到调用虚方法的代码时，是通过vtable指针以及对应方法在虚表里的offset，然后获取对应的函数指针实现的，由于offset在编译过程就已经固定了，这样在执行过程中几乎没有产生任何额外的计算就实现了多态调用，效率相当高。<br><strong>缺点就是当你修改了一个dll链接文件，另一个dll链接文件可能还是用的老的偏移，这导致你即使重启程序了，仍然还是错误的调用。 你必须将两个链接文件都重新编译才可以。</strong></p>
<p>但对于java而言，只需要替换一个jar包即可， 类之间的方法调用关系，方法偏移，都是可以类加载过程中去生成的。</p>
<p>换言之，最大的区别就是修改部分方法带来的影响，java是最小的</p>
<h4><span id="java-xu-biao-de-sheng-cheng-guo-cheng">java虚表的生成过程</span><a href="#java-xu-biao-de-sheng-cheng-guo-cheng" class="header-anchor">#</a></h4><ol>
<li>在加载该类的时候，常量池的所有<strong>虚函数的签名</strong>（包括调用的以及自身定义的）都会<strong>添加到全局的符号表</strong>（事实上是一个HashTable）。</li>
<li><strong>首先对字符值进行Hash值计算，然后在全局HashTable进行查找</strong>，如果发现已经存在对应的Hash值，则返回对应的符号指针Symbol *，否则创建新的Symbol并添加到HashTable中，然后返回新创建的Symbol *。这样常量池就把字符串的引用转换成符号的引用。另外这个过程可以确保所有字符串在jvm只存有一个引用。、</li>
<li>当在某个类对象调用虚方法的时候，通过调用函数的符号和自身定义的符号进行比较（由于这里都是引用全局符号表的唯一符号，因此可以通过内存地址进行快速比较），就会解析出调用虚函数的信息，<strong>通过信息就可以获取虚表的索引，然后调用对应的虚函数字节码</strong></li>
<li>为了提高调用时的性能，Java采用的是Lazy解析，<strong>第一次解析出虚表的索引后，则会保留到cache里面</strong>，这样下次调用就可以从缓存直接获取索引</li>
</ol>
<h2><span id="jie-xi">解析</span><a href="#jie-xi" class="header-anchor">#</a></h2><h3><span id="jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan">解析的误区：并不是一个单纯的阶段</span><a href="#jie-xi-de-wu-qu-bing-bu-shi-yi-ge-dan-chun-de-jie-duan" class="header-anchor">#</a></h3><p>解析其实分为“静态解析”和“动态解析”。<br>因此将解析说成是“连接”中的一部分是不严谨的， 只有静态解析，才是“连接”的一部分。</p>
<p>静态解析在初始化前发生，但动态解析则可能在初始化或者初始化之后才去使用。</p>
<h3><span id="jing-tai-jie-xi">静态解析</span><a href="#jing-tai-jie-xi" class="header-anchor">#</a></h3><p>静态解析用于解析私有方法、父类构造器、final方法等不存在多态可能的方法。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652605263696340667.png" alt="image.png"></p>
<h3><span id="jie-xi-he-fen-pai-de-qu-bie">解析和分派的区别</span><a href="#jie-xi-he-fen-pai-de-qu-bie" class="header-anchor">#</a></h3><p>静态分派、动态分派， 指的是2个方法的不同阶段，他们不存在冲突的关系，即方法会先触发静态分派，再触发动态分派。</p>
<p>静态分派可以理解为编译器在编写class文件时，通过方法名+描述符+优先级，确定了这个位置调用的是哪个方法。</p>
<p>但是由于多态的特性，具体执行者可能不同，因此后面还会触发动态分派。</p>
<p>而静态解析和动态解析是2个不同的解析，前者是默认定死了方法引用位置，后者则必须依赖动态分派，对一个方法而言不可能同时存在动态和静态解析的情况。</p>
<h1><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor">#</a></h1><h2><span id="cinit-fang-fa-xi-jie-jie-xi">cinit方法细节解析</span><a href="#cinit-fang-fa-xi-jie-jie-xi" class="header-anchor">#</a></h2><p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606173785989291.png" alt="image.png"><br>关于初始化时机的解释，在开头就已经阐述过了，这里不再重复解释。</p>
<h3><span id="yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de">疑问1：cinit方法中的代码是如何生成的？</span><a href="#yi-wen-1-cinit-fang-fa-zhong-de-dai-ma-shi-ru-he-sheng-cheng-de" class="header-anchor">#</a></h3><p>cinit方法 是编译器收集所有类静态变量的赋值动作和静态语句块static{}中的语句合并产生，按照顺序收集。<br>因此类加载赋值的顺序和类定义顺序有关，原理就取决于cinit生成的原理。</p>
<h3><span id="yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma">疑问2：cinit类初始化是线程安全的吗？</span><a href="#yi-wen-2-cinit-lei-chu-shi-hua-shi-xian-cheng-an-quan-de-ma" class="header-anchor">#</a></h3><p>是线程安全的，虚拟机会保证一个类的加载和cinit方法会被正确的加锁、同步。<br>因此多线程场景下，同时使用一个之前没初始化过的类，且类初始化过程耗时非常久的话， 且可能会造成线程阻塞。<br>而这也是可以利用类初始化+内部类的方式，来做单例模式的实现的原理：</p>
<h2><span id="chu-shi-hua-zhong-de-dong-tai-jie-xi">初始化中的动态解析</span><a href="#chu-shi-hua-zhong-de-dong-tai-jie-xi" class="header-anchor">#</a></h2><p>而初始化过程中，可能会涉及其他对象实例方法的调用，因此是可能发生动态解析过程的！<br>类方法和接口方法的解析过程如下<br>类方法的解析可以借助虚方法表简化解析过程。<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606407501364079.png" alt="image.png"></p>
<h2><span id="kuo-zhan-invoke-dynamic-shi-shi-me">扩展:invoke_dynamic是什么</span><a href="#kuo-zhan-invoke-dynamic-shi-shi-me" class="header-anchor">#</a></h2><h3><span id="dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie">动态语言和静态语言的区别</span><a href="#dong-tai-yu-yan-he-jing-tai-yu-yan-de-qu-bie" class="header-anchor">#</a></h3><p>动态类型语言： 类型检查的主体是运行期而不是编译器。 例如PHP、Lua\python<br>而静态类型语言就是编译器将类型都检查完，比如C++、java</p>
<p>静态语言的好处：在编译器就能确定类型，可以进行严谨的类型检查， 代价就是代码会很臃肿。<br>动态语言编写时更为随意，可以快速开发和运行。</p>
<h3><span id="java-de-methodhandle-yong-fa">java的MethodHandle用法</span><a href="#java-de-methodhandle-yong-fa" class="header-anchor">#</a></h3><p>jdk1.7之后提供的 MethodHandle， 类似于C/C++里的函数指针， 或者C#里的delegate。<br>C里面可以<br>sort(list, size,  int (* compare)(int, int))<br>即传入一个函数指针，这个函数是哪个类调用的？不知道</p>
<p>java提供了methodHandle用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is a print:&quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodHandle <span class="title function_">getPrintlnMethodHandle</span><span class="params">(Object object)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 返回值，入参</span></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup()</span><br><span class="line">                <span class="comment">// 找到对象所对应的类，确认是否存在方法</span></span><br><span class="line">                .findVirtual(object.getClass(), <span class="string">&quot;println&quot;</span>, methodType)</span><br><span class="line">                <span class="comment">// 这个对对象绑定上去调用. java的反射不是也能做到吗》？</span></span><br><span class="line">                .bindTo(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">ClassA</span> <span class="variable">classA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line">        <span class="comment">// invokeExact：执行并传入参数，classA和System.out不是同一个父类或者接口，但是可以执行相同的方法</span></span><br><span class="line">        getPrintlnMethodHandle(classA).invokeExact(<span class="string">&quot;afdsafds&quot;</span>);</span><br><span class="line">        getPrintlnMethodHandle(System.out).invokeExact(<span class="string">&quot;afdsafds&quot;</span>);</span><br><span class="line">        <span class="comment">// 以后排序就可以这样做了：  sort(list, MethodHandle mt)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中methodHandle背后就是由invoke_dynamic指令触发的。</p>
<h3><span id="methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa">methodHandle典型应用场景：如何调用爷爷类的虚方法</span><a href="#methodhandle-dian-xing-ying-yong-chang-jing-ru-he-diao-yong-ye-ye-lei-de-xu-fang-fa" class="header-anchor">#</a></h3><p>如何在儿子类中，分派调用祖父类的虚方法？ 且儿子类和父类都已经实现了这个虚方法。父类不能提供新的方法</p>
<p>通过loopup().findSpecial(祖父类， “方法名”， MethodHandle.methodType(返回值，入参),  当前类)<br>拿到一个方法句柄mh<br>然后方法句柄mh.invoke(this)，即可调用祖父类的方法。</p>
<h3><span id="java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma">java的methodHandle机制和reflection的反射有什么区别吗？</span><a href="#java-de-methodhandle-ji-zhi-he-reflection-de-fan-she-you-shi-me-qu-bie-ma" class="header-anchor">#</a></h3><ol>
<li>调用指令层面：</li>
</ol>
<ul>
<li>reflection是模拟java代码调用，不关心底层指令</li>
<li>而methodHandle是模拟了字节码的执行，上面的Loopup().findVirtual，等同于invokevirtual指令（同理还有invokestatic\invokeinteface\invokespecial)</li>
</ul>
<ol start="2">
<li>method对象大小问题</li>
</ol>
<ul>
<li>reflection返回的method对象，包含的信息更多，例如签名、描述、属性等，返回的method比较重量级</li>
<li>而methodHandle仅包含执行方法相关的信息，是轻量级、</li>
</ul>
<ol start="3">
<li>可以基于methodHandle手动做虚拟机的相关调用优化（例如内联），而反射无法实现。</li>
<li>从最终设计目的而言，反射只针对java， 而methodHandle的核心目的在于可以将其他无类型的语言运行在java迅即之上！</li>
</ol>
<h3><span id="invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi">invoke_dynamic指令原理。是否涉及动态分派、类加载和解析？</span><a href="#invoke-dynamic-zhi-ling-yuan-li-shi-fou-she-ji-dong-tai-fen-pai-lei-jia-zai-he-jie-xi" class="header-anchor">#</a></h3><p>我们首先看下invoke_dynamic指令调用的dynamic_info常量长什么样的：<br><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/1652606577911480954.png" alt="image.png"><br>可以看到它只包含了一个方法索引和描述，但似乎没包含方法属于哪个类。</p>
<p>它的作用是用java实现一些类似于脚本语言的逻辑，脚本语言不关心静态类型，不做编译检查，只关心运行期的内容。所以invoke_dynamic以及constant_dynamic_info应运而生。但书本和工作中对这块的接触都不是太深，因此我的理解也只能局限于此了。</p>
<p>书上还有句话可以记一下：<strong>除了invokeddynamic动态调用指令， 其他的invokevirual之类的，都会缓存解析结果。</strong></p>
<hr>
<h1><span id="zui-hou-de-wan-zheng-da-tu">最后的完整大图</span><a href="#zui-hou-de-wan-zheng-da-tu" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8">在线地址</a><br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8">https://www.processon.com/view/link/5e7eed6ce4b0ffc4ad43fda8</a></p>
<p><img src="/images/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/5e7eed6ce4b08b6157409373.png" alt="完整大图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/abd.png">
      <meta itemprop="name" content="breakDawn">
      <meta itemprop="description" content="君子终日乾乾,夕惕若厉,无咎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冲破黎明前的黑暗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">jvm垃圾收集器演进和原理详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-31 07:52:57 / 修改时间：07:54:52" itemprop="dateCreated datePublished" datetime="2022-05-31T07:52:57+08:00">2022-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/java%E9%AB%98%E7%BA%A7%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">java高级原理</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/31/%E7%9F%A5%E8%AF%86%E5%BA%93/java/java-high/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重读了一遍《深入理解java虚拟机》， 发现第一遍读垃圾回收器相关的进化历程时，没有细细去研究各自的区别，觉得太多了记不住。<br>实际上理解了这个进化过程，这对于我们理解回收器是有很大帮助的。</p>
<p><strong>看来经典书籍要多读多总结，是有道理的。</strong><br>于是在阅读这个章节时，画了一张大的演化图，方便理解变化和区别。</p>
 <div class="toc">

<!-- toc -->

<ul>
<li><a href="#serial-old-he-serial-dan-xian-cheng-shou-ji-qi">Serial Old和Serial（单线程收集器）</a><ul>
<li><a href="#serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma">Serial类型的收集器被淘汰了吗？它还有优势吗？</a></li>
</ul>
</li>
<li><a href="#parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi">ParOld和ParNew收集器（多线程收集器）</a></li>
<li><a href="#parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan">Parallel Scavenge收集器（对回收时间的优化开端）</a><ul>
<li><a href="#ru-he-li-jie-tun-tu-liang">如何理解吞吐量</a></li>
<li><a href="#parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de">Parallel Savenge收集器是如何控制吞吐量的</a></li>
<li><a href="#dai-jie-shi-shi-me">代价是什么？</a></li>
</ul>
</li>
<li><a href="#cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu">CMS收集器（Concurrent Mark Sweep, 并发收集概念的重大提出）</a><ul>
<li><a href="#cms-jie-duan-1-chu-shi-biao-ji">CMS阶段1：初始标记</a><ul>
<li><a href="#gcroot-de-xuan-qu-yuan-ze-shi-shi-me">GCRoot的选取原则是什么？</a></li>
<li><a href="#parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma">ParNew年轻代收集时，需要遍历CMS老年代的所有GCROOT吗？</a></li>
</ul>
</li>
<li><a href="#cms-jie-duan-2-bing-fa-biao-ji">CMS阶段2：并发标记</a><ul>
<li><a href="#bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de">并发标记用了怎样的算法去标记的？</a></li>
<li><a href="#bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng">并发标记时如何记录引用变更？</a></li>
<li><a href="#shi-me-shi-kua-dai-yin-yong">什么是跨代引用？</a></li>
<li><a href="#ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang">如何避免跨代引用，保障并发标记安全（写屏障</a></li>
</ul>
</li>
<li><a href="#cms-jie-duan-3-chong-xin-biao-ji">CMS阶段3：重新标记</a></li>
<li><a href="#cms-jie-duan-4-bing-fa-qing-chu">CMS阶段4：并发清除</a><ul>
<li><a href="#wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa">为什么是要用“标记-清除”这么缺点大的方法？</a></li>
<li><a href="#cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang">CMS如何解决标记-清除后碎片过多，无法放入新对象的情况？</a></li>
<li><a href="#bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban">并发回收过程中，如果工作线程突然生成大量新垃圾，导致内存不足怎么办？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi">G1收集器（回收概念发生诸多变革，目前最先进收集器）</a><ul>
<li><a href="#g1-xiang-bi-cms-de-chong-da-sheng-ji-dian">G1相比CMS的重大升级点：</a></li>
<li><a href="#region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma">region之间都要通过BFS遍历吗？</a></li>
</ul>
</li>
<li><a href="#wan-zheng-da-tu">完整大图</a></li>
</ul>
<!-- tocstop -->

</div> 


<p>[toc]</p>
<hr>
<h1><span id="serial-old-he-serial-dan-xian-cheng-shou-ji-qi">Serial Old和Serial（单线程收集器）</span><a href="#serial-old-he-serial-dan-xian-cheng-shou-ji-qi" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830465493764891.png" alt="image.png"></p>
<ul>
<li>Serial Old指的是老年代收集器，使用标记-整理清理垃圾</li>
<li>Serial指的是年轻代收集器，使用复制算法清理垃圾。</li>
</ul>
<p>Serial就是单线程的意思，不仅代表它使用单线程做回收，<strong>更意味着他会进行stop world暂停工作线程</strong></p>
<h2><span id="serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma">Serial类型的收集器被淘汰了吗？它还有优势吗？</span><a href="#serial-lei-xing-de-shou-ji-qi-bei-tao-tai-liao-ma-ta-huan-you-you-shi-ma" class="header-anchor">#</a></h2><p>没有，它是client模式下默认的收集器。<br>优势在于，它具有<strong>最高的单线程收集效率</strong><br>而client模式一般不会用于处理大量请求，因此非常适合serial。</p>
<p>除了client，书上还提了另外2个功能：</p>
<ul>
<li>Serial Old收集器会作为CMS的后备预案</li>
<li>与Parallel Scavenge搭配使用</li>
</ul>
<h1><span id="parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi">ParOld和ParNew收集器（多线程收集器）</span><a href="#parold-he-parnew-shou-ji-qi-duo-xian-cheng-shou-ji-qi" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830556269329780.png" alt="image.png"><br>Par收集器就是Serial收集器的多线程版本，其他策略则都与serial一致。</p>
<p><strong>注意， 虽然是多线程收集器，但是用户的工作线程仍然是暂停状态（为了防止收集过程中发生变化导致回收错误</strong></p>
<p>ParNew收集器可以与CMS收集器配合使用。</p>
<h1><span id="parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan">Parallel Scavenge收集器（对回收时间的优化开端）</span><a href="#parallel-scavenge-shou-ji-qi-dui-hui-shou-shi-jian-de-you-hua-kai-duan" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652830818239387635.png" alt="image.png"></p>
<p>Parallel Scavenge 收集器是一个<strong>新生代收集器</strong>，他不包含老年代。<br>前两代的收集器，默认必须收集完成，对工作线程影响巨大。<br><strong>这是首次开始关注回收时间对工作线程影响的一代收集器，成为了垃圾收集器升级优化的一个重要开端。</strong></p>
<h2><span id="ru-he-li-jie-tun-tu-liang">如何理解吞吐量</span><a href="#ru-he-li-jie-tun-tu-liang" class="header-anchor">#</a></h2><p>虚拟机运行了100分钟， 垃圾收集花掉了一分钟，那么吞吐量就是100%。</p>
<h2><span id="parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de">Parallel Savenge收集器是如何控制吞吐量的</span><a href="#parallel-savenge-shou-ji-qi-shi-ru-he-kong-zhi-tun-tu-liang-de" class="header-anchor">#</a></h2><p>通过控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数，以及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br>通过修改这2个参数，jvm可以计算一个合适的新生代空间，<strong>空间越小，回收时间越快</strong>，他的停顿时间便能够满足吞吐量要求。</p>
<ul>
<li>换句话说，本质上就是通过你设定的吞吐量或者暂停时间，自适应地得到一个新生代空间大小而已。</li>
</ul>
<h2><span id="dai-jie-shi-shi-me">代价是什么？</span><a href="#dai-jie-shi-shi-me" class="header-anchor">#</a></h2><p>新生代越小，那么意味着老年代的空间就越大。</p>
<p>虽然能做到基本不停顿或者停顿间隔很小，但这样就会<strong>导致新生代频繁发生minorGc，并不断将垃圾扔给老年代收集器</strong>，容易在下一个时间段触发更多的fullGc。<br>因此这个策略仅仅是饮鸠止渴，无法真正解决问题。</p>
<ul>
<li>注意，这里ParaleelSavenge的吞吐量，指的就是新生代的吞吐量，不代表fullGc占用的时间。</li>
</ul>
<h1><span id="cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu">CMS收集器（Concurrent Mark Sweep, 并发收集概念的重大提出）</span><a href="#cms-shou-ji-qi-concurrent-mark-sweep-bing-fa-shou-ji-gai-nian-de-chong-da-ti-chu" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652831748531127900.png" alt="image.png"><br>而从这一代开始，jvm终于想到了可以如何尽可能少地暂停工作线程的方式，提出了并发收集的概念。</p>
<p>首先明确并行收集和并发收集的区别</p>
<ul>
<li>并行收集：指用多线程来收集，但是工作线程仍然暂停</li>
<li>并发收集：收集线程和工作线程允许不冲突地交替并发执行</li>
</ul>
<hr>
<p>CMS是老年代收集器，必须和parNew等结合使用<br>使用的是回收-清除算法，有较多碎片。</p>
<hr>
<h2><span id="cms-jie-duan-1-chu-shi-biao-ji">CMS阶段1：初始标记</span><a href="#cms-jie-duan-1-chu-shi-biao-ji" class="header-anchor">#</a></h2><p>初始标记就是对GCRoot对象进行标记，以GCroot作为起点。<br>GCRoot的那4种经典对象，瞄一眼就好</p>
<blockquote>
<blockquote>
<p>虚拟机栈（栈帧中的本地变量表）中的引用的对象<br>方法区中的类静态属性引用的对象<br>方法区中的常量引用的对象<br>本地方法栈中JNI（Native方法）的引用对象</p>
</blockquote>
</blockquote>
<h3><span id="gcroot-de-xuan-qu-yuan-ze-shi-shi-me">GCRoot的选取原则是什么？</span><a href="#gcroot-de-xuan-qu-yuan-ze-shi-shi-me" class="header-anchor">#</a></h3><p>这个问题很有意思，为什么要这样选择？如果能理解这个问题，也就不需要去死记硬背上面的内容了。</p>
<p>首先，可能有很多个方法栈，每个栈都有一个栈顶的栈帧，说明这是<strong>正在执行</strong>的方法， 在此刻是一定不需要被回收的！<br>因此选取了2种栈的栈顶作为GCRoot选取位置。</p>
<p>而方法区中的对象一般不会被释放，长期持有，因此方法区中的静态引用对象、常量引用对象也是稳定能被使用的。</p>
<h3><span id="parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma">ParNew年轻代收集时，需要遍历CMS老年代的所有GCROOT吗？</span><a href="#parnew-nian-qing-dai-shou-ji-shi-xu-yao-bian-li-cms-lao-nian-dai-de-suo-you-gcroot-ma" class="header-anchor">#</a></h3><p>CMS是老年代的收集器， 经常要和年轻代收集器例如ParDoNew配合。（因此上面4个阶段都是处理老年代回收的，年轻代内存占用小，不需要那么麻烦）<br>那么当ParNew年轻代回收时，是否也要把老年代的所有GCROOT都算上？后面全部遍历的话，时间是不是太久了？</p>
<p>因此才有了<strong>卡表</strong>的出现！<br>卡表作为一个比特位的集合，每一个比特位可以用来表示年老代的某一区域中的所有对象是否持有新生代对象的引用。<br>这样新生代在GC时，可以先扫描卡表，只有卡表的标记位为1时，才需要扫描给定区域的年老代对象。而卡表位为0的所在区域的年老代对象，一定不包含有对新生代的引用，从而提高了年轻代的回收效率！</p>
<h2><span id="cms-jie-duan-2-bing-fa-biao-ji">CMS阶段2：并发标记</span><a href="#cms-jie-duan-2-bing-fa-biao-ji" class="header-anchor">#</a></h2><p>这时候不会做stopWorld。标记线程和工作线程同时进行。</p>
<h3><span id="bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de">并发标记用了怎样的算法去标记的？</span><a href="#bing-fa-biao-ji-yong-liao-zen-yang-de-suan-fa-qu-biao-ji-de" class="header-anchor">#</a></h3><p>当通过gcRoot做并发标记的时候，是一种bfs搜索。<br>有一种三色标记法可以作为参考：</p>
<ul>
<li>白色：还没有搜索过的对象（白色对象会被当成垃圾对象）</li>
<li>灰色：正在搜索的对象</li>
<li>黑色：搜索完成的对象（不会当成垃圾对象，不会被GC）</li>
</ul>
<ol>
<li>默认起始是白色节点。</li>
<li>是每次标记当前搜索节点的引用节点（类似于相邻点）为灰色，入队列。</li>
<li>当相邻点全部入队列完成，则把当前搜索节点置黑色。然后根据队列取队头继续处理灰色节点</li>
</ol>
<p>是不是和数据结构的bfs非常类似？</p>
<h3><span id="bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng">并发标记时如何记录引用变更？</span><a href="#bing-fa-biao-ji-shi-ru-he-ji-lu-yin-yong-bian-geng" class="header-anchor">#</a></h3><p>对于CMS在并发标记时的引用变更，书上没有细讲，只是一笔带过，个人认为错失了许多精华。<br>有些类似的概念确实有在G1收集器里简单阐述，但是很难让人马上和CMS中对应起来。个人认为应该在CMS的章节就提前给出。<br>下面以我自己的理解，给出对CMS并发标记过程的理解。</p>
<h3><span id="shi-me-shi-kua-dai-yin-yong">什么是跨代引用？</span><a href="#shi-me-shi-kua-dai-yin-yong" class="header-anchor">#</a></h3><p>首先基于上面提到的三色标记，给出跨代引用问题的例子和解释。<br>假设此时正处于并发标记中，且正好在bfs处理A这个节点。<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652881948481607802.png" alt="image.png"><br>这时取消了A对B的引用，以及B对C的引用，同时新增了A对C的引用，变成如图所示：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652881964705631549.png" alt="image.png"><br>那么当继续搜索入队的B时，将无法再走到C，C永远被标记为白色，就会出现严重的后果：误杀了C，从而导致A对C调用时报错！<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882075127270117.png" alt="image.png"></p>
<h3><span id="ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang">如何避免跨代引用，保障并发标记安全（写屏障</span><a href="#ru-he-bi-mian-kua-dai-yin-yong-bao-zhang-bing-fa-biao-ji-an-quan-xie-ping-zhang" class="header-anchor">#</a></h3><p>CMS引入了一个叫“写屏障”的东西，写屏障工作示意如下：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882482680209447.png" alt="image.png"><br>而标记栈就会在后面的“重新标记”阶段用上。</p>
<h2><span id="cms-jie-duan-3-chong-xin-biao-ji">CMS阶段3：重新标记</span><a href="#cms-jie-duan-3-chong-xin-biao-ji" class="header-anchor">#</a></h2><p>前面的写屏障为我们把为标记却被新增引用的对象放入了栈中。<br>此时会进入StopWorld，我们可以从栈中取出标记对象进行“重新标记”了。<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652882580296867154.png" alt="image.png"></p>
<h2><span id="cms-jie-duan-4-bing-fa-qing-chu">CMS阶段4：并发清除</span><a href="#cms-jie-duan-4-bing-fa-qing-chu" class="header-anchor">#</a></h2><p>最后清除的时候，选用了“标记-清除”算法，来进行回收和处理。<br>同时采用并发机制，避免影响了工作线程。<br>“标记-清除”算法的示意图如下：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652883305646281243.png" alt="image.png"></p>
<h3><span id="wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa">为什么是要用“标记-清除”这么缺点大的方法？</span><a href="#wei-shi-me-shi-yao-yong-biao-ji-qing-chu-zhe-me-que-dian-da-de-fang-fa" class="header-anchor">#</a></h3><p>因为老年代算法，要么是标记-整理，要么是标记-清除<br><strong>而标记-整理算法是无法和工作线程并发执行的</strong><br>所以才选择标记-清除，这也导致了碎片带来的隐患</p>
<h3><span id="cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang">CMS如何解决标记-清除后碎片过多，无法放入新对象的情况？</span><a href="#cms-ru-he-jie-jue-biao-ji-qing-chu-hou-sui-pian-guo-duo-wu-fa-fang-ru-xin-dui-xiang-de-qing-kuang" class="header-anchor">#</a></h3><p>当因为碎片过多，无法放入新对象时，会触发fullGC，此时会做1次内存碎片的合并（整理）操作</p>
<p>还提供了一个参数，设置多少次非合并的fullGC时，可做一次碎片的集中合并和整理。</p>
<h3><span id="bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban">并发回收过程中，如果工作线程突然生成大量新垃圾，导致内存不足怎么办？</span><a href="#bing-fa-hui-shou-guo-cheng-zhong-ru-guo-gong-zuo-xian-cheng-tu-ran-sheng-cheng-da-liang-xin-la-ji-dao-zhi-nei-cun-bu-zu-zen-me-ban" class="header-anchor">#</a></h3><p>因为并发回收时工作线程还在运行，可能产生大量的对象，导致老年代被填满。<br>这时候CMS会触发一个“Concurrent Mod Failure”机制，并紧急替换为SerialOld收集进行stopWorld回收。<br>因此，<strong>CMS可能存在临时退化为SerialOld的可能</strong></p>
<h1><span id="g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi">G1收集器（回收概念发生诸多变革，目前最先进收集器）</span><a href="#g1-shou-ji-qi-hui-shou-gai-nian-fa-sheng-zhu-duo-bian-ge-mu-qian-zui-xian-jin-shou-ji-qi" class="header-anchor">#</a></h1><p><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652884348846944605.png" alt="image.png"></p>
<p>G1收集器，书上感觉并没有讲得特别深，很多概念、区别都没讲好，个人认为是种遗憾，因此我在透彻学习G1之前，我也只能简单写写了。</p>
<h2><span id="g1-xiang-bi-cms-de-chong-da-sheng-ji-dian">G1相比CMS的重大升级点：</span><a href="#g1-xiang-bi-cms-de-chong-da-sheng-ji-dian" class="header-anchor">#</a></h2><ol>
<li><strong>回收范围不同</strong>。 CMS是老年代收集器，必须和parNew等结合使用。  G1则可以同时管理老年代和年轻代。</li>
<li><strong>停顿目标不同</strong>。 CMS会让停顿时间尽可能小， G1则建立了可预测的时间模型。</li>
<li><strong>清理方式不同</strong>。 CMS是标记-清除，  G1是标记-整理，碎片大大减少。</li>
<li><strong>G1支持筛选回收</strong> G1可以根据每个region的价值进行回收，CMS则不行。</li>
<li><strong>并发标记后的最终标记处理方式不同</strong><br>这个标记方式的区别讲述起来有点抽象，简而言之就是：</li>
</ol>
<ul>
<li>CMS是希望记录所有新增的引用，并重新做好多次BFS，保证没有疏漏，代价非常大。</li>
<li>G1则是只更新o = null这种删除引用的情况。对于新增的引用，直接认为那个对象不需要杀。<br>换句话说，<strong>CMS更严谨，做细致的重新检查。 而G1为了性能，会漏掉一些本该被回收的对象，但是无关大雅，大不了就下次再回收</strong>。</li>
</ul>
<h2><span id="region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma">region之间都要通过BFS遍历吗？</span><a href="#region-zhi-jian-du-yao-tong-guo-bfs-bian-li-ma" class="header-anchor">#</a></h2><p>这个问题，和之前CMS中回收年轻代时， 是否要走一遍全量的老年代是一个道理。</p>
<p>G1里用的是一个RememberSet来避免全region扫描的。<br>每个G1的region都有一个<strong>记忆集(Rset)</strong><br>记忆集会记录下当前这个region中的对象被哪些对象所引用。<br>例如，region2中的两个对象分别被region1中的对象和region3中的对象所引用，那么，region2的记忆集记录的就是region1和region3中的引用region2的对象的引用。</p>
<p>这样一来在回收region2的时候，就不用扫描全部的region了，只需要访问记忆集，就知道当前region2里面的对象被哪些对象所引用，判断其是不是存活对象。</p>
<p><strong>简单来说，就是标记我这个region被哪些region引用，简化扫描，避免不必要的检索。</strong></p>
<hr>
<p>但是书上提到了一句话（P85)：</p>
<blockquote>
<blockquote>
<p>“通过cardTable卡表把相关引用信息记录到被引用对象所属的region的rememberedSet之中”</p>
</blockquote>
</blockquote>
<p>这里我就点没看懂，卡表不是老年代对年轻代的引用么，为什么G1里也有？不是用了记忆集吗？不解，等以后有解答了，再来修改这里的内容。</p>
<hr>
<h1><span id="wan-zheng-da-tu">完整大图</span><a href="#wan-zheng-da-tu" class="header-anchor">#</a></h1><p>关于垃圾收集，书上倾向于先将一些基本概念或者基本回收思路，再讲发展流程，同时对G1缺少更细致的解释，这就容易混杂起来，导致垃圾收集器的进化那一章节看得很迷。</p>
<p>后面找到了一本书，叫做《The Garbage Collection Handbook》，已经收藏，有时间的话可以看看，据说对G1做了非常细致的讲解<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/1652885621080294993.png" alt="image.png"></p>
<p>最后送上完整大图：<br><img src="/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%BC%94%E8%BF%9B%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/5d139636e4b065dc2c6b9a50.png" alt="垃圾收集器大图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/home/page/2/">2</a><a class="extend next" rel="next" href="/home/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="breakDawn"
      src="/images/abd.png">
  <p class="site-author-name" itemprop="name">breakDawn</p>
  <div class="site-description" itemprop="description">君子终日乾乾,夕惕若厉,无咎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:799581229@@qq.com" title="E-Mail → mailto:799581229@@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/182319148" title="Genshin-UID → 182319148"><i class="fa fa-gamepad fa-fw"></i>Genshin-UID</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15990050657" title="WeChat → 15990050657"><i class="fa fa-weixin fa-fw"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/10007940" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;10007940" rel="noopener" target="_blank"><i class="custom bilibili fa-fw"></i>bilibili</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">breakDawn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
  <script src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'vANR4mLN0FDjQuhKexHroAe0-gzGzoHsz',
      appKey     : 'f23UP4XaRBeNlbo8CW07s3Dh',
      placeholder: "天下第一帅到此一游",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zn-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
